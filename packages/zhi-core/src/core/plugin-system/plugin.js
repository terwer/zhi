!(function () {
  "use strict"
  try {
    if ("undefined" != typeof document) {
      var e = document.createElement("style")
      e.appendChild(
        document.createTextNode(
          ".command.svelte-1bq7axd{padding:8px 12px}.command.svelte-1bq7axd:hover{cursor:pointer;background-color:#0003;color:var(--b3-theme-primary)}.command-selected.svelte-1bq7axd{color:var(--b3-theme-primary);background-color:#0003}.command-plugin.svelte-1bq7axd{font-size:14px}.command-shortcut.svelte-1bq7axd{font-size:12px;color:var(--color-text-3)}.plugin.svelte-bwhxpp span.remove.svelte-bwhxpp{display:none;color:var(--b3-theme-error);margin-left:4px}.plugin.svelte-bwhxpp:hover span.remove.svelte-bwhxpp{display:inline;cursor:pointer}.plugin.svelte-bwhxpp:hover span.remove.svelte-bwhxpp:hover{text-decoration:underline}.plugin-info.svelte-bj9chc{display:flex;align-items:center}.plugin-detail.svelte-bj9chc{margin-top:12px;width:100%}.plugin-name.svelte-bj9chc{display:inline;margin-right:6px;font-size:24px}.plugin-key.svelte-bj9chc{display:inline;font-size:16px}.plugin-manifest.svelte-bj9chc{margin-top:12px}.plugin-readme.svelte-bj9chc{margin-top:20px}.go-back.svelte-bj9chc{margin-left:12px;font-size:12px;height:24px}.go-back-icon.svelte-bj9chc{height:12px;width:12px;margin-right:4px}"
        )
      ),
        document.head.appendChild(e)
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t)
  }
})()
var _a
var commonjsGlobal =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : {}
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1
;(function (Reflect2) {
  ;(function (factory2) {
    var root =
      typeof commonjsGlobal === "object"
        ? commonjsGlobal
        : typeof self === "object"
        ? self
        : typeof this === "object"
        ? this
        : Function("return this;")()
    var exporter = makeExporter(Reflect2)
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect2
    } else {
      exporter = makeExporter(root.Reflect, exporter)
    }
    factory2(exporter)
    function makeExporter(target, previous) {
      return function (key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value })
        }
        if (previous) previous(key, value)
      }
    }
  })(function (exporter) {
    var hasOwn = Object.prototype.hasOwnProperty
    var supportsSymbol = typeof Symbol === "function"
    var toPrimitiveSymbol =
      supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive"
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator"
    var supportsCreate = typeof Object.create === "function"
    var supportsProto = { __proto__: [] } instanceof Array
    var downLevel = !supportsCreate && !supportsProto
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate
        ? function () {
            return MakeDictionary(/* @__PURE__ */ Object.create(null))
          }
        : supportsProto
        ? function () {
            return MakeDictionary({ __proto__: null })
          }
        : function () {
            return MakeDictionary({})
          },
      has: downLevel
        ? function (map, key) {
            return hasOwn.call(map, key)
          }
        : function (map, key) {
            return key in map
          },
      get: downLevel
        ? function (map, key) {
            return hasOwn.call(map, key) ? map[key] : void 0
          }
        : function (map, key) {
            return map[key]
          },
    }
    var functionPrototype = Object.getPrototypeOf(Function)
    var usePolyfill =
      typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true"
    var _Map =
      !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function"
        ? Map
        : CreateMapPolyfill()
    var _Set =
      !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function"
        ? Set
        : CreateSetPolyfill()
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill()
    var Metadata2 = new _WeakMap()
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators)) throw new TypeError()
        if (!IsObject(target)) throw new TypeError()
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError()
        if (IsNull(attributes)) attributes = void 0
        propertyKey = ToPropertyKey(propertyKey)
        return DecorateProperty(decorators, target, propertyKey, attributes)
      } else {
        if (!IsArray(decorators)) throw new TypeError()
        if (!IsConstructor(target)) throw new TypeError()
        return DecorateConstructor(decorators, target)
      }
    }
    exporter("decorate", decorate)
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError()
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError()
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey)
      }
      return decorator
    }
    exporter("metadata", metadata)
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey)
    }
    exporter("defineMetadata", defineMetadata)
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      return OrdinaryHasMetadata(metadataKey, target, propertyKey)
    }
    exporter("hasMetadata", hasMetadata)
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey)
    }
    exporter("hasOwnMetadata", hasOwnMetadata)
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      return OrdinaryGetMetadata(metadataKey, target, propertyKey)
    }
    exporter("getMetadata", getMetadata)
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey)
    }
    exporter("getOwnMetadata", getOwnMetadata)
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      return OrdinaryMetadataKeys(target, propertyKey)
    }
    exporter("getMetadataKeys", getMetadataKeys)
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      return OrdinaryOwnMetadataKeys(target, propertyKey)
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys)
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError()
      if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey)
      var metadataMap = GetOrCreateMetadataMap(
        target,
        propertyKey,
        /*Create*/
        false
      )
      if (IsUndefined(metadataMap)) return false
      if (!metadataMap.delete(metadataKey)) return false
      if (metadataMap.size > 0) return true
      var targetMetadata = Metadata2.get(target)
      targetMetadata.delete(propertyKey)
      if (targetMetadata.size > 0) return true
      Metadata2.delete(target)
      return true
    }
    exporter("deleteMetadata", deleteMetadata)
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i]
        var decorated = decorator(target)
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated)) throw new TypeError()
          target = decorated
        }
      }
      return target
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i]
        var decorated = decorator(target, propertyKey, descriptor)
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated)) throw new TypeError()
          descriptor = decorated
        }
      }
      return descriptor
    }
    function GetOrCreateMetadataMap(O, P2, Create) {
      var targetMetadata = Metadata2.get(O)
      if (IsUndefined(targetMetadata)) {
        if (!Create) return void 0
        targetMetadata = new _Map()
        Metadata2.set(O, targetMetadata)
      }
      var metadataMap = targetMetadata.get(P2)
      if (IsUndefined(metadataMap)) {
        if (!Create) return void 0
        metadataMap = new _Map()
        targetMetadata.set(P2, metadataMap)
      }
      return metadataMap
    }
    function OrdinaryHasMetadata(MetadataKey, O, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P2)
      if (hasOwn2) return true
      var parent = OrdinaryGetPrototypeOf(O)
      if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P2)
      return false
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P2) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        false
      )
      if (IsUndefined(metadataMap)) return false
      return ToBoolean(metadataMap.has(MetadataKey))
    }
    function OrdinaryGetMetadata(MetadataKey, O, P2) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P2)
      if (hasOwn2) return OrdinaryGetOwnMetadata(MetadataKey, O, P2)
      var parent = OrdinaryGetPrototypeOf(O)
      if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P2)
      return void 0
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P2) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        false
      )
      if (IsUndefined(metadataMap)) return void 0
      return metadataMap.get(MetadataKey)
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P2) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        true
      )
      metadataMap.set(MetadataKey, MetadataValue)
    }
    function OrdinaryMetadataKeys(O, P2) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P2)
      var parent = OrdinaryGetPrototypeOf(O)
      if (parent === null) return ownKeys
      var parentKeys = OrdinaryMetadataKeys(parent, P2)
      if (parentKeys.length <= 0) return ownKeys
      if (ownKeys.length <= 0) return parentKeys
      var set = new _Set()
      var keys = []
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i]
        var hasKey = set.has(key)
        if (!hasKey) {
          set.add(key)
          keys.push(key)
        }
      }
      for (var _a2 = 0, parentKeys_1 = parentKeys; _a2 < parentKeys_1.length; _a2++) {
        var key = parentKeys_1[_a2]
        var hasKey = set.has(key)
        if (!hasKey) {
          set.add(key)
          keys.push(key)
        }
      }
      return keys
    }
    function OrdinaryOwnMetadataKeys(O, P2) {
      var keys = []
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P2,
        /*Create*/
        false
      )
      if (IsUndefined(metadataMap)) return keys
      var keysObj = metadataMap.keys()
      var iterator2 = GetIterator(keysObj)
      var k2 = 0
      while (true) {
        var next = IteratorStep(iterator2)
        if (!next) {
          keys.length = k2
          return keys
        }
        var nextValue = IteratorValue(next)
        try {
          keys[k2] = nextValue
        } catch (e) {
          try {
            IteratorClose(iterator2)
          } finally {
            throw e
          }
        }
        k2++
      }
    }
    function Type(x) {
      if (x === null) return 1
      switch (typeof x) {
        case "undefined":
          return 0
        case "boolean":
          return 2
        case "string":
          return 3
        case "symbol":
          return 4
        case "number":
          return 5
        case "object":
          return x === null ? 1 : 6
        default:
          return 6
      }
    }
    function IsUndefined(x) {
      return x === void 0
    }
    function IsNull(x) {
      return x === null
    }
    function IsSymbol(x) {
      return typeof x === "symbol"
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function"
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input
        case 1:
          return input
        case 2:
          return input
        case 3:
          return input
        case 4:
          return input
        case 5:
          return input
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default"
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol)
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint)
        if (IsObject(result)) throw new TypeError()
        return result
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint)
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O)
          if (!IsObject(result)) return result
        }
        var valueOf = O.valueOf
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O)
          if (!IsObject(result)) return result
        }
      } else {
        var valueOf = O.valueOf
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O)
          if (!IsObject(result)) return result
        }
        var toString_2 = O.toString
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O)
          if (!IsObject(result)) return result
        }
      }
      throw new TypeError()
    }
    function ToBoolean(argument) {
      return !!argument
    }
    function ToString(argument) {
      return "" + argument
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      )
      if (IsSymbol(key)) return key
      return ToString(key)
    }
    function IsArray(argument) {
      return Array.isArray
        ? Array.isArray(argument)
        : argument instanceof Object
        ? argument instanceof Array
        : Object.prototype.toString.call(argument) === "[object Array]"
    }
    function IsCallable(argument) {
      return typeof argument === "function"
    }
    function IsConstructor(argument) {
      return typeof argument === "function"
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true
        case 4:
          return true
        default:
          return false
      }
    }
    function GetMethod(V, P2) {
      var func = V[P2]
      if (func === void 0 || func === null) return void 0
      if (!IsCallable(func)) throw new TypeError()
      return func
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol)
      if (!IsCallable(method)) throw new TypeError()
      var iterator2 = method.call(obj)
      if (!IsObject(iterator2)) throw new TypeError()
      return iterator2
    }
    function IteratorValue(iterResult) {
      return iterResult.value
    }
    function IteratorStep(iterator2) {
      var result = iterator2.next()
      return result.done ? false : result
    }
    function IteratorClose(iterator2) {
      var f = iterator2["return"]
      if (f) f.call(iterator2)
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O)
      if (typeof O !== "function" || O === functionPrototype) return proto
      if (proto !== functionPrototype) return proto
      var prototype2 = O.prototype
      var prototypeProto = prototype2 && Object.getPrototypeOf(prototype2)
      if (prototypeProto == null || prototypeProto === Object.prototype) return proto
      var constructor = prototypeProto.constructor
      if (typeof constructor !== "function") return proto
      if (constructor === O) return proto
      return constructor
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {}
      var arraySentinel = []
      var MapIterator =
        /** @class */
        (function () {
          function MapIterator2(keys, values, selector) {
            this._index = 0
            this._keys = keys
            this._values = values
            this._selector = selector
          }
          MapIterator2.prototype["@@iterator"] = function () {
            return this
          }
          MapIterator2.prototype[iteratorSymbol] = function () {
            return this
          }
          MapIterator2.prototype.next = function () {
            var index = this._index
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index])
              if (index + 1 >= this._keys.length) {
                this._index = -1
                this._keys = arraySentinel
                this._values = arraySentinel
              } else {
                this._index++
              }
              return { value: result, done: false }
            }
            return { value: void 0, done: true }
          }
          MapIterator2.prototype.throw = function (error2) {
            if (this._index >= 0) {
              this._index = -1
              this._keys = arraySentinel
              this._values = arraySentinel
            }
            throw error2
          }
          MapIterator2.prototype.return = function (value) {
            if (this._index >= 0) {
              this._index = -1
              this._keys = arraySentinel
              this._values = arraySentinel
            }
            return { value, done: true }
          }
          return MapIterator2
        })()
      return (
        /** @class */
        (function () {
          function Map2() {
            this._keys = []
            this._values = []
            this._cacheKey = cacheSentinel
            this._cacheIndex = -2
          }
          Object.defineProperty(Map2.prototype, "size", {
            get: function () {
              return this._keys.length
            },
            enumerable: true,
            configurable: true,
          })
          Map2.prototype.has = function (key) {
            return (
              this._find(
                key,
                /*insert*/
                false
              ) >= 0
            )
          }
          Map2.prototype.get = function (key) {
            var index = this._find(
              key,
              /*insert*/
              false
            )
            return index >= 0 ? this._values[index] : void 0
          }
          Map2.prototype.set = function (key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            )
            this._values[index] = value
            return this
          }
          Map2.prototype.delete = function (key) {
            var index = this._find(
              key,
              /*insert*/
              false
            )
            if (index >= 0) {
              var size = this._keys.length
              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i]
                this._values[i - 1] = this._values[i]
              }
              this._keys.length--
              this._values.length--
              if (key === this._cacheKey) {
                this._cacheKey = cacheSentinel
                this._cacheIndex = -2
              }
              return true
            }
            return false
          }
          Map2.prototype.clear = function () {
            this._keys.length = 0
            this._values.length = 0
            this._cacheKey = cacheSentinel
            this._cacheIndex = -2
          }
          Map2.prototype.keys = function () {
            return new MapIterator(this._keys, this._values, getKey3)
          }
          Map2.prototype.values = function () {
            return new MapIterator(this._keys, this._values, getValue)
          }
          Map2.prototype.entries = function () {
            return new MapIterator(this._keys, this._values, getEntry)
          }
          Map2.prototype["@@iterator"] = function () {
            return this.entries()
          }
          Map2.prototype[iteratorSymbol] = function () {
            return this.entries()
          }
          Map2.prototype._find = function (key, insert2) {
            if (this._cacheKey !== key) {
              this._cacheIndex = this._keys.indexOf((this._cacheKey = key))
            }
            if (this._cacheIndex < 0 && insert2) {
              this._cacheIndex = this._keys.length
              this._keys.push(key)
              this._values.push(void 0)
            }
            return this._cacheIndex
          }
          return Map2
        })()
      )
      function getKey3(key, _2) {
        return key
      }
      function getValue(_2, value) {
        return value
      }
      function getEntry(key, value) {
        return [key, value]
      }
    }
    function CreateSetPolyfill() {
      return (
        /** @class */
        (function () {
          function Set2() {
            this._map = new _Map()
          }
          Object.defineProperty(Set2.prototype, "size", {
            get: function () {
              return this._map.size
            },
            enumerable: true,
            configurable: true,
          })
          Set2.prototype.has = function (value) {
            return this._map.has(value)
          }
          Set2.prototype.add = function (value) {
            return this._map.set(value, value), this
          }
          Set2.prototype.delete = function (value) {
            return this._map.delete(value)
          }
          Set2.prototype.clear = function () {
            this._map.clear()
          }
          Set2.prototype.keys = function () {
            return this._map.keys()
          }
          Set2.prototype.values = function () {
            return this._map.values()
          }
          Set2.prototype.entries = function () {
            return this._map.entries()
          }
          Set2.prototype["@@iterator"] = function () {
            return this.keys()
          }
          Set2.prototype[iteratorSymbol] = function () {
            return this.keys()
          }
          return Set2
        })()
      )
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16
      var keys = HashMap.create()
      var rootKey = CreateUniqueKey()
      return (
        /** @class */
        (function () {
          function WeakMap2() {
            this._key = CreateUniqueKey()
          }
          WeakMap2.prototype.has = function (target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            )
            return table !== void 0 ? HashMap.has(table, this._key) : false
          }
          WeakMap2.prototype.get = function (target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            )
            return table !== void 0 ? HashMap.get(table, this._key) : void 0
          }
          WeakMap2.prototype.set = function (target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            )
            table[this._key] = value
            return this
          }
          WeakMap2.prototype.delete = function (target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            )
            return table !== void 0 ? delete table[this._key] : false
          }
          WeakMap2.prototype.clear = function () {
            this._key = CreateUniqueKey()
          }
          return WeakMap2
        })()
      )
      function CreateUniqueKey() {
        var key
        do key = "@@WeakMap@@" + CreateUUID()
        while (HashMap.has(keys, key))
        keys[key] = true
        return key
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create) return void 0
          Object.defineProperty(target, rootKey, { value: HashMap.create() })
        }
        return target[rootKey]
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i) buffer[i] = (Math.random() * 255) | 0
        return buffer
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined") return crypto.getRandomValues(new Uint8Array(size))
          if (typeof msCrypto !== "undefined") return msCrypto.getRandomValues(new Uint8Array(size))
          return FillRandomBytes(new Uint8Array(size), size)
        }
        return FillRandomBytes(new Array(size), size)
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE)
        data[6] = (data[6] & 79) | 64
        data[8] = (data[8] & 191) | 128
        var result = ""
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset]
          if (offset === 4 || offset === 6 || offset === 8) result += "-"
          if (byte < 16) result += "0"
          result += byte.toString(16).toLowerCase()
        }
        return result
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0
      delete obj.__
      return obj
    }
  })
})(Reflect$1 || (Reflect$1 = {}))
const VERSION$1 = "0.7.0"
const VERSION_URL = "https://gitee.com/zuoez02/siyuan-plugin-system/raw/main/VERSION"
const SCRIPT_URL = "https://gitee.com/zuoez02/siyuan-plugin-system/raw/main/main.js"
const PLUGIN_SYS_ABS_PATH = "/data/widgets/插件系统/plugin.js"
const config = () => ({ token: window.siyuan.config.api.token })
const TYPES = {
  StorageManager: "StorageManager",
  PluginSystem: "PluginSystem",
  SystemManager: "PluginSystemLocalManager",
  PluginLoader: "PluginLoader",
  PluginFileManager: "PluginFileManager",
  EventBus: "EventBus",
  Shortcut: "Shortcut",
  CommandManager: "CommandManager",
  Store: "Store",
  SettingManager: "SettingManager",
}
async function request$1(url2, data) {
  let resData = null
  await fetch(url2, {
    body: JSON.stringify(data),
    method: "POST",
    headers: {
      Authorization: `Token ${config().token}`,
    },
  }).then(function (response) {
    resData = response.json()
  })
  return resData
}
async function parseBody(response) {
  let r = await response
  return r.code === 0 ? r.data : null
}
async function transactions(protyle, transactions2 = []) {
  const url2 = "/api/transactions"
  const ws_url = new URL(protyle.ws.ws.url)
  const data = {
    app: ws_url.searchParams.get("app"),
    session: ws_url.searchParams.get("id"),
    transactions: transactions2,
  }
  return parseBody(request$1(url2, data))
}
async function sql(sql2) {
  let sqldata = {
    stmt: sql2,
  }
  let url2 = "/api/query/sql"
  return parseBody(request$1(url2, sqldata))
}
async function lsNotebooks(sql2) {
  let sqldata = { stmt: sql2 }
  let url2 = "/api/notebook/lsNotebooks"
  return parseBody(request$1(url2, sqldata))
}
async function getAnchor(anchorText, name2) {
  anchorText = anchorText.replace("((", "").replace("))", "")
  let sqlScript = `select * from blocks where id = '${anchorText}'`
  let sqlRes = await sql(sqlScript)
  let anchor = ""
  if (sqlRes) {
    try {
      if (sqlRes[0][name2]) {
        anchor = sqlRes[0][name2]
      } else if (sqlRes[0]["content"]) {
        anchor = sqlRes[0]["content"]
      } else {
        anchor = anchorText
      }
    } catch (e) {
      anchor = "解析错误"
    }
  }
  return anchor
}
async function openNotebook(notebookId) {
  let data = {
    notebook: notebookId,
  }
  let url2 = "/api/notebook/openNotebook"
  return parseBody(request$1(url2, data))
}
async function closeNotebook(notebookId) {
  let data = {
    notebook: notebookId,
  }
  let url2 = "/api/notebook/closeNotebook"
  return parseBody(request$1(url2, data))
}
async function renameNotebook(notebookId, notebookNewName) {
  let data = {
    notebook: notebookId,
    name: notebookNewName,
  }
  let url2 = "/api/notebook/renameNotebook"
  return parseBody(request$1(url2, data))
}
async function createNotebook(notebookName) {
  let data = {
    name: notebookName,
  }
  let url2 = "/api/notebook/createNotebook"
  return parseBody(request$1(url2, data))
}
async function removeNotebook(notebookId) {
  let data = { notebook: notebookId }
  let url2 = "/api/notebook/removeNotebook"
  return parseBody(request$1(url2, data))
}
async function getNotebookConf(notebookId) {
  let data = { notebook: notebookId }
  let url2 = "/api/notebook/getNotebookConf"
  return parseBody(request$1(url2, data))
}
async function setNotebookConf(notebookId) {
  let data = { notebook: notebookId }
  let url2 = "/api/notebook/setNotebookConf"
  return parseBody(request$1(url2, data))
}
async function renameDoc(notebookId, path, title) {
  let data = {
    notebook: notebookId,
    path,
    title,
  }
  let url2 = "/api/filetree/renameDoc"
  return parseBody(request$1(url2, data))
}
async function removeDoc(notebookId, path) {
  let data = {
    notebook: notebookId,
    path,
  }
  let url2 = "/api/filetree/removeDoc"
  return parseBody(request$1(url2, data))
}
async function moveDoc(srcNotebookId, srcPath, targetNotebookId, targetPath) {
  let data = {
    fromNotebook: srcNotebookId,
    fromPath: srcPath,
    toNotebook: targetNotebookId,
    toPath: targetPath,
  }
  let url2 = "/api/filetree/moveDoc"
  return parseBody(request$1(url2, data))
}
async function getHPathByPath(notebookId, path) {
  let data = {
    Notebook: notebookId,
    Path: path,
  }
  let url2 = "/api/filetree/getHPathByPath"
  return parseBody(request$1(url2, data))
}
async function getHPathByID(ID) {
  let data = {
    id: ID,
  }
  let url2 = "/api/filetree/getHPathByID"
  return parseBody(request$1(url2, data))
}
async function getBlockAttrs(blockId) {
  let data = {
    id: blockId,
  }
  let url2 = "/api/attr/getBlockAttrs"
  return parseBody(request$1(url2, data))
}
async function getBlockByID(blockId) {
  let sqlScript = `select * from blocks where id ='${blockId}'`
  let data = await sql(sqlScript)
  return data[0]
}
async function getBlockKramdown(blockId) {
  const data = {
    id: blockId,
  }
  const url2 = "/api/block/getBlockKramdown"
  return parseBody(request$1(url2, data))
}
async function getBlockBreadcrumb(ID) {
  const data = {
    id: ID,
  }
  const url2 = "/api/block/getBlockBreadcrumb"
  return parseBody(request$1(url2, data))
}
async function setBlockAttrs(blockId, attrs) {
  let url2 = "/api/attr/setBlockAttrs"
  return parseBody(
    request$1(url2, {
      id: blockId,
      attrs,
    })
  )
}
async function exportMdContent(docId) {
  let data = {
    id: docId,
  }
  let url2 = "/api/export/exportMdContent"
  return parseBody(request$1(url2, data))
}
async function getDocOutline(docId) {
  let data = {
    id: docId,
  }
  let url2 = "/api/outline/getDocOutline"
  return parseBody(request$1(url2, data))
}
async function listDocsByPath(path) {
  let data = {
    path,
  }
  let url2 = "/api/filetree/listDocsByPath"
  return parseBody(request$1(url2, data))
}
async function getBacklink(id2) {
  let data = {
    id: id2,
    beforeLen: 10,
    k: "",
    mk: "",
  }
  let url2 = "/api/ref/getBacklink"
  return parseBody(request$1(url2, data))
}
async function searchEmbedBlock(excludeIds, sql2) {
  let data = {
    stmt: sql2,
    excludeIDs: excludeIds,
  }
  let url2 = "/api/search/searchEmbedBlock"
  return parseBody(request$1(url2, data))
}
async function getDoc(id2) {
  let data = {
    id: id2,
    k: "",
    mode: 2,
    size: 36,
  }
  let url2 = "/api/filetree/getDoc"
  return parseBody(request$1(url2, data))
}
async function getFocusedDoc(id2) {
  let data = {
    id: id2,
    k: "",
    mode: 0,
    size: 36,
  }
  let url2 = "/api/filetree/getDoc"
  return parseBody(request$1(url2, data))
}
async function getTag() {
  let data = {}
  let url2 = "/api/tag/getTag"
  return parseBody(request$1(url2, data))
}
async function getLocalGraph(k2, id2, conf, reqId) {
  let data = {
    id: id2,
    k: k2,
    conf,
    reqId,
  }
  let url2 = "/api/graph/getLocalGraph"
  return parseBody(request$1(url2, data))
}
async function getGraph(k2, conf, reqId) {
  let data = {
    k: k2,
    conf,
    reqId,
  }
  let url2 = "/api/graph/getGraph"
  return parseBody(request$1(url2, data))
}
async function searchDocs(k2) {
  let data = {
    k: k2,
  }
  let url2 = "/api/filetree/searchDocs"
  return parseBody(request$1(url2, data))
}
async function searchBlock(query) {
  let data = {
    query,
  }
  let url2 = "/api/search/searchBlock"
  return parseBody(request$1(url2, data))
}
async function searchTemplate(k2) {
  let data = {
    k: k2,
  }
  let url2 = "/api/search/searchTemplate"
  return parseBody(request$1(url2, data))
}
async function createDocWithMd(notebook, path, markdown) {
  let data = {
    notebook,
    path,
    markdown,
  }
  let url2 = "/api/filetree/createDocWithMd"
  return parseBody(request$1(url2, data))
}
async function docSaveAsTemplate(id2, overwrite = false) {
  let url2 = "/api/template/docSaveAsTemplate"
  let data = {
    id: id2,
    overwrite,
  }
  return parseBody(request$1(url2, data))
}
async function render(data) {
  let url2 = "/api/template/render"
  return parseBody(request$1(url2, data))
}
async function insertBlock(previousID, dataType, data) {
  let url2 = "/api/block/insertBlock"
  return parseBody(
    request$1(
      (url2 = url2),
      (data = {
        previousID,
        dataType,
        data,
      })
    )
  )
}
async function prependBlock(parentID, dataType, data) {
  let url2 = "/api/block/prependBlock"
  return parseBody(
    request$1(
      (url2 = url2),
      (data = {
        parentID,
        dataType,
        data,
      })
    )
  )
}
async function appendBlock(parentID, dataType, data) {
  let url2 = "/api/block/appendBlock"
  return parseBody(
    request$1(
      (url2 = url2),
      (data = {
        parentID,
        dataType,
        data,
      })
    )
  )
}
async function updateBlock(id2, dataType, data) {
  let url2 = "/api/block/updateBlock"
  return parseBody(
    request$1(
      (url2 = url2),
      (data = {
        id: id2,
        dataType,
        data,
      })
    )
  )
}
async function deleteBlock(id2) {
  let url2 = "/api/block/deleteBlock"
  return parseBody(request$1(url2, { id: id2 }))
}
async function moveBlock(id2, previousID, parentID) {
  let url2 = "/api/block/moveBlock"
  return parseBody(request$1(url2, { id: id2, previousID, parentID }))
}
async function getSysFonts() {
  let url2 = "/api/system/getSysFonts"
  return parseBody(request$1(url2, null))
}
async function getFile(path, type = "text") {
  const response = await fetch("/api/file/getFile", {
    method: "POST",
    headers: {
      Authorization: `Token ${config().token}`,
    },
    body: JSON.stringify({
      path,
    }),
  })
  if (response.status === 200) {
    if (type === "text") {
      return await response.text()
    }
    if (type === "json") {
      return (await response.json()).data
    }
  }
  return null
}
async function putFile(path, filedata, isDir = false, modTime = Date.now()) {
  let blob = new Blob([filedata])
  let file = new File([blob], path.split("/").pop())
  let formdata = new FormData()
  formdata.append("path", path)
  formdata.append("file", file)
  formdata.append("isDir", String(isDir))
  formdata.append("modTime", String(modTime))
  const response = await fetch("/api/file/putFile", {
    body: formdata,
    method: "POST",
    headers: {
      Authorization: `Token ${config().token}`,
    },
  })
  if (response.status === 200) return await response.json()
  else return null
}
async function readDir(path) {
  const response = await fetch("/api/file/readDir", {
    method: "POST",
    headers: {
      Authorization: `Token ${config().token}`,
    },
    body: JSON.stringify({
      path,
    }),
  })
  if (response.status === 200) {
    return (await response.json()).data
  }
  return null
}
async function removeFile(path) {
  const response = await fetch("/api/file/removeFile", {
    method: "POST",
    headers: {
      Authorization: `Token ${config().token}`,
    },
    body: JSON.stringify({
      path,
    }),
  })
  if (response.status === 200) return
  else return null
}
const language = (_a = window.theme) == null ? void 0 : _a.languageMode
async function pushMsg(message = null, text2 = null, timeout = 7e3) {
  const url2 = "/api/notification/pushMsg"
  const data = {
    msg: message ? message[language] || message.other : text2,
    timeout,
  }
  return parseBody(request$1(url2, data))
}
async function pushErrMsg(message = null, text2 = null, timeout = 7e3) {
  const url2 = "/api/notification/pushErrMsg"
  const data = {
    msg: message ? message[language] || message.other : text2,
    timeout,
  }
  return parseBody(request$1(url2, data))
}
async function setStorageVal(key, val) {
  const url2 = "/api/storage/setLocalStorageVal"
  const data = {
    app: genUUID(),
    key,
    val,
  }
  return parseBody(request$1(url2, data))
}
async function getLocalStorage() {
  const url2 = "/api/storage/getLocalStorage"
  return parseBody(request$1(url2, null))
}
async function renderSprig(sprig) {
  let url2 = "/api/template/renderSprig"
  return parseBody(request$1(url2, { template: sprig }))
}
async function getBazzarWidget() {
  const url2 = "/api/bazaar/getBazaarWidget"
  return parseBody(request$1(url2, null))
}
const serverApi = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      appendBlock,
      closeNotebook,
      createDocWithMd,
      createNotebook,
      deleteBlock,
      docSaveAsTemplate,
      exportMdContent,
      getAnchor,
      getBacklink,
      getBazzarWidget,
      getBlockAttrs,
      getBlockBreadcrumb,
      getBlockByID,
      getBlockKramdown,
      getDoc,
      getDocOutline,
      getFile,
      getFocusedDoc,
      getGraph,
      getHPathByID,
      getHPathByPath,
      getLocalGraph,
      getLocalStorage,
      getNotebookConf,
      getSysFonts,
      getTag,
      insertBlock,
      listDocsByPath,
      lsNotebooks,
      moveBlock,
      moveDoc,
      openNotebook,
      parseBody,
      prependBlock,
      pushErrMsg,
      pushMsg,
      putFile,
      readDir,
      removeDoc,
      removeFile,
      removeNotebook,
      renameDoc,
      renameNotebook,
      render,
      renderSprig,
      request: request$1,
      searchBlock,
      searchDocs,
      searchEmbedBlock,
      searchTemplate,
      setBlockAttrs,
      setNotebookConf,
      setStorageVal,
      sql,
      transactions,
      updateBlock,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
)
class Notification {
  constructor(option) {
    this.option = option
  }
  show() {
    if (this.option.type === "error") {
      pushErrMsg(null, this.option.message, this.option.timeout)
    } else {
      pushMsg(null, this.option.message, this.option.timeout)
    }
  }
}
var z = Object.defineProperty
var D = (i, e, t2) =>
  e in i ? z(i, e, { enumerable: true, configurable: true, writable: true, value: t2 }) : (i[e] = t2)
var _$1 = (i, e, t2) => (D(i, typeof e != "symbol" ? e + "" : e, t2), t2)
var P =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : typeof self < "u"
      ? self
      : {},
  b = {},
  W = {
    get exports() {
      return b
    },
    set exports(i) {
      b = i
    },
  }
;(function (i) {
  ;(function (e, t2) {
    i.exports ? (i.exports = t2()) : (e.log = t2())
  })(P, function () {
    var e = function () {},
      t2 = "undefined",
      l = typeof window !== t2 && typeof window.navigator !== t2 && /Trident\/|MSIE /.test(window.navigator.userAgent),
      p = ["trace", "debug", "info", "warn", "error"]
    function c(a2, s) {
      var f = a2[s]
      if (typeof f.bind == "function") return f.bind(a2)
      try {
        return Function.prototype.bind.call(f, a2)
      } catch {
        return function () {
          return Function.prototype.apply.apply(f, [a2, arguments])
        }
      }
    }
    function g() {
      console.log &&
        (console.log.apply
          ? console.log.apply(console, arguments)
          : Function.prototype.apply.apply(console.log, [console, arguments])),
        console.trace && console.trace()
    }
    function w(a2) {
      return (
        a2 === "debug" && (a2 = "log"),
        typeof console === t2
          ? false
          : a2 === "trace" && l
          ? g
          : console[a2] !== void 0
          ? c(console, a2)
          : console.log !== void 0
          ? c(console, "log")
          : e
      )
    }
    function E(a2, s) {
      for (var f = 0; f < p.length; f++) {
        var o = p[f]
        this[o] = f < a2 ? e : this.methodFactory(o, a2, s)
      }
      this.log = this.debug
    }
    function F(a2, s, f) {
      return function () {
        typeof console !== t2 && (E.call(this, s, f), this[a2].apply(this, arguments))
      }
    }
    function r(a2, s, f) {
      return w(a2) || F.apply(this, arguments)
    }
    function v(a2, s, f) {
      var o = this,
        O
      s = s ?? "WARN"
      var u = "loglevel"
      typeof a2 == "string" ? (u += ":" + a2) : typeof a2 == "symbol" && (u = void 0)
      function C(n) {
        var d = (p[n] || "silent").toUpperCase()
        if (!(typeof window === t2 || !u)) {
          try {
            window.localStorage[u] = d
            return
          } catch {}
          try {
            window.document.cookie = encodeURIComponent(u) + "=" + d + ";"
          } catch {}
        }
      }
      function k2() {
        var n
        if (!(typeof window === t2 || !u)) {
          try {
            n = window.localStorage[u]
          } catch {}
          if (typeof n === t2)
            try {
              var d = window.document.cookie,
                m = d.indexOf(encodeURIComponent(u) + "=")
              m !== -1 && (n = /^([^;]+)/.exec(d.slice(m))[1])
            } catch {}
          return o.levels[n] === void 0 && (n = void 0), n
        }
      }
      function V() {
        if (!(typeof window === t2 || !u)) {
          try {
            window.localStorage.removeItem(u)
            return
          } catch {}
          try {
            window.document.cookie = encodeURIComponent(u) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC"
          } catch {}
        }
      }
      ;(o.name = a2),
        (o.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5,
        }),
        (o.methodFactory = f || r),
        (o.getLevel = function () {
          return O
        }),
        (o.setLevel = function (n, d) {
          if (
            (typeof n == "string" && o.levels[n.toUpperCase()] !== void 0 && (n = o.levels[n.toUpperCase()]),
            typeof n == "number" && n >= 0 && n <= o.levels.SILENT)
          ) {
            if (((O = n), d !== false && C(n), E.call(o, n, a2), typeof console === t2 && n < o.levels.SILENT))
              return "No console available for logging"
          } else throw "log.setLevel() called with invalid level: " + n
        }),
        (o.setDefaultLevel = function (n) {
          ;(s = n), k2() || o.setLevel(n, false)
        }),
        (o.resetLevel = function () {
          o.setLevel(s, false), V()
        }),
        (o.enableAll = function (n) {
          o.setLevel(o.levels.TRACE, n)
        }),
        (o.disableAll = function (n) {
          o.setLevel(o.levels.SILENT, n)
        })
      var y = k2()
      y == null && (y = s), o.setLevel(y, false)
    }
    var L = new v(),
      h = {}
    L.getLogger = function (s) {
      if ((typeof s != "symbol" && typeof s != "string") || s === "")
        throw new TypeError("You must supply a name when creating a logger.")
      var f = h[s]
      return f || (f = h[s] = new v(s, L.getLevel(), L.methodFactory)), f
    }
    var G = typeof window !== t2 ? window.log : void 0
    return (
      (L.noConflict = function () {
        return typeof window !== t2 && window.log === L && (window.log = G), L
      }),
      (L.getLoggers = function () {
        return h
      }),
      (L.default = L),
      L
    )
  })
})(W)
var R = {},
  B = {
    get exports() {
      return R
    },
    set exports(i) {
      R = i
    },
  }
;(function (i) {
  ;(function (e, t2) {
    i.exports ? (i.exports = t2()) : (e.prefix = t2(e))
  })(P, function (e) {
    var t2 = function (r) {
        for (var v = 1, L = arguments.length, h; v < L; v++)
          for (h in arguments[v]) Object.prototype.hasOwnProperty.call(arguments[v], h) && (r[h] = arguments[v][h])
        return r
      },
      l = {
        template: "[%t] %l:",
        levelFormatter: function (r) {
          return r.toUpperCase()
        },
        nameFormatter: function (r) {
          return r || "root"
        },
        timestampFormatter: function (r) {
          return r.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1")
        },
        format: void 0,
      },
      p,
      c = {},
      g = function (r) {
        if (!r || !r.getLogger) throw new TypeError("Argument is not a root logger")
        p = r
      },
      w = function (r, v) {
        if (!r || !r.setLevel) throw new TypeError("Argument is not a logger")
        var L = r.methodFactory,
          h = r.name || "",
          G = c[h] || c[""] || l
        function a2(s, f, o) {
          var O = L(s, f, o),
            u = c[o] || c[""],
            C = u.template.indexOf("%t") !== -1,
            k2 = u.template.indexOf("%l") !== -1,
            V = u.template.indexOf("%n") !== -1
          return function () {
            for (var y = "", n = arguments.length, d = Array(n), m = 0; m < n; m++) d[m] = arguments[m]
            if (h || !c[o]) {
              var x = u.timestampFormatter(new Date()),
                U = u.levelFormatter(s),
                A = u.nameFormatter(o)
              u.format
                ? (y += u.format(U, A, x))
                : ((y += u.template),
                  C && (y = y.replace(/%t/, x)),
                  k2 && (y = y.replace(/%l/, U)),
                  V && (y = y.replace(/%n/, A))),
                d.length && typeof d[0] == "string" ? (d[0] = y + " " + d[0]) : d.unshift(y)
            }
            O.apply(void 0, d)
          }
        }
        return (
          c[h] || (r.methodFactory = a2),
          (v = v || {}),
          v.template && (v.format = void 0),
          (c[h] = t2({}, G, v)),
          r.setLevel(r.getLevel()),
          p ||
            r.warn(
              "It is necessary to call the function reg() of loglevel-plugin-prefix before calling apply. From the next release, it will throw an error. See more: https://github.com/kutuluk/loglevel-plugin-prefix/blob/master/README.md"
            ),
          r
        )
      },
      E = {
        reg: g,
        apply: w,
      },
      F
    return (
      e &&
        ((F = e.prefix),
        (E.noConflict = function () {
          return e.prefix === E && (e.prefix = F), E
        })),
      E
    )
  })
})(B)
class T {}
_$1(T, "LOG_LEVEL_KEY", "VITE_LOG_LEVEL"), _$1(T, "LOG_PREFIX_KEY", "VITE_LOG_PREFIX")
var S = /* @__PURE__ */ ((i) => (
  (i.LOG_LEVEL_DEBUG = "DEBUG"),
  (i.LOG_LEVEL_INFO = "INFO"),
  (i.LOG_LEVEL_WARN = "WARN"),
  (i.LOG_LEVEL_ERROR = "ERROR"),
  i
))(S || {})
function K() {
  const i = Error.prepareStackTrace
  Error.prepareStackTrace = (t2, l) => l
  const e = new Error().stack.slice(1)
  return (Error.prepareStackTrace = i), e
}
class I {
  /**
   * 解析日志级别为枚举
   *
   * @param enumObj 枚举对象
   * @param value 配置的值
   */
  static stringToEnumValue(e, t2) {
    return e[Object.keys(e).filter((l) => e[l].toString() === t2)[0]]
  }
  /**
   * 获取配置的日志级别
   */
  static getEnvLevel(e) {
    if (!e) return
    const t2 = e.getEnvOrDefault(T.LOG_LEVEL_KEY, S.LOG_LEVEL_INFO),
      l = I.stringToEnumValue(S, t2.toUpperCase())
    return (
      l ||
        console.warn(
          "[zhi-log] LOG_LEVEL is invalid in you .env file.Must be either debug, info, warn or error, fallback to default info level"
        ),
      l
    )
  }
  /**
   * 获取默认日志
   */
  static getEnvLogger(e) {
    if (e) return e.getEnv(T.LOG_PREFIX_KEY)
  }
}
class Y {
  constructor(e, t2, l) {
    _$1(this, "consoleLogger", "console")
    _$1(this, "stackSize", 1)
    _$1(this, "getLogger", (e2) => {
      let t3
      if (e2) t3 = e2
      else {
        const l2 = this.getCallStack(),
          p2 = [],
          c2 = []
        for (let g = 0; g < l2.length; g++) {
          const w = l2[g],
            E = w.getFileName() ?? "none"
          if (g > this.stackSize - 1) break
          const F = E + "-" + w.getLineNumber() + ":" + w.getColumnNumber()
          p2.push(F)
        }
        c2.length > 0 && (t3 = p2.join(" -> "))
      }
      return (!t3 || t3.trim().length === 0) && (t3 = this.consoleLogger), b.getLogger(t3)
    })
    this.stackSize = 1
    let p
    e ? (p = e) : (p = I.getEnvLevel(l)), (p = p ?? S.LOG_LEVEL_INFO), b.setLevel(p)
    const c = {
      gray: (g) => g.toString(),
      green: (g) => g.toString(),
      yellow: (g) => g.toString(),
      red: (g) => g.toString(),
    }
    R.reg(b),
      R.apply(b, {
        format(g, w, E) {
          const r = ["[" + (t2 ?? I.getEnvLogger(l) ?? "zhi") + "]"]
          switch ((r.push(c.gray("[") + c.green(E).toString() + c.gray("]")), g)) {
            case S.LOG_LEVEL_DEBUG:
              r.push(c.gray(g.toUpperCase().toString()))
              break
            case S.LOG_LEVEL_INFO:
              r.push(c.green(g.toUpperCase().toString()))
              break
            case S.LOG_LEVEL_WARN:
              r.push(c.yellow(g.toUpperCase().toString()))
              break
            case S.LOG_LEVEL_ERROR:
              r.push(c.red(g.toUpperCase().toString()))
              break
          }
          return r.push(c.green(w).toString()), r.push(c.gray(":")), r.join(" ")
        },
      })
  }
  /**
   * 设置输出栈的深度，默认1
   *
   * @param stackSize - 栈的深度
   */
  setStackSize(e) {
    this.stackSize = e ?? 1
  }
  /**
   * 获取调用堆栈，若未获取到直接返回空数组
   *
   * @author terwer
   * @since 1.6.0
   */
  getCallStack() {
    let e
    try {
      e = K()
    } catch {
      e = []
    }
    return e
  }
}
class X {
  /**
   * 默认日志级别
   *
   * @param level - 可选，未设置默认INFO
   * @param sign - 可选前缀，默认zhi
   * @param env - 可选环境变量实例
   */
  constructor(e, t2, l) {
    _$1(this, "logger")
    this.logger = new Y(e, t2, l)
  }
  /**
   * 获取日志记录器
   *
   * @param loggerName - 日志记录器名称
   * @param stackSize - 打印栈的深度
   * @protected
   */
  getLogger(e, t2) {
    return this.logger.setStackSize(t2), this.logger.getLogger(e)
  }
}
class N extends X {
  constructor(e, t2, l) {
    super(e, t2, l)
  }
  /**
   * 获取默认的日志记录器
   *
   * @param loggerName - 日志记录器名称
   * @param stackSize - 打印栈的深度
   */
  getLogger(e, t2) {
    return super.getLogger(e, t2)
  }
}
class M {
  /**
   * 默认日志记录器
   *
   * @param stackSize - 栈的深度
   * @param env - 环境变量实例
   */
  static defaultLogger(e, t2) {
    return M.customLogFactory(void 0, void 0, e).getLogger(void 0, t2)
  }
  /**
   * 自定义日志工厂
   */
  static customLogFactory(e, t2, l) {
    return new N(e, t2, l)
  }
  /**
   * 自定义日志工厂，自定义前缀
   */
  static customSignLogFactory(e, t2) {
    return new N(void 0, e, t2)
  }
}
function insertBefore(positionEl, el) {
  return positionEl.insertAdjacentElement("beforebegin", el)
}
function insertAfter(positionEl, el) {
  return positionEl.insertAdjacentElement("afterend", el)
}
function addToolbarLeft(el) {
  var _a2
  const title = (_a2 = document.getElementById("toolbar")) == null ? void 0 : _a2.getElementsByClassName("fn__ellipsis")
  if (!title) {
    return
  }
  insertBefore(title[0], el)
}
function addToolbarRight(el) {
  var _a2
  const title = (_a2 = document.getElementById("toolbar")) == null ? void 0 : _a2.getElementsByClassName("fn__ellipsis")
  if (!title) {
    return
  }
  insertAfter(title[0], el)
}
const createLogger = (name2) => getLogger(name2)
const clientApi = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      addToolbarLeft,
      addToolbarRight,
      createLogger,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
)
class Menu {
  constructor(id2) {
    var _a2, _b
    const menu = (_b = (_a2 = window.siyuan) == null ? void 0 : _a2.menus) == null ? void 0 : _b.menu
    if (!menu) {
      throw Error("Siyuan internal menu not found!")
    }
    this.menu = menu
    if (!id2) {
      throw Error("Menu must has an id, got empty or undefined!")
    }
    menu.remove()
    menu.element.setAttribute("data-name", id2)
  }
  addItem(item) {
    this.menu.append(item.element)
    return this
  }
  addSeparator() {
    this.addItem(new MenuItem({ type: "separator" }))
    return this
  }
  showAtMouseEvent(event) {
    this.menu.popup({ x: event.clientX, y: event.clientY })
    return this
  }
  showAtPosition(position) {
    this.menu.popup({ x: position.x, y: position.y })
    return this
  }
  close() {
    this.menu.remove()
  }
}
class MenuItem {
  constructor(options) {
    this.element = document.createElement("button")
    if (options.disabled) {
      this.element.setAttribute("disabled", "disabled")
    }
    if (options.type === "separator") {
      this.element.classList.add("b3-menu__separator")
      return
    }
    this.element.classList.add("b3-menu__item")
    if (options.current) {
      this.element.classList.add("b3-menu__item--selected")
    }
    if (options.click) {
      this.element.addEventListener("click", (event) => {
        if (this.element.getAttribute("disabled")) {
          return
        }
        options.click(this.element)
        event.preventDefault()
        event.stopImmediatePropagation()
        event.stopPropagation()
        window.siyuan.menus.menu.remove()
      })
    }
    let html = `<span class="b3-menu__label">${options.label}</span>`
    if (options.iconHTML) {
      html = options.iconHTML + html
    } else {
      html = `<svg class="b3-menu__icon${
        ["HTML (SiYuan)", window.siyuan.languages.template].includes(options.label) ? " ft__error" : ""
      }" style="${options.icon === "iconClose" ? "height:10px;" : ""}"><use xlink:href="#${
        options.icon || ""
      }"></use></svg>${html}`
    }
    if (options.action) {
      html += `<svg class="b3-menu__action"><use xlink:href="#${options.action}"></use></svg>`
    }
    if (options.id) {
      this.element.setAttribute("data-id", options.id)
    }
    if (options.type === "readonly") {
      this.element.classList.add("b3-menu__item--readonly")
    }
    this.element.innerHTML = html
    if (options.bind) {
      this.element.classList.add("b3-menu__item--custom")
      options.bind(this.element)
    }
    if (options.submenu) {
      const submenuElement = document.createElement("div")
      submenuElement.classList.add("b3-menu__submenu")
      options.submenu.forEach((item) => {
        submenuElement.append(new MenuItem(item).element)
      })
      this.element.insertAdjacentHTML(
        "beforeend",
        '<svg class="b3-menu__icon b3-menu__icon--arrow"><use xlink:href="#iconRight"></use></svg>'
      )
      this.element.append(submenuElement)
    }
  }
}
class MenuSeparator {}
class Dialog {
  constructor(options) {
    this.disableClose = options.disableClose
    this.id = genUUID()
    window.siyuan.dialogs.push(this)
    this.destroyCallback = options.destroyCallback
    this.element = document.createElement("div")
    this.element.innerHTML = `<div class="b3-dialog">
<div class="b3-dialog__scrim"${options.transparent ? 'style="background-color:transparent"' : ""}></div>
<div class="b3-dialog__container" style="width:${options.width || "auto"}">
  <svg class="b3-dialog__close fn__a${this.disableClose ? " fn__none" : ""}"><use xlink:href="#iconClose"></use></svg>
  <div class="b3-dialog__header${options.title ? "" : " fn__none"}" onselectstart="return false;">${
      options.title || ""
    }</div>
  <div style="height:${options.height || "auto"}">${options.content}</div>
</div></div>`
    this.element.querySelector(".b3-dialog__scrim").addEventListener("click", (event) => {
      if (!this.disableClose) {
        this.destroy()
      }
      event.preventDefault()
      event.stopPropagation()
      window.siyuan.menus.menu.remove()
    })
    if (!this.disableClose) {
      this.element.querySelector(".b3-dialog__close").addEventListener("click", (event) => {
        this.destroy()
        event.preventDefault()
        event.stopPropagation()
      })
    }
    document.body.append(this.element)
    if (options.disableAnimation) {
      this.element.classList.add("b3-dialog--open")
    } else {
      setTimeout(() => {
        this.element.classList.add("b3-dialog--open")
      })
    }
    window.siyuan.menus.menu.remove()
  }
  static destroyAll() {
    window.siyuan.dialogs.forEach((p) => p.destroy())
  }
  destroy() {
    this.element.remove()
    window.siyuan.menus.menu.remove()
    if (this.destroyCallback) {
      this.destroyCallback()
    }
    window.siyuan.dialogs.find((item, index) => {
      if (item.id === this.id) {
        window.siyuan.dialogs.splice(index, 1)
        return true
      }
    })
  }
  bindInput(inputElement, enterEvent) {
    inputElement.focus()
    inputElement.addEventListener("keydown", (event) => {
      if (event.isComposing) {
        event.preventDefault()
        return
      }
      if (event.key === "Escape") {
        this.destroy()
        event.preventDefault()
        event.stopPropagation()
        return
      }
      if (event.key === "Enter" && enterEvent) {
        enterEvent()
        event.preventDefault()
      }
    })
  }
}
class Plugin {
  onload() {}
  onunload() {}
  registerCommand(command) {}
  registerSettingRender(settingRender) {}
  async loadStorage(filename) {
    return null
  }
  async writeStorage(filename, content) {}
}
const api = {
  clientApi,
  serverApi,
  Plugin,
  Menu,
  MenuItem,
  MenuSeparator,
  Notification,
  Dialog,
}
var reExports = {}
var re$3 = {
  get exports() {
    return reExports
  },
  set exports(v) {
    reExports = v
  },
}
const SEMVER_SPEC_VERSION = "2.0.0"
const MAX_LENGTH$2 = 256
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER /* istanbul ignore next */ || 9007199254740991
const MAX_SAFE_COMPONENT_LENGTH = 16
var constants$1 = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH,
}
const debug$1 =
  typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (...args) => console.error("SEMVER", ...args)
    : () => {}
var debug_1 = debug$1
;(function (module2, exports2) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants$1
  const debug2 = debug_1
  exports2 = module2.exports = {}
  const re2 = (exports2.re = [])
  const src = (exports2.src = [])
  const t2 = (exports2.t = {})
  let R2 = 0
  const createToken = (name2, value, isGlobal) => {
    const index = R2++
    debug2(name2, index, value)
    t2[name2] = index
    src[index] = value
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0)
  }
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*")
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+")
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*")
  createToken(
    "MAINVERSION",
    `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`
  )
  createToken(
    "MAINVERSIONLOOSE",
    `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`
  )
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`)
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`)
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`)
  createToken(
    "PRERELEASELOOSE",
    `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`
  )
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+")
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`)
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`)
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`)
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`)
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`)
  createToken("GTLT", "((?:<|>)?=?)")
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`)
  createToken(
    "XRANGEPLAIN",
    `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${
      src[t2.PRERELEASE]
    })?${src[t2.BUILD]}?)?)?`
  )
  createToken(
    "XRANGEPLAINLOOSE",
    `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
      src[t2.XRANGEIDENTIFIERLOOSE]
    })(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`
  )
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`)
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`)
  createToken(
    "COERCE",
    `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`
  )
  createToken("COERCERTL", src[t2.COERCE], true)
  createToken("LONETILDE", "(?:~>?)")
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true)
  exports2.tildeTrimReplace = "$1~"
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`)
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`)
  createToken("LONECARET", "(?:\\^)")
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true)
  exports2.caretTrimReplace = "$1^"
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`)
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`)
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`)
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`)
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true)
  exports2.comparatorTrimReplace = "$1$2$3"
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`)
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`)
  createToken("STAR", "(<|>)?=?\\s*\\*")
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$")
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
})(re$3, reExports)
const opts = ["includePrerelease", "loose", "rtl"]
const parseOptions$2 = (options) =>
  !options
    ? {}
    : typeof options !== "object"
    ? { loose: true }
    : opts
        .filter((k2) => options[k2])
        .reduce((o, k2) => {
          o[k2] = true
          return o
        }, {})
var parseOptions_1 = parseOptions$2
const numeric = /^[0-9]+$/
const compareIdentifiers$1 = (a2, b2) => {
  const anum = numeric.test(a2)
  const bnum = numeric.test(b2)
  if (anum && bnum) {
    a2 = +a2
    b2 = +b2
  }
  return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1
}
const rcompareIdentifiers = (a2, b2) => compareIdentifiers$1(b2, a2)
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers,
}
const debug = debug_1
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants$1
const { re: re$2, t: t$2 } = reExports
const parseOptions$1 = parseOptions_1
const { compareIdentifiers } = identifiers$1
let SemVer$d = class SemVer2 {
  constructor(version2, options) {
    options = parseOptions$1(options)
    if (version2 instanceof SemVer2) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2
      } else {
        version2 = version2.version
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid Version: ${version2}`)
    }
    if (version2.length > MAX_LENGTH$1) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`)
    }
    debug("SemVer", version2, options)
    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease
    const m = version2.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL])
    if (!m) {
      throw new TypeError(`Invalid Version: ${version2}`)
    }
    this.raw = version2
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version")
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version")
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version")
    }
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id2
      })
    }
    this.build = m[5] ? m[5].split(".") : []
    this.format()
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`
    }
    return this.version
  }
  toString() {
    return this.version
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other)
    if (!(other instanceof SemVer2)) {
      if (typeof other === "string" && other === this.version) {
        return 0
      }
      other = new SemVer2(other, this.options)
    }
    if (other.version === this.version) {
      return 0
    }
    return this.compareMain(other) || this.comparePre(other)
  }
  compareMain(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options)
    }
    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }
  comparePre(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options)
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }
    let i = 0
    do {
      const a2 = this.prerelease[i]
      const b2 = other.prerelease[i]
      debug("prerelease compare", i, a2, b2)
      if (a2 === void 0 && b2 === void 0) {
        return 0
      } else if (b2 === void 0) {
        return 1
      } else if (a2 === void 0) {
        return -1
      } else if (a2 === b2) {
        continue
      } else {
        return compareIdentifiers(a2, b2)
      }
    } while (++i)
  }
  compareBuild(other) {
    if (!(other instanceof SemVer2)) {
      other = new SemVer2(other, this.options)
    }
    let i = 0
    do {
      const a2 = this.build[i]
      const b2 = other.build[i]
      debug("prerelease compare", i, a2, b2)
      if (a2 === void 0 && b2 === void 0) {
        return 0
      } else if (b2 === void 0) {
        return 1
      } else if (a2 === void 0) {
        return -1
      } else if (a2 === b2) {
        continue
      } else {
        return compareIdentifiers(a2, b2)
      }
    } while (++i)
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc("pre", identifier)
        break
      case "preminor":
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc("pre", identifier)
        break
      case "prepatch":
        this.prerelease.length = 0
        this.inc("patch", identifier)
        this.inc("pre", identifier)
        break
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier)
        }
        this.inc("pre", identifier)
        break
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}
var semver$1 = SemVer$d
const { MAX_LENGTH } = constants$1
const { re: re$1, t: t$1 } = reExports
const SemVer$c = semver$1
const parseOptions = parseOptions_1
const parse$6 = (version2, options) => {
  options = parseOptions(options)
  if (version2 instanceof SemVer$c) {
    return version2
  }
  if (typeof version2 !== "string") {
    return null
  }
  if (version2.length > MAX_LENGTH) {
    return null
  }
  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]
  if (!r.test(version2)) {
    return null
  }
  try {
    return new SemVer$c(version2, options)
  } catch (er) {
    return null
  }
}
var parse_1 = parse$6
const parse$5 = parse_1
const valid$2 = (version2, options) => {
  const v = parse$5(version2, options)
  return v ? v.version : null
}
var valid_1 = valid$2
const parse$4 = parse_1
const clean$1 = (version2, options) => {
  const s = parse$4(version2.trim().replace(/^[=v]+/, ""), options)
  return s ? s.version : null
}
var clean_1 = clean$1
const SemVer$b = semver$1
const inc$1 = (version2, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options
    options = void 0
  }
  try {
    return new SemVer$b(version2 instanceof SemVer$b ? version2.version : version2, options).inc(release, identifier)
      .version
  } catch (er) {
    return null
  }
}
var inc_1 = inc$1
const SemVer$a = semver$1
const compare$b = (a2, b2, loose) => new SemVer$a(a2, loose).compare(new SemVer$a(b2, loose))
var compare_1 = compare$b
const compare$a = compare_1
const eq$3 = (a2, b2, loose) => compare$a(a2, b2, loose) === 0
var eq_1 = eq$3
const parse$3 = parse_1
const eq$2 = eq_1
const diff$1 = (version1, version2) => {
  if (eq$2(version1, version2)) {
    return null
  } else {
    const v1 = parse$3(version1)
    const v2 = parse$3(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? "pre" : ""
    const defaultResult = hasPre ? "prerelease" : ""
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult
  }
}
var diff_1 = diff$1
const SemVer$9 = semver$1
const major$1 = (a2, loose) => new SemVer$9(a2, loose).major
var major_1 = major$1
const SemVer$8 = semver$1
const minor$1 = (a2, loose) => new SemVer$8(a2, loose).minor
var minor_1 = minor$1
const SemVer$7 = semver$1
const patch$1 = (a2, loose) => new SemVer$7(a2, loose).patch
var patch_1 = patch$1
const parse$2 = parse_1
const prerelease$1 = (version2, options) => {
  const parsed = parse$2(version2, options)
  return parsed && parsed.prerelease.length ? parsed.prerelease : null
}
var prerelease_1 = prerelease$1
const compare$9 = compare_1
const rcompare$1 = (a2, b2, loose) => compare$9(b2, a2, loose)
var rcompare_1 = rcompare$1
const compare$8 = compare_1
const compareLoose$1 = (a2, b2) => compare$8(a2, b2, true)
var compareLoose_1 = compareLoose$1
const SemVer$6 = semver$1
const compareBuild$3 = (a2, b2, loose) => {
  const versionA = new SemVer$6(a2, loose)
  const versionB = new SemVer$6(b2, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
var compareBuild_1 = compareBuild$3
const compareBuild$2 = compareBuild_1
const sort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$2(a2, b2, loose))
var sort_1 = sort$1
const compareBuild$1 = compareBuild_1
const rsort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$1(b2, a2, loose))
var rsort_1 = rsort$1
const compare$7 = compare_1
const gt$4 = (a2, b2, loose) => compare$7(a2, b2, loose) > 0
var gt_1 = gt$4
const compare$6 = compare_1
const lt$3 = (a2, b2, loose) => compare$6(a2, b2, loose) < 0
var lt_1 = lt$3
const compare$5 = compare_1
const neq$2 = (a2, b2, loose) => compare$5(a2, b2, loose) !== 0
var neq_1 = neq$2
const compare$4 = compare_1
const gte$3 = (a2, b2, loose) => compare$4(a2, b2, loose) >= 0
var gte_1 = gte$3
const compare$3 = compare_1
const lte$3 = (a2, b2, loose) => compare$3(a2, b2, loose) <= 0
var lte_1 = lte$3
const eq$1 = eq_1
const neq$1 = neq_1
const gt$3 = gt_1
const gte$2 = gte_1
const lt$2 = lt_1
const lte$2 = lte_1
const cmp$1 = (a2, op, b2, loose) => {
  switch (op) {
    case "===":
      if (typeof a2 === "object") {
        a2 = a2.version
      }
      if (typeof b2 === "object") {
        b2 = b2.version
      }
      return a2 === b2
    case "!==":
      if (typeof a2 === "object") {
        a2 = a2.version
      }
      if (typeof b2 === "object") {
        b2 = b2.version
      }
      return a2 !== b2
    case "":
    case "=":
    case "==":
      return eq$1(a2, b2, loose)
    case "!=":
      return neq$1(a2, b2, loose)
    case ">":
      return gt$3(a2, b2, loose)
    case ">=":
      return gte$2(a2, b2, loose)
    case "<":
      return lt$2(a2, b2, loose)
    case "<=":
      return lte$2(a2, b2, loose)
    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
var cmp_1 = cmp$1
const SemVer$5 = semver$1
const parse$1 = parse_1
const { re, t } = reExports
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2
  }
  if (typeof version2 === "number") {
    version2 = String(version2)
  }
  if (typeof version2 !== "string") {
    return null
  }
  options = options || {}
  let match = null
  if (!options.rtl) {
    match = version2.match(re[t.COERCE])
  } else {
    let next
    while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    re[t.COERCERTL].lastIndex = -1
  }
  if (match === null) {
    return null
  }
  return parse$1(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options)
}
var coerce_1 = coerce$1
var iterator
var hasRequiredIterator
function requireIterator() {
  if (hasRequiredIterator) return iterator
  hasRequiredIterator = 1
  iterator = function (Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value
      }
    }
  }
  return iterator
}
var yallist
var hasRequiredYallist
function requireYallist() {
  if (hasRequiredYallist) return yallist
  hasRequiredYallist = 1
  yallist = Yallist
  Yallist.Node = Node
  Yallist.create = Yallist
  function Yallist(list) {
    var self2 = this
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist()
    }
    self2.tail = null
    self2.head = null
    self2.length = 0
    if (list && typeof list.forEach === "function") {
      list.forEach(function (item) {
        self2.push(item)
      })
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self2.push(arguments[i])
      }
    }
    return self2
  }
  Yallist.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list")
    }
    var next = node.next
    var prev = node.prev
    if (next) {
      next.prev = prev
    }
    if (prev) {
      prev.next = next
    }
    if (node === this.head) {
      this.head = next
    }
    if (node === this.tail) {
      this.tail = prev
    }
    node.list.length--
    node.next = null
    node.prev = null
    node.list = null
    return next
  }
  Yallist.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return
    }
    if (node.list) {
      node.list.removeNode(node)
    }
    var head = this.head
    node.list = this
    node.next = head
    if (head) {
      head.prev = node
    }
    this.head = node
    if (!this.tail) {
      this.tail = node
    }
    this.length++
  }
  Yallist.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return
    }
    if (node.list) {
      node.list.removeNode(node)
    }
    var tail = this.tail
    node.list = this
    node.prev = tail
    if (tail) {
      tail.next = node
    }
    this.tail = node
    if (!this.head) {
      this.head = node
    }
    this.length++
  }
  Yallist.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i])
    }
    return this.length
  }
  Yallist.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i])
    }
    return this.length
  }
  Yallist.prototype.pop = function () {
    if (!this.tail) {
      return void 0
    }
    var res = this.tail.value
    this.tail = this.tail.prev
    if (this.tail) {
      this.tail.next = null
    } else {
      this.head = null
    }
    this.length--
    return res
  }
  Yallist.prototype.shift = function () {
    if (!this.head) {
      return void 0
    }
    var res = this.head.value
    this.head = this.head.next
    if (this.head) {
      this.head.prev = null
    } else {
      this.tail = null
    }
    this.length--
    return res
  }
  Yallist.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this)
      walker = walker.next
    }
  }
  Yallist.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this)
      walker = walker.prev
    }
  }
  Yallist.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next
    }
    if (i === n && walker !== null) {
      return walker.value
    }
  }
  Yallist.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev
    }
    if (i === n && walker !== null) {
      return walker.value
    }
  }
  Yallist.prototype.map = function (fn, thisp) {
    thisp = thisp || this
    var res = new Yallist()
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this))
      walker = walker.next
    }
    return res
  }
  Yallist.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this
    var res = new Yallist()
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this))
      walker = walker.prev
    }
    return res
  }
  Yallist.prototype.reduce = function (fn, initial) {
    var acc
    var walker = this.head
    if (arguments.length > 1) {
      acc = initial
    } else if (this.head) {
      walker = this.head.next
      acc = this.head.value
    } else {
      throw new TypeError("Reduce of empty list with no initial value")
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i)
      walker = walker.next
    }
    return acc
  }
  Yallist.prototype.reduceReverse = function (fn, initial) {
    var acc
    var walker = this.tail
    if (arguments.length > 1) {
      acc = initial
    } else if (this.tail) {
      walker = this.tail.prev
      acc = this.tail.value
    } else {
      throw new TypeError("Reduce of empty list with no initial value")
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i)
      walker = walker.prev
    }
    return acc
  }
  Yallist.prototype.toArray = function () {
    var arr = new Array(this.length)
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value
      walker = walker.next
    }
    return arr
  }
  Yallist.prototype.toArrayReverse = function () {
    var arr = new Array(this.length)
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value
      walker = walker.prev
    }
    return arr
  }
  Yallist.prototype.slice = function (from, to) {
    to = to || this.length
    if (to < 0) {
      to += this.length
    }
    from = from || 0
    if (from < 0) {
      from += this.length
    }
    var ret = new Yallist()
    if (to < from || to < 0) {
      return ret
    }
    if (from < 0) {
      from = 0
    }
    if (to > this.length) {
      to = this.length
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value)
    }
    return ret
  }
  Yallist.prototype.sliceReverse = function (from, to) {
    to = to || this.length
    if (to < 0) {
      to += this.length
    }
    from = from || 0
    if (from < 0) {
      from += this.length
    }
    var ret = new Yallist()
    if (to < from || to < 0) {
      return ret
    }
    if (from < 0) {
      from = 0
    }
    if (to > this.length) {
      to = this.length
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value)
    }
    return ret
  }
  Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1
    }
    if (start < 0) {
      start = this.length + start
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next
    }
    var ret = []
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value)
      walker = this.removeNode(walker)
    }
    if (walker === null) {
      walker = this.tail
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert2(this, walker, nodes[i])
    }
    return ret
  }
  Yallist.prototype.reverse = function () {
    var head = this.head
    var tail = this.tail
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev
      walker.prev = walker.next
      walker.next = p
    }
    this.head = tail
    this.tail = head
    return this
  }
  function insert2(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2)
    if (inserted.next === null) {
      self2.tail = inserted
    }
    if (inserted.prev === null) {
      self2.head = inserted
    }
    self2.length++
    return inserted
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2)
    if (!self2.head) {
      self2.head = self2.tail
    }
    self2.length++
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2)
    if (!self2.tail) {
      self2.tail = self2.head
    }
    self2.length++
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list)
    }
    this.list = list
    this.value = value
    if (prev) {
      prev.next = this
      this.prev = prev
    } else {
      this.prev = null
    }
    if (next) {
      next.prev = this
      this.next = next
    } else {
      this.next = null
    }
  }
  try {
    requireIterator()(Yallist)
  } catch (er) {}
  return yallist
}
var lruCache
var hasRequiredLruCache
function requireLruCache() {
  if (hasRequiredLruCache) return lruCache
  hasRequiredLruCache = 1
  const Yallist = requireYallist()
  const MAX = Symbol("max")
  const LENGTH = Symbol("length")
  const LENGTH_CALCULATOR = Symbol("lengthCalculator")
  const ALLOW_STALE = Symbol("allowStale")
  const MAX_AGE = Symbol("maxAge")
  const DISPOSE = Symbol("dispose")
  const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet")
  const LRU_LIST = Symbol("lruList")
  const CACHE = Symbol("cache")
  const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet")
  const naiveLength = () => 1
  class LRUCache {
    constructor(options) {
      if (typeof options === "number") options = { max: options }
      if (!options) options = {}
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number")
      this[MAX] = options.max || Infinity
      const lc = options.length || naiveLength
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc
      this[ALLOW_STALE] = options.stale || false
      if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number")
      this[MAX_AGE] = options.maxAge || 0
      this[DISPOSE] = options.dispose
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
      this.reset()
    }
    // resize the cache when the max changes.
    set max(mL) {
      if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number")
      this[MAX] = mL || Infinity
      trim2(this)
    }
    get max() {
      return this[MAX]
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale
    }
    get allowStale() {
      return this[ALLOW_STALE]
    }
    set maxAge(mA) {
      if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number")
      this[MAX_AGE] = mA
      trim2(this)
    }
    get maxAge() {
      return this[MAX_AGE]
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
      if (typeof lC !== "function") lC = naiveLength
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC
        this[LENGTH] = 0
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
          this[LENGTH] += hit.length
        })
      }
      trim2(this)
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR]
    }
    get length() {
      return this[LENGTH]
    }
    get itemCount() {
      return this[LRU_LIST].length
    }
    rforEach(fn, thisp) {
      thisp = thisp || this
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev = walker.prev
        forEachStep(this, fn, walker, thisp)
        walker = prev
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next = walker.next
        forEachStep(this, fn, walker, thisp)
        walker = next
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k2) => k2.key)
    }
    values() {
      return this[LRU_LIST].toArray().map((k2) => k2.value)
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value))
      }
      this[CACHE] = /* @__PURE__ */ new Map()
      this[LRU_LIST] = new Yallist()
      this[LENGTH] = 0
    }
    dump() {
      return this[LRU_LIST].map((hit) =>
        isStale(this, hit)
          ? false
          : {
              k: hit.key,
              v: hit.value,
              e: hit.now + (hit.maxAge || 0),
            }
      )
        .toArray()
        .filter((h) => h)
    }
    dumpLru() {
      return this[LRU_LIST]
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE]
      if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number")
      const now = maxAge ? Date.now() : 0
      const len = this[LENGTH_CALCULATOR](value, key)
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key))
          return false
        }
        const node = this[CACHE].get(key)
        const item = node.value
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value)
        }
        item.now = now
        item.maxAge = maxAge
        item.value = value
        this[LENGTH] += len - item.length
        item.length = len
        this.get(key)
        trim2(this)
        return true
      }
      const hit = new Entry(key, value, len, now, maxAge)
      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value)
        return false
      }
      this[LENGTH] += hit.length
      this[LRU_LIST].unshift(hit)
      this[CACHE].set(key, this[LRU_LIST].head)
      trim2(this)
      return true
    }
    has(key) {
      if (!this[CACHE].has(key)) return false
      const hit = this[CACHE].get(key).value
      return !isStale(this, hit)
    }
    get(key) {
      return get(this, key, true)
    }
    peek(key) {
      return get(this, key, false)
    }
    pop() {
      const node = this[LRU_LIST].tail
      if (!node) return null
      del(this, node)
      return node.value
    }
    del(key) {
      del(this, this[CACHE].get(key))
    }
    load(arr) {
      this.reset()
      const now = Date.now()
      for (let l = arr.length - 1; l >= 0; l--) {
        const hit = arr[l]
        const expiresAt = hit.e || 0
        if (expiresAt === 0) this.set(hit.k, hit.v)
        else {
          const maxAge = expiresAt - now
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge)
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false))
    }
  }
  const get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key)
    if (node) {
      const hit = node.value
      if (isStale(self2, hit)) {
        del(self2, node)
        if (!self2[ALLOW_STALE]) return void 0
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET]) node.value.now = Date.now()
          self2[LRU_LIST].unshiftNode(node)
        }
      }
      return hit.value
    }
  }
  const isStale = (self2, hit) => {
    if (!hit || (!hit.maxAge && !self2[MAX_AGE])) return false
    const diff2 = Date.now() - hit.now
    return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE]
  }
  const trim2 = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev
        del(self2, walker)
        walker = prev
      }
    }
  }
  const del = (self2, node) => {
    if (node) {
      const hit = node.value
      if (self2[DISPOSE]) self2[DISPOSE](hit.key, hit.value)
      self2[LENGTH] -= hit.length
      self2[CACHE].delete(hit.key)
      self2[LRU_LIST].removeNode(node)
    }
  }
  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key
      this.value = value
      this.length = length
      this.now = now
      this.maxAge = maxAge || 0
    }
  }
  const forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value
    if (isStale(self2, hit)) {
      del(self2, node)
      if (!self2[ALLOW_STALE]) hit = void 0
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self2)
  }
  lruCache = LRUCache
  return lruCache
}
var range
var hasRequiredRange
function requireRange() {
  if (hasRequiredRange) return range
  hasRequiredRange = 1
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options)
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2
        } else {
          return new Range2(range2.raw, options)
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value
        this.set = [[range2]]
        this.format()
        return this
      }
      this.options = options
      this.loose = !!options.loose
      this.includePrerelease = !!options.includePrerelease
      this.raw = range2
      this.set = range2
        .split("||")
        .map((r) => this.parseRange(r.trim()))
        .filter((c) => c.length)
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range2}`)
      }
      if (this.set.length > 1) {
        const first = this.set[0]
        this.set = this.set.filter((c) => !isNullSet(c[0]))
        if (this.set.length === 0) {
          this.set = [first]
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c]
              break
            }
          }
        }
      }
      this.format()
    }
    format() {
      this.range = this.set
        .map((comps) => {
          return comps.join(" ").trim()
        })
        .join("||")
        .trim()
      return this.range
    }
    toString() {
      return this.range
    }
    parseRange(range2) {
      range2 = range2.trim()
      const memoOpts = Object.keys(this.options).join(",")
      const memoKey = `parseRange:${memoOpts}:${range2}`
      const cached = cache.get(memoKey)
      if (cached) {
        return cached
      }
      const loose = this.options.loose
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE]
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease))
      debug2("hyphen replace", range2)
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace)
      debug2("comparator trim", range2)
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace)
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace)
      range2 = range2.split(/\s+/).join(" ")
      let rangeList = range2
        .split(" ")
        .map((comp) => parseComparator(comp, this.options))
        .join(" ")
        .split(/\s+/)
        .map((comp) => replaceGTE0(comp, this.options))
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options)
          return !!comp.match(re2[t2.COMPARATORLOOSE])
        })
      }
      debug2("range list", rangeList)
      const rangeMap = /* @__PURE__ */ new Map()
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options))
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp]
        }
        rangeMap.set(comp.value, comp)
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("")
      }
      const result = [...rangeMap.values()]
      cache.set(memoKey, result)
      return result
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required")
      }
      return this.set.some((thisComparators) => {
        return (
          isSatisfiable(thisComparators, options) &&
          range2.set.some((rangeComparators) => {
            return (
              isSatisfiable(rangeComparators, options) &&
              thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options)
                })
              })
            )
          })
        )
      })
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options)
        } catch (er) {
          return false
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true
        }
      }
      return false
    }
  }
  range = Range2
  const LRU = requireLruCache()
  const cache = new LRU({ max: 1e3 })
  const parseOptions2 = parseOptions_1
  const Comparator2 = requireComparator()
  const debug2 = debug_1
  const SemVer3 = semver$1
  const { re: re2, t: t2, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = reExports
  const isNullSet = (c) => c.value === "<0.0.0-0"
  const isAny = (c) => c.value === ""
  const isSatisfiable = (comparators, options) => {
    let result = true
    const remainingComparators = comparators.slice()
    let testComparator = remainingComparators.pop()
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options)
      })
      testComparator = remainingComparators.pop()
    }
    return result
  }
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options)
    comp = replaceCarets(comp, options)
    debug2("caret", comp)
    comp = replaceTildes(comp, options)
    debug2("tildes", comp)
    comp = replaceXRanges(comp, options)
    debug2("xrange", comp)
    comp = replaceStars(comp, options)
    debug2("stars", comp)
    return comp
  }
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*"
  const replaceTildes = (comp, options) =>
    comp
      .trim()
      .split(/\s+/)
      .map((c) => {
        return replaceTilde(c, options)
      })
      .join(" ")
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE]
    return comp.replace(r, (_2, M2, m, p, pr) => {
      debug2("tilde", comp, _2, M2, m, p, pr)
      let ret
      if (isX(M2)) {
        ret = ""
      } else if (isX(m)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`
      } else if (isX(p)) {
        ret = `>=${M2}.${m}.0 <${M2}.${+m + 1}.0-0`
      } else if (pr) {
        debug2("replaceTilde pr", pr)
        ret = `>=${M2}.${m}.${p}-${pr} <${M2}.${+m + 1}.0-0`
      } else {
        ret = `>=${M2}.${m}.${p} <${M2}.${+m + 1}.0-0`
      }
      debug2("tilde return", ret)
      return ret
    })
  }
  const replaceCarets = (comp, options) =>
    comp
      .trim()
      .split(/\s+/)
      .map((c) => {
        return replaceCaret(c, options)
      })
      .join(" ")
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options)
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET]
    const z2 = options.includePrerelease ? "-0" : ""
    return comp.replace(r, (_2, M2, m, p, pr) => {
      debug2("caret", comp, _2, M2, m, p, pr)
      let ret
      if (isX(M2)) {
        ret = ""
      } else if (isX(m)) {
        ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`
      } else if (isX(p)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m}.0${z2} <${M2}.${+m + 1}.0-0`
        } else {
          ret = `>=${M2}.${m}.0${z2} <${+M2 + 1}.0.0-0`
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr)
        if (M2 === "0") {
          if (m === "0") {
            ret = `>=${M2}.${m}.${p}-${pr} <${M2}.${m}.${+p + 1}-0`
          } else {
            ret = `>=${M2}.${m}.${p}-${pr} <${M2}.${+m + 1}.0-0`
          }
        } else {
          ret = `>=${M2}.${m}.${p}-${pr} <${+M2 + 1}.0.0-0`
        }
      } else {
        debug2("no pr")
        if (M2 === "0") {
          if (m === "0") {
            ret = `>=${M2}.${m}.${p}${z2} <${M2}.${m}.${+p + 1}-0`
          } else {
            ret = `>=${M2}.${m}.${p}${z2} <${M2}.${+m + 1}.0-0`
          }
        } else {
          ret = `>=${M2}.${m}.${p} <${+M2 + 1}.0.0-0`
        }
      }
      debug2("caret return", ret)
      return ret
    })
  }
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options)
    return comp
      .split(/\s+/)
      .map((c) => {
        return replaceXRange(c, options)
      })
      .join(" ")
  }
  const replaceXRange = (comp, options) => {
    comp = comp.trim()
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE]
    return comp.replace(r, (ret, gtlt, M2, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M2, m, p, pr)
      const xM = isX(M2)
      const xm = xM || isX(m)
      const xp = xm || isX(p)
      const anyX = xp
      if (gtlt === "=" && anyX) {
        gtlt = ""
      }
      pr = options.includePrerelease ? "-0" : ""
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0"
        } else {
          ret = "*"
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0
        }
        p = 0
        if (gtlt === ">") {
          gtlt = ">="
          if (xm) {
            M2 = +M2 + 1
            m = 0
            p = 0
          } else {
            m = +m + 1
            p = 0
          }
        } else if (gtlt === "<=") {
          gtlt = "<"
          if (xm) {
            M2 = +M2 + 1
          } else {
            m = +m + 1
          }
        }
        if (gtlt === "<") {
          pr = "-0"
        }
        ret = `${gtlt + M2}.${m}.${p}${pr}`
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`
      } else if (xp) {
        ret = `>=${M2}.${m}.0${pr} <${M2}.${+m + 1}.0-0`
      }
      debug2("xRange return", ret)
      return ret
    })
  }
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options)
    return comp.trim().replace(re2[t2.STAR], "")
  }
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options)
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "")
  }
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = ""
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`
    } else if (fpr) {
      from = `>=${from}`
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`
    }
    if (isX(tM)) {
      to = ""
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`
    } else {
      to = `<=${to}`
    }
    return `${from} ${to}`.trim()
  }
  const testSet = (set, version2, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug2(set[i].semver)
        if (set[i].semver === Comparator2.ANY) {
          continue
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver
          if (
            allowed.major === version2.major &&
            allowed.minor === version2.minor &&
            allowed.patch === version2.patch
          ) {
            return true
          }
        }
      }
      return false
    }
    return true
  }
  return range
}
var comparator
var hasRequiredComparator
function requireComparator() {
  if (hasRequiredComparator) return comparator
  hasRequiredComparator = 1
  const ANY2 = Symbol("SemVer ANY")
  class Comparator2 {
    static get ANY() {
      return ANY2
    }
    constructor(comp, options) {
      options = parseOptions2(options)
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp
        } else {
          comp = comp.value
        }
      }
      debug2("comparator", comp, options)
      this.options = options
      this.loose = !!options.loose
      this.parse(comp)
      if (this.semver === ANY2) {
        this.value = ""
      } else {
        this.value = this.operator + this.semver.version
      }
      debug2("comp", this)
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR]
      const m = comp.match(r)
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`)
      }
      this.operator = m[1] !== void 0 ? m[1] : ""
      if (this.operator === "=") {
        this.operator = ""
      }
      if (!m[2]) {
        this.semver = ANY2
      } else {
        this.semver = new SemVer3(m[2], this.options.loose)
      }
    }
    toString() {
      return this.value
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose)
      if (this.semver === ANY2 || version2 === ANY2) {
        return true
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options)
        } catch (er) {
          return false
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options)
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required")
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false,
        }
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true
        }
        return new Range2(comp.value, options).test(this.value)
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true
        }
        return new Range2(this.value, options).test(comp.semver)
      }
      const sameDirectionIncreasing =
        (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">")
      const sameDirectionDecreasing =
        (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<")
      const sameSemVer = this.semver.version === comp.semver.version
      const differentDirectionsInclusive =
        (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=")
      const oppositeDirectionsLessThan =
        cmp2(this.semver, "<", comp.semver, options) &&
        (this.operator === ">=" || this.operator === ">") &&
        (comp.operator === "<=" || comp.operator === "<")
      const oppositeDirectionsGreaterThan =
        cmp2(this.semver, ">", comp.semver, options) &&
        (this.operator === "<=" || this.operator === "<") &&
        (comp.operator === ">=" || comp.operator === ">")
      return (
        sameDirectionIncreasing ||
        sameDirectionDecreasing ||
        (sameSemVer && differentDirectionsInclusive) ||
        oppositeDirectionsLessThan ||
        oppositeDirectionsGreaterThan
      )
    }
  }
  comparator = Comparator2
  const parseOptions2 = parseOptions_1
  const { re: re2, t: t2 } = reExports
  const cmp2 = cmp_1
  const debug2 = debug_1
  const SemVer3 = semver$1
  const Range2 = requireRange()
  return comparator
}
const Range$9 = requireRange()
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options)
  } catch (er) {
    return false
  }
  return range2.test(version2)
}
var satisfies_1 = satisfies$4
const Range$8 = requireRange()
const toComparators$1 = (range2, options) =>
  new Range$8(range2, options).set.map((comp) =>
    comp
      .map((c) => c.value)
      .join(" ")
      .trim()
      .split(" ")
  )
var toComparators_1 = toComparators$1
const SemVer$4 = semver$1
const Range$7 = requireRange()
const maxSatisfying$1 = (versions, range2, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range$7(range2, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v
        maxSV = new SemVer$4(max, options)
      }
    }
  })
  return max
}
var maxSatisfying_1 = maxSatisfying$1
const SemVer$3 = semver$1
const Range$6 = requireRange()
const minSatisfying$1 = (versions, range2, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range$6(range2, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v
        minSV = new SemVer$3(min, options)
      }
    }
  })
  return min
}
var minSatisfying_1 = minSatisfying$1
const SemVer$2 = semver$1
const Range$5 = requireRange()
const gt$2 = gt_1
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose)
  let minver = new SemVer$2("0.0.0")
  if (range2.test(minver)) {
    return minver
  }
  minver = new SemVer$2("0.0.0-0")
  if (range2.test(minver)) {
    return minver
  }
  minver = null
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i]
    let setMin = null
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version)
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver
          }
          break
        case "<":
        case "<=":
          break
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`)
      }
    })
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin
    }
  }
  if (minver && range2.test(minver)) {
    return minver
  }
  return null
}
var minVersion_1 = minVersion$1
const Range$4 = requireRange()
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*"
  } catch (er) {
    return null
  }
}
var valid$1 = validRange$1
const SemVer$1 = semver$1
const Comparator$2 = requireComparator()
const { ANY: ANY$1 } = Comparator$2
const Range$3 = requireRange()
const satisfies$3 = satisfies_1
const gt$1 = gt_1
const lt$1 = lt_1
const lte$1 = lte_1
const gte$1 = gte_1
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options)
  range2 = new Range$3(range2, options)
  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case ">":
      gtfn = gt$1
      ltefn = lte$1
      ltfn = lt$1
      comp = ">"
      ecomp = ">="
      break
    case "<":
      gtfn = lt$1
      ltefn = gte$1
      ltfn = gt$1
      comp = "<"
      ecomp = "<="
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }
  if (satisfies$3(version2, range2, options)) {
    return false
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i]
    let high = null
    let low = null
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0")
      }
      high = high || comparator2
      low = low || comparator2
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2
      }
    })
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false
    }
  }
  return true
}
var outside_1 = outside$3
const outside$2 = outside_1
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options)
var gtr_1 = gtr$1
const outside$1 = outside_1
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options)
var ltr_1 = ltr$1
const Range$2 = requireRange()
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options)
  r2 = new Range$2(r2, options)
  return r1.intersects(r2)
}
var intersects_1 = intersects$1
const satisfies$2 = satisfies_1
const compare$2 = compare_1
var simplify = (versions, range2, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a2, b2) => compare$2(a2, b2, options))
  for (const version2 of v) {
    const included = satisfies$2(version2, range2, options)
    if (included) {
      prev = version2
      if (!first) {
        first = version2
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }
  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push("*")
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(" || ")
  const original = typeof range2.raw === "string" ? range2.raw : String(range2)
  return simplified.length < original.length ? simplified : range2
}
const Range$1 = requireRange()
const Comparator$1 = requireComparator()
const { ANY } = Comparator$1
const satisfies$1 = satisfies_1
const compare$1 = compare_1
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }
  sub = new Range$1(sub, options)
  dom = new Range$1(dom, options)
  let sawNonNull = false
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    if (sawNonNull) {
      return false
    }
  }
  return true
}
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = [new Comparator$1(">=0.0.0-0")]
    } else {
      sub = [new Comparator$1(">=0.0.0")]
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = [new Comparator$1(">=0.0.0")]
    }
  }
  const eqSet = /* @__PURE__ */ new Set()
  let gt2, lt2
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options)
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }
  if (eqSet.size > 1) {
    return null
  }
  let gtltComp
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false
      }
    }
    return true
  }
  let higher, lower
  let hasDomLT, hasDomGT
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false
  if (
    needDomLTPre &&
    needDomLTPre.prerelease.length === 1 &&
    lt2.operator === "<" &&
    needDomLTPre.prerelease[0] === 0
  ) {
    needDomLTPre = false
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">="
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<="
    if (gt2) {
      if (needDomGTPre) {
        if (
          c.semver.prerelease &&
          c.semver.prerelease.length &&
          c.semver.major === needDomGTPre.major &&
          c.semver.minor === needDomGTPre.minor &&
          c.semver.patch === needDomGTPre.patch
        ) {
          needDomGTPre = false
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options)
        if (higher === c && higher !== gt2) {
          return false
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (
          c.semver.prerelease &&
          c.semver.prerelease.length &&
          c.semver.major === needDomLTPre.major &&
          c.semver.minor === needDomLTPre.minor &&
          c.semver.patch === needDomLTPre.patch
        ) {
          needDomLTPre = false
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options)
        if (lower === c && lower !== lt2) {
          return false
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false
  }
  if (needDomGTPre || needDomLTPre) {
    return false
  }
  return true
}
const higherGT = (a2, b2, options) => {
  if (!a2) {
    return b2
  }
  const comp = compare$1(a2.semver, b2.semver, options)
  return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2
}
const lowerLT = (a2, b2, options) => {
  if (!a2) {
    return b2
  }
  const comp = compare$1(a2.semver, b2.semver, options)
  return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2
}
var subset_1 = subset$1
const internalRe = reExports
const constants = constants$1
const SemVer = semver$1
const identifiers = identifiers$1
const parse = parse_1
const valid = valid_1
const clean = clean_1
const inc = inc_1
const diff = diff_1
const major = major_1
const minor = minor_1
const patch = patch_1
const prerelease = prerelease_1
const compare = compare_1
const rcompare = rcompare_1
const compareLoose = compareLoose_1
const compareBuild = compareBuild_1
const sort = sort_1
const rsort = rsort_1
const gt = gt_1
const lt = lt_1
const eq = eq_1
const neq = neq_1
const gte = gte_1
const lte = lte_1
const cmp = cmp_1
const coerce = coerce_1
const Comparator = requireComparator()
const Range = requireRange()
const satisfies = satisfies_1
const toComparators = toComparators_1
const maxSatisfying = maxSatisfying_1
const minSatisfying = minSatisfying_1
const minVersion = minVersion_1
const validRange = valid$1
const outside = outside_1
const gtr = gtr_1
const ltr = ltr_1
const intersects = intersects_1
const simplifyRange = simplify
const subset = subset_1
var semver = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}
class FileClient {
  constructor() {
    this.electronApi = {
      readDir(p) {
        const fs = window.require("fs")
        const path = window.require("path")
        const SIYUAN_WORKSPACE = path.join(window.siyuan.config.system.dataDir, "..")
        return new Promise((resolve2) => {
          fs.readdir(path.join(SIYUAN_WORKSPACE, p), (err, files) => {
            if (err) {
              resolve2([])
              return
            }
            const result = files.map((f) => ({
              isDir: fs.statSync(path.join(SIYUAN_WORKSPACE, p, f)).isDirectory(),
              name: f,
            }))
            resolve2(result)
          })
        })
      },
      getFile(f, type = "text") {
        return new Promise((resolve2, reject) => {
          const fs = window.require("fs")
          const path = window.require("path")
          const SIYUAN_WORKSPACE = path.join(window.siyuan.config.system.dataDir, "..")
          fs.readFile(path.join(SIYUAN_WORKSPACE, f), (err, data) => {
            if (err) {
              return reject(err)
            }
            const text2 = data.toString("utf8")
            if (type === "json") {
              try {
                return resolve2(JSON.parse(text2))
              } catch (e) {
                reject(e)
                return
              }
            }
            return resolve2(text2)
          })
        })
      },
      putFile,
      removeFile(f) {
        return new Promise((resolve2, reject) => {
          const fs = window.require("fs")
          const path = window.require("path")
          const SIYUAN_WORKSPACE = path.join(window.siyuan.config.system.dataDir, "..")
          const p = path.join(SIYUAN_WORKSPACE, f)
          log("Remove files from", p)
          fs.rm(p, { recursive: true, force: true }, (err) => {
            if (err) {
              return reject(err)
            }
            resolve2(null)
          })
        })
      },
    }
    this.serverApi = {
      readDir,
      getFile,
      putFile,
      removeFile,
    }
    const v = this.getVersion()
    if (semver.compare(v, "2.8.1") < 0) {
      this.fileApi = this.electronApi
    } else {
      this.fileApi = this.serverApi
    }
  }
  getVersion() {
    return window.siyuan.config.system.kernelVersion
  }
  static getInstanceApi() {
    if (!this.fileClient) {
      this.fileClient = new FileClient()
    }
    return this.fileClient
  }
}
const author$1 = "作者"
const version$1 = "版本"
const description$1 = "描述"
const goBack$1 = "返回"
const url$1 = "地址"
const readme$1 = "README"
const loading$1 = "加载中"
const downloading$1 = "下载中"
const downloaded$1 = "已下载"
const download$1 = "下载"
const upgrade$1 = "升级"
const nodescription$1 = "无描述内容"
const safemode$1 = "安全模式"
const safemodetip$1 = "关闭安全模式允许第三方插件加载"
const autoupgrade$1 = "自动更新"
const autoupgradetip$1 = "从固定位置获取版本并更新本地存储的插件系统脚本"
const store_url$1 = "插件商店地址"
const store_url_tip$1 = "线上插件系统仓库地址, 默认为"
const menu_common$1 = "通用配置"
const menu_list$1 = "插件列表"
const menu_store$1 = "插件商店"
const plugin_system$1 = "插件系统"
const plugin_system_setting$1 = "插件系统设置"
const reload$1 = "重载"
const show_plugin_system_config$1 = "显示插件系统配置"
const reload_window$1 = "重载当前窗口"
const shortcut$1 = "快捷键"
const show_command_panel$1 = "显示控制面板"
const uninstall$1 = "卸载"
const new_version_widget$1 = "集市发现新版本的插件系统,请前往更新并重载"
const zh_CN = {
  author: author$1,
  version: version$1,
  description: description$1,
  goBack: goBack$1,
  url: url$1,
  readme: readme$1,
  loading: loading$1,
  downloading: downloading$1,
  downloaded: downloaded$1,
  download: download$1,
  upgrade: upgrade$1,
  nodescription: nodescription$1,
  safemode: safemode$1,
  safemodetip: safemodetip$1,
  autoupgrade: autoupgrade$1,
  autoupgradetip: autoupgradetip$1,
  store_url: store_url$1,
  store_url_tip: store_url_tip$1,
  menu_common: menu_common$1,
  menu_list: menu_list$1,
  menu_store: menu_store$1,
  plugin_system: plugin_system$1,
  plugin_system_setting: plugin_system_setting$1,
  reload: reload$1,
  show_plugin_system_config: show_plugin_system_config$1,
  reload_window: reload_window$1,
  shortcut: shortcut$1,
  show_command_panel: show_command_panel$1,
  uninstall: uninstall$1,
  new_version_widget: new_version_widget$1,
}
const author = "Author"
const version = "Version"
const description = "Description"
const goBack = "Go Back"
const url = "URL"
const readme = "README"
const loading = "Loading"
const downloading = "Downloading"
const downloaded = "Downloaded"
const download = "Download"
const upgrade = "Upgrade"
const nodescription = "No Description content"
const safemode = "Safe Mode"
const safemodetip = "Turn off safe mode to enable third party plugins."
const autoupgrade = "Auto Upgrade"
const autoupgradetip = "Auto upgrade plugin system online."
const store_url = "Plugin Store URL"
const store_url_tip = "Plugin Store URL, default is"
const menu_common = "Common Setting"
const menu_list = "Plugins"
const menu_store = "Store"
const plugin_system = "Plugin System"
const plugin_system_setting = "Plugin System Setting"
const reload = "Reload"
const show_plugin_system_config = "Show plugin system config"
const reload_window = "Reload current window"
const shortcut = "Shortcut"
const show_command_panel = "Show command panel"
const uninstall = "Uninstall"
const new_version_widget = "New version plugin system found in Bazzar, please upgrade and reload."
const en_US = {
  author,
  version,
  description,
  goBack,
  url,
  readme,
  loading,
  downloading,
  downloaded,
  download,
  upgrade,
  nodescription,
  safemode,
  safemodetip,
  autoupgrade,
  autoupgradetip,
  store_url,
  store_url_tip,
  menu_common,
  menu_list,
  menu_store,
  plugin_system,
  plugin_system_setting,
  reload,
  show_plugin_system_config,
  reload_window,
  shortcut,
  show_command_panel,
  uninstall,
  new_version_widget,
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments)
  }
}
const { toString } = Object.prototype
const { getPrototypeOf } = Object
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing)
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase())
})(/* @__PURE__ */ Object.create(null))
const kindOfTest = (type) => {
  type = type.toLowerCase()
  return (thing) => kindOf(thing) === type
}
const typeOfTest = (type) => (thing) => typeof thing === type
const { isArray } = Array
const isUndefined = typeOfTest("undefined")
function isBuffer(val) {
  return (
    val !== null &&
    !isUndefined(val) &&
    val.constructor !== null &&
    !isUndefined(val.constructor) &&
    isFunction(val.constructor.isBuffer) &&
    val.constructor.isBuffer(val)
  )
}
const isArrayBuffer = kindOfTest("ArrayBuffer")
function isArrayBufferView(val) {
  let result
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val)
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer)
  }
  return result
}
const isString = typeOfTest("string")
const isFunction = typeOfTest("function")
const isNumber = typeOfTest("number")
const isObject = (thing) => thing !== null && typeof thing === "object"
const isBoolean = (thing) => thing === true || thing === false
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false
  }
  const prototype2 = getPrototypeOf(val)
  return (
    (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) &&
    !(Symbol.toStringTag in val) &&
    !(Symbol.iterator in val)
  )
}
const isDate = kindOfTest("Date")
const isFile = kindOfTest("File")
const isBlob = kindOfTest("Blob")
const isFileList = kindOfTest("FileList")
const isStream = (val) => isObject(val) && isFunction(val.pipe)
const isFormData = (thing) => {
  const pattern = "[object FormData]"
  return (
    thing &&
    ((typeof FormData === "function" && thing instanceof FormData) ||
      toString.call(thing) === pattern ||
      (isFunction(thing.toString) && thing.toString() === pattern))
  )
}
const isURLSearchParams = kindOfTest("URLSearchParams")
const trim = (str) => (str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""))
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return
  }
  let i
  let l
  if (typeof obj !== "object") {
    obj = [obj]
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj)
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj)
    const len = keys.length
    let key
    for (i = 0; i < len; i++) {
      key = keys[i]
      fn.call(null, obj[key], key, obj)
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase()
  const keys = Object.keys(obj)
  let i = keys.length
  let _key
  while (i-- > 0) {
    _key = keys[i]
    if (key === _key.toLowerCase()) {
      return _key
    }
  }
  return null
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global
})()
const isContextDefined = (context) => !isUndefined(context) && context !== _global
function merge() {
  const { caseless } = (isContextDefined(this) && this) || {}
  const result = {}
  const assignValue = (val, key) => {
    const targetKey = (caseless && findKey(result, key)) || key
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val)
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val)
    } else if (isArray(val)) {
      result[targetKey] = val.slice()
    } else {
      result[targetKey] = val
    }
  }
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue)
  }
  return result
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(
    b2,
    (val, key) => {
      if (thisArg && isFunction(val)) {
        a2[key] = bind(val, thisArg)
      } else {
        a2[key] = val
      }
    },
    { allOwnKeys }
  )
  return a2
}
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1)
  }
  return content
}
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2)
  constructor.prototype.constructor = constructor
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype,
  })
  props && Object.assign(constructor.prototype, props)
}
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props
  let i
  let prop
  const merged = {}
  destObj = destObj || {}
  if (sourceObj == null) return destObj
  do {
    props = Object.getOwnPropertyNames(sourceObj)
    i = props.length
    while (i-- > 0) {
      prop = props[i]
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop]
        merged[prop] = true
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj)
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype)
  return destObj
}
const endsWith = (str, searchString, position) => {
  str = String(str)
  if (position === void 0 || position > str.length) {
    position = str.length
  }
  position -= searchString.length
  const lastIndex = str.indexOf(searchString, position)
  return lastIndex !== -1 && lastIndex === position
}
const toArray = (thing) => {
  if (!thing) return null
  if (isArray(thing)) return thing
  let i = thing.length
  if (!isNumber(i)) return null
  const arr = new Array(i)
  while (i-- > 0) {
    arr[i] = thing[i]
  }
  return arr
}
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray
  }
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array))
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator]
  const iterator2 = generator.call(obj)
  let result
  while ((result = iterator2.next()) && !result.done) {
    const pair = result.value
    fn.call(obj, pair[0], pair[1])
  }
}
const matchAll = (regExp, str) => {
  let matches
  const arr = []
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches)
  }
  return arr
}
const isHTMLForm = kindOfTest("HTMLFormElement")
const toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2
  })
}
const hasOwnProperty = (
  ({ hasOwnProperty: hasOwnProperty2 }) =>
  (obj, prop) =>
    hasOwnProperty2.call(obj, prop)
)(Object.prototype)
const isRegExp = kindOfTest("RegExp")
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj)
  const reducedDescriptors = {}
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor
    }
  })
  Object.defineProperties(obj, reducedDescriptors)
}
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false
    }
    const value = obj[name2]
    if (!isFunction(value)) return
    descriptor.enumerable = false
    if ("writable" in descriptor) {
      descriptor.writable = false
      return
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'")
      }
    }
  })
}
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {}
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true
    })
  }
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter))
  return obj
}
const noop$1 = () => {}
const toFiniteNumber = (value, defaultValue) => {
  value = +value
  return Number.isFinite(value) ? value : defaultValue
}
const ALPHA = "abcdefghijklmnopqrstuvwxyz"
const DIGIT = "0123456789"
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT,
}
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = ""
  const { length } = alphabet
  while (size--) {
    str += alphabet[(Math.random() * length) | 0]
  }
  return str
}
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator])
}
const toJSONObject = (obj) => {
  const stack = new Array(10)
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return
      }
      if (!("toJSON" in source)) {
        stack[i] = source
        const target = isArray(source) ? [] : {}
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1)
          !isUndefined(reducedValue) && (target[key] = reducedValue)
        })
        stack[i] = void 0
        return target
      }
    }
    return source
  }
  return visit(obj, 0)
}
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
}
function AxiosError(message, code3, config2, request2, response) {
  Error.call(this)
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor)
  } else {
    this.stack = new Error().stack
  }
  this.message = message
  this.name = "AxiosError"
  code3 && (this.code = code3)
  config2 && (this.config = config2)
  request2 && (this.request = request2)
  response && (this.response = response)
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null,
    }
  },
})
const prototype$1 = AxiosError.prototype
const descriptors = {}
;[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
  // eslint-disable-next-line func-names
].forEach((code3) => {
  descriptors[code3] = { value: code3 }
})
Object.defineProperties(AxiosError, descriptors)
Object.defineProperty(prototype$1, "isAxiosError", { value: true })
AxiosError.from = (error2, code3, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype$1)
  utils.toFlatObject(
    error2,
    axiosError,
    function filter3(obj) {
      return obj !== Error.prototype
    },
    (prop) => {
      return prop !== "isAxiosError"
    }
  )
  AxiosError.call(axiosError, error2.message, code3, config2, request2, response)
  axiosError.cause = error2
  axiosError.name = error2.name
  customProps && Object.assign(axiosError, customProps)
  return axiosError
}
const httpAdapter = null
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing)
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key
}
function renderKey(path, key, dots) {
  if (!path) return key
  return path
    .concat(key)
    .map(function each(token, i) {
      token = removeBrackets(token)
      return !dots && i ? "[" + token + "]" : token
    })
    .join(dots ? "." : "")
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable)
}
const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop)
})
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object")
  }
  formData = formData || new FormData()
  options = utils.toFlatObject(
    options,
    {
      metaTokens: true,
      dots: false,
      indexes: false,
    },
    false,
    function defined(option, source) {
      return !utils.isUndefined(source[option])
    }
  )
  const metaTokens = options.metaTokens
  const visitor = options.visitor || defaultVisitor
  const dots = options.dots
  const indexes = options.indexes
  const _Blob = options.Blob || (typeof Blob !== "undefined" && Blob)
  const useBlob = _Blob && utils.isSpecCompliantForm(formData)
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function")
  }
  function convertValue(value) {
    if (value === null) return ""
    if (utils.isDate(value)) {
      return value.toISOString()
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.")
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value)
    }
    return value
  }
  function defaultVisitor(value, key, path) {
    let arr = value
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2)
        value = JSON.stringify(value)
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value)))
      ) {
        key = removeBrackets(key)
        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) &&
            formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            )
        })
        return false
      }
    }
    if (isVisitable(value)) {
      return true
    }
    formData.append(renderKey(path, key, dots), convertValue(value))
    return false
  }
  const stack = []
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable,
  })
  function build(value, path) {
    if (utils.isUndefined(value)) return
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."))
    }
    stack.push(value)
    utils.forEach(value, function each(el, key) {
      const result =
        !(utils.isUndefined(el) || el === null) &&
        visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers)
      if (result === true) {
        build(el, path ? path.concat(key) : [key])
      }
    })
    stack.pop()
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object")
  }
  build(obj)
  return formData
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  }
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match]
  })
}
function AxiosURLSearchParams(params, options) {
  this._pairs = []
  params && toFormData(params, this, options)
}
const prototype = AxiosURLSearchParams.prototype
prototype.append = function append2(name2, value) {
  this._pairs.push([name2, value])
}
prototype.toString = function toString2(encoder) {
  const _encode = encoder
    ? function (value) {
        return encoder.call(this, value, encode$1)
      }
    : encode$1
  return this._pairs
    .map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1])
    }, "")
    .join("&")
}
function encode(val) {
  return encodeURIComponent(val)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]")
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2
  }
  const _encode = (options && options.encode) || encode
  const serializeFn = options && options.serialize
  let serializedParams
  if (serializeFn) {
    serializedParams = serializeFn(params, options)
  } else {
    serializedParams = utils.isURLSearchParams(params)
      ? params.toString()
      : new AxiosURLSearchParams(params, options).toString(_encode)
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#")
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex)
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams
  }
  return url2
}
class InterceptorManager {
  constructor() {
    this.handlers = []
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null,
    })
    return this.handlers.length - 1
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = []
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h)
      }
    })
  }
}
const InterceptorManager$1 = InterceptorManager
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false,
}
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams
const FormData$1 = typeof FormData !== "undefined" ? FormData : null
const Blob$1 = typeof Blob !== "undefined" ? Blob : null
const isStandardBrowserEnv = (() => {
  let product
  if (
    typeof navigator !== "undefined" &&
    ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")
  ) {
    return false
  }
  return typeof window !== "undefined" && typeof document !== "undefined"
})()
const isStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === "function"
  )
})()
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1,
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"],
}
function toURLEncodedForm(data, options) {
  return toFormData(
    data,
    new platform.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (value, key, path, helpers) {
          if (platform.isNode && utils.isBuffer(value)) {
            this.append(key, value.toString("base64"))
            return false
          }
          return helpers.defaultVisitor.apply(this, arguments)
        },
      },
      options
    )
  )
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0]
  })
}
function arrayToObject(arr) {
  const obj = {}
  const keys = Object.keys(arr)
  let i
  const len = keys.length
  let key
  for (i = 0; i < len; i++) {
    key = keys[i]
    obj[key] = arr[key]
  }
  return obj
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++]
    const isNumericKey = Number.isFinite(+name2)
    const isLast = index >= path.length
    name2 = !name2 && utils.isArray(target) ? target.length : name2
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value]
      } else {
        target[name2] = value
      }
      return !isNumericKey
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = []
    }
    const result = buildPath(path, value, target[name2], index)
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2])
    }
    return !isNumericKey
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {}
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0)
    })
    return obj
  }
  return null
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0,
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      ;(parser || JSON.parse)(rawValue)
      return utils.trim(rawValue)
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue)
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [
    function transformRequest(data, headers) {
      const contentType = headers.getContentType() || ""
      const hasJSONContentType = contentType.indexOf("application/json") > -1
      const isObjectPayload = utils.isObject(data)
      if (isObjectPayload && utils.isHTMLForm(data)) {
        data = new FormData(data)
      }
      const isFormData2 = utils.isFormData(data)
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data
      }
      if (
        utils.isArrayBuffer(data) ||
        utils.isBuffer(data) ||
        utils.isStream(data) ||
        utils.isFile(data) ||
        utils.isBlob(data)
      ) {
        return data
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer
      }
      if (utils.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false)
        return data.toString()
      }
      let isFileList2
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString()
        }
        if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData
          return toFormData(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData(), this.formSerializer)
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false)
        return stringifySafely(data)
      }
      return data
    },
  ],
  transformResponse: [
    function transformResponse(data) {
      const transitional2 = this.transitional || defaults.transitional
      const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing
      const JSONRequested = this.responseType === "json"
      if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
        const silentJSONParsing = transitional2 && transitional2.silentJSONParsing
        const strictJSONParsing = !silentJSONParsing && JSONRequested
        try {
          return JSON.parse(data)
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response)
            }
            throw e
          }
        }
      }
      return data
    },
  ],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob,
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
    },
  },
}
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {}
})
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE)
})
const defaults$1 = defaults
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent",
])
const parseHeaders = (rawHeaders) => {
  const parsed = {}
  let key
  let val
  let i
  rawHeaders &&
    rawHeaders.split("\n").forEach(function parser(line) {
      i = line.indexOf(":")
      key = line.substring(0, i).trim().toLowerCase()
      val = line.substring(i + 1).trim()
      if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
        return
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val)
        } else {
          parsed[key] = [val]
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val
      }
    })
  return parsed
}
const $internals = Symbol("internals")
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase()
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value)
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null)
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g
  let match
  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2]
  }
  return tokens
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim())
}
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils.isFunction(filter3)) {
    return filter3.call(this, value, header)
  }
  if (isHeaderNameFilter) {
    value = header
  }
  if (!utils.isString(value)) return
  if (utils.isString(filter3)) {
    return value.indexOf(filter3) !== -1
  }
  if (utils.isRegExp(filter3)) {
    return filter3.test(value)
  }
}
function formatHeader(header) {
  return header
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str
    })
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header)
  ;["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3)
      },
      configurable: true,
    })
  })
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers)
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header)
      if (!lHeader) {
        throw new Error("header name must be a non-empty string")
      }
      const key = utils.findKey(self2, lHeader)
      if (!key || self2[key] === void 0 || _rewrite === true || (_rewrite === void 0 && self2[key] !== false)) {
        self2[key || _header] = normalizeValue(_value)
      }
    }
    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite))
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite)
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite)
    }
    return this
  }
  get(header, parser) {
    header = normalizeHeader(header)
    if (header) {
      const key = utils.findKey(this, header)
      if (key) {
        const value = this[key]
        if (!parser) {
          return value
        }
        if (parser === true) {
          return parseTokens(value)
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key)
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value)
        }
        throw new TypeError("parser must be boolean|regexp|function")
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header)
    if (header) {
      const key = utils.findKey(this, header)
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)))
    }
    return false
  }
  delete(header, matcher) {
    const self2 = this
    let deleted = false
    function deleteHeader(_header) {
      _header = normalizeHeader(_header)
      if (_header) {
        const key = utils.findKey(self2, _header)
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key]
          deleted = true
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader)
    } else {
      deleteHeader(header)
    }
    return deleted
  }
  clear(matcher) {
    const keys = Object.keys(this)
    let i = keys.length
    let deleted = false
    while (i--) {
      const key = keys[i]
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key]
        deleted = true
      }
    }
    return deleted
  }
  normalize(format) {
    const self2 = this
    const headers = {}
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header)
      if (key) {
        self2[key] = normalizeValue(value)
        delete self2[header]
        return
      }
      const normalized = format ? formatHeader(header) : String(header).trim()
      if (normalized !== header) {
        delete self2[header]
      }
      self2[normalized] = normalizeValue(value)
      headers[normalized] = true
    })
    return this
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets)
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null)
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value)
    })
    return obj
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]()
  }
  toString() {
    return Object.entries(this.toJSON())
      .map(([header, value]) => header + ": " + value)
      .join("\n")
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders"
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing)
  }
  static concat(first, ...targets) {
    const computed = new this(first)
    targets.forEach((target) => computed.set(target))
    return computed
  }
  static accessor(header) {
    const internals =
      (this[$internals] =
      this[$internals] =
        {
          accessors: {},
        })
    const accessors = internals.accessors
    const prototype2 = this.prototype
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header)
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header)
        accessors[lHeader] = true
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header)
    return this
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"])
utils.freezeMethods(AxiosHeaders.prototype)
utils.freezeMethods(AxiosHeaders)
const AxiosHeaders$1 = AxiosHeaders
function transformData(fns, response) {
  const config2 = this || defaults$1
  const context = response || config2
  const headers = AxiosHeaders$1.from(context.headers)
  let data = context.data
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0)
  })
  headers.normalize()
  return data
}
function isCancel(value) {
  return !!(value && value.__CANCEL__)
}
function CanceledError(message, config2, request2) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request2)
  this.name = "CanceledError"
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true,
})
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response)
  } else {
    reject(
      new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      )
    )
  }
}
const cookies = platform.isStandardBrowserEnv
  ? // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name2, value, expires, path, domain, secure) {
          const cookie = []
          cookie.push(name2 + "=" + encodeURIComponent(value))
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString())
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path)
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain)
          }
          if (secure === true) {
            cookie.push("secure")
          }
          document.cookie = cookie.join("; ")
        },
        read: function read(name2) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"))
          return match ? decodeURIComponent(match[3]) : null
        },
        remove: function remove(name2) {
          this.write(name2, "", Date.now() - 864e5)
        },
      }
    })()
  : // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() {
          return null
        },
        remove: function remove() {},
      }
    })()
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2)
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL)
  }
  return requestedURL
}
const isURLSameOrigin = platform.isStandardBrowserEnv
  ? // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv2() {
      const msie = /(msie|trident)/i.test(navigator.userAgent)
      const urlParsingNode = document.createElement("a")
      let originURL
      function resolveURL(url2) {
        let href = url2
        if (msie) {
          urlParsingNode.setAttribute("href", href)
          href = urlParsingNode.href
        }
        urlParsingNode.setAttribute("href", href)
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname,
        }
      }
      originURL = resolveURL(window.location.href)
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host
      }
    })()
  : // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv2() {
      return function isURLSameOrigin2() {
        return true
      }
    })()
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2)
  return (match && match[1]) || ""
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10
  const bytes = new Array(samplesCount)
  const timestamps = new Array(samplesCount)
  let head = 0
  let tail = 0
  let firstSampleTS
  min = min !== void 0 ? min : 1e3
  return function push(chunkLength) {
    const now = Date.now()
    const startedAt = timestamps[tail]
    if (!firstSampleTS) {
      firstSampleTS = now
    }
    bytes[head] = chunkLength
    timestamps[head] = now
    let i = tail
    let bytesCount = 0
    while (i !== head) {
      bytesCount += bytes[i++]
      i = i % samplesCount
    }
    head = (head + 1) % samplesCount
    if (head === tail) {
      tail = (tail + 1) % samplesCount
    }
    if (now - firstSampleTS < min) {
      return
    }
    const passed = startedAt && now - startedAt
    return passed ? Math.round((bytesCount * 1e3) / passed) : void 0
  }
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0
  const _speedometer = speedometer(50, 250)
  return (e) => {
    const loaded = e.loaded
    const total = e.lengthComputable ? e.total : void 0
    const progressBytes = loaded - bytesNotified
    const rate = _speedometer(progressBytes)
    const inRange = loaded <= total
    bytesNotified = loaded
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
    }
    data[isDownloadStream ? "download" : "upload"] = true
    listener(data)
  }
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined"
const xhrAdapter =
  isXHRAdapterSupported &&
  function (config2) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      let requestData = config2.data
      const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize()
      const responseType = config2.responseType
      let onCanceled
      function done() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled)
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled)
        }
      }
      if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
        requestHeaders.setContentType(false)
      }
      let request2 = new XMLHttpRequest()
      if (config2.auth) {
        const username = config2.auth.username || ""
        const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : ""
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password))
      }
      const fullPath = buildFullPath(config2.baseURL, config2.url)
      request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true)
      request2.timeout = config2.timeout
      function onloadend() {
        if (!request2) {
          return
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
        )
        const responseData =
          !responseType || responseType === "text" || responseType === "json"
            ? request2.responseText
            : request2.response
        const response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config: config2,
          request: request2,
        }
        settle(
          function _resolve(value) {
            resolve2(value)
            done()
          },
          function _reject(err) {
            reject(err)
            done()
          },
          response
        )
        request2 = null
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return
          }
          setTimeout(onloadend)
        }
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request2))
        request2 = null
      }
      request2.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request2))
        request2 = null
      }
      request2.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded"
        const transitional2 = config2.transitional || transitionalDefaults
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage
        }
        reject(
          new AxiosError(
            timeoutErrorMessage,
            transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config2,
            request2
          )
        )
        request2 = null
      }
      if (platform.isStandardBrowserEnv) {
        const xsrfValue =
          (config2.withCredentials || isURLSameOrigin(fullPath)) &&
          config2.xsrfCookieName &&
          cookies.read(config2.xsrfCookieName)
        if (xsrfValue) {
          requestHeaders.set(config2.xsrfHeaderName, xsrfValue)
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null)
      if ("setRequestHeader" in request2) {
        utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request2.setRequestHeader(key, val)
        })
      }
      if (!utils.isUndefined(config2.withCredentials)) {
        request2.withCredentials = !!config2.withCredentials
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config2.responseType
      }
      if (typeof config2.onDownloadProgress === "function") {
        request2.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true))
      }
      if (typeof config2.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress))
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = (cancel) => {
          if (!request2) {
            return
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config2, request2) : cancel)
          request2.abort()
          request2 = null
        }
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled)
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled)
        }
      }
      const protocol = parseProtocol(fullPath)
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2))
        return
      }
      request2.send(requestData || null)
    })
  }
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
}
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value })
    } catch (e) {}
    Object.defineProperty(fn, "adapterName", { value })
  }
})
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2]
    const { length } = adapters2
    let nameOrAdapter
    let adapter
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i]
      if ((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
        break
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(`Adapter ${nameOrAdapter} is not supported by the environment`, "ERR_NOT_SUPPORT")
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter)
          ? `Adapter '${nameOrAdapter}' is not available in the build`
          : `Unknown adapter '${nameOrAdapter}'`
      )
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function")
    }
    return adapter
  },
  adapters: knownAdapters,
}
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested()
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2)
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2)
  config2.headers = AxiosHeaders$1.from(config2.headers)
  config2.data = transformData.call(config2, config2.transformRequest)
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false)
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter)
  return adapter(config2).then(
    function onAdapterResolution(response) {
      throwIfCancellationRequested(config2)
      response.data = transformData.call(config2, config2.transformResponse, response)
      response.headers = AxiosHeaders$1.from(response.headers)
      return response
    },
    function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2)
        if (reason && reason.response) {
          reason.response.data = transformData.call(config2, config2.transformResponse, reason.response)
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers)
        }
      }
      return Promise.reject(reason)
    }
  )
}
const headersToObject = (thing) => (thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing)
function mergeConfig(config1, config2) {
  config2 = config2 || {}
  const config3 = {}
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source)
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source)
    } else if (utils.isArray(source)) {
      return source.slice()
    }
    return source
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless)
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless)
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2)
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2)
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2)
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2)
    } else if (prop in config1) {
      return getMergedValue(void 0, a2)
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true),
  }
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties
    const configValue = merge2(config1[prop], config2[prop], prop)
    ;(utils.isUndefined(configValue) && merge2 !== mergeDirectKeys) || (config3[prop] = configValue)
  })
  return config3
}
const VERSION = "1.3.4"
const validators$1 = {}
;["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type
  }
})
const deprecatedWarnings = {}
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "")
  }
  return (value, opt, opts2) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      )
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true
      console.warn(
        formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future")
      )
    }
    return validator2 ? validator2(value, opt, opts2) : true
  }
}
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE)
  }
  const keys = Object.keys(options)
  let i = keys.length
  while (i-- > 0) {
    const opt = keys[i]
    const validator2 = schema[opt]
    if (validator2) {
      const value = options[opt]
      const result = value === void 0 || validator2(value, opt, options)
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE)
      }
      continue
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION)
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1,
}
const validators = validator.validators
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1(),
    }
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {}
      config2.url = configOrUrl
    } else {
      config2 = configOrUrl || {}
    }
    config2 = mergeConfig(this.defaults, config2)
    const { transitional: transitional2, paramsSerializer, headers } = config2
    if (transitional2 !== void 0) {
      validator.assertOptions(
        transitional2,
        {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean),
        },
        false
      )
    }
    if (paramsSerializer !== void 0) {
      validator.assertOptions(
        paramsSerializer,
        {
          encode: validators.function,
          serialize: validators.function,
        },
        true
      )
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase()
    let contextHeaders
    contextHeaders = headers && utils.merge(headers.common, headers[config2.method])
    contextHeaders &&
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
        delete headers[method]
      })
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers)
    const requestInterceptorChain = []
    let synchronousRequestInterceptors = true
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected)
    })
    const responseInterceptorChain = []
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected)
    })
    let promise
    let i = 0
    let len
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0]
      chain.unshift.apply(chain, requestInterceptorChain)
      chain.push.apply(chain, responseInterceptorChain)
      len = chain.length
      promise = Promise.resolve(config2)
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++])
      }
      return promise
    }
    len = requestInterceptorChain.length
    let newConfig = config2
    i = 0
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++]
      const onRejected = requestInterceptorChain[i++]
      try {
        newConfig = onFulfilled(newConfig)
      } catch (error2) {
        onRejected.call(this, error2)
        break
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig)
    } catch (error2) {
      return Promise.reject(error2)
    }
    i = 0
    len = responseInterceptorChain.length
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++])
    }
    return promise
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2)
    const fullPath = buildFullPath(config2.baseURL, config2.url)
    return buildURL(fullPath, config2.params, config2.paramsSerializer)
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function (url2, config2) {
    return this.request(
      mergeConfig(config2 || {}, {
        method,
        url: url2,
        data: (config2 || {}).data,
      })
    )
  }
})
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(
        mergeConfig(config2 || {}, {
          method,
          headers: isForm
            ? {
                "Content-Type": "multipart/form-data",
              }
            : {},
          url: url2,
          data,
        })
      )
    }
  }
  Axios.prototype[method] = generateHTTPMethod()
  Axios.prototype[method + "Form"] = generateHTTPMethod(true)
})
const Axios$1 = Axios
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.")
    }
    let resolvePromise
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2
    })
    const token = this
    this.promise.then((cancel) => {
      if (!token._listeners) return
      let i = token._listeners.length
      while (i-- > 0) {
        token._listeners[i](cancel)
      }
      token._listeners = null
    })
    this.promise.then = (onfulfilled) => {
      let _resolve
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2)
        _resolve = resolve2
      }).then(onfulfilled)
      promise.cancel = function reject() {
        token.unsubscribe(_resolve)
      }
      return promise
    }
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return
      }
      token.reason = new CanceledError(message, config2, request2)
      resolvePromise(token.reason)
    })
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason)
      return
    }
    if (this._listeners) {
      this._listeners.push(listener)
    } else {
      this._listeners = [listener]
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return
    }
    const index = this._listeners.indexOf(listener)
    if (index !== -1) {
      this._listeners.splice(index, 1)
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel
    const token = new CancelToken(function executor(c) {
      cancel = c
    })
    return {
      token,
      cancel,
    }
  }
}
const CancelToken$1 = CancelToken
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr)
  }
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
}
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key
})
const HttpStatusCode$1 = HttpStatusCode
function createInstance(defaultConfig2) {
  const context = new Axios$1(defaultConfig2)
  const instance2 = bind(Axios$1.prototype.request, context)
  utils.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true })
  utils.extend(instance2, context, null, { allOwnKeys: true })
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig2, instanceConfig))
  }
  return instance2
}
const axios = createInstance(defaults$1)
axios.Axios = Axios$1
axios.CanceledError = CanceledError
axios.CancelToken = CancelToken$1
axios.isCancel = isCancel
axios.VERSION = VERSION
axios.toFormData = toFormData
axios.AxiosError = AxiosError
axios.Cancel = axios.CanceledError
axios.all = function all(promises) {
  return Promise.all(promises)
}
axios.spread = spread
axios.isAxiosError = isAxiosError
axios.mergeConfig = mergeConfig
axios.AxiosHeaders = AxiosHeaders$1
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing)
axios.HttpStatusCode = HttpStatusCode$1
axios.default = axios
const axios$1 = axios
const factory = M.customLogFactory(S.LOG_LEVEL_INFO, "PluginSystem")
const pluginSystemLogger = factory.getLogger("plugin system")
const log = (...p) => {
  pluginSystemLogger.info(...p)
}
const request = axios$1.create({
  withCredentials: false,
  headers: {
    "Cache-Control": "no-cache",
    Pragma: "no-cache",
    Expires: "0",
  },
})
const sleep = async (t2) => {
  return new Promise((resolve2) => {
    setTimeout(() => resolve2(null), t2)
  })
}
const error = (...p) => pluginSystemLogger.error(...p)
const reloadWindow = () => window.location.reload()
const genUUID = () =>
  ([1e7].toString() + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>
    (parseInt(c, 10) ^ (window.crypto.getRandomValues(new Uint32Array(1))[0] & (15 >> (parseInt(c, 10) / 4)))).toString(
      16
    )
  )
async function isExists(p) {
  try {
    const res = await FileClient.getInstanceApi().fileApi.getFile(p)
    return res !== null
  } catch {
    return false
  }
}
let Error$1 = class Error2 {
  constructor(message) {
    this.message = message
  }
}
class Warning {
  constructor(message) {
    this.message = message
  }
}
const showInfoMessage = (message, timeout) => new Notification({ type: "info", message, timeout }).show()
const showErrorMessage = (message, timeout) => new Notification({ type: "error", message, timeout }).show()
const getLogger = (name2) => factory.getLogger(name2)
const langs = {
  zh_CN,
  en_US,
}
const _ = (v) => {
  return langs[window.siyuan.config.lang][v] || "not defined"
}
var NAMED_TAG = "named"
var NAME_TAG = "name"
var UNMANAGED_TAG = "unmanaged"
var OPTIONAL_TAG = "optional"
var INJECT_TAG = "inject"
var MULTI_INJECT_TAG = "multi_inject"
var TAGGED = "inversify:tagged"
var TAGGED_PROP = "inversify:tagged_props"
var PARAM_TYPES = "inversify:paramtypes"
var DESIGN_PARAM_TYPES = "design:paramtypes"
var POST_CONSTRUCT = "post_construct"
var PRE_DESTROY = "pre_destroy"
function getNonCustomTagKeys() {
  return [INJECT_TAG, MULTI_INJECT_TAG, NAME_TAG, UNMANAGED_TAG, NAMED_TAG, OPTIONAL_TAG]
}
var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys()
var BindingScopeEnum = {
  Request: "Request",
  Singleton: "Singleton",
  Transient: "Transient",
}
var BindingTypeEnum = {
  ConstantValue: "ConstantValue",
  Constructor: "Constructor",
  DynamicValue: "DynamicValue",
  Factory: "Factory",
  Function: "Function",
  Instance: "Instance",
  Invalid: "Invalid",
  Provider: "Provider",
}
var TargetTypeEnum = {
  ClassProperty: "ClassProperty",
  ConstructorArgument: "ConstructorArgument",
  Variable: "Variable",
}
var idCounter = 0
function id() {
  return idCounter++
}
var Binding = (function () {
  function Binding2(serviceIdentifier, scope) {
    this.id = id()
    this.activated = false
    this.serviceIdentifier = serviceIdentifier
    this.scope = scope
    this.type = BindingTypeEnum.Invalid
    this.constraint = function (request2) {
      return true
    }
    this.implementationType = null
    this.cache = null
    this.factory = null
    this.provider = null
    this.onActivation = null
    this.onDeactivation = null
    this.dynamicValue = null
  }
  Binding2.prototype.clone = function () {
    var clone = new Binding2(this.serviceIdentifier, this.scope)
    clone.activated = clone.scope === BindingScopeEnum.Singleton ? this.activated : false
    clone.implementationType = this.implementationType
    clone.dynamicValue = this.dynamicValue
    clone.scope = this.scope
    clone.type = this.type
    clone.factory = this.factory
    clone.provider = this.provider
    clone.constraint = this.constraint
    clone.onActivation = this.onActivation
    clone.onDeactivation = this.onDeactivation
    clone.cache = this.cache
    return clone
  }
  return Binding2
})()
var DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times."
var DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:"
var NULL_ARGUMENT = "NULL argument"
var KEY_NOT_FOUND = "Key Not Found"
var AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:"
var CANNOT_UNBIND = "Could not unbind serviceIdentifier:"
var NOT_REGISTERED = "No matching bindings found for serviceIdentifier:"
var MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:"
var MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:"
var UNDEFINED_INJECT_ANNOTATION = function (name2) {
  return (
    "@inject called with undefined this could mean that the class " +
    name2 +
    " has a circular dependency problem. You can use a LazyServiceIdentifer to  overcome this limitation."
  )
}
var CIRCULAR_DEPENDENCY = "Circular dependency found:"
var INVALID_BINDING_TYPE = "Invalid binding type:"
var NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore."
var INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!"
var INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!"
var LAZY_IN_SYNC = function (key) {
  return "You are attempting to construct '" + key + "' in a synchronous way\n but it has asynchronous dependencies."
}
var INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier"
var INVALID_DECORATOR_OPERATION =
  "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property."
var ARGUMENTS_LENGTH_MISMATCH = function () {
  var values = []
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i]
  }
  return (
    "The number of constructor arguments in the derived class " +
    (values[0] + " must be >= than the number of constructor arguments of its base class.")
  )
}
var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object."
var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE =
  "Invalid Container option. Default scope must be a string ('singleton' or 'transient')."
var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean"
var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean"
var ASYNC_UNBIND_REQUIRED =
  "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)"
var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) {
  return "@postConstruct error in class " + clazz + ": " + errorMessage
}
var PRE_DESTROY_ERROR = function (clazz, errorMessage) {
  return "@preDestroy error in class " + clazz + ": " + errorMessage
}
var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) {
  return "onDeactivation() error in class " + clazz + ": " + errorMessage
}
var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {
  return (
    "It looks like there is a circular dependency in one of the '" +
    factoryType +
    "' bindings. Please investigate bindings with" +
    ("service identifier '" + serviceIdentifier + "'.")
  )
}
var STACK_OVERFLOW = "Maximum call stack size exceeded"
var MetadataReader = (function () {
  function MetadataReader2() {}
  MetadataReader2.prototype.getConstructorMetadata = function (constructorFunc) {
    var compilerGeneratedMetadata = Reflect.getMetadata(PARAM_TYPES, constructorFunc)
    var userGeneratedMetadata = Reflect.getMetadata(TAGGED, constructorFunc)
    return {
      compilerGeneratedMetadata,
      userGeneratedMetadata: userGeneratedMetadata || {},
    }
  }
  MetadataReader2.prototype.getPropertiesMetadata = function (constructorFunc) {
    var userGeneratedMetadata = Reflect.getMetadata(TAGGED_PROP, constructorFunc) || []
    return userGeneratedMetadata
  }
  return MetadataReader2
})()
var BindingCount = {
  MultipleBindingsAvailable: 2,
  NoBindingsAvailable: 0,
  OnlyOneBindingAvailable: 1,
}
function isStackOverflowExeption(error2) {
  return error2 instanceof RangeError || error2.message === STACK_OVERFLOW
}
var tryAndThrowErrorIfStackOverflow = function (fn, errorCallback) {
  try {
    return fn()
  } catch (error2) {
    if (isStackOverflowExeption(error2)) {
      error2 = errorCallback()
    }
    throw error2
  }
}
function getServiceIdentifierAsString(serviceIdentifier) {
  if (typeof serviceIdentifier === "function") {
    var _serviceIdentifier = serviceIdentifier
    return _serviceIdentifier.name
  } else if (typeof serviceIdentifier === "symbol") {
    return serviceIdentifier.toString()
  } else {
    var _serviceIdentifier = serviceIdentifier
    return _serviceIdentifier
  }
}
function listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifier, getBindings2) {
  var registeredBindingsList = ""
  var registeredBindings = getBindings2(container2, serviceIdentifier)
  if (registeredBindings.length !== 0) {
    registeredBindingsList = "\nRegistered bindings:"
    registeredBindings.forEach(function (binding) {
      var name2 = "Object"
      if (binding.implementationType !== null) {
        name2 = getFunctionName(binding.implementationType)
      }
      registeredBindingsList = registeredBindingsList + "\n " + name2
      if (binding.constraint.metaData) {
        registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData
      }
    })
  }
  return registeredBindingsList
}
function alreadyDependencyChain(request2, serviceIdentifier) {
  if (request2.parentRequest === null) {
    return false
  } else if (request2.parentRequest.serviceIdentifier === serviceIdentifier) {
    return true
  } else {
    return alreadyDependencyChain(request2.parentRequest, serviceIdentifier)
  }
}
function dependencyChainToString(request2) {
  function _createStringArr(req, result) {
    if (result === void 0) {
      result = []
    }
    var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier)
    result.push(serviceIdentifier)
    if (req.parentRequest !== null) {
      return _createStringArr(req.parentRequest, result)
    }
    return result
  }
  var stringArr = _createStringArr(request2)
  return stringArr.reverse().join(" --> ")
}
function circularDependencyToException(request2) {
  request2.childRequests.forEach(function (childRequest) {
    if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
      var services = dependencyChainToString(childRequest)
      throw new Error(CIRCULAR_DEPENDENCY + " " + services)
    } else {
      circularDependencyToException(childRequest)
    }
  })
}
function listMetadataForTarget(serviceIdentifierString, target) {
  if (target.isTagged() || target.isNamed()) {
    var m_1 = ""
    var namedTag = target.getNamedTag()
    var otherTags = target.getCustomTags()
    if (namedTag !== null) {
      m_1 += namedTag.toString() + "\n"
    }
    if (otherTags !== null) {
      otherTags.forEach(function (tag) {
        m_1 += tag.toString() + "\n"
      })
    }
    return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1
  } else {
    return " " + serviceIdentifierString
  }
}
function getFunctionName(func) {
  if (func.name) {
    return func.name
  } else {
    var name_1 = func.toString()
    var match = name_1.match(/^function\s*([^\s(]+)/)
    return match ? match[1] : "Anonymous function: " + name_1
  }
}
function getSymbolDescription(symbol) {
  return symbol.toString().slice(7, -1)
}
var Context = (function () {
  function Context2(container2) {
    this.id = id()
    this.container = container2
  }
  Context2.prototype.addPlan = function (plan2) {
    this.plan = plan2
  }
  Context2.prototype.setCurrentRequest = function (currentRequest) {
    this.currentRequest = currentRequest
  }
  return Context2
})()
var Metadata = (function () {
  function Metadata2(key, value) {
    this.key = key
    this.value = value
  }
  Metadata2.prototype.toString = function () {
    if (this.key === NAMED_TAG) {
      return "named: " + String(this.value).toString() + " "
    } else {
      return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }"
    }
  }
  return Metadata2
})()
var Plan = (function () {
  function Plan2(parentContext, rootRequest) {
    this.parentContext = parentContext
    this.rootRequest = rootRequest
  }
  return Plan2
})()
var LazyServiceIdentifer = (function () {
  function LazyServiceIdentifer2(cb) {
    this._cb = cb
  }
  LazyServiceIdentifer2.prototype.unwrap = function () {
    return this._cb()
  }
  return LazyServiceIdentifer2
})()
var QueryableString = (function () {
  function QueryableString2(str) {
    this.str = str
  }
  QueryableString2.prototype.startsWith = function (searchString) {
    return this.str.indexOf(searchString) === 0
  }
  QueryableString2.prototype.endsWith = function (searchString) {
    var reverseString = ""
    var reverseSearchString = searchString.split("").reverse().join("")
    reverseString = this.str.split("").reverse().join("")
    return this.startsWith.call({ str: reverseString }, reverseSearchString)
  }
  QueryableString2.prototype.contains = function (searchString) {
    return this.str.indexOf(searchString) !== -1
  }
  QueryableString2.prototype.equals = function (compareString) {
    return this.str === compareString
  }
  QueryableString2.prototype.value = function () {
    return this.str
  }
  return QueryableString2
})()
var Target = (function () {
  function Target2(type, identifier, serviceIdentifier, namedOrTagged) {
    this.id = id()
    this.type = type
    this.serviceIdentifier = serviceIdentifier
    var queryableName = typeof identifier === "symbol" ? getSymbolDescription(identifier) : identifier
    this.name = new QueryableString(queryableName || "")
    this.identifier = identifier
    this.metadata = []
    var metadataItem = null
    if (typeof namedOrTagged === "string") {
      metadataItem = new Metadata(NAMED_TAG, namedOrTagged)
    } else if (namedOrTagged instanceof Metadata) {
      metadataItem = namedOrTagged
    }
    if (metadataItem !== null) {
      this.metadata.push(metadataItem)
    }
  }
  Target2.prototype.hasTag = function (key) {
    for (var _i = 0, _a2 = this.metadata; _i < _a2.length; _i++) {
      var m = _a2[_i]
      if (m.key === key) {
        return true
      }
    }
    return false
  }
  Target2.prototype.isArray = function () {
    return this.hasTag(MULTI_INJECT_TAG)
  }
  Target2.prototype.matchesArray = function (name2) {
    return this.matchesTag(MULTI_INJECT_TAG)(name2)
  }
  Target2.prototype.isNamed = function () {
    return this.hasTag(NAMED_TAG)
  }
  Target2.prototype.isTagged = function () {
    return this.metadata.some(function (metadata) {
      return NON_CUSTOM_TAG_KEYS.every(function (key) {
        return metadata.key !== key
      })
    })
  }
  Target2.prototype.isOptional = function () {
    return this.matchesTag(OPTIONAL_TAG)(true)
  }
  Target2.prototype.getNamedTag = function () {
    if (this.isNamed()) {
      return this.metadata.filter(function (m) {
        return m.key === NAMED_TAG
      })[0]
    }
    return null
  }
  Target2.prototype.getCustomTags = function () {
    if (this.isTagged()) {
      return this.metadata.filter(function (metadata) {
        return NON_CUSTOM_TAG_KEYS.every(function (key) {
          return metadata.key !== key
        })
      })
    } else {
      return null
    }
  }
  Target2.prototype.matchesNamedTag = function (name2) {
    return this.matchesTag(NAMED_TAG)(name2)
  }
  Target2.prototype.matchesTag = function (key) {
    var _this = this
    return function (value) {
      for (var _i = 0, _a2 = _this.metadata; _i < _a2.length; _i++) {
        var m = _a2[_i]
        if (m.key === key && m.value === value) {
          return true
        }
      }
      return false
    }
  }
  return Target2
})()
var __spreadArray$2 =
  (globalThis && globalThis.__spreadArray) ||
  function (to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i)
          ar[i] = from[i]
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from))
  }
function getDependencies(metadataReader, func) {
  var constructorName = getFunctionName(func)
  return getTargets(metadataReader, constructorName, func, false)
}
function getTargets(metadataReader, constructorName, func, isBaseClass) {
  var metadata = metadataReader.getConstructorMetadata(func)
  var serviceIdentifiers = metadata.compilerGeneratedMetadata
  if (serviceIdentifiers === void 0) {
    var msg = MISSING_INJECTABLE_ANNOTATION + " " + constructorName + "."
    throw new Error(msg)
  }
  var constructorArgsMetadata = metadata.userGeneratedMetadata
  var keys = Object.keys(constructorArgsMetadata)
  var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0
  var hasOptionalParameters = keys.length > func.length
  var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length
  var constructorTargets = getConstructorArgsAsTargets(
    isBaseClass,
    constructorName,
    serviceIdentifiers,
    constructorArgsMetadata,
    iterations
  )
  var propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName)
  var targets = __spreadArray$2(__spreadArray$2([], constructorTargets, true), propertyTargets, true)
  return targets
}
function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
  var targetMetadata = constructorArgsMetadata[index.toString()] || []
  var metadata = formatTargetMetadata(targetMetadata)
  var isManaged = metadata.unmanaged !== true
  var serviceIdentifier = serviceIdentifiers[index]
  var injectIdentifier = metadata.inject || metadata.multiInject
  serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier
  if (serviceIdentifier instanceof LazyServiceIdentifer) {
    serviceIdentifier = serviceIdentifier.unwrap()
  }
  if (isManaged) {
    var isObject2 = serviceIdentifier === Object
    var isFunction2 = serviceIdentifier === Function
    var isUndefined2 = serviceIdentifier === void 0
    var isUnknownType = isObject2 || isFunction2 || isUndefined2
    if (!isBaseClass && isUnknownType) {
      var msg = MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + "."
      throw new Error(msg)
    }
    var target = new Target(TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier)
    target.metadata = targetMetadata
    return target
  }
  return null
}
function getConstructorArgsAsTargets(
  isBaseClass,
  constructorName,
  serviceIdentifiers,
  constructorArgsMetadata,
  iterations
) {
  var targets = []
  for (var i = 0; i < iterations; i++) {
    var index = i
    var target = getConstructorArgsAsTarget(
      index,
      isBaseClass,
      constructorName,
      serviceIdentifiers,
      constructorArgsMetadata
    )
    if (target !== null) {
      targets.push(target)
    }
  }
  return targets
}
function _getServiceIdentifierForProperty(inject2, multiInject, propertyName, className) {
  var serviceIdentifier = inject2 || multiInject
  if (serviceIdentifier === void 0) {
    var msg = MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + "."
    throw new Error(msg)
  }
  return serviceIdentifier
}
function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
  var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc)
  var targets = []
  var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata)
  var stringKeys = Object.keys(classPropsMetadata)
  var keys = stringKeys.concat(symbolKeys)
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i]
    var targetMetadata = classPropsMetadata[key]
    var metadata = formatTargetMetadata(targetMetadata)
    var identifier = metadata.targetName || key
    var serviceIdentifier = _getServiceIdentifierForProperty(
      metadata.inject,
      metadata.multiInject,
      key,
      constructorName
    )
    var target = new Target(TargetTypeEnum.ClassProperty, identifier, serviceIdentifier)
    target.metadata = targetMetadata
    targets.push(target)
  }
  var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor
  if (baseConstructor !== Object) {
    var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName)
    targets = __spreadArray$2(__spreadArray$2([], targets, true), baseTargets, true)
  }
  return targets
}
function getBaseClassDependencyCount(metadataReader, func) {
  var baseConstructor = Object.getPrototypeOf(func.prototype).constructor
  if (baseConstructor !== Object) {
    var baseConstructorName = getFunctionName(baseConstructor)
    var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true)
    var metadata = targets.map(function (t2) {
      return t2.metadata.filter(function (m) {
        return m.key === UNMANAGED_TAG
      })
    })
    var unmanagedCount = [].concat.apply([], metadata).length
    var dependencyCount = targets.length - unmanagedCount
    if (dependencyCount > 0) {
      return dependencyCount
    } else {
      return getBaseClassDependencyCount(metadataReader, baseConstructor)
    }
  } else {
    return 0
  }
}
function formatTargetMetadata(targetMetadata) {
  var targetMetadataMap = {}
  targetMetadata.forEach(function (m) {
    targetMetadataMap[m.key.toString()] = m.value
  })
  return {
    inject: targetMetadataMap[INJECT_TAG],
    multiInject: targetMetadataMap[MULTI_INJECT_TAG],
    targetName: targetMetadataMap[NAME_TAG],
    unmanaged: targetMetadataMap[UNMANAGED_TAG],
  }
}
var Request = (function () {
  function Request2(serviceIdentifier, parentContext, parentRequest, bindings, target) {
    this.id = id()
    this.serviceIdentifier = serviceIdentifier
    this.parentContext = parentContext
    this.parentRequest = parentRequest
    this.target = target
    this.childRequests = []
    this.bindings = Array.isArray(bindings) ? bindings : [bindings]
    this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null
  }
  Request2.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {
    var child = new Request2(serviceIdentifier, this.parentContext, this, bindings, target)
    this.childRequests.push(child)
    return child
  }
  return Request2
})()
function getBindingDictionary(cntnr) {
  return cntnr._bindingDictionary
}
function _createTarget(isMultiInject, targetType, serviceIdentifier, name2, key, value) {
  var metadataKey = isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG
  var injectMetadata = new Metadata(metadataKey, serviceIdentifier)
  var target = new Target(targetType, name2, serviceIdentifier, injectMetadata)
  if (key !== void 0) {
    var tagMetadata = new Metadata(key, value)
    target.metadata.push(tagMetadata)
  }
  return target
}
function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
  var bindings = getBindings(context.container, target.serviceIdentifier)
  var activeBindings = []
  if (
    bindings.length === BindingCount.NoBindingsAvailable &&
    context.container.options.autoBindInjectable &&
    typeof target.serviceIdentifier === "function" &&
    metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata
  ) {
    context.container.bind(target.serviceIdentifier).toSelf()
    bindings = getBindings(context.container, target.serviceIdentifier)
  }
  if (!avoidConstraints) {
    activeBindings = bindings.filter(function (binding) {
      var request2 = new Request(binding.serviceIdentifier, context, parentRequest, binding, target)
      return binding.constraint(request2)
    })
  } else {
    activeBindings = bindings
  }
  _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container)
  return activeBindings
}
function _validateActiveBindingCount(serviceIdentifier, bindings, target, container2) {
  switch (bindings.length) {
    case BindingCount.NoBindingsAvailable:
      if (target.isOptional()) {
        return bindings
      } else {
        var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier)
        var msg = NOT_REGISTERED
        msg += listMetadataForTarget(serviceIdentifierString, target)
        msg += listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifierString, getBindings)
        throw new Error(msg)
      }
    case BindingCount.OnlyOneBindingAvailable:
      return bindings
    case BindingCount.MultipleBindingsAvailable:
    default:
      if (!target.isArray()) {
        var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier)
        var msg = AMBIGUOUS_MATCH + " " + serviceIdentifierString
        msg += listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifierString, getBindings)
        throw new Error(msg)
      } else {
        return bindings
      }
  }
}
function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
  var activeBindings
  var childRequest
  if (parentRequest === null) {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target)
    childRequest = new Request(serviceIdentifier, context, null, activeBindings, target)
    var thePlan = new Plan(context, childRequest)
    context.addPlan(thePlan)
  } else {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target)
    childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target)
  }
  activeBindings.forEach(function (binding) {
    var subChildRequest = null
    if (target.isArray()) {
      subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target)
    } else {
      if (binding.cache) {
        return
      }
      subChildRequest = childRequest
    }
    if (binding.type === BindingTypeEnum.Instance && binding.implementationType !== null) {
      var dependencies = getDependencies(metadataReader, binding.implementationType)
      if (!context.container.options.skipBaseClassChecks) {
        var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType)
        if (dependencies.length < baseClassDependencyCount) {
          var error2 = ARGUMENTS_LENGTH_MISMATCH(getFunctionName(binding.implementationType))
          throw new Error(error2)
        }
      }
      dependencies.forEach(function (dependency) {
        _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency)
      })
    }
  })
}
function getBindings(container2, serviceIdentifier) {
  var bindings = []
  var bindingDictionary = getBindingDictionary(container2)
  if (bindingDictionary.hasKey(serviceIdentifier)) {
    bindings = bindingDictionary.get(serviceIdentifier)
  } else if (container2.parent !== null) {
    bindings = getBindings(container2.parent, serviceIdentifier)
  }
  return bindings
}
function plan(metadataReader, container2, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
  if (avoidConstraints === void 0) {
    avoidConstraints = false
  }
  var context = new Context(container2)
  var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value)
  try {
    _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target)
    return context
  } catch (error2) {
    if (isStackOverflowExeption(error2)) {
      circularDependencyToException(context.plan.rootRequest)
    }
    throw error2
  }
}
function createMockRequest(container2, serviceIdentifier, key, value) {
  var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key, value))
  var context = new Context(container2)
  var request2 = new Request(serviceIdentifier, context, null, [], target)
  return request2
}
function isPromise(object) {
  var isObjectOrFunction = (typeof object === "object" && object !== null) || typeof object === "function"
  return isObjectOrFunction && typeof object.then === "function"
}
function isPromiseOrContainsPromise(object) {
  if (isPromise(object)) {
    return true
  }
  return Array.isArray(object) && object.some(isPromise)
}
var __awaiter$3 =
  (globalThis && globalThis.__awaiter) ||
  function (thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2
        ? value
        : new P2(function (resolve2) {
            resolve2(value)
          })
    }
    return new (P2 || (P2 = Promise))(function (resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value))
        } catch (e) {
          reject(e)
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value))
        } catch (e) {
          reject(e)
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected)
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next())
    })
  }
var __generator$3 =
  (globalThis && globalThis.__generator) ||
  function (thisArg, body) {
    var _2 = {
        label: 0,
        sent: function () {
          if (t2[0] & 1) throw t2[1]
          return t2[1]
        },
        trys: [],
        ops: [],
      },
      f,
      y,
      t2,
      g
    return (
      (g = { next: verb(0), throw: verb(1), return: verb(2) }),
      typeof Symbol === "function" &&
        (g[Symbol.iterator] = function () {
          return this
        }),
      g
    )
    function verb(n) {
      return function (v) {
        return step([n, v])
      }
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.")
      while (_2)
        try {
          if (
            ((f = 1),
            y &&
              (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) &&
              !(t2 = t2.call(y, op[1])).done)
          )
            return t2
          if (((y = 0), t2)) op = [op[0] & 2, t2.value]
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op
              break
            case 4:
              _2.label++
              return { value: op[1], done: false }
            case 5:
              _2.label++
              y = op[1]
              op = [0]
              continue
            case 7:
              op = _2.ops.pop()
              _2.trys.pop()
              continue
            default:
              if (!((t2 = _2.trys), (t2 = t2.length > 0 && t2[t2.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0
                continue
              }
              if (op[0] === 3 && (!t2 || (op[1] > t2[0] && op[1] < t2[3]))) {
                _2.label = op[1]
                break
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1]
                t2 = op
                break
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2]
                _2.ops.push(op)
                break
              }
              if (t2[2]) _2.ops.pop()
              _2.trys.pop()
              continue
          }
          op = body.call(thisArg, _2)
        } catch (e) {
          op = [6, e]
          y = 0
        } finally {
          f = t2 = 0
        }
      if (op[0] & 5) throw op[1]
      return { value: op[0] ? op[1] : void 0, done: true }
    }
  }
var tryGetFromScope = function (requestScope, binding) {
  if (binding.scope === BindingScopeEnum.Singleton && binding.activated) {
    return binding.cache
  }
  if (binding.scope === BindingScopeEnum.Request && requestScope.has(binding.id)) {
    return requestScope.get(binding.id)
  }
  return null
}
var saveToScope = function (requestScope, binding, result) {
  if (binding.scope === BindingScopeEnum.Singleton) {
    _saveToSingletonScope(binding, result)
  }
  if (binding.scope === BindingScopeEnum.Request) {
    _saveToRequestScope(requestScope, binding, result)
  }
}
var _saveToRequestScope = function (requestScope, binding, result) {
  if (!requestScope.has(binding.id)) {
    requestScope.set(binding.id, result)
  }
}
var _saveToSingletonScope = function (binding, result) {
  binding.cache = result
  binding.activated = true
  if (isPromise(result)) {
    void _saveAsyncResultToSingletonScope(binding, result)
  }
}
var _saveAsyncResultToSingletonScope = function (binding, asyncResult) {
  return __awaiter$3(void 0, void 0, void 0, function () {
    var result, ex_1
    return __generator$3(this, function (_a2) {
      switch (_a2.label) {
        case 0:
          _a2.trys.push([0, 2, , 3])
          return [4, asyncResult]
        case 1:
          result = _a2.sent()
          binding.cache = result
          return [3, 3]
        case 2:
          ex_1 = _a2.sent()
          binding.cache = null
          binding.activated = false
          throw ex_1
        case 3:
          return [2]
      }
    })
  })
}
var FactoryType
;(function (FactoryType2) {
  FactoryType2["DynamicValue"] = "toDynamicValue"
  FactoryType2["Factory"] = "toFactory"
  FactoryType2["Provider"] = "toProvider"
})(FactoryType || (FactoryType = {}))
var ensureFullyBound = function (binding) {
  var boundValue = null
  switch (binding.type) {
    case BindingTypeEnum.ConstantValue:
    case BindingTypeEnum.Function:
      boundValue = binding.cache
      break
    case BindingTypeEnum.Constructor:
    case BindingTypeEnum.Instance:
      boundValue = binding.implementationType
      break
    case BindingTypeEnum.DynamicValue:
      boundValue = binding.dynamicValue
      break
    case BindingTypeEnum.Provider:
      boundValue = binding.provider
      break
    case BindingTypeEnum.Factory:
      boundValue = binding.factory
      break
  }
  if (boundValue === null) {
    var serviceIdentifierAsString = getServiceIdentifierAsString(binding.serviceIdentifier)
    throw new Error(INVALID_BINDING_TYPE + " " + serviceIdentifierAsString)
  }
}
var getFactoryDetails = function (binding) {
  switch (binding.type) {
    case BindingTypeEnum.Factory:
      return { factory: binding.factory, factoryType: FactoryType.Factory }
    case BindingTypeEnum.Provider:
      return { factory: binding.provider, factoryType: FactoryType.Provider }
    case BindingTypeEnum.DynamicValue:
      return { factory: binding.dynamicValue, factoryType: FactoryType.DynamicValue }
    default:
      throw new Error("Unexpected factory type " + binding.type)
  }
}
var __assign$1 =
  (globalThis && globalThis.__assign) ||
  function () {
    __assign$1 =
      Object.assign ||
      function (t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i]
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p]
        }
        return t2
      }
    return __assign$1.apply(this, arguments)
  }
var __awaiter$2 =
  (globalThis && globalThis.__awaiter) ||
  function (thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2
        ? value
        : new P2(function (resolve2) {
            resolve2(value)
          })
    }
    return new (P2 || (P2 = Promise))(function (resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value))
        } catch (e) {
          reject(e)
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value))
        } catch (e) {
          reject(e)
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected)
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next())
    })
  }
var __generator$2 =
  (globalThis && globalThis.__generator) ||
  function (thisArg, body) {
    var _2 = {
        label: 0,
        sent: function () {
          if (t2[0] & 1) throw t2[1]
          return t2[1]
        },
        trys: [],
        ops: [],
      },
      f,
      y,
      t2,
      g
    return (
      (g = { next: verb(0), throw: verb(1), return: verb(2) }),
      typeof Symbol === "function" &&
        (g[Symbol.iterator] = function () {
          return this
        }),
      g
    )
    function verb(n) {
      return function (v) {
        return step([n, v])
      }
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.")
      while (_2)
        try {
          if (
            ((f = 1),
            y &&
              (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) &&
              !(t2 = t2.call(y, op[1])).done)
          )
            return t2
          if (((y = 0), t2)) op = [op[0] & 2, t2.value]
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op
              break
            case 4:
              _2.label++
              return { value: op[1], done: false }
            case 5:
              _2.label++
              y = op[1]
              op = [0]
              continue
            case 7:
              op = _2.ops.pop()
              _2.trys.pop()
              continue
            default:
              if (!((t2 = _2.trys), (t2 = t2.length > 0 && t2[t2.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0
                continue
              }
              if (op[0] === 3 && (!t2 || (op[1] > t2[0] && op[1] < t2[3]))) {
                _2.label = op[1]
                break
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1]
                t2 = op
                break
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2]
                _2.ops.push(op)
                break
              }
              if (t2[2]) _2.ops.pop()
              _2.trys.pop()
              continue
          }
          op = body.call(thisArg, _2)
        } catch (e) {
          op = [6, e]
          y = 0
        } finally {
          f = t2 = 0
        }
      if (op[0] & 5) throw op[1]
      return { value: op[0] ? op[1] : void 0, done: true }
    }
  }
var __spreadArray$1 =
  (globalThis && globalThis.__spreadArray) ||
  function (to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i)
          ar[i] = from[i]
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from))
  }
function _resolveRequests(childRequests, resolveRequest) {
  return childRequests.reduce(
    function (resolvedRequests, childRequest) {
      var injection = resolveRequest(childRequest)
      var targetType = childRequest.target.type
      if (targetType === TargetTypeEnum.ConstructorArgument) {
        resolvedRequests.constructorInjections.push(injection)
      } else {
        resolvedRequests.propertyRequests.push(childRequest)
        resolvedRequests.propertyInjections.push(injection)
      }
      if (!resolvedRequests.isAsync) {
        resolvedRequests.isAsync = isPromiseOrContainsPromise(injection)
      }
      return resolvedRequests
    },
    { constructorInjections: [], propertyInjections: [], propertyRequests: [], isAsync: false }
  )
}
function _createInstance(constr, childRequests, resolveRequest) {
  var result
  if (childRequests.length > 0) {
    var resolved = _resolveRequests(childRequests, resolveRequest)
    var createInstanceWithInjectionsArg = __assign$1(__assign$1({}, resolved), { constr })
    if (resolved.isAsync) {
      result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg)
    } else {
      result = createInstanceWithInjections(createInstanceWithInjectionsArg)
    }
  } else {
    result = new constr()
  }
  return result
}
function createInstanceWithInjections(args) {
  var _a2
  var instance2 = new ((_a2 = args.constr).bind.apply(
    _a2,
    __spreadArray$1([void 0], args.constructorInjections, false)
  ))()
  args.propertyRequests.forEach(function (r, index) {
    var property = r.target.identifier
    var injection = args.propertyInjections[index]
    instance2[property] = injection
  })
  return instance2
}
function createInstanceWithInjectionsAsync(args) {
  return __awaiter$2(this, void 0, void 0, function () {
    var constructorInjections, propertyInjections
    return __generator$2(this, function (_a2) {
      switch (_a2.label) {
        case 0:
          return [4, possiblyWaitInjections(args.constructorInjections)]
        case 1:
          constructorInjections = _a2.sent()
          return [4, possiblyWaitInjections(args.propertyInjections)]
        case 2:
          propertyInjections = _a2.sent()
          return [
            2,
            createInstanceWithInjections(
              __assign$1(__assign$1({}, args), { constructorInjections, propertyInjections })
            ),
          ]
      }
    })
  })
}
function possiblyWaitInjections(possiblePromiseinjections) {
  return __awaiter$2(this, void 0, void 0, function () {
    var injections, _i, possiblePromiseinjections_1, injection
    return __generator$2(this, function (_a2) {
      injections = []
      for (
        _i = 0, possiblePromiseinjections_1 = possiblePromiseinjections;
        _i < possiblePromiseinjections_1.length;
        _i++
      ) {
        injection = possiblePromiseinjections_1[_i]
        if (Array.isArray(injection)) {
          injections.push(Promise.all(injection))
        } else {
          injections.push(injection)
        }
      }
      return [2, Promise.all(injections)]
    })
  })
}
function _getInstanceAfterPostConstruct(constr, result) {
  var postConstructResult = _postConstruct(constr, result)
  if (isPromise(postConstructResult)) {
    return postConstructResult.then(function () {
      return result
    })
  } else {
    return result
  }
}
function _postConstruct(constr, instance2) {
  var _a2, _b
  if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
    var data = Reflect.getMetadata(POST_CONSTRUCT, constr)
    try {
      return (_b = (_a2 = instance2)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a2)
    } catch (e) {
      throw new Error(POST_CONSTRUCT_ERROR(constr.name, e.message))
    }
  }
}
function _validateInstanceResolution(binding, constr) {
  if (binding.scope !== BindingScopeEnum.Singleton) {
    _throwIfHandlingDeactivation(binding, constr)
  }
}
function _throwIfHandlingDeactivation(binding, constr) {
  var scopeErrorMessage =
    "Class cannot be instantiated in " +
    (binding.scope === BindingScopeEnum.Request ? "request" : "transient") +
    " scope."
  if (typeof binding.onDeactivation === "function") {
    throw new Error(ON_DEACTIVATION_ERROR(constr.name, scopeErrorMessage))
  }
  if (Reflect.hasMetadata(PRE_DESTROY, constr)) {
    throw new Error(PRE_DESTROY_ERROR(constr.name, scopeErrorMessage))
  }
}
function resolveInstance(binding, constr, childRequests, resolveRequest) {
  _validateInstanceResolution(binding, constr)
  var result = _createInstance(constr, childRequests, resolveRequest)
  if (isPromise(result)) {
    return result.then(function (resolvedResult) {
      return _getInstanceAfterPostConstruct(constr, resolvedResult)
    })
  } else {
    return _getInstanceAfterPostConstruct(constr, result)
  }
}
var __awaiter$1 =
  (globalThis && globalThis.__awaiter) ||
  function (thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2
        ? value
        : new P2(function (resolve2) {
            resolve2(value)
          })
    }
    return new (P2 || (P2 = Promise))(function (resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value))
        } catch (e) {
          reject(e)
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value))
        } catch (e) {
          reject(e)
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected)
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next())
    })
  }
var __generator$1 =
  (globalThis && globalThis.__generator) ||
  function (thisArg, body) {
    var _2 = {
        label: 0,
        sent: function () {
          if (t2[0] & 1) throw t2[1]
          return t2[1]
        },
        trys: [],
        ops: [],
      },
      f,
      y,
      t2,
      g
    return (
      (g = { next: verb(0), throw: verb(1), return: verb(2) }),
      typeof Symbol === "function" &&
        (g[Symbol.iterator] = function () {
          return this
        }),
      g
    )
    function verb(n) {
      return function (v) {
        return step([n, v])
      }
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.")
      while (_2)
        try {
          if (
            ((f = 1),
            y &&
              (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) &&
              !(t2 = t2.call(y, op[1])).done)
          )
            return t2
          if (((y = 0), t2)) op = [op[0] & 2, t2.value]
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op
              break
            case 4:
              _2.label++
              return { value: op[1], done: false }
            case 5:
              _2.label++
              y = op[1]
              op = [0]
              continue
            case 7:
              op = _2.ops.pop()
              _2.trys.pop()
              continue
            default:
              if (!((t2 = _2.trys), (t2 = t2.length > 0 && t2[t2.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0
                continue
              }
              if (op[0] === 3 && (!t2 || (op[1] > t2[0] && op[1] < t2[3]))) {
                _2.label = op[1]
                break
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1]
                t2 = op
                break
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2]
                _2.ops.push(op)
                break
              }
              if (t2[2]) _2.ops.pop()
              _2.trys.pop()
              continue
          }
          op = body.call(thisArg, _2)
        } catch (e) {
          op = [6, e]
          y = 0
        } finally {
          f = t2 = 0
        }
      if (op[0] & 5) throw op[1]
      return { value: op[0] ? op[1] : void 0, done: true }
    }
  }
var _resolveRequest = function (requestScope) {
  return function (request2) {
    request2.parentContext.setCurrentRequest(request2)
    var bindings = request2.bindings
    var childRequests = request2.childRequests
    var targetIsAnArray = request2.target && request2.target.isArray()
    var targetParentIsNotAnArray =
      !request2.parentRequest ||
      !request2.parentRequest.target ||
      !request2.target ||
      !request2.parentRequest.target.matchesArray(request2.target.serviceIdentifier)
    if (targetIsAnArray && targetParentIsNotAnArray) {
      return childRequests.map(function (childRequest) {
        var _f = _resolveRequest(requestScope)
        return _f(childRequest)
      })
    } else {
      if (request2.target.isOptional() && bindings.length === 0) {
        return void 0
      }
      var binding = bindings[0]
      return _resolveBinding(requestScope, request2, binding)
    }
  }
}
var _resolveFactoryFromBinding = function (binding, context) {
  var factoryDetails = getFactoryDetails(binding)
  return tryAndThrowErrorIfStackOverflow(
    function () {
      return factoryDetails.factory.bind(binding)(context)
    },
    function () {
      return new Error(
        CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString())
      )
    }
  )
}
var _getResolvedFromBinding = function (requestScope, request2, binding) {
  var result
  var childRequests = request2.childRequests
  ensureFullyBound(binding)
  switch (binding.type) {
    case BindingTypeEnum.ConstantValue:
    case BindingTypeEnum.Function:
      result = binding.cache
      break
    case BindingTypeEnum.Constructor:
      result = binding.implementationType
      break
    case BindingTypeEnum.Instance:
      result = resolveInstance(binding, binding.implementationType, childRequests, _resolveRequest(requestScope))
      break
    default:
      result = _resolveFactoryFromBinding(binding, request2.parentContext)
  }
  return result
}
var _resolveInScope = function (requestScope, binding, resolveFromBinding) {
  var result = tryGetFromScope(requestScope, binding)
  if (result !== null) {
    return result
  }
  result = resolveFromBinding()
  saveToScope(requestScope, binding, result)
  return result
}
var _resolveBinding = function (requestScope, request2, binding) {
  return _resolveInScope(requestScope, binding, function () {
    var result = _getResolvedFromBinding(requestScope, request2, binding)
    if (isPromise(result)) {
      result = result.then(function (resolved) {
        return _onActivation(request2, binding, resolved)
      })
    } else {
      result = _onActivation(request2, binding, result)
    }
    return result
  })
}
function _onActivation(request2, binding, resolved) {
  var result = _bindingActivation(request2.parentContext, binding, resolved)
  var containersIterator = _getContainersIterator(request2.parentContext.container)
  var container2
  var containersIteratorResult = containersIterator.next()
  do {
    container2 = containersIteratorResult.value
    var context_1 = request2.parentContext
    var serviceIdentifier = request2.serviceIdentifier
    var activationsIterator = _getContainerActivationsForService(container2, serviceIdentifier)
    if (isPromise(result)) {
      result = _activateContainerAsync(activationsIterator, context_1, result)
    } else {
      result = _activateContainer(activationsIterator, context_1, result)
    }
    containersIteratorResult = containersIterator.next()
  } while (
    containersIteratorResult.done !== true &&
    !getBindingDictionary(container2).hasKey(request2.serviceIdentifier)
  )
  return result
}
var _bindingActivation = function (context, binding, previousResult) {
  var result
  if (typeof binding.onActivation === "function") {
    result = binding.onActivation(context, previousResult)
  } else {
    result = previousResult
  }
  return result
}
var _activateContainer = function (activationsIterator, context, result) {
  var activation = activationsIterator.next()
  while (!activation.done) {
    result = activation.value(context, result)
    if (isPromise(result)) {
      return _activateContainerAsync(activationsIterator, context, result)
    }
    activation = activationsIterator.next()
  }
  return result
}
var _activateContainerAsync = function (activationsIterator, context, resultPromise) {
  return __awaiter$1(void 0, void 0, void 0, function () {
    var result, activation
    return __generator$1(this, function (_a2) {
      switch (_a2.label) {
        case 0:
          return [4, resultPromise]
        case 1:
          result = _a2.sent()
          activation = activationsIterator.next()
          _a2.label = 2
        case 2:
          if (activation.done) return [3, 4]
          return [4, activation.value(context, result)]
        case 3:
          result = _a2.sent()
          activation = activationsIterator.next()
          return [3, 2]
        case 4:
          return [2, result]
      }
    })
  })
}
var _getContainerActivationsForService = function (container2, serviceIdentifier) {
  var activations = container2._activations
  return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values()
}
var _getContainersIterator = function (container2) {
  var containersStack = [container2]
  var parent = container2.parent
  while (parent !== null) {
    containersStack.push(parent)
    parent = parent.parent
  }
  var getNextContainer = function () {
    var nextContainer = containersStack.pop()
    if (nextContainer !== void 0) {
      return { done: false, value: nextContainer }
    } else {
      return { done: true, value: void 0 }
    }
  }
  var containersIterator = {
    next: getNextContainer,
  }
  return containersIterator
}
function resolve(context) {
  var _f = _resolveRequest(context.plan.rootRequest.requestScope)
  return _f(context.plan.rootRequest)
}
var traverseAncerstors = function (request2, constraint) {
  var parent = request2.parentRequest
  if (parent !== null) {
    return constraint(parent) ? true : traverseAncerstors(parent, constraint)
  } else {
    return false
  }
}
var taggedConstraint = function (key) {
  return function (value) {
    var constraint = function (request2) {
      return request2 !== null && request2.target !== null && request2.target.matchesTag(key)(value)
    }
    constraint.metaData = new Metadata(key, value)
    return constraint
  }
}
var namedConstraint = taggedConstraint(NAMED_TAG)
var typeConstraint = function (type) {
  return function (request2) {
    var binding = null
    if (request2 !== null) {
      binding = request2.bindings[0]
      if (typeof type === "string") {
        var serviceIdentifier = binding.serviceIdentifier
        return serviceIdentifier === type
      } else {
        var constructor = request2.bindings[0].implementationType
        return type === constructor
      }
    }
    return false
  }
}
var BindingWhenSyntax = (function () {
  function BindingWhenSyntax2(binding) {
    this._binding = binding
  }
  BindingWhenSyntax2.prototype.when = function (constraint) {
    this._binding.constraint = constraint
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenTargetNamed = function (name2) {
    this._binding.constraint = namedConstraint(name2)
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenTargetIsDefault = function () {
    this._binding.constraint = function (request2) {
      if (request2 === null) {
        return false
      }
      var targetIsDefault = request2.target !== null && !request2.target.isNamed() && !request2.target.isTagged()
      return targetIsDefault
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenTargetTagged = function (tag, value) {
    this._binding.constraint = taggedConstraint(tag)(value)
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenInjectedInto = function (parent) {
    this._binding.constraint = function (request2) {
      return request2 !== null && typeConstraint(parent)(request2.parentRequest)
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenParentNamed = function (name2) {
    this._binding.constraint = function (request2) {
      return request2 !== null && namedConstraint(name2)(request2.parentRequest)
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenParentTagged = function (tag, value) {
    this._binding.constraint = function (request2) {
      return request2 !== null && taggedConstraint(tag)(value)(request2.parentRequest)
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenAnyAncestorIs = function (ancestor) {
    this._binding.constraint = function (request2) {
      return request2 !== null && traverseAncerstors(request2, typeConstraint(ancestor))
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenNoAncestorIs = function (ancestor) {
    this._binding.constraint = function (request2) {
      return request2 !== null && !traverseAncerstors(request2, typeConstraint(ancestor))
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenAnyAncestorNamed = function (name2) {
    this._binding.constraint = function (request2) {
      return request2 !== null && traverseAncerstors(request2, namedConstraint(name2))
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenNoAncestorNamed = function (name2) {
    this._binding.constraint = function (request2) {
      return request2 !== null && !traverseAncerstors(request2, namedConstraint(name2))
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenAnyAncestorTagged = function (tag, value) {
    this._binding.constraint = function (request2) {
      return request2 !== null && traverseAncerstors(request2, taggedConstraint(tag)(value))
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenNoAncestorTagged = function (tag, value) {
    this._binding.constraint = function (request2) {
      return request2 !== null && !traverseAncerstors(request2, taggedConstraint(tag)(value))
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenAnyAncestorMatches = function (constraint) {
    this._binding.constraint = function (request2) {
      return request2 !== null && traverseAncerstors(request2, constraint)
    }
    return new BindingOnSyntax(this._binding)
  }
  BindingWhenSyntax2.prototype.whenNoAncestorMatches = function (constraint) {
    this._binding.constraint = function (request2) {
      return request2 !== null && !traverseAncerstors(request2, constraint)
    }
    return new BindingOnSyntax(this._binding)
  }
  return BindingWhenSyntax2
})()
var BindingOnSyntax = (function () {
  function BindingOnSyntax2(binding) {
    this._binding = binding
  }
  BindingOnSyntax2.prototype.onActivation = function (handler) {
    this._binding.onActivation = handler
    return new BindingWhenSyntax(this._binding)
  }
  BindingOnSyntax2.prototype.onDeactivation = function (handler) {
    this._binding.onDeactivation = handler
    return new BindingWhenSyntax(this._binding)
  }
  return BindingOnSyntax2
})()
var BindingWhenOnSyntax = (function () {
  function BindingWhenOnSyntax2(binding) {
    this._binding = binding
    this._bindingWhenSyntax = new BindingWhenSyntax(this._binding)
    this._bindingOnSyntax = new BindingOnSyntax(this._binding)
  }
  BindingWhenOnSyntax2.prototype.when = function (constraint) {
    return this._bindingWhenSyntax.when(constraint)
  }
  BindingWhenOnSyntax2.prototype.whenTargetNamed = function (name2) {
    return this._bindingWhenSyntax.whenTargetNamed(name2)
  }
  BindingWhenOnSyntax2.prototype.whenTargetIsDefault = function () {
    return this._bindingWhenSyntax.whenTargetIsDefault()
  }
  BindingWhenOnSyntax2.prototype.whenTargetTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenTargetTagged(tag, value)
  }
  BindingWhenOnSyntax2.prototype.whenInjectedInto = function (parent) {
    return this._bindingWhenSyntax.whenInjectedInto(parent)
  }
  BindingWhenOnSyntax2.prototype.whenParentNamed = function (name2) {
    return this._bindingWhenSyntax.whenParentNamed(name2)
  }
  BindingWhenOnSyntax2.prototype.whenParentTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenParentTagged(tag, value)
  }
  BindingWhenOnSyntax2.prototype.whenAnyAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor)
  }
  BindingWhenOnSyntax2.prototype.whenNoAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenNoAncestorIs(ancestor)
  }
  BindingWhenOnSyntax2.prototype.whenAnyAncestorNamed = function (name2) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(name2)
  }
  BindingWhenOnSyntax2.prototype.whenAnyAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value)
  }
  BindingWhenOnSyntax2.prototype.whenNoAncestorNamed = function (name2) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(name2)
  }
  BindingWhenOnSyntax2.prototype.whenNoAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value)
  }
  BindingWhenOnSyntax2.prototype.whenAnyAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint)
  }
  BindingWhenOnSyntax2.prototype.whenNoAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(constraint)
  }
  BindingWhenOnSyntax2.prototype.onActivation = function (handler) {
    return this._bindingOnSyntax.onActivation(handler)
  }
  BindingWhenOnSyntax2.prototype.onDeactivation = function (handler) {
    return this._bindingOnSyntax.onDeactivation(handler)
  }
  return BindingWhenOnSyntax2
})()
var BindingInSyntax = (function () {
  function BindingInSyntax2(binding) {
    this._binding = binding
  }
  BindingInSyntax2.prototype.inRequestScope = function () {
    this._binding.scope = BindingScopeEnum.Request
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingInSyntax2.prototype.inSingletonScope = function () {
    this._binding.scope = BindingScopeEnum.Singleton
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingInSyntax2.prototype.inTransientScope = function () {
    this._binding.scope = BindingScopeEnum.Transient
    return new BindingWhenOnSyntax(this._binding)
  }
  return BindingInSyntax2
})()
var BindingInWhenOnSyntax = (function () {
  function BindingInWhenOnSyntax2(binding) {
    this._binding = binding
    this._bindingWhenSyntax = new BindingWhenSyntax(this._binding)
    this._bindingOnSyntax = new BindingOnSyntax(this._binding)
    this._bindingInSyntax = new BindingInSyntax(binding)
  }
  BindingInWhenOnSyntax2.prototype.inRequestScope = function () {
    return this._bindingInSyntax.inRequestScope()
  }
  BindingInWhenOnSyntax2.prototype.inSingletonScope = function () {
    return this._bindingInSyntax.inSingletonScope()
  }
  BindingInWhenOnSyntax2.prototype.inTransientScope = function () {
    return this._bindingInSyntax.inTransientScope()
  }
  BindingInWhenOnSyntax2.prototype.when = function (constraint) {
    return this._bindingWhenSyntax.when(constraint)
  }
  BindingInWhenOnSyntax2.prototype.whenTargetNamed = function (name2) {
    return this._bindingWhenSyntax.whenTargetNamed(name2)
  }
  BindingInWhenOnSyntax2.prototype.whenTargetIsDefault = function () {
    return this._bindingWhenSyntax.whenTargetIsDefault()
  }
  BindingInWhenOnSyntax2.prototype.whenTargetTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenTargetTagged(tag, value)
  }
  BindingInWhenOnSyntax2.prototype.whenInjectedInto = function (parent) {
    return this._bindingWhenSyntax.whenInjectedInto(parent)
  }
  BindingInWhenOnSyntax2.prototype.whenParentNamed = function (name2) {
    return this._bindingWhenSyntax.whenParentNamed(name2)
  }
  BindingInWhenOnSyntax2.prototype.whenParentTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenParentTagged(tag, value)
  }
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor)
  }
  BindingInWhenOnSyntax2.prototype.whenNoAncestorIs = function (ancestor) {
    return this._bindingWhenSyntax.whenNoAncestorIs(ancestor)
  }
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorNamed = function (name2) {
    return this._bindingWhenSyntax.whenAnyAncestorNamed(name2)
  }
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value)
  }
  BindingInWhenOnSyntax2.prototype.whenNoAncestorNamed = function (name2) {
    return this._bindingWhenSyntax.whenNoAncestorNamed(name2)
  }
  BindingInWhenOnSyntax2.prototype.whenNoAncestorTagged = function (tag, value) {
    return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value)
  }
  BindingInWhenOnSyntax2.prototype.whenAnyAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint)
  }
  BindingInWhenOnSyntax2.prototype.whenNoAncestorMatches = function (constraint) {
    return this._bindingWhenSyntax.whenNoAncestorMatches(constraint)
  }
  BindingInWhenOnSyntax2.prototype.onActivation = function (handler) {
    return this._bindingOnSyntax.onActivation(handler)
  }
  BindingInWhenOnSyntax2.prototype.onDeactivation = function (handler) {
    return this._bindingOnSyntax.onDeactivation(handler)
  }
  return BindingInWhenOnSyntax2
})()
var BindingToSyntax = (function () {
  function BindingToSyntax2(binding) {
    this._binding = binding
  }
  BindingToSyntax2.prototype.to = function (constructor) {
    this._binding.type = BindingTypeEnum.Instance
    this._binding.implementationType = constructor
    return new BindingInWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toSelf = function () {
    if (typeof this._binding.serviceIdentifier !== "function") {
      throw new Error("" + INVALID_TO_SELF_VALUE)
    }
    var self2 = this._binding.serviceIdentifier
    return this.to(self2)
  }
  BindingToSyntax2.prototype.toConstantValue = function (value) {
    this._binding.type = BindingTypeEnum.ConstantValue
    this._binding.cache = value
    this._binding.dynamicValue = null
    this._binding.implementationType = null
    this._binding.scope = BindingScopeEnum.Singleton
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toDynamicValue = function (func) {
    this._binding.type = BindingTypeEnum.DynamicValue
    this._binding.cache = null
    this._binding.dynamicValue = func
    this._binding.implementationType = null
    return new BindingInWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toConstructor = function (constructor) {
    this._binding.type = BindingTypeEnum.Constructor
    this._binding.implementationType = constructor
    this._binding.scope = BindingScopeEnum.Singleton
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toFactory = function (factory2) {
    this._binding.type = BindingTypeEnum.Factory
    this._binding.factory = factory2
    this._binding.scope = BindingScopeEnum.Singleton
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toFunction = function (func) {
    if (typeof func !== "function") {
      throw new Error(INVALID_FUNCTION_BINDING)
    }
    var bindingWhenOnSyntax = this.toConstantValue(func)
    this._binding.type = BindingTypeEnum.Function
    this._binding.scope = BindingScopeEnum.Singleton
    return bindingWhenOnSyntax
  }
  BindingToSyntax2.prototype.toAutoFactory = function (serviceIdentifier) {
    this._binding.type = BindingTypeEnum.Factory
    this._binding.factory = function (context) {
      var autofactory = function () {
        return context.container.get(serviceIdentifier)
      }
      return autofactory
    }
    this._binding.scope = BindingScopeEnum.Singleton
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toAutoNamedFactory = function (serviceIdentifier) {
    this._binding.type = BindingTypeEnum.Factory
    this._binding.factory = function (context) {
      return function (named) {
        return context.container.getNamed(serviceIdentifier, named)
      }
    }
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toProvider = function (provider) {
    this._binding.type = BindingTypeEnum.Provider
    this._binding.provider = provider
    this._binding.scope = BindingScopeEnum.Singleton
    return new BindingWhenOnSyntax(this._binding)
  }
  BindingToSyntax2.prototype.toService = function (service) {
    this.toDynamicValue(function (context) {
      return context.container.get(service)
    })
  }
  return BindingToSyntax2
})()
var ContainerSnapshot = (function () {
  function ContainerSnapshot2() {}
  ContainerSnapshot2.of = function (bindings, middleware, activations, deactivations, moduleActivationStore) {
    var snapshot = new ContainerSnapshot2()
    snapshot.bindings = bindings
    snapshot.middleware = middleware
    snapshot.deactivations = deactivations
    snapshot.activations = activations
    snapshot.moduleActivationStore = moduleActivationStore
    return snapshot
  }
  return ContainerSnapshot2
})()
function isClonable(obj) {
  return typeof obj === "object" && obj !== null && "clone" in obj && typeof obj.clone === "function"
}
var Lookup = (function () {
  function Lookup2() {
    this._map = /* @__PURE__ */ new Map()
  }
  Lookup2.prototype.getMap = function () {
    return this._map
  }
  Lookup2.prototype.add = function (serviceIdentifier, value) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT)
    }
    if (value === null || value === void 0) {
      throw new Error(NULL_ARGUMENT)
    }
    var entry = this._map.get(serviceIdentifier)
    if (entry !== void 0) {
      entry.push(value)
    } else {
      this._map.set(serviceIdentifier, [value])
    }
  }
  Lookup2.prototype.get = function (serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT)
    }
    var entry = this._map.get(serviceIdentifier)
    if (entry !== void 0) {
      return entry
    } else {
      throw new Error(KEY_NOT_FOUND)
    }
  }
  Lookup2.prototype.remove = function (serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT)
    }
    if (!this._map.delete(serviceIdentifier)) {
      throw new Error(KEY_NOT_FOUND)
    }
  }
  Lookup2.prototype.removeIntersection = function (lookup) {
    var _this = this
    this.traverse(function (serviceIdentifier, value) {
      var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0
      if (lookupActivations !== void 0) {
        var filteredValues = value.filter(function (lookupValue) {
          return !lookupActivations.some(function (moduleActivation) {
            return lookupValue === moduleActivation
          })
        })
        _this._setValue(serviceIdentifier, filteredValues)
      }
    })
  }
  Lookup2.prototype.removeByCondition = function (condition) {
    var _this = this
    var removals = []
    this._map.forEach(function (entries, key) {
      var updatedEntries = []
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i]
        var remove = condition(entry)
        if (remove) {
          removals.push(entry)
        } else {
          updatedEntries.push(entry)
        }
      }
      _this._setValue(key, updatedEntries)
    })
    return removals
  }
  Lookup2.prototype.hasKey = function (serviceIdentifier) {
    if (serviceIdentifier === null || serviceIdentifier === void 0) {
      throw new Error(NULL_ARGUMENT)
    }
    return this._map.has(serviceIdentifier)
  }
  Lookup2.prototype.clone = function () {
    var copy = new Lookup2()
    this._map.forEach(function (value, key) {
      value.forEach(function (b2) {
        return copy.add(key, isClonable(b2) ? b2.clone() : b2)
      })
    })
    return copy
  }
  Lookup2.prototype.traverse = function (func) {
    this._map.forEach(function (value, key) {
      func(key, value)
    })
  }
  Lookup2.prototype._setValue = function (serviceIdentifier, value) {
    if (value.length > 0) {
      this._map.set(serviceIdentifier, value)
    } else {
      this._map.delete(serviceIdentifier)
    }
  }
  return Lookup2
})()
var ModuleActivationStore = (function () {
  function ModuleActivationStore2() {
    this._map = /* @__PURE__ */ new Map()
  }
  ModuleActivationStore2.prototype.remove = function (moduleId) {
    if (this._map.has(moduleId)) {
      var handlers = this._map.get(moduleId)
      this._map.delete(moduleId)
      return handlers
    }
    return this._getEmptyHandlersStore()
  }
  ModuleActivationStore2.prototype.addDeactivation = function (moduleId, serviceIdentifier, onDeactivation) {
    this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation)
  }
  ModuleActivationStore2.prototype.addActivation = function (moduleId, serviceIdentifier, onActivation) {
    this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation)
  }
  ModuleActivationStore2.prototype.clone = function () {
    var clone = new ModuleActivationStore2()
    this._map.forEach(function (handlersStore, moduleId) {
      clone._map.set(moduleId, {
        onActivations: handlersStore.onActivations.clone(),
        onDeactivations: handlersStore.onDeactivations.clone(),
      })
    })
    return clone
  }
  ModuleActivationStore2.prototype._getModuleActivationHandlers = function (moduleId) {
    var moduleActivationHandlers = this._map.get(moduleId)
    if (moduleActivationHandlers === void 0) {
      moduleActivationHandlers = this._getEmptyHandlersStore()
      this._map.set(moduleId, moduleActivationHandlers)
    }
    return moduleActivationHandlers
  }
  ModuleActivationStore2.prototype._getEmptyHandlersStore = function () {
    var handlersStore = {
      onActivations: new Lookup(),
      onDeactivations: new Lookup(),
    }
    return handlersStore
  }
  return ModuleActivationStore2
})()
var __assign =
  (globalThis && globalThis.__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i]
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p]
        }
        return t2
      }
    return __assign.apply(this, arguments)
  }
var __awaiter =
  (globalThis && globalThis.__awaiter) ||
  function (thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2
        ? value
        : new P2(function (resolve2) {
            resolve2(value)
          })
    }
    return new (P2 || (P2 = Promise))(function (resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value))
        } catch (e) {
          reject(e)
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value))
        } catch (e) {
          reject(e)
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected)
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next())
    })
  }
var __generator =
  (globalThis && globalThis.__generator) ||
  function (thisArg, body) {
    var _2 = {
        label: 0,
        sent: function () {
          if (t2[0] & 1) throw t2[1]
          return t2[1]
        },
        trys: [],
        ops: [],
      },
      f,
      y,
      t2,
      g
    return (
      (g = { next: verb(0), throw: verb(1), return: verb(2) }),
      typeof Symbol === "function" &&
        (g[Symbol.iterator] = function () {
          return this
        }),
      g
    )
    function verb(n) {
      return function (v) {
        return step([n, v])
      }
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.")
      while (_2)
        try {
          if (
            ((f = 1),
            y &&
              (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) &&
              !(t2 = t2.call(y, op[1])).done)
          )
            return t2
          if (((y = 0), t2)) op = [op[0] & 2, t2.value]
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op
              break
            case 4:
              _2.label++
              return { value: op[1], done: false }
            case 5:
              _2.label++
              y = op[1]
              op = [0]
              continue
            case 7:
              op = _2.ops.pop()
              _2.trys.pop()
              continue
            default:
              if (!((t2 = _2.trys), (t2 = t2.length > 0 && t2[t2.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0
                continue
              }
              if (op[0] === 3 && (!t2 || (op[1] > t2[0] && op[1] < t2[3]))) {
                _2.label = op[1]
                break
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1]
                t2 = op
                break
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2]
                _2.ops.push(op)
                break
              }
              if (t2[2]) _2.ops.pop()
              _2.trys.pop()
              continue
          }
          op = body.call(thisArg, _2)
        } catch (e) {
          op = [6, e]
          y = 0
        } finally {
          f = t2 = 0
        }
      if (op[0] & 5) throw op[1]
      return { value: op[0] ? op[1] : void 0, done: true }
    }
  }
var __spreadArray =
  (globalThis && globalThis.__spreadArray) ||
  function (to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i)
          ar[i] = from[i]
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from))
  }
var Container = (function () {
  function Container2(containerOptions) {
    var options = containerOptions || {}
    if (typeof options !== "object") {
      throw new Error("" + CONTAINER_OPTIONS_MUST_BE_AN_OBJECT)
    }
    if (options.defaultScope === void 0) {
      options.defaultScope = BindingScopeEnum.Transient
    } else if (
      options.defaultScope !== BindingScopeEnum.Singleton &&
      options.defaultScope !== BindingScopeEnum.Transient &&
      options.defaultScope !== BindingScopeEnum.Request
    ) {
      throw new Error("" + CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE)
    }
    if (options.autoBindInjectable === void 0) {
      options.autoBindInjectable = false
    } else if (typeof options.autoBindInjectable !== "boolean") {
      throw new Error("" + CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE)
    }
    if (options.skipBaseClassChecks === void 0) {
      options.skipBaseClassChecks = false
    } else if (typeof options.skipBaseClassChecks !== "boolean") {
      throw new Error("" + CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK)
    }
    this.options = {
      autoBindInjectable: options.autoBindInjectable,
      defaultScope: options.defaultScope,
      skipBaseClassChecks: options.skipBaseClassChecks,
    }
    this.id = id()
    this._bindingDictionary = new Lookup()
    this._snapshots = []
    this._middleware = null
    this._activations = new Lookup()
    this._deactivations = new Lookup()
    this.parent = null
    this._metadataReader = new MetadataReader()
    this._moduleActivationStore = new ModuleActivationStore()
  }
  Container2.merge = function (container1, container2) {
    var containers = []
    for (var _i = 2; _i < arguments.length; _i++) {
      containers[_i - 2] = arguments[_i]
    }
    var container3 = new Container2()
    var targetContainers = __spreadArray([container1, container2], containers, true).map(function (targetContainer) {
      return getBindingDictionary(targetContainer)
    })
    var bindingDictionary = getBindingDictionary(container3)
    function copyDictionary(origin, destination) {
      origin.traverse(function (_key, value) {
        value.forEach(function (binding) {
          destination.add(binding.serviceIdentifier, binding.clone())
        })
      })
    }
    targetContainers.forEach(function (targetBindingDictionary) {
      copyDictionary(targetBindingDictionary, bindingDictionary)
    })
    return container3
  }
  Container2.prototype.load = function () {
    var modules = []
    for (var _i = 0; _i < arguments.length; _i++) {
      modules[_i] = arguments[_i]
    }
    var getHelpers = this._getContainerModuleHelpersFactory()
    for (var _a2 = 0, modules_1 = modules; _a2 < modules_1.length; _a2++) {
      var currentModule = modules_1[_a2]
      var containerModuleHelpers = getHelpers(currentModule.id)
      currentModule.registry(
        containerModuleHelpers.bindFunction,
        containerModuleHelpers.unbindFunction,
        containerModuleHelpers.isboundFunction,
        containerModuleHelpers.rebindFunction,
        containerModuleHelpers.unbindAsyncFunction,
        containerModuleHelpers.onActivationFunction,
        containerModuleHelpers.onDeactivationFunction
      )
    }
  }
  Container2.prototype.loadAsync = function () {
    var modules = []
    for (var _i = 0; _i < arguments.length; _i++) {
      modules[_i] = arguments[_i]
    }
    return __awaiter(this, void 0, void 0, function () {
      var getHelpers, _a2, modules_2, currentModule, containerModuleHelpers
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            getHelpers = this._getContainerModuleHelpersFactory()
            ;(_a2 = 0), (modules_2 = modules)
            _b.label = 1
          case 1:
            if (!(_a2 < modules_2.length)) return [3, 4]
            currentModule = modules_2[_a2]
            containerModuleHelpers = getHelpers(currentModule.id)
            return [
              4,
              currentModule.registry(
                containerModuleHelpers.bindFunction,
                containerModuleHelpers.unbindFunction,
                containerModuleHelpers.isboundFunction,
                containerModuleHelpers.rebindFunction,
                containerModuleHelpers.unbindAsyncFunction,
                containerModuleHelpers.onActivationFunction,
                containerModuleHelpers.onDeactivationFunction
              ),
            ]
          case 2:
            _b.sent()
            _b.label = 3
          case 3:
            _a2++
            return [3, 1]
          case 4:
            return [2]
        }
      })
    })
  }
  Container2.prototype.unload = function () {
    var _this = this
    var modules = []
    for (var _i = 0; _i < arguments.length; _i++) {
      modules[_i] = arguments[_i]
    }
    modules.forEach(function (module2) {
      var deactivations = _this._removeModuleBindings(module2.id)
      _this._deactivateSingletons(deactivations)
      _this._removeModuleHandlers(module2.id)
    })
  }
  Container2.prototype.unloadAsync = function () {
    var modules = []
    for (var _i = 0; _i < arguments.length; _i++) {
      modules[_i] = arguments[_i]
    }
    return __awaiter(this, void 0, void 0, function () {
      var _a2, modules_3, module_1, deactivations
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            ;(_a2 = 0), (modules_3 = modules)
            _b.label = 1
          case 1:
            if (!(_a2 < modules_3.length)) return [3, 4]
            module_1 = modules_3[_a2]
            deactivations = this._removeModuleBindings(module_1.id)
            return [4, this._deactivateSingletonsAsync(deactivations)]
          case 2:
            _b.sent()
            this._removeModuleHandlers(module_1.id)
            _b.label = 3
          case 3:
            _a2++
            return [3, 1]
          case 4:
            return [2]
        }
      })
    })
  }
  Container2.prototype.bind = function (serviceIdentifier) {
    var scope = this.options.defaultScope || BindingScopeEnum.Transient
    var binding = new Binding(serviceIdentifier, scope)
    this._bindingDictionary.add(serviceIdentifier, binding)
    return new BindingToSyntax(binding)
  }
  Container2.prototype.rebind = function (serviceIdentifier) {
    this.unbind(serviceIdentifier)
    return this.bind(serviceIdentifier)
  }
  Container2.prototype.rebindAsync = function (serviceIdentifier) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.unbindAsync(serviceIdentifier)]
          case 1:
            _a2.sent()
            return [2, this.bind(serviceIdentifier)]
        }
      })
    })
  }
  Container2.prototype.unbind = function (serviceIdentifier) {
    if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier)
      this._deactivateSingletons(bindings)
    }
    this._removeServiceFromDictionary(serviceIdentifier)
  }
  Container2.prototype.unbindAsync = function (serviceIdentifier) {
    return __awaiter(this, void 0, void 0, function () {
      var bindings
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            if (!this._bindingDictionary.hasKey(serviceIdentifier)) return [3, 2]
            bindings = this._bindingDictionary.get(serviceIdentifier)
            return [4, this._deactivateSingletonsAsync(bindings)]
          case 1:
            _a2.sent()
            _a2.label = 2
          case 2:
            this._removeServiceFromDictionary(serviceIdentifier)
            return [2]
        }
      })
    })
  }
  Container2.prototype.unbindAll = function () {
    var _this = this
    this._bindingDictionary.traverse(function (_key, value) {
      _this._deactivateSingletons(value)
    })
    this._bindingDictionary = new Lookup()
  }
  Container2.prototype.unbindAllAsync = function () {
    return __awaiter(this, void 0, void 0, function () {
      var promises
      var _this = this
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            promises = []
            this._bindingDictionary.traverse(function (_key, value) {
              promises.push(_this._deactivateSingletonsAsync(value))
            })
            return [4, Promise.all(promises)]
          case 1:
            _a2.sent()
            this._bindingDictionary = new Lookup()
            return [2]
        }
      })
    })
  }
  Container2.prototype.onActivation = function (serviceIdentifier, onActivation) {
    this._activations.add(serviceIdentifier, onActivation)
  }
  Container2.prototype.onDeactivation = function (serviceIdentifier, onDeactivation) {
    this._deactivations.add(serviceIdentifier, onDeactivation)
  }
  Container2.prototype.isBound = function (serviceIdentifier) {
    var bound = this._bindingDictionary.hasKey(serviceIdentifier)
    if (!bound && this.parent) {
      bound = this.parent.isBound(serviceIdentifier)
    }
    return bound
  }
  Container2.prototype.isCurrentBound = function (serviceIdentifier) {
    return this._bindingDictionary.hasKey(serviceIdentifier)
  }
  Container2.prototype.isBoundNamed = function (serviceIdentifier, named) {
    return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named)
  }
  Container2.prototype.isBoundTagged = function (serviceIdentifier, key, value) {
    var bound = false
    if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier)
      var request_1 = createMockRequest(this, serviceIdentifier, key, value)
      bound = bindings.some(function (b2) {
        return b2.constraint(request_1)
      })
    }
    if (!bound && this.parent) {
      bound = this.parent.isBoundTagged(serviceIdentifier, key, value)
    }
    return bound
  }
  Container2.prototype.snapshot = function () {
    this._snapshots.push(
      ContainerSnapshot.of(
        this._bindingDictionary.clone(),
        this._middleware,
        this._activations.clone(),
        this._deactivations.clone(),
        this._moduleActivationStore.clone()
      )
    )
  }
  Container2.prototype.restore = function () {
    var snapshot = this._snapshots.pop()
    if (snapshot === void 0) {
      throw new Error(NO_MORE_SNAPSHOTS_AVAILABLE)
    }
    this._bindingDictionary = snapshot.bindings
    this._activations = snapshot.activations
    this._deactivations = snapshot.deactivations
    this._middleware = snapshot.middleware
    this._moduleActivationStore = snapshot.moduleActivationStore
  }
  Container2.prototype.createChild = function (containerOptions) {
    var child = new Container2(containerOptions || this.options)
    child.parent = this
    return child
  }
  Container2.prototype.applyMiddleware = function () {
    var middlewares = []
    for (var _i = 0; _i < arguments.length; _i++) {
      middlewares[_i] = arguments[_i]
    }
    var initial = this._middleware ? this._middleware : this._planAndResolve()
    this._middleware = middlewares.reduce(function (prev, curr) {
      return curr(prev)
    }, initial)
  }
  Container2.prototype.applyCustomMetadataReader = function (metadataReader) {
    this._metadataReader = metadataReader
  }
  Container2.prototype.get = function (serviceIdentifier) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, false)
    return this._getButThrowIfAsync(getArgs)
  }
  Container2.prototype.getAsync = function (serviceIdentifier) {
    return __awaiter(this, void 0, void 0, function () {
      var getArgs
      return __generator(this, function (_a2) {
        getArgs = this._getNotAllArgs(serviceIdentifier, false)
        return [2, this._get(getArgs)]
      })
    })
  }
  Container2.prototype.getTagged = function (serviceIdentifier, key, value) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value)
    return this._getButThrowIfAsync(getArgs)
  }
  Container2.prototype.getTaggedAsync = function (serviceIdentifier, key, value) {
    return __awaiter(this, void 0, void 0, function () {
      var getArgs
      return __generator(this, function (_a2) {
        getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value)
        return [2, this._get(getArgs)]
      })
    })
  }
  Container2.prototype.getNamed = function (serviceIdentifier, named) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named)
  }
  Container2.prototype.getNamedAsync = function (serviceIdentifier, named) {
    return this.getTaggedAsync(serviceIdentifier, NAMED_TAG, named)
  }
  Container2.prototype.getAll = function (serviceIdentifier) {
    var getArgs = this._getAllArgs(serviceIdentifier)
    return this._getButThrowIfAsync(getArgs)
  }
  Container2.prototype.getAllAsync = function (serviceIdentifier) {
    var getArgs = this._getAllArgs(serviceIdentifier)
    return this._getAll(getArgs)
  }
  Container2.prototype.getAllTagged = function (serviceIdentifier, key, value) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value)
    return this._getButThrowIfAsync(getArgs)
  }
  Container2.prototype.getAllTaggedAsync = function (serviceIdentifier, key, value) {
    var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value)
    return this._getAll(getArgs)
  }
  Container2.prototype.getAllNamed = function (serviceIdentifier, named) {
    return this.getAllTagged(serviceIdentifier, NAMED_TAG, named)
  }
  Container2.prototype.getAllNamedAsync = function (serviceIdentifier, named) {
    return this.getAllTaggedAsync(serviceIdentifier, NAMED_TAG, named)
  }
  Container2.prototype.resolve = function (constructorFunction) {
    var isBound = this.isBound(constructorFunction)
    if (!isBound) {
      this.bind(constructorFunction).toSelf()
    }
    var resolved = this.get(constructorFunction)
    if (!isBound) {
      this.unbind(constructorFunction)
    }
    return resolved
  }
  Container2.prototype._preDestroy = function (constructor, instance2) {
    if (Reflect.hasMetadata(PRE_DESTROY, constructor)) {
      var data = Reflect.getMetadata(PRE_DESTROY, constructor)
      return instance2[data.value]()
    }
  }
  Container2.prototype._removeModuleHandlers = function (moduleId) {
    var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId)
    this._activations.removeIntersection(moduleActivationsHandlers.onActivations)
    this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations)
  }
  Container2.prototype._removeModuleBindings = function (moduleId) {
    return this._bindingDictionary.removeByCondition(function (binding) {
      return binding.moduleId === moduleId
    })
  }
  Container2.prototype._deactivate = function (binding, instance2) {
    var _this = this
    var constructor = Object.getPrototypeOf(instance2).constructor
    try {
      if (this._deactivations.hasKey(binding.serviceIdentifier)) {
        var result = this._deactivateContainer(instance2, this._deactivations.get(binding.serviceIdentifier).values())
        if (isPromise(result)) {
          return this._handleDeactivationError(
            result.then(function () {
              return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance2, constructor)
            }),
            constructor
          )
        }
      }
      var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(
        binding,
        instance2,
        constructor
      )
      if (isPromise(propagateDeactivationResult)) {
        return this._handleDeactivationError(propagateDeactivationResult, constructor)
      }
    } catch (ex) {
      throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex.message))
    }
  }
  Container2.prototype._handleDeactivationError = function (asyncResult, constructor) {
    return __awaiter(this, void 0, void 0, function () {
      var ex_1
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3])
            return [4, asyncResult]
          case 1:
            _a2.sent()
            return [3, 3]
          case 2:
            ex_1 = _a2.sent()
            throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex_1.message))
          case 3:
            return [2]
        }
      })
    })
  }
  Container2.prototype._deactivateContainer = function (instance2, deactivationsIterator) {
    var _this = this
    var deactivation = deactivationsIterator.next()
    while (deactivation.value) {
      var result = deactivation.value(instance2)
      if (isPromise(result)) {
        return result.then(function () {
          return _this._deactivateContainerAsync(instance2, deactivationsIterator)
        })
      }
      deactivation = deactivationsIterator.next()
    }
  }
  Container2.prototype._deactivateContainerAsync = function (instance2, deactivationsIterator) {
    return __awaiter(this, void 0, void 0, function () {
      var deactivation
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            deactivation = deactivationsIterator.next()
            _a2.label = 1
          case 1:
            if (!deactivation.value) return [3, 3]
            return [4, deactivation.value(instance2)]
          case 2:
            _a2.sent()
            deactivation = deactivationsIterator.next()
            return [3, 1]
          case 3:
            return [2]
        }
      })
    })
  }
  Container2.prototype._getContainerModuleHelpersFactory = function () {
    var _this = this
    var setModuleId = function (bindingToSyntax, moduleId) {
      bindingToSyntax._binding.moduleId = moduleId
    }
    var getBindFunction = function (moduleId) {
      return function (serviceIdentifier) {
        var bindingToSyntax = _this.bind(serviceIdentifier)
        setModuleId(bindingToSyntax, moduleId)
        return bindingToSyntax
      }
    }
    var getUnbindFunction = function () {
      return function (serviceIdentifier) {
        return _this.unbind(serviceIdentifier)
      }
    }
    var getUnbindAsyncFunction = function () {
      return function (serviceIdentifier) {
        return _this.unbindAsync(serviceIdentifier)
      }
    }
    var getIsboundFunction = function () {
      return function (serviceIdentifier) {
        return _this.isBound(serviceIdentifier)
      }
    }
    var getRebindFunction = function (moduleId) {
      return function (serviceIdentifier) {
        var bindingToSyntax = _this.rebind(serviceIdentifier)
        setModuleId(bindingToSyntax, moduleId)
        return bindingToSyntax
      }
    }
    var getOnActivationFunction = function (moduleId) {
      return function (serviceIdentifier, onActivation) {
        _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation)
        _this.onActivation(serviceIdentifier, onActivation)
      }
    }
    var getOnDeactivationFunction = function (moduleId) {
      return function (serviceIdentifier, onDeactivation) {
        _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation)
        _this.onDeactivation(serviceIdentifier, onDeactivation)
      }
    }
    return function (mId) {
      return {
        bindFunction: getBindFunction(mId),
        isboundFunction: getIsboundFunction(),
        onActivationFunction: getOnActivationFunction(mId),
        onDeactivationFunction: getOnDeactivationFunction(mId),
        rebindFunction: getRebindFunction(mId),
        unbindFunction: getUnbindFunction(),
        unbindAsyncFunction: getUnbindAsyncFunction(),
      }
    }
  }
  Container2.prototype._getAll = function (getArgs) {
    return Promise.all(this._get(getArgs))
  }
  Container2.prototype._get = function (getArgs) {
    var planAndResolveArgs = __assign(__assign({}, getArgs), {
      contextInterceptor: function (context) {
        return context
      },
      targetType: TargetTypeEnum.Variable,
    })
    if (this._middleware) {
      var middlewareResult = this._middleware(planAndResolveArgs)
      if (middlewareResult === void 0 || middlewareResult === null) {
        throw new Error(INVALID_MIDDLEWARE_RETURN)
      }
      return middlewareResult
    }
    return this._planAndResolve()(planAndResolveArgs)
  }
  Container2.prototype._getButThrowIfAsync = function (getArgs) {
    var result = this._get(getArgs)
    if (isPromiseOrContainsPromise(result)) {
      throw new Error(LAZY_IN_SYNC(getArgs.serviceIdentifier))
    }
    return result
  }
  Container2.prototype._getAllArgs = function (serviceIdentifier) {
    var getAllArgs = {
      avoidConstraints: true,
      isMultiInject: true,
      serviceIdentifier,
    }
    return getAllArgs
  }
  Container2.prototype._getNotAllArgs = function (serviceIdentifier, isMultiInject, key, value) {
    var getNotAllArgs = {
      avoidConstraints: false,
      isMultiInject,
      serviceIdentifier,
      key,
      value,
    }
    return getNotAllArgs
  }
  Container2.prototype._planAndResolve = function () {
    var _this = this
    return function (args) {
      var context = plan(
        _this._metadataReader,
        _this,
        args.isMultiInject,
        args.targetType,
        args.serviceIdentifier,
        args.key,
        args.value,
        args.avoidConstraints
      )
      context = args.contextInterceptor(context)
      var result = resolve(context)
      return result
    }
  }
  Container2.prototype._deactivateIfSingleton = function (binding) {
    var _this = this
    if (!binding.activated) {
      return
    }
    if (isPromise(binding.cache)) {
      return binding.cache.then(function (resolved) {
        return _this._deactivate(binding, resolved)
      })
    }
    return this._deactivate(binding, binding.cache)
  }
  Container2.prototype._deactivateSingletons = function (bindings) {
    for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
      var binding = bindings_1[_i]
      var result = this._deactivateIfSingleton(binding)
      if (isPromise(result)) {
        throw new Error(ASYNC_UNBIND_REQUIRED)
      }
    }
  }
  Container2.prototype._deactivateSingletonsAsync = function (bindings) {
    return __awaiter(this, void 0, void 0, function () {
      var _this = this
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            return [
              4,
              Promise.all(
                bindings.map(function (b2) {
                  return _this._deactivateIfSingleton(b2)
                })
              ),
            ]
          case 1:
            _a2.sent()
            return [2]
        }
      })
    })
  }
  Container2.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function (
    binding,
    instance2,
    constructor
  ) {
    if (this.parent) {
      return this._deactivate.bind(this.parent)(binding, instance2)
    } else {
      return this._bindingDeactivationAndPreDestroy(binding, instance2, constructor)
    }
  }
  Container2.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function (
    binding,
    instance2,
    constructor
  ) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            if (!this.parent) return [3, 2]
            return [4, this._deactivate.bind(this.parent)(binding, instance2)]
          case 1:
            _a2.sent()
            return [3, 4]
          case 2:
            return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance2, constructor)]
          case 3:
            _a2.sent()
            _a2.label = 4
          case 4:
            return [2]
        }
      })
    })
  }
  Container2.prototype._removeServiceFromDictionary = function (serviceIdentifier) {
    try {
      this._bindingDictionary.remove(serviceIdentifier)
    } catch (e) {
      throw new Error(CANNOT_UNBIND + " " + getServiceIdentifierAsString(serviceIdentifier))
    }
  }
  Container2.prototype._bindingDeactivationAndPreDestroy = function (binding, instance2, constructor) {
    var _this = this
    if (typeof binding.onDeactivation === "function") {
      var result = binding.onDeactivation(instance2)
      if (isPromise(result)) {
        return result.then(function () {
          return _this._preDestroy(constructor, instance2)
        })
      }
    }
    return this._preDestroy(constructor, instance2)
  }
  Container2.prototype._bindingDeactivationAndPreDestroyAsync = function (binding, instance2, constructor) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a2) {
        switch (_a2.label) {
          case 0:
            if (!(typeof binding.onDeactivation === "function")) return [3, 2]
            return [4, binding.onDeactivation(instance2)]
          case 1:
            _a2.sent()
            _a2.label = 2
          case 2:
            return [4, this._preDestroy(constructor, instance2)]
          case 3:
            _a2.sent()
            return [2]
        }
      })
    })
  }
  return Container2
})()
function getFirstArrayDuplicate(array) {
  var seenValues = /* @__PURE__ */ new Set()
  for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
    var entry = array_1[_i]
    if (seenValues.has(entry)) {
      return entry
    } else {
      seenValues.add(entry)
    }
  }
  return void 0
}
function targetIsConstructorFunction(target) {
  return target.prototype !== void 0
}
function _throwIfMethodParameter(parameterName) {
  if (parameterName !== void 0) {
    throw new Error(INVALID_DECORATOR_OPERATION)
  }
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _throwIfMethodParameter(parameterName)
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata)
}
function tagProperty(annotationTarget, propertyName, metadata) {
  if (targetIsConstructorFunction(annotationTarget)) {
    throw new Error(INVALID_DECORATOR_OPERATION)
  }
  _tagParameterOrProperty(TAGGED_PROP, annotationTarget.constructor, propertyName, metadata)
}
function _ensureNoMetadataKeyDuplicates(metadata) {
  var metadatas = []
  if (Array.isArray(metadata)) {
    metadatas = metadata
    var duplicate = getFirstArrayDuplicate(
      metadatas.map(function (md) {
        return md.key
      })
    )
    if (duplicate !== void 0) {
      throw new Error(DUPLICATED_METADATA + " " + duplicate.toString())
    }
  } else {
    metadatas = [metadata]
  }
  return metadatas
}
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  var metadatas = _ensureNoMetadataKeyDuplicates(metadata)
  var paramsOrPropertiesMetadata = {}
  if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
    paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget)
  }
  var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key]
  if (paramOrPropertyMetadata === void 0) {
    paramOrPropertyMetadata = []
  } else {
    var _loop_1 = function (m2) {
      if (
        metadatas.some(function (md) {
          return md.key === m2.key
        })
      ) {
        throw new Error(DUPLICATED_METADATA + " " + m2.key.toString())
      }
    }
    for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
      var m = paramOrPropertyMetadata_1[_i]
      _loop_1(m)
    }
  }
  paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas)
  paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata
  Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget)
}
function createTaggedDecorator(metadata) {
  return function (target, targetKey, indexOrPropertyDescriptor) {
    if (typeof indexOrPropertyDescriptor === "number") {
      tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata)
    } else {
      tagProperty(target, targetKey, metadata)
    }
  }
}
function injectable() {
  return function (target) {
    if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) {
      throw new Error(DUPLICATED_INJECTABLE_DECORATOR)
    }
    var types = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || []
    Reflect.defineMetadata(PARAM_TYPES, types, target)
    return target
  }
}
function injectBase(metadataKey) {
  return function (serviceIdentifier) {
    return function (target, targetKey, indexOrPropertyDescriptor) {
      if (serviceIdentifier === void 0) {
        var className = typeof target === "function" ? target.name : target.constructor.name
        throw new Error(UNDEFINED_INJECT_ANNOTATION(className))
      }
      return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(
        target,
        targetKey,
        indexOrPropertyDescriptor
      )
    }
  }
}
var inject = injectBase(INJECT_TAG)
const PLUGIN_SYSTEM_AUTO_UPDATE = "PLUGIN_SYSTEM_AUTO_UPDATE"
const PLUGIN_SYSTEM_PLUGIN = "PLUGIN_SYSTEM_PLUGIN"
const PLUGIN_SYSTEM_THIRD_PARTY_PLUGIN = "PLUGIN_SYSTEM_THIRD_PARTY_PLUGIN"
const PLUGIN_SYSTEM_SAFE_MODE_ENABLED = "PLUGIN_SYSTEM_SAFE_MODE_ENABLED"
const PLUGIN_STORE_URL = "PLUGIN_STORE_URL"
const defaultConfig = {
  [PLUGIN_SYSTEM_SAFE_MODE_ENABLED]: true,
  [PLUGIN_SYSTEM_AUTO_UPDATE]: true,
  [PLUGIN_SYSTEM_PLUGIN]: [{ key: "setting", enabled: true }],
  [PLUGIN_SYSTEM_THIRD_PARTY_PLUGIN]: [],
  [PLUGIN_STORE_URL]: "https://bitbucket.org/siyuan-plugin/siyuan-plugins/raw/main/",
}
function noop() {}
function assign(tar, src) {
  for (const k2 in src) tar[k2] = src[k2]
  return tar
}
function run(fn) {
  return fn()
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null)
}
function run_all(fns) {
  fns.forEach(run)
}
function is_function(thing) {
  return typeof thing === "function"
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object") || typeof a2 === "function"
}
function is_empty(obj) {
  return Object.keys(obj).length === 0
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn)
    return definition[0](slot_ctx)
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty))
    if ($$scope.dirty === void 0) {
      return lets
    }
    if (typeof lets === "object") {
      const merged = []
      const len = Math.max($$scope.dirty.length, lets.length)
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i]
      }
      return merged
    }
    return $$scope.dirty | lets
  }
  return $$scope.dirty
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn)
    slot.p(slot_context, slot_changes)
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = []
    const length = $$scope.ctx.length / 32
    for (let i = 0; i < length; i++) {
      dirty[i] = -1
    }
    return dirty
  }
  return -1
}
function null_to_empty(value) {
  return value == null ? "" : value
}
function append(target, node) {
  target.appendChild(node)
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null)
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node)
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching)
  }
}
function element(name2) {
  return document.createElement(name2)
}
function svg_element(name2) {
  return document.createElementNS("http://www.w3.org/2000/svg", name2)
}
function text(data) {
  return document.createTextNode(data)
}
function space() {
  return text(" ")
}
function empty() {
  return text("")
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options)
  return () => node.removeEventListener(event, handler, options)
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute)
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value)
}
function xlink_attr(node, attribute, value) {
  node.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value)
}
function children(element2) {
  return Array.from(element2.childNodes)
}
function set_data(text2, data) {
  data = "" + data
  if (text2.wholeText !== data) text2.data = data
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key)
  } else {
    node.style.setProperty(key, value, important ? "important" : "")
  }
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent")
  e.initCustomEvent(type, bubbles, cancelable, detail)
  return e
}
class HtmlTag {
  constructor(is_svg = false) {
    this.is_svg = false
    this.is_svg = is_svg
    this.e = this.n = null
  }
  c(html) {
    this.h(html)
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg) this.e = svg_element(target.nodeName)
      else this.e = element(target.nodeName)
      this.t = target
      this.c(html)
    }
    this.i(anchor)
  }
  h(html) {
    this.e.innerHTML = html
    this.n = Array.from(this.e.childNodes)
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor)
    }
  }
  p(html) {
    this.d()
    this.h(html)
    this.i(this.a)
  }
  d() {
    this.n.forEach(detach)
  }
}
function construct_svelte_component(component, props) {
  return new component(props)
}
let current_component
function set_current_component(component) {
  current_component = component
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization")
  return current_component
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn)
}
function createEventDispatcher() {
  const component = get_current_component()
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type]
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable })
      callbacks.slice().forEach((fn) => {
        fn.call(component, event)
      })
      return !event.defaultPrevented
    }
    return true
  }
}
const dirty_components = []
const binding_callbacks = []
const render_callbacks = []
const flush_callbacks = []
const resolved_promise = Promise.resolve()
let update_scheduled = false
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true
    resolved_promise.then(flush)
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn)
}
const seen_callbacks = /* @__PURE__ */ new Set()
let flushidx = 0
function flush() {
  if (flushidx !== 0) {
    return
  }
  const saved_component = current_component
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx]
        flushidx++
        set_current_component(component)
        update(component.$$)
      }
    } catch (e) {
      dirty_components.length = 0
      flushidx = 0
      throw e
    }
    set_current_component(null)
    dirty_components.length = 0
    flushidx = 0
    while (binding_callbacks.length) binding_callbacks.pop()()
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i]
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback)
        callback()
      }
    }
    render_callbacks.length = 0
  } while (dirty_components.length)
  while (flush_callbacks.length) {
    flush_callbacks.pop()()
  }
  update_scheduled = false
  seen_callbacks.clear()
  set_current_component(saved_component)
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update()
    run_all($$.before_update)
    const dirty = $$.dirty
    $$.dirty = [-1]
    $$.fragment && $$.fragment.p($$.ctx, dirty)
    $$.after_update.forEach(add_render_callback)
  }
}
const outroing = /* @__PURE__ */ new Set()
let outros
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros,
    // parent group
  }
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c)
  }
  outros = outros.p
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block)
    block.i(local)
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return
    outroing.add(block)
    outros.c.push(() => {
      outroing.delete(block)
      if (callback) {
        if (detach2) block.d(1)
        callback()
      }
    })
    block.o(local)
  } else if (callback) {
    callback()
  }
}
function create_component(block) {
  block && block.c()
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$
  fragment && fragment.m(target, anchor)
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function)
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy)
      } else {
        run_all(new_on_destroy)
      }
      component.$$.on_mount = []
    })
  }
  after_update.forEach(add_render_callback)
}
function destroy_component(component, detaching) {
  const $$ = component.$$
  if ($$.fragment !== null) {
    run_all($$.on_destroy)
    $$.fragment && $$.fragment.d(detaching)
    $$.on_destroy = $$.fragment = null
    $$.ctx = []
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component)
    schedule_update()
    component.$$.dirty.fill(0)
  }
  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component
  set_current_component(component)
  const $$ = (component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root,
  })
  append_styles && append_styles($$.root)
  let ready = false
  $$.ctx = instance2
    ? instance2(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret
        if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
          if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value)
          if (ready) make_dirty(component, i)
        }
        return ret
      })
    : []
  $$.update()
  ready = true
  run_all($$.before_update)
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target)
      $$.fragment && $$.fragment.l(nodes)
      nodes.forEach(detach)
    } else {
      $$.fragment && $$.fragment.c()
    }
    if (options.intro) transition_in(component.$$.fragment)
    mount_component(component, options.target, options.anchor, options.customElement)
    flush()
  }
  set_current_component(parent_component)
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1)
    this.$destroy = noop
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = [])
    callbacks.push(callback)
    return () => {
      const index = callbacks.indexOf(callback)
      if (index !== -1) callbacks.splice(index, 1)
    }
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true
      this.$$set($$props)
      this.$$.skip_bound = false
    }
  }
}
const commandPanel_svelte_svelte_type_style_lang = ""
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice()
  child_ctx[11] = list[i]
  child_ctx[13] = i
  return child_ctx
}
function create_if_block$5(ctx) {
  let each_1_anchor
  let each_value =
    /*result*/
    ctx[2]
  let each_blocks = []
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i))
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c()
      }
      each_1_anchor = empty()
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor)
      }
      insert(target, each_1_anchor, anchor)
    },
    p(ctx2, dirty) {
      if (dirty /*currentIndex, onClick, result, _*/ & 22) {
        each_value = /*result*/ ctx2[2]
        let i
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i)
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty)
          } else {
            each_blocks[i] = create_each_block$4(child_ctx)
            each_blocks[i].c()
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor)
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1)
        }
        each_blocks.length = each_value.length
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching)
      if (detaching) detach(each_1_anchor)
    },
  }
}
function create_if_block_1$4(ctx) {
  let div
  let t0_value = _("shortcut") + ""
  let t0
  let t1
  let t2_value =
    /*com*/
    ctx[11].shortcut + ""
  let t2
  return {
    c() {
      div = element("div")
      t0 = text(t0_value)
      t1 = text(": ")
      t2 = text(t2_value)
      attr(div, "class", "command-shortcut svelte-1bq7axd")
    },
    m(target, anchor) {
      insert(target, div, anchor)
      append(div, t0)
      append(div, t1)
      append(div, t2)
    },
    p(ctx2, dirty) {
      if (dirty /*result*/ & 4 && t2_value !== (t2_value = /*com*/ ctx2[11].shortcut + "")) set_data(t2, t2_value)
    },
    d(detaching) {
      if (detaching) detach(div)
    },
  }
}
function create_each_block$4(ctx) {
  let div
  let span0
  let t0_value =
    /*com*/
    ctx[11].pluginName + ""
  let t0
  let t1
  let t2_value = ":"
  let t2
  let t3
  let span1
  let t4_value =
    /*com*/
    ctx[11].command + ""
  let t4
  let t5
  let t6_value =
    /*com*/
    (ctx[11].description || "") + ""
  let t6
  let t7
  let t8
  let div_class_value
  let mounted
  let dispose
  let if_block =
    /*com*/
    ctx[11].shortcut && create_if_block_1$4(ctx)
  function click_handler() {
    return (
      /*click_handler*/
      ctx[7](
        /*i*/
        ctx[13]
      )
    )
  }
  return {
    c() {
      div = element("div")
      span0 = element("span")
      t0 = text(t0_value)
      t1 = space()
      t2 = text(t2_value)
      t3 = space()
      span1 = element("span")
      t4 = text(t4_value)
      t5 = space()
      t6 = text(t6_value)
      t7 = space()
      if (if_block) if_block.c()
      t8 = space()
      attr(span0, "class", "command-plugin svelte-1bq7axd")
      attr(span1, "class", "command-description")
      attr(
        div,
        "class",
        (div_class_value =
          null_to_empty(
            /*i*/
            ctx[13] /*currentIndex*/ === ctx[1] ? "command-selected command" : "command"
          ) + " svelte-1bq7axd")
      )
    },
    m(target, anchor) {
      insert(target, div, anchor)
      append(div, span0)
      append(span0, t0)
      append(span0, t1)
      append(span0, t2)
      append(div, t3)
      append(div, span1)
      append(span1, t4)
      append(span1, t5)
      append(span1, t6)
      append(div, t7)
      if (if_block) if_block.m(div, null)
      append(div, t8)
      if (!mounted) {
        dispose = listen(div, "click", click_handler)
        mounted = true
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      if (dirty /*result*/ & 4 && t0_value !== (t0_value = /*com*/ ctx[11].pluginName + "")) set_data(t0, t0_value)
      if (dirty /*result*/ & 4 && t4_value !== (t4_value = /*com*/ ctx[11].command + "")) set_data(t4, t4_value)
      if (dirty /*result*/ & 4 && t6_value !== (t6_value = /*com*/ (ctx[11].description || "") + ""))
        set_data(t6, t6_value)
      if (
        /*com*/
        ctx[11].shortcut
      ) {
        if (if_block) {
          if_block.p(ctx, dirty)
        } else {
          if_block = create_if_block_1$4(ctx)
          if_block.c()
          if_block.m(div, t8)
        }
      } else if (if_block) {
        if_block.d(1)
        if_block = null
      }
      if (
        dirty /*currentIndex*/ & 2 &&
        div_class_value !==
          (div_class_value =
            null_to_empty(
              /*i*/
              ctx[13] /*currentIndex*/ === ctx[1] ? "command-selected command" : "command"
            ) + " svelte-1bq7axd")
      ) {
        attr(div, "class", div_class_value)
      }
    },
    d(detaching) {
      if (detaching) detach(div)
      if (if_block) if_block.d()
      mounted = false
      dispose()
    },
  }
}
function create_fragment$7(ctx) {
  let div1
  let div0
  let svg
  let path
  let t0
  let input
  let t1
  let mounted
  let dispose
  let if_block =
    /*result*/
    ctx[2] && create_if_block$5(ctx)
  return {
    c() {
      div1 = element("div")
      div0 = element("div")
      svg = svg_element("svg")
      path = svg_element("path")
      t0 = space()
      input = element("input")
      t1 = space()
      if (if_block) if_block.c()
      attr(
        path,
        "d",
        "M64 112v800h896V112H64z m846 750H114V162h796v700zM234.6 688.8L411.3 512 234.6 335.2l35.4-35.4L482.1 512 269.9 724.1l-35.3-35.3z m554.8-10.2h-300v-50h300v50z"
      )
      set_style(svg, "left", "14px")
      attr(svg, "class", "b3-form__icon-icon")
      attr(svg, "viewBox", "0 0 1024 1024")
      attr(svg, "version", "1.1")
      attr(svg, "xmlns", "http://www.w3.org/2000/svg")
      attr(svg, "width", "200")
      attr(svg, "height", "200")
      attr(input, "id", "commandPanelInput")
      attr(input, "class", "b3-text-field b3-text-field--text fn__block b3-form__icon-input")
      attr(div0, "class", "b3-form__icon search__header")
      attr(div1, "class", "fn__flex-column")
      set_style(div1, "border-radius", "4px")
      set_style(div1, "overflow", "hidden")
      set_style(div1, "position", "relative")
      set_style(div1, "width", "max(80vw, 1000px)")
    },
    m(target, anchor) {
      insert(target, div1, anchor)
      append(div1, div0)
      append(div0, svg)
      append(svg, path)
      append(div0, t0)
      append(div0, input)
      set_input_value(
        input,
        /*command*/
        ctx[0]
      )
      append(div1, t1)
      if (if_block) if_block.m(div1, null)
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen(
            input,
            "keydown",
            /*onkeypress*/
            ctx[3]
          ),
        ]
        mounted = true
      }
    },
    p(ctx2, [dirty]) {
      if (dirty /*command*/ & 1 && input.value /*command*/ !== ctx2[0]) {
        set_input_value(
          input,
          /*command*/
          ctx2[0]
        )
      }
      if (
        /*result*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty)
        } else {
          if_block = create_if_block$5(ctx2)
          if_block.c()
          if_block.m(div1, null)
        }
      } else if (if_block) {
        if_block.d(1)
        if_block = null
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(div1)
      if (if_block) if_block.d()
      mounted = false
      run_all(dispose)
    },
  }
}
function instance$7($$self, $$props, $$invalidate) {
  const commandManager = container.get("CommandManager")
  let commands = []
  let command = ""
  let currentIndex = 0
  let result = []
  const onkeypress = (e) => {
    if (e.keyCode === 13) {
      onEnter()
      return
    }
    if (e.keyCode === 38) {
      e.preventDefault()
      if (currentIndex === 0) {
        return
      }
      $$invalidate(1, currentIndex--, currentIndex)
      return
    }
    if (e.keyCode === 40) {
      const len = result.length
      e.preventDefault()
      if (currentIndex >= len - 1) {
        return
      }
      $$invalidate(1, currentIndex++, currentIndex)
    }
  }
  const onEnter = () => {
    const com = result[currentIndex]
    Dialog.destroyAll()
    com.callback()
  }
  const onClick = (i) => {
    $$invalidate(1, (currentIndex = i))
    onEnter()
  }
  const hasContent = (v, c) => v && v.toLowerCase().indexOf(c.toLowerCase()) >= 0
  onMount(() => {
    $$invalidate(5, (commands = commandManager.getCommands()))
    const el = document.getElementById("commandPanelInput")
    el.focus()
  })
  function input_input_handler() {
    command = this.value
    $$invalidate(0, command)
  }
  const click_handler = (i) => onClick(i)
  $$self.$$.update = () => {
    if ($$self.$$.dirty /*command, commands*/ & 33) {
      {
        $$invalidate(1, (currentIndex = 0))
        if (!command) {
          $$invalidate(2, (result = commands))
        } else {
          $$invalidate(
            2,
            (result = commands.filter((c) => {
              return (
                hasContent(c.plugin, command) ||
                hasContent(c.pluginName, command) ||
                hasContent(c.command, command) ||
                hasContent(c.description, command)
              )
            }))
          )
        }
      }
    }
  }
  return [command, currentIndex, result, onkeypress, onClick, commands, input_input_handler, click_handler]
}
class Command_panel extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance$7, create_fragment$7, safe_not_equal, {})
  }
}
class CommandPanelPlugin extends Plugin {
  onload() {
    this.registerCommand({
      command: "Show command panel",
      description: _("show_command_panel"),
      shortcut: "ctrl+shift+o,command+shift+o",
      callback: () => {
        this.showPanel()
      },
    })
  }
  showPanel() {
    Dialog.destroyAll()
    new Dialog({ content: '<div id="command-panel"></div>' })
    setImmediate(() => {
      new Command_panel({
        target: document.getElementById("command-panel"),
      })
    })
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice()
  child_ctx[5] = list[i]
  child_ctx[6] = list
  child_ctx[7] = i
  return child_ctx
}
function create_if_block_1$3(ctx) {
  let input
  let mounted
  let dispose
  function input_input_handler() {
    ctx[2].call(
      input,
      /*each_value*/
      ctx[6],
      /*config_index*/
      ctx[7]
    )
  }
  return {
    c() {
      input = element("input")
      attr(input, "class", "b3-text-field fn__flex-center fn__size200")
      attr(input, "type", "input")
    },
    m(target, anchor) {
      insert(target, input, anchor)
      set_input_value(
        input,
        /*config*/
        ctx[5].value
      )
      if (!mounted) {
        dispose = [
          listen(input, "input", input_input_handler),
          listen(input, "change", function () {
            if (
              is_function(
                /*config*/
                ctx[5].onChange
              )
            )
              ctx[5].onChange.apply(this, arguments)
          }),
        ]
        mounted = true
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      if (dirty /*configs*/ & 1) {
        set_input_value(
          input,
          /*config*/
          ctx[5].value
        )
      }
    },
    d(detaching) {
      if (detaching) detach(input)
      mounted = false
      run_all(dispose)
    },
  }
}
function create_if_block$4(ctx) {
  let input
  let mounted
  let dispose
  function input_change_handler() {
    ctx[1].call(
      input,
      /*each_value*/
      ctx[6],
      /*config_index*/
      ctx[7]
    )
  }
  return {
    c() {
      input = element("input")
      attr(input, "class", "b3-switch fn__flex-center")
      attr(input, "type", "checkbox")
    },
    m(target, anchor) {
      insert(target, input, anchor)
      input.checked = /*config*/ ctx[5].checked
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler),
          listen(input, "change", function () {
            if (
              is_function(
                /*config*/
                ctx[5].onChange
              )
            )
              ctx[5].onChange.apply(this, arguments)
          }),
        ]
        mounted = true
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      if (dirty /*configs*/ & 1) {
        input.checked = /*config*/ ctx[5].checked
      }
    },
    d(detaching) {
      if (detaching) detach(input)
      mounted = false
      run_all(dispose)
    },
  }
}
function create_each_block$3(ctx) {
  let label
  let div1
  let t0_value =
    /*config*/
    ctx[5].label + ""
  let t0
  let t1
  let div0
  let t2_value =
    /*config*/
    ctx[5].tip + ""
  let t2
  let t3
  let span
  let t4
  let t5
  function select_block_type(ctx2, dirty) {
    if (
      /*config*/
      ctx2[5].type === "checkbox"
    )
      return create_if_block$4
    if (
      /*config*/
      ctx2[5].type === "input"
    )
      return create_if_block_1$3
  }
  let current_block_type = select_block_type(ctx)
  let if_block = current_block_type && current_block_type(ctx)
  return {
    c() {
      label = element("label")
      div1 = element("div")
      t0 = text(t0_value)
      t1 = space()
      div0 = element("div")
      t2 = text(t2_value)
      t3 = space()
      span = element("span")
      t4 = space()
      if (if_block) if_block.c()
      t5 = space()
      attr(div0, "class", "b3-label__text")
      attr(div1, "class", "fn__flex-1")
      attr(span, "class", "fn__space")
      attr(label, "class", "fn__flex b3-label config__item")
    },
    m(target, anchor) {
      insert(target, label, anchor)
      append(label, div1)
      append(div1, t0)
      append(div1, t1)
      append(div1, div0)
      append(div0, t2)
      append(label, t3)
      append(label, span)
      append(label, t4)
      if (if_block) if_block.m(label, null)
      append(label, t5)
    },
    p(ctx2, dirty) {
      if (dirty /*configs*/ & 1 && t0_value !== (t0_value = /*config*/ ctx2[5].label + "")) set_data(t0, t0_value)
      if (dirty /*configs*/ & 1 && t2_value !== (t2_value = /*config*/ ctx2[5].tip + "")) set_data(t2, t2_value)
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty)
      } else {
        if (if_block) if_block.d(1)
        if_block = current_block_type && current_block_type(ctx2)
        if (if_block) {
          if_block.c()
          if_block.m(label, t5)
        }
      }
    },
    d(detaching) {
      if (detaching) detach(label)
      if (if_block) {
        if_block.d()
      }
    },
  }
}
function create_fragment$6(ctx) {
  let each_1_anchor
  let each_value =
    /*configs*/
    ctx[0]
  let each_blocks = []
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i))
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c()
      }
      each_1_anchor = empty()
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor)
      }
      insert(target, each_1_anchor, anchor)
    },
    p(ctx2, [dirty]) {
      if (dirty /*configs*/ & 1) {
        each_value = /*configs*/ ctx2[0]
        let i
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i)
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty)
          } else {
            each_blocks[i] = create_each_block$3(child_ctx)
            each_blocks[i].c()
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor)
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1)
        }
        each_blocks.length = each_value.length
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      destroy_each(each_blocks, detaching)
      if (detaching) detach(each_1_anchor)
    },
  }
}
function instance$6($$self, $$props, $$invalidate) {
  const storageManager = container.get(TYPES.StorageManager)
  const pluginSystem = container.get(TYPES.PluginSystem)
  let configs = [
    {
      label: _("safemode"),
      tip: _("safemodetip"),
      checked: true,
      type: "checkbox",
      onChange: (event) => {
        const checked = event.target.checked
        if (checked) {
          pluginSystem.turnOnSafeMode()
        } else {
          pluginSystem.turnOffSafeMode()
        }
      },
    },
    // {
    //     label: _('autoupgrade'),
    //     tip: _('autoupgradetip'),
    //     checked: true,
    //     type: 'checkbox',
    //     onChange: (event) => {
    //         storageManager.set(PLUGIN_SYSTEM_AUTO_UPDATE, event.target.checked);
    //     },
    // },
    {
      label: _("store_url"),
      tip: `${_("store_url_tip")} ${defaultConfig.PLUGIN_STORE_URL}`,
      type: "input",
      value: storageManager.get(PLUGIN_STORE_URL),
      onChange: (event) => {
        storageManager.set(PLUGIN_STORE_URL, event.target.value)
      },
    },
  ]
  onMount(() => {
    const securityMode = storageManager.get(PLUGIN_SYSTEM_SAFE_MODE_ENABLED)
    $$invalidate(0, (configs[0].checked = securityMode), configs)
    const autoUpdate = storageManager.get(PLUGIN_SYSTEM_AUTO_UPDATE)
    $$invalidate(0, (configs[1].checked = autoUpdate), configs)
  })
  function input_change_handler(each_value, config_index) {
    each_value[config_index].checked = this.checked
    $$invalidate(0, configs)
  }
  function input_input_handler(each_value, config_index) {
    each_value[config_index].value = this.value
    $$invalidate(0, configs)
  }
  return [configs, input_change_handler, input_input_handler]
}
class Setting_common extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance$6, create_fragment$6, safe_not_equal, {})
  }
}
const settingList_svelte_svelte_type_style_lang = ""
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice()
  child_ctx[10] = list[i]
  child_ctx[11] = list
  child_ctx[12] = i
  return child_ctx
}
function create_if_block$3(ctx) {
  let label
  let div1
  let t0_value =
    /*plugin*/
    ctx[10].name + ""
  let t0
  let t1
  let t2_value =
    /*plugin*/
    ctx[10].version + ""
  let t2
  let t3
  let span0
  let t5
  let div0
  let t6_value =
    /*plugin*/
    (ctx[10].description || _("nodescription")) + ""
  let t6
  let t7
  let span1
  let t8
  let input
  let t9
  let mounted
  let dispose
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[4](
        /*plugin*/
        ctx[10],
        ...args
      )
    )
  }
  function input_change_handler() {
    ctx[5].call(
      input,
      /*each_value*/
      ctx[11],
      /*plugin_index*/
      ctx[12]
    )
  }
  return {
    c() {
      label = element("label")
      div1 = element("div")
      t0 = text(t0_value)
      t1 = space()
      t2 = text(t2_value)
      t3 = space()
      span0 = element("span")
      span0.textContent = `${_("uninstall")}`
      t5 = space()
      div0 = element("div")
      t6 = text(t6_value)
      t7 = space()
      span1 = element("span")
      t8 = space()
      input = element("input")
      t9 = space()
      attr(span0, "class", "remove svelte-bwhxpp")
      attr(div0, "class", "b3-label__text")
      attr(div1, "class", "plugin fn__flex-1 svelte-bwhxpp")
      attr(span1, "class", "fn__space")
      attr(input, "class", "b3-switch fn__flex-center")
      attr(input, "id", "fullWidth")
      attr(input, "type", "checkbox")
      attr(label, "class", "fn__flex b3-label")
    },
    m(target, anchor) {
      insert(target, label, anchor)
      append(label, div1)
      append(div1, t0)
      append(div1, t1)
      append(div1, t2)
      append(div1, t3)
      append(div1, span0)
      append(div1, t5)
      append(div1, div0)
      append(div0, t6)
      append(label, t7)
      append(label, span1)
      append(label, t8)
      append(label, input)
      input.checked = /*plugin*/ ctx[10].enabled
      append(label, t9)
      if (!mounted) {
        dispose = [
          listen(span0, "click", click_handler),
          listen(input, "change", input_change_handler),
          listen(input, "change", function () {
            if (
              is_function(
                /*onPluginEnabledChange*/
                ctx[1](
                  /*plugin*/
                  ctx[10].key
                )
              )
            )
              ctx[1](
                /*plugin*/
                ctx[10].key
              ).apply(this, arguments)
          }),
        ]
        mounted = true
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      if (dirty /*outsidePlugins*/ & 1 && t0_value !== (t0_value = /*plugin*/ ctx[10].name + "")) set_data(t0, t0_value)
      if (dirty /*outsidePlugins*/ & 1 && t2_value !== (t2_value = /*plugin*/ ctx[10].version + ""))
        set_data(t2, t2_value)
      if (
        dirty /*outsidePlugins*/ & 1 &&
        t6_value !== (t6_value = /*plugin*/ (ctx[10].description || _("nodescription")) + "")
      )
        set_data(t6, t6_value)
      if (dirty /*outsidePlugins*/ & 1) {
        input.checked = /*plugin*/ ctx[10].enabled
      }
    },
    d(detaching) {
      if (detaching) detach(label)
      mounted = false
      run_all(dispose)
    },
  }
}
function create_each_block$2(ctx) {
  let if_block_anchor
  let if_block = !(/*plugin*/ ctx[10].hidden) && create_if_block$3(ctx)
  return {
    c() {
      if (if_block) if_block.c()
      if_block_anchor = empty()
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor)
      insert(target, if_block_anchor, anchor)
    },
    p(ctx2, dirty) {
      if (!(/*plugin*/ ctx2[10].hidden)) {
        if (if_block) {
          if_block.p(ctx2, dirty)
        } else {
          if_block = create_if_block$3(ctx2)
          if_block.c()
          if_block.m(if_block_anchor.parentNode, if_block_anchor)
        }
      } else if (if_block) {
        if_block.d(1)
        if_block = null
      }
    },
    d(detaching) {
      if (if_block) if_block.d(detaching)
      if (detaching) detach(if_block_anchor)
    },
  }
}
function create_fragment$5(ctx) {
  let label
  let div
  let each_value =
    /*outsidePlugins*/
    ctx[0]
  let each_blocks = []
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i))
  }
  return {
    c() {
      label = element("label")
      div = element("div")
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c()
      }
      attr(div, "class", "fn__flex-1")
      attr(label, "class", "b3-label fn__flex")
    },
    m(target, anchor) {
      insert(target, label, anchor)
      append(label, div)
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null)
      }
    },
    p(ctx2, [dirty]) {
      if (dirty /*outsidePlugins, onPluginEnabledChange, _, uninstall*/ & 7) {
        each_value = /*outsidePlugins*/ ctx2[0]
        let i
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i)
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty)
          } else {
            each_blocks[i] = create_each_block$2(child_ctx)
            each_blocks[i].c()
            each_blocks[i].m(div, null)
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1)
        }
        each_blocks.length = each_value.length
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(label)
      destroy_each(each_blocks, detaching)
    },
  }
}
function instance$5($$self, $$props, $$invalidate) {
  let outsidePlugins
  const storageManager = container.get(TYPES.StorageManager)
  const pluginSystem = container.get(TYPES.PluginSystem)
  let plugins = []
  const loadPlugins = () => {
    $$invalidate(3, (plugins = storageManager.getPlugins()))
  }
  const dispatcher = createEventDispatcher()
  const onPluginEnabledChange = (key) => async (event) => {
    const safeMode = storageManager.get(PLUGIN_SYSTEM_SAFE_MODE_ENABLED)
    const checked = event.target.checked
    await storageManager.setPluginEnabled(key, checked)
    if (safeMode) {
      return
    }
    if (checked) {
      pluginSystem.loadPlugin(key)
    } else {
      pluginSystem.unloadPlugin(key)
    }
    dispatcher("update")
  }
  const uninstall2 = async (key, event) => {
    event.preventDefault()
    event.stopPropagation()
    await pluginSystem.unloadPlugin(key)
    await storageManager.uninstallPlugin(key)
    await storageManager.initStorage()
    loadPlugins()
  }
  onMount(async () => {
    await storageManager.initStorage()
    loadPlugins()
  })
  const click_handler = (plugin2, event) => uninstall2(plugin2.key, event)
  function input_change_handler(each_value, plugin_index) {
    each_value[plugin_index].enabled = this.checked
    $$invalidate(0, outsidePlugins), $$invalidate(3, plugins)
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty /*plugins*/ & 8) {
      $$invalidate(0, (outsidePlugins = plugins.filter((p) => p.script)))
    }
  }
  return [outsidePlugins, onPluginEnabledChange, uninstall2, plugins, click_handler, input_change_handler]
}
class Setting_list extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {})
  }
}
var __defProp$9 = Object.defineProperty
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor
var __decorateClass$9 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$9(target, key, result)
  return result
}
var __decorateParam$6 = (index, decorator) => (target, key) => decorator(target, key, index)
let Store = class {
  constructor(storageManager) {
    this.storageManager = storageManager
    this.plugins = []
    this.pluginStatus = []
  }
  async init() {
    this.plugins = []
    this.pluginStatus = []
    await Promise.all([this.loadPluginsFromUrl(), this.storageManager.initStorage()])
    const plugins = this.storageManager.getPlugins()
    const storePlugins = []
    for (const plugin2 of this.plugins) {
      const p = { ...plugin2, isExist: false, needUpgrade: false }
      const oldPlugin = plugins.find((p2) => p2.key === plugin2.key)
      if (oldPlugin) {
        p.isExist = true
        const pV = new semver.SemVer(p.version)
        const oldPluginV = new semver.SemVer(oldPlugin.version)
        if (pV.compare(oldPluginV) === 1) {
          p.needUpgrade = true
        }
      }
      storePlugins.push(p)
    }
    this.pluginStatus = storePlugins
  }
  getStoreUrl() {
    return this.storageManager.get(PLUGIN_STORE_URL)
  }
  getPlugins() {
    return this.plugins
  }
  async loadPlugins() {
    await this.init()
    return this.getPluginsWithStatus()
  }
  getPluginsWithStatus() {
    return this.pluginStatus
  }
  async loadPluginsFromUrl() {
    var _a2, _b
    const storeUrl = this.getStoreUrl()
    if (!storeUrl) {
      return
    }
    let res
    try {
      res = await request.get(storeUrl + "/plugins.json", {
        headers: {
          "Cache-Control": "no-cache",
        },
      })
    } catch (e) {
      console.error(e)
      return
    }
    const req = []
    if (Array.isArray((_a2 = res.data) == null ? void 0 : _a2.plugins)) {
      for (const pluginKey of ((_b = res.data) == null ? void 0 : _b.plugins) || {}) {
        const plugin2 = this.getPluginManifest(`${storeUrl}/${pluginKey}`)
        req.push(plugin2)
      }
    }
    this.plugins = await Promise.all(req)
  }
  async getPluginByUrl(url2) {
    return Promise.all([this.getPluginManifest(url2), this.getPluginMainJs(url2)]).then((value) => {
      return {
        manifest: value[0],
        mainJs: value[1],
      }
    })
  }
  async getPluginManifest(url2) {
    try {
      const manifest = await request.get(`${url2}/manifest.json`, {
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache",
        },
      })
      return manifest.data
    } catch (e) {
      console.error(e)
      return null
    }
  }
  async getPluginMainJs(url2) {
    try {
      const res = await request.get(`${url2}/main.js`, {
        headers: {
          "Content-Type": "text/plain",
          "Cache-Control": "no-cache",
        },
      })
      return res.data
    } catch (e) {
      console.error(e)
      return null
    }
  }
  async getPluginReadme(key) {
    const url2 = `${this.getStoreUrl()}/${key}`
    try {
      const res = await request.get(`${url2}/README.md`, {
        headers: {
          "Content-Type": "text/plain",
          "Cache-Control": "no-cache",
        },
      })
      return res.data
    } catch (e) {
      console.error(e)
      return null
    }
  }
  async downloadPlugin(key) {
    await sleep(500)
    const files = await this.getPluginByUrl(`${this.getStoreUrl()}/${key}`)
    const manifestJson = files.manifest
    const mainJs = files.mainJs
    return await Promise.all([
      FileClient.getInstanceApi().fileApi.putFile(`/data/plugins/${key}`, null, true),
      FileClient.getInstanceApi().fileApi.putFile(
        `/data/plugins/${key}/manifest.json`,
        JSON.stringify(manifestJson),
        false
      ),
      FileClient.getInstanceApi().fileApi.putFile(`/data/plugins/${key}/main.js`, mainJs, false),
    ])
  }
}
Store = __decorateClass$9([injectable(), __decorateParam$6(0, inject(TYPES.StorageManager))], Store)
function create_fragment$4(ctx) {
  let button
  let current
  let mounted
  let dispose
  const default_slot_template =
    /*#slots*/
    ctx[3].default
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  )
  return {
    c() {
      button = element("button")
      if (default_slot) default_slot.c()
      button.disabled = /*disabled*/ ctx[1]
      attr(button, "class", "b3-button")
    },
    m(target, anchor) {
      insert(target, button, anchor)
      if (default_slot) {
        default_slot.m(button, null)
      }
      current = true
      if (!mounted) {
        dispose = listen(button, "click", function () {
          if (
            is_function(
              /*onClick*/
              ctx[0]
            )
          )
            ctx[0].apply(this, arguments)
        })
        mounted = true
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx
      if (default_slot) {
        if (default_slot.p && (!current || dirty /*$$scope*/ & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[2],
            !current
              ? get_all_dirty_from_scope(
                  /*$$scope*/
                  ctx[2]
                )
              : get_slot_changes(
                  default_slot_template,
                  /*$$scope*/
                  ctx[2],
                  dirty,
                  null
                ),
            null
          )
        }
      }
      if (!current || dirty /*disabled*/ & 2) {
        button.disabled = /*disabled*/ ctx[1]
      }
    },
    i(local) {
      if (current) return
      transition_in(default_slot, local)
      current = true
    },
    o(local) {
      transition_out(default_slot, local)
      current = false
    },
    d(detaching) {
      if (detaching) detach(button)
      if (default_slot) default_slot.d(detaching)
      mounted = false
      dispose()
    },
  }
}
function instance$4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props
  let { onClick = null } = $$props
  let { disabled = false } = $$props
  $$self.$$set = ($$props2) => {
    if ("onClick" in $$props2) $$invalidate(0, (onClick = $$props2.onClick))
    if ("disabled" in $$props2) $$invalidate(1, (disabled = $$props2.disabled))
    if ("$$scope" in $$props2) $$invalidate(2, ($$scope = $$props2.$$scope))
  }
  return [onClick, disabled, $$scope, slots]
}
class Button extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { onClick: 0, disabled: 1 })
  }
}
const settingPreview_svelte_svelte_type_style_lang = ""
function create_if_block_4$1(ctx) {
  let div
  let t0_value = _("url") + ""
  let t0
  let t1
  let a2
  let t2_value =
    /*plugin*/
    ctx[0].url + ""
  let t2
  let a_href_value
  return {
    c() {
      div = element("div")
      t0 = text(t0_value)
      t1 = text(": ")
      a2 = element("a")
      t2 = text(t2_value)
      attr(a2, "href", (a_href_value = /*plugin*/ ctx[0].url))
      attr(a2, "target", "_blank")
      attr(a2, "rel", "noreferrer")
      attr(div, "class", "plugin-item")
    },
    m(target, anchor) {
      insert(target, div, anchor)
      append(div, t0)
      append(div, t1)
      append(div, a2)
      append(a2, t2)
    },
    p(ctx2, dirty) {
      if (dirty /*plugin*/ & 1 && t2_value !== (t2_value = /*plugin*/ ctx2[0].url + "")) set_data(t2, t2_value)
      if (dirty /*plugin*/ & 1 && a_href_value !== (a_href_value = /*plugin*/ ctx2[0].url)) {
        attr(a2, "href", a_href_value)
      }
    },
    d(detaching) {
      if (detaching) detach(div)
    },
  }
}
function create_if_block_3$1(ctx) {
  let div
  let t0_value = _("author") + ""
  let t0
  let t1
  let t2_value =
    /*plugin*/
    ctx[0].author + ""
  let t2
  return {
    c() {
      div = element("div")
      t0 = text(t0_value)
      t1 = text(": ")
      t2 = text(t2_value)
      attr(div, "class", "plugin-item")
    },
    m(target, anchor) {
      insert(target, div, anchor)
      append(div, t0)
      append(div, t1)
      append(div, t2)
    },
    p(ctx2, dirty) {
      if (dirty /*plugin*/ & 1 && t2_value !== (t2_value = /*plugin*/ ctx2[0].author + "")) set_data(t2, t2_value)
    },
    d(detaching) {
      if (detaching) detach(div)
    },
  }
}
function create_if_block_2$1(ctx) {
  let div
  let t0_value = _("version") + ""
  let t0
  let t1
  let t2_value =
    /*plugin*/
    ctx[0].version + ""
  let t2
  return {
    c() {
      div = element("div")
      t0 = text(t0_value)
      t1 = text(": ")
      t2 = text(t2_value)
      attr(div, "class", "plugin-item")
    },
    m(target, anchor) {
      insert(target, div, anchor)
      append(div, t0)
      append(div, t1)
      append(div, t2)
    },
    p(ctx2, dirty) {
      if (dirty /*plugin*/ & 1 && t2_value !== (t2_value = /*plugin*/ ctx2[0].version + "")) set_data(t2, t2_value)
    },
    d(detaching) {
      if (detaching) detach(div)
    },
  }
}
function create_if_block_1$2(ctx) {
  let div
  let t0_value = _("description") + ""
  let t0
  let t1
  let t2_value =
    /*plugin*/
    ctx[0].description + ""
  let t2
  return {
    c() {
      div = element("div")
      t0 = text(t0_value)
      t1 = text(": ")
      t2 = text(t2_value)
      attr(div, "class", "plugin-item")
    },
    m(target, anchor) {
      insert(target, div, anchor)
      append(div, t0)
      append(div, t1)
      append(div, t2)
    },
    p(ctx2, dirty) {
      if (dirty /*plugin*/ & 1 && t2_value !== (t2_value = /*plugin*/ ctx2[0].description + "")) set_data(t2, t2_value)
    },
    d(detaching) {
      if (detaching) detach(div)
    },
  }
}
function create_else_block$2(ctx) {
  let html_tag
  let raw_value =
    /*previewHTML*/
    ctx[2]() + ""
  let html_anchor
  return {
    c() {
      html_tag = new HtmlTag(false)
      html_anchor = empty()
      html_tag.a = html_anchor
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor)
      insert(target, html_anchor, anchor)
    },
    p(ctx2, dirty) {
      if (dirty /*previewHTML*/ & 4 && raw_value !== (raw_value = /*previewHTML*/ ctx2[2]() + "")) html_tag.p(raw_value)
    },
    d(detaching) {
      if (detaching) detach(html_anchor)
      if (detaching) html_tag.d()
    },
  }
}
function create_if_block$2(ctx) {
  let span
  return {
    c() {
      span = element("span")
      span.textContent = `${_("readme")}`
    },
    m(target, anchor) {
      insert(target, span, anchor)
    },
    p: noop,
    d(detaching) {
      if (detaching) detach(span)
    },
  }
}
function create_fragment$3(ctx) {
  let div6
  let div4
  let div2
  let div0
  let t0_value =
    /*plugin*/
    ctx[0].name + ""
  let t0
  let t1
  let div1
  let t2
  let t3_value =
    /*plugin*/
    ctx[0].key + ""
  let t3
  let t4
  let t5
  let button
  let svg
  let use
  let t6_value = _("goBack") + ""
  let t6
  let t7
  let div3
  let t8
  let t9
  let t10
  let t11
  let hr
  let t12
  let div5
  let mounted
  let dispose
  let if_block0 =
    /*plugin*/
    ctx[0].url && create_if_block_4$1(ctx)
  let if_block1 =
    /*plugin*/
    ctx[0].author && create_if_block_3$1(ctx)
  let if_block2 =
    /*plugin*/
    ctx[0].version && create_if_block_2$1(ctx)
  let if_block3 =
    /*plugin*/
    ctx[0].description && create_if_block_1$2(ctx)
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[1]
    )
      return create_if_block$2
    return create_else_block$2
  }
  let current_block_type = select_block_type(ctx)
  let if_block4 = current_block_type(ctx)
  return {
    c() {
      div6 = element("div")
      div4 = element("div")
      div2 = element("div")
      div0 = element("div")
      t0 = text(t0_value)
      t1 = space()
      div1 = element("div")
      t2 = text("(")
      t3 = text(t3_value)
      t4 = text(")")
      t5 = space()
      button = element("button")
      svg = svg_element("svg")
      use = svg_element("use")
      t6 = text(t6_value)
      t7 = space()
      div3 = element("div")
      if (if_block0) if_block0.c()
      t8 = space()
      if (if_block1) if_block1.c()
      t9 = space()
      if (if_block2) if_block2.c()
      t10 = space()
      if (if_block3) if_block3.c()
      t11 = space()
      hr = element("hr")
      t12 = space()
      div5 = element("div")
      if_block4.c()
      attr(div0, "class", "plugin-name svelte-bj9chc")
      attr(div1, "class", "plugin-key svelte-bj9chc")
      xlink_attr(use, "xlink:href", "#iconBack")
      attr(svg, "class", "go-back-icon svelte-bj9chc")
      attr(button, "class", "go-back b3-button svelte-bj9chc")
      attr(div2, "class", "plugin-info svelte-bj9chc")
      attr(div3, "class", "plugin-manifest svelte-bj9chc")
      attr(div4, "class", "plugin-basic")
      attr(div5, "class", "plugin-readme b3-typography svelte-bj9chc")
      attr(div6, "class", "plugin-detail svelte-bj9chc")
    },
    m(target, anchor) {
      insert(target, div6, anchor)
      append(div6, div4)
      append(div4, div2)
      append(div2, div0)
      append(div0, t0)
      append(div2, t1)
      append(div2, div1)
      append(div1, t2)
      append(div1, t3)
      append(div1, t4)
      append(div2, t5)
      append(div2, button)
      append(button, svg)
      append(svg, use)
      append(button, t6)
      append(div4, t7)
      append(div4, div3)
      if (if_block0) if_block0.m(div3, null)
      append(div3, t8)
      if (if_block1) if_block1.m(div3, null)
      append(div3, t9)
      if (if_block2) if_block2.m(div3, null)
      append(div3, t10)
      if (if_block3) if_block3.m(div3, null)
      append(div6, t11)
      append(div6, hr)
      append(div6, t12)
      append(div6, div5)
      if_block4.m(div5, null)
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        )
        mounted = true
      }
    },
    p(ctx2, [dirty]) {
      if (dirty /*plugin*/ & 1 && t0_value !== (t0_value = /*plugin*/ ctx2[0].name + "")) set_data(t0, t0_value)
      if (dirty /*plugin*/ & 1 && t3_value !== (t3_value = /*plugin*/ ctx2[0].key + "")) set_data(t3, t3_value)
      if (
        /*plugin*/
        ctx2[0].url
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty)
        } else {
          if_block0 = create_if_block_4$1(ctx2)
          if_block0.c()
          if_block0.m(div3, t8)
        }
      } else if (if_block0) {
        if_block0.d(1)
        if_block0 = null
      }
      if (
        /*plugin*/
        ctx2[0].author
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty)
        } else {
          if_block1 = create_if_block_3$1(ctx2)
          if_block1.c()
          if_block1.m(div3, t9)
        }
      } else if (if_block1) {
        if_block1.d(1)
        if_block1 = null
      }
      if (
        /*plugin*/
        ctx2[0].version
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty)
        } else {
          if_block2 = create_if_block_2$1(ctx2)
          if_block2.c()
          if_block2.m(div3, t10)
        }
      } else if (if_block2) {
        if_block2.d(1)
        if_block2 = null
      }
      if (
        /*plugin*/
        ctx2[0].description
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty)
        } else {
          if_block3 = create_if_block_1$2(ctx2)
          if_block3.c()
          if_block3.m(div3, null)
        }
      } else if (if_block3) {
        if_block3.d(1)
        if_block3 = null
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block4) {
        if_block4.p(ctx2, dirty)
      } else {
        if_block4.d(1)
        if_block4 = current_block_type(ctx2)
        if (if_block4) {
          if_block4.c()
          if_block4.m(div5, null)
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(div6)
      if (if_block0) if_block0.d()
      if (if_block1) if_block1.d()
      if (if_block2) if_block2.d()
      if (if_block3) if_block3.d()
      if_block4.d()
      mounted = false
      dispose()
    },
  }
}
function instance$3($$self, $$props, $$invalidate) {
  let previewHTML
  const dispatch2 = createEventDispatcher()
  let loading2 = true
  let { plugin: plugin2 } = $$props
  const getPluginReadme = async () => {
    $$invalidate(4, (readme2 = await container.get("Store").getPluginReadme(plugin2.key)))
    $$invalidate(1, (loading2 = false))
  }
  let readme2
  const LuteMdConverter = window.Lute.New()
  onMount(() => {
    getPluginReadme()
  })
  const goBack2 = () => {
    dispatch2("goback")
  }
  const click_handler = () => goBack2()
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2) $$invalidate(0, (plugin2 = $$props2.plugin))
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty /*readme*/ & 16) {
      $$invalidate(
        2,
        (previewHTML = () => {
          return readme2 ? LuteMdConverter.Md2HTML(readme2) : ""
        })
      )
    }
  }
  return [plugin2, loading2, previewHTML, goBack2, readme2, click_handler]
}
class Setting_preview extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { plugin: 0 })
  }
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice()
  child_ctx[11] = list[i]
  return child_ctx
}
function create_else_block_2(ctx) {
  let settingpreview
  let current
  settingpreview = new Setting_preview({
    props: {
      plugin:
        /*selectedPlugin*/
        ctx[3],
    },
  })
  settingpreview.$on(
    "goback",
    /*goback_handler*/
    ctx[9]
  )
  return {
    c() {
      create_component(settingpreview.$$.fragment)
    },
    m(target, anchor) {
      mount_component(settingpreview, target, anchor)
      current = true
    },
    p(ctx2, dirty) {
      const settingpreview_changes = {}
      if (dirty /*selectedPlugin*/ & 8) settingpreview_changes.plugin = /*selectedPlugin*/ ctx2[3]
      settingpreview.$set(settingpreview_changes)
    },
    i(local) {
      if (current) return
      transition_in(settingpreview.$$.fragment, local)
      current = true
    },
    o(local) {
      transition_out(settingpreview.$$.fragment, local)
      current = false
    },
    d(detaching) {
      destroy_component(settingpreview, detaching)
    },
  }
}
function create_if_block_1$1(ctx) {
  let div
  let current
  let each_value =
    /*plugins*/
    ctx[0]
  let each_blocks = []
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i))
  }
  const out = (i) =>
    transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null
    })
  return {
    c() {
      div = element("div")
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c()
      }
      attr(div, "class", "fn__flex-1")
    },
    m(target, anchor) {
      insert(target, div, anchor)
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null)
      }
      current = true
    },
    p(ctx2, dirty) {
      if (dirty /*_, loadingMap, plugins, downloadPlugin, previewPlugin*/ & 53) {
        each_value = /*plugins*/ ctx2[0]
        let i
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i)
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty)
            transition_in(each_blocks[i], 1)
          } else {
            each_blocks[i] = create_each_block$1(child_ctx)
            each_blocks[i].c()
            transition_in(each_blocks[i], 1)
            each_blocks[i].m(div, null)
          }
        }
        group_outros()
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i)
        }
        check_outros()
      }
    },
    i(local) {
      if (current) return
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i])
      }
      current = true
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean)
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i])
      }
      current = false
    },
    d(detaching) {
      if (detaching) detach(div)
      destroy_each(each_blocks, detaching)
    },
  }
}
function create_if_block$1(ctx) {
  let div
  return {
    c() {
      div = element("div")
      div.textContent = `${_("loading")}`
    },
    m(target, anchor) {
      insert(target, div, anchor)
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(div)
    },
  }
}
function create_else_block_1(ctx) {
  let button
  let current
  function func_1() {
    return (
      /*func_1*/
      ctx[8](
        /*plugin*/
        ctx[11]
      )
    )
  }
  button = new Button({
    props: {
      onClick: func_1,
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx },
    },
  })
  return {
    c() {
      create_component(button.$$.fragment)
    },
    m(target, anchor) {
      mount_component(button, target, anchor)
      current = true
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      const button_changes = {}
      if (dirty /*plugins*/ & 1) button_changes.onClick = func_1
      if (dirty /*$$scope*/ & 16384) {
        button_changes.$$scope = { dirty, ctx }
      }
      button.$set(button_changes)
    },
    i(local) {
      if (current) return
      transition_in(button.$$.fragment, local)
      current = true
    },
    o(local) {
      transition_out(button.$$.fragment, local)
      current = false
    },
    d(detaching) {
      destroy_component(button, detaching)
    },
  }
}
function create_if_block_3(ctx) {
  let current_block_type_index
  let if_block
  let if_block_anchor
  let current
  const if_block_creators = [create_if_block_4, create_else_block$1]
  const if_blocks = []
  function select_block_type_2(ctx2, dirty) {
    if (
      /*plugin*/
      ctx2[11].needUpgrade
    )
      return 0
    return 1
  }
  current_block_type_index = select_block_type_2(ctx)
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx)
  return {
    c() {
      if_block.c()
      if_block_anchor = empty()
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor)
      insert(target, if_block_anchor, anchor)
      current = true
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index
      current_block_type_index = select_block_type_2(ctx2)
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty)
      } else {
        group_outros()
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null
        })
        check_outros()
        if_block = if_blocks[current_block_type_index]
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2)
          if_block.c()
        } else {
          if_block.p(ctx2, dirty)
        }
        transition_in(if_block, 1)
        if_block.m(if_block_anchor.parentNode, if_block_anchor)
      }
    },
    i(local) {
      if (current) return
      transition_in(if_block)
      current = true
    },
    o(local) {
      transition_out(if_block)
      current = false
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching)
      if (detaching) detach(if_block_anchor)
    },
  }
}
function create_if_block_2(ctx) {
  let button
  let current
  button = new Button({
    props: {
      disabled: true,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx },
    },
  })
  return {
    c() {
      create_component(button.$$.fragment)
    },
    m(target, anchor) {
      mount_component(button, target, anchor)
      current = true
    },
    p(ctx2, dirty) {
      const button_changes = {}
      if (dirty /*$$scope*/ & 16384) {
        button_changes.$$scope = { dirty, ctx: ctx2 }
      }
      button.$set(button_changes)
    },
    i(local) {
      if (current) return
      transition_in(button.$$.fragment, local)
      current = true
    },
    o(local) {
      transition_out(button.$$.fragment, local)
      current = false
    },
    d(detaching) {
      destroy_component(button, detaching)
    },
  }
}
function create_default_slot_3(ctx) {
  let t_value = _("download") + ""
  let t2
  return {
    c() {
      t2 = text(t_value)
    },
    m(target, anchor) {
      insert(target, t2, anchor)
    },
    p: noop,
    d(detaching) {
      if (detaching) detach(t2)
    },
  }
}
function create_else_block$1(ctx) {
  let button
  let current
  button = new Button({
    props: {
      disabled: true,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx },
    },
  })
  return {
    c() {
      create_component(button.$$.fragment)
    },
    m(target, anchor) {
      mount_component(button, target, anchor)
      current = true
    },
    p(ctx2, dirty) {
      const button_changes = {}
      if (dirty /*$$scope*/ & 16384) {
        button_changes.$$scope = { dirty, ctx: ctx2 }
      }
      button.$set(button_changes)
    },
    i(local) {
      if (current) return
      transition_in(button.$$.fragment, local)
      current = true
    },
    o(local) {
      transition_out(button.$$.fragment, local)
      current = false
    },
    d(detaching) {
      destroy_component(button, detaching)
    },
  }
}
function create_if_block_4(ctx) {
  let button
  let current
  function func() {
    return (
      /*func*/
      ctx[7](
        /*plugin*/
        ctx[11]
      )
    )
  }
  button = new Button({
    props: {
      onClick: func,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx },
    },
  })
  return {
    c() {
      create_component(button.$$.fragment)
    },
    m(target, anchor) {
      mount_component(button, target, anchor)
      current = true
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      const button_changes = {}
      if (dirty /*plugins*/ & 1) button_changes.onClick = func
      if (dirty /*$$scope*/ & 16384) {
        button_changes.$$scope = { dirty, ctx }
      }
      button.$set(button_changes)
    },
    i(local) {
      if (current) return
      transition_in(button.$$.fragment, local)
      current = true
    },
    o(local) {
      transition_out(button.$$.fragment, local)
      current = false
    },
    d(detaching) {
      destroy_component(button, detaching)
    },
  }
}
function create_default_slot_2(ctx) {
  let t_value = _("downloaded") + ""
  let t2
  return {
    c() {
      t2 = text(t_value)
    },
    m(target, anchor) {
      insert(target, t2, anchor)
    },
    p: noop,
    d(detaching) {
      if (detaching) detach(t2)
    },
  }
}
function create_default_slot_1(ctx) {
  let t_value = _("upgrade") + ""
  let t2
  return {
    c() {
      t2 = text(t_value)
    },
    m(target, anchor) {
      insert(target, t2, anchor)
    },
    p: noop,
    d(detaching) {
      if (detaching) detach(t2)
    },
  }
}
function create_default_slot(ctx) {
  let t_value = _("downloading") + ""
  let t2
  return {
    c() {
      t2 = text(t_value)
    },
    m(target, anchor) {
      insert(target, t2, anchor)
    },
    p: noop,
    d(detaching) {
      if (detaching) detach(t2)
    },
  }
}
function create_each_block$1(ctx) {
  let label
  let div1
  let a2
  let t0_value =
    /*plugin*/
    ctx[11].name + ""
  let t0
  let t1
  let t2_value =
    /*plugin*/
    ctx[11].version + ""
  let t2
  let t3
  let div0
  let t4_value =
    /*plugin*/
    (ctx[11].description || "") + ""
  let t4
  let t5
  let span
  let t6
  let current_block_type_index
  let if_block
  let t7
  let current
  let mounted
  let dispose
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[6](
        /*plugin*/
        ctx[11],
        ...args
      )
    )
  }
  const if_block_creators = [create_if_block_2, create_if_block_3, create_else_block_1]
  const if_blocks = []
  function select_block_type_1(ctx2, dirty) {
    if (
      /*loadingMap*/
      ctx2[2][
        /*plugin*/
        ctx2[11].key
      ]
    )
      return 0
    if (
      /*plugin*/
      ctx2[11].isExist
    )
      return 1
    return 2
  }
  current_block_type_index = select_block_type_1(ctx)
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx)
  return {
    c() {
      label = element("label")
      div1 = element("div")
      a2 = element("a")
      t0 = text(t0_value)
      t1 = space()
      t2 = text(t2_value)
      t3 = space()
      div0 = element("div")
      t4 = text(t4_value)
      t5 = space()
      span = element("span")
      t6 = space()
      if_block.c()
      t7 = space()
      attr(a2, "href", "javascript:void(0)")
      attr(a2, "class", "")
      attr(div0, "class", "b3-label__text")
      attr(div1, "class", "fn__flex-1")
      attr(span, "class", "fn__space")
      attr(label, "class", "fn__flex b3-label")
    },
    m(target, anchor) {
      insert(target, label, anchor)
      append(label, div1)
      append(div1, a2)
      append(a2, t0)
      append(div1, t1)
      append(div1, t2)
      append(div1, t3)
      append(div1, div0)
      append(div0, t4)
      append(label, t5)
      append(label, span)
      append(label, t6)
      if_blocks[current_block_type_index].m(label, null)
      append(label, t7)
      current = true
      if (!mounted) {
        dispose = listen(a2, "click", click_handler)
        mounted = true
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      if ((!current || dirty /*plugins*/ & 1) && t0_value !== (t0_value = /*plugin*/ ctx[11].name + ""))
        set_data(t0, t0_value)
      if ((!current || dirty /*plugins*/ & 1) && t2_value !== (t2_value = /*plugin*/ ctx[11].version + ""))
        set_data(t2, t2_value)
      if ((!current || dirty /*plugins*/ & 1) && t4_value !== (t4_value = /*plugin*/ (ctx[11].description || "") + ""))
        set_data(t4, t4_value)
      let previous_block_index = current_block_type_index
      current_block_type_index = select_block_type_1(ctx)
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty)
      } else {
        group_outros()
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null
        })
        check_outros()
        if_block = if_blocks[current_block_type_index]
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx)
          if_block.c()
        } else {
          if_block.p(ctx, dirty)
        }
        transition_in(if_block, 1)
        if_block.m(label, t7)
      }
    },
    i(local) {
      if (current) return
      transition_in(if_block)
      current = true
    },
    o(local) {
      transition_out(if_block)
      current = false
    },
    d(detaching) {
      if (detaching) detach(label)
      if_blocks[current_block_type_index].d()
      mounted = false
      dispose()
    },
  }
}
function create_fragment$2(ctx) {
  let div
  let current_block_type_index
  let if_block
  let current
  const if_block_creators = [create_if_block$1, create_if_block_1$1, create_else_block_2]
  const if_blocks = []
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[1]
    )
      return 0
    if (!(/*selectedPlugin*/ ctx2[3])) return 1
    return 2
  }
  current_block_type_index = select_block_type(ctx)
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx)
  return {
    c() {
      div = element("div")
      if_block.c()
      attr(div, "class", "b3-label fn__flex")
    },
    m(target, anchor) {
      insert(target, div, anchor)
      if_blocks[current_block_type_index].m(div, null)
      current = true
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index
      current_block_type_index = select_block_type(ctx2)
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty)
      } else {
        group_outros()
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null
        })
        check_outros()
        if_block = if_blocks[current_block_type_index]
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2)
          if_block.c()
        } else {
          if_block.p(ctx2, dirty)
        }
        transition_in(if_block, 1)
        if_block.m(div, null)
      }
    },
    i(local) {
      if (current) return
      transition_in(if_block)
      current = true
    },
    o(local) {
      transition_out(if_block)
      current = false
    },
    d(detaching) {
      if (detaching) detach(div)
      if_blocks[current_block_type_index].d()
    },
  }
}
function instance$2($$self, $$props, $$invalidate) {
  const store = container.get(TYPES.Store)
  let plugins = []
  let loading2 = true
  const loadingMap = {}
  onMount(async () => {
    $$invalidate(0, (plugins = await store.loadPlugins()))
    $$invalidate(1, (loading2 = false))
  })
  const downloadPlugin = async (key) => {
    if (loadingMap[key]) {
      return
    }
    try {
      $$invalidate(2, (loadingMap[key] = true), loadingMap)
      await store.downloadPlugin(key)
      const p = plugins.find((k2) => k2.key === key)
      if (p) {
        p.isExist = true
        p.needUpgrade = false
      }
    } finally {
      $$invalidate(2, (loadingMap[key] = false), loadingMap)
    }
  }
  let selectedPlugin = null
  const previewPlugin = (event, plugin2) => {
    $$invalidate(3, (selectedPlugin = plugin2))
    event.stopPropagation()
    event.preventDefault()
  }
  const click_handler = (plugin2, event) => previewPlugin(event, plugin2)
  const func = (plugin2) => downloadPlugin(plugin2.key)
  const func_1 = (plugin2) => downloadPlugin(plugin2.key)
  const goback_handler = () => $$invalidate(3, (selectedPlugin = null))
  return [
    plugins,
    loading2,
    loadingMap,
    selectedPlugin,
    downloadPlugin,
    previewPlugin,
    click_handler,
    func,
    func_1,
    goback_handler,
  ]
}
class Setting_store extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {})
  }
}
function create_fragment$1(ctx) {
  let div
  return {
    c() {
      div = element("div")
      attr(div, "id", "setting-custom-render")
    },
    m(target, anchor) {
      insert(target, div, anchor)
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(div)
    },
  }
}
function instance$1($$self, $$props, $$invalidate) {
  let root
  let { render: render2 } = $$props
  onMount(() => {
    $$invalidate(1, (root = document.createElement("div")))
    document.getElementById("setting-custom-render").appendChild(root)
    render2(root)
  })
  $$self.$$set = ($$props2) => {
    if ("render" in $$props2) $$invalidate(0, (render2 = $$props2.render))
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty /*root, render*/ & 3) {
      {
        const el = document.getElementById("setting-custom-render")
        if (el) {
          if (root) {
            root.remove()
          }
          $$invalidate(1, (root = document.createElement("div")))
          document.getElementById("setting-custom-render").appendChild(root)
          render2(root)
        }
      }
    }
  }
  return [render2, root]
}
class Setting_custom extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { render: 0 })
  }
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice()
  child_ctx[13] = list[i]
  return child_ctx
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice()
  child_ctx[13] = list[i]
  return child_ctx
}
function create_each_block_1(ctx) {
  let li
  let span
  let t_value =
    /*menu*/
    ctx[13].name + ""
  let t2
  let li_class_value
  let mounted
  let dispose
  function click_handler() {
    return (
      /*click_handler*/
      ctx[6](
        /*menu*/
        ctx[13]
      )
    )
  }
  return {
    c() {
      li = element("li")
      span = element("span")
      t2 = text(t_value)
      attr(span, "class", "b3-list-item__text")
      attr(
        li,
        "data-name",
        /*menu*/
        ctx[13].key
      )
      attr(
        li,
        "class",
        (li_class_value =
          /*currentSelection*/
          ctx[0].key /*menu*/ === ctx[13].key
            ? "b3-list-item--focus b3-list-item b3-list-item--big"
            : "b3-list-item b3-list-item--big")
      )
    },
    m(target, anchor) {
      insert(target, li, anchor)
      append(li, span)
      append(span, t2)
      if (!mounted) {
        dispose = listen(li, "click", click_handler)
        mounted = true
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      if (
        dirty /*currentSelection*/ & 1 &&
        li_class_value !==
          (li_class_value =
            /*currentSelection*/
            ctx[0].key /*menu*/ === ctx[13].key
              ? "b3-list-item--focus b3-list-item b3-list-item--big"
              : "b3-list-item b3-list-item--big")
      ) {
        attr(li, "class", li_class_value)
      }
    },
    d(detaching) {
      if (detaching) detach(li)
      mounted = false
      dispose()
    },
  }
}
function create_if_block_1(ctx) {
  let hr
  return {
    c() {
      hr = element("hr")
      set_style(hr, "margin", "12px")
    },
    m(target, anchor) {
      insert(target, hr, anchor)
    },
    d(detaching) {
      if (detaching) detach(hr)
    },
  }
}
function create_each_block(ctx) {
  let li
  let span
  let t0_value =
    /*menu*/
    ctx[13].name + ""
  let t0
  let t1
  let li_data_name_value
  let li_class_value
  let mounted
  let dispose
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[7](
        /*menu*/
        ctx[13]
      )
    )
  }
  return {
    c() {
      li = element("li")
      span = element("span")
      t0 = text(t0_value)
      t1 = space()
      attr(span, "class", "b3-list-item__text")
      attr(li, "data-name", (li_data_name_value = /*menu*/ ctx[13].key))
      attr(
        li,
        "class",
        (li_class_value =
          /*currentSelection*/
          ctx[0].key /*menu*/ === ctx[13].key
            ? "b3-list-item--focus b3-list-item b3-list-item--big"
            : "b3-list-item b3-list-item--big")
      )
    },
    m(target, anchor) {
      insert(target, li, anchor)
      append(li, span)
      append(span, t0)
      append(li, t1)
      if (!mounted) {
        dispose = listen(li, "click", click_handler_1)
        mounted = true
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx
      if (dirty /*thirdMenus*/ & 2 && t0_value !== (t0_value = /*menu*/ ctx[13].name + "")) set_data(t0, t0_value)
      if (dirty /*thirdMenus*/ & 2 && li_data_name_value !== (li_data_name_value = /*menu*/ ctx[13].key)) {
        attr(li, "data-name", li_data_name_value)
      }
      if (
        dirty /*currentSelection, thirdMenus*/ & 3 &&
        li_class_value !==
          (li_class_value =
            /*currentSelection*/
            ctx[0].key /*menu*/ === ctx[13].key
              ? "b3-list-item--focus b3-list-item b3-list-item--big"
              : "b3-list-item b3-list-item--big")
      ) {
        attr(li, "class", li_class_value)
      }
    },
    d(detaching) {
      if (detaching) detach(li)
      mounted = false
      dispose()
    },
  }
}
function create_else_block(ctx) {
  let settingcustom
  let current
  settingcustom = new Setting_custom({
    props: {
      render:
        /*currentSelection*/
        ctx[0].render,
    },
  })
  return {
    c() {
      create_component(settingcustom.$$.fragment)
    },
    m(target, anchor) {
      mount_component(settingcustom, target, anchor)
      current = true
    },
    p(ctx2, dirty) {
      const settingcustom_changes = {}
      if (dirty /*currentSelection*/ & 1) settingcustom_changes.render = /*currentSelection*/ ctx2[0].render
      settingcustom.$set(settingcustom_changes)
    },
    i(local) {
      if (current) return
      transition_in(settingcustom.$$.fragment, local)
      current = true
    },
    o(local) {
      transition_out(settingcustom.$$.fragment, local)
      current = false
    },
    d(detaching) {
      destroy_component(settingcustom, detaching)
    },
  }
}
function create_if_block(ctx) {
  let switch_instance
  let switch_instance_anchor
  let current
  var switch_value =
    /*currentSelection*/
    ctx[0].component
  function switch_props(ctx2) {
    return {}
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props())
    switch_instance.$on(
      "update",
      /*update_handler*/
      ctx[8]
    )
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment)
      switch_instance_anchor = empty()
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor)
      insert(target, switch_instance_anchor, anchor)
      current = true
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = /*currentSelection*/ ctx2[0].component)) {
        if (switch_instance) {
          group_outros()
          const old_component = switch_instance
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1)
          })
          check_outros()
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props())
          switch_instance.$on(
            "update",
            /*update_handler*/
            ctx2[8]
          )
          create_component(switch_instance.$$.fragment)
          transition_in(switch_instance.$$.fragment, 1)
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor)
        } else {
          switch_instance = null
        }
      }
    },
    i(local) {
      if (current) return
      if (switch_instance) transition_in(switch_instance.$$.fragment, local)
      current = true
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local)
      current = false
    },
    d(detaching) {
      if (detaching) detach(switch_instance_anchor)
      if (switch_instance) destroy_component(switch_instance, detaching)
    },
  }
}
function create_fragment(ctx) {
  let div2
  let div1
  let ul
  let t0
  let t1
  let t2
  let div0
  let current_block_type_index
  let if_block1
  let div0_data_name_value
  let current
  let each_value_1 =
    /*menus*/
    ctx[2]
  let each_blocks_1 = []
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i))
  }
  let if_block0 =
    /*thirdMenus*/
    ctx[1].length > 0 && create_if_block_1()
  let each_value =
    /*thirdMenus*/
    ctx[1]
  let each_blocks = []
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i))
  }
  const if_block_creators = [create_if_block, create_else_block]
  const if_blocks = []
  function select_block_type(ctx2, dirty) {
    if (
      /*currentSelection*/
      ctx2[0].type === "internal"
    )
      return 0
    return 1
  }
  current_block_type_index = select_block_type(ctx)
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx)
  return {
    c() {
      div2 = element("div")
      div1 = element("div")
      ul = element("ul")
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c()
      }
      t0 = space()
      if (if_block0) if_block0.c()
      t1 = space()
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c()
      }
      t2 = space()
      div0 = element("div")
      if_block1.c()
      attr(ul, "class", "b3-tab-bar b3-list b3-list--background")
      set_style(ul, "height", "unset", 1)
      attr(div0, "class", "config__tab-container")
      set_style(div0, "height", "unset", 1)
      attr(div0, "data-name", (div0_data_name_value = /*currentSelection*/ ctx[0].key))
      attr(div1, "class", "fn__flex-1 fn__flex config__panel")
      attr(div2, "class", "fn__flex-column")
      set_style(div2, "border-radius", "4px")
      set_style(div2, "overflow", "auto")
      set_style(div2, "position", "relative")
      set_style(div2, "height", "80vh")
    },
    m(target, anchor) {
      insert(target, div2, anchor)
      append(div2, div1)
      append(div1, ul)
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(ul, null)
      }
      append(ul, t0)
      if (if_block0) if_block0.m(ul, null)
      append(ul, t1)
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null)
      }
      append(div1, t2)
      append(div1, div0)
      if_blocks[current_block_type_index].m(div0, null)
      current = true
    },
    p(ctx2, [dirty]) {
      if (dirty /*menus, currentSelection, setCurrentSelection*/ & 13) {
        each_value_1 = /*menus*/ ctx2[2]
        let i
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i)
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty)
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx)
            each_blocks_1[i].c()
            each_blocks_1[i].m(ul, t0)
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1)
        }
        each_blocks_1.length = each_value_1.length
      }
      if (
        /*thirdMenus*/
        ctx2[1].length > 0
      ) {
        if (if_block0);
        else {
          if_block0 = create_if_block_1()
          if_block0.c()
          if_block0.m(ul, t1)
        }
      } else if (if_block0) {
        if_block0.d(1)
        if_block0 = null
      }
      if (dirty /*thirdMenus, currentSelection, setCurrentSelection*/ & 11) {
        each_value = /*thirdMenus*/ ctx2[1]
        let i
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i)
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty)
          } else {
            each_blocks[i] = create_each_block(child_ctx)
            each_blocks[i].c()
            each_blocks[i].m(ul, null)
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1)
        }
        each_blocks.length = each_value.length
      }
      let previous_block_index = current_block_type_index
      current_block_type_index = select_block_type(ctx2)
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty)
      } else {
        group_outros()
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null
        })
        check_outros()
        if_block1 = if_blocks[current_block_type_index]
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2)
          if_block1.c()
        } else {
          if_block1.p(ctx2, dirty)
        }
        transition_in(if_block1, 1)
        if_block1.m(div0, null)
      }
      if (
        !current ||
        (dirty /*currentSelection*/ & 1 &&
          div0_data_name_value !== (div0_data_name_value = /*currentSelection*/ ctx2[0].key))
      ) {
        attr(div0, "data-name", div0_data_name_value)
      }
    },
    i(local) {
      if (current) return
      transition_in(if_block1)
      current = true
    },
    o(local) {
      transition_out(if_block1)
      current = false
    },
    d(detaching) {
      if (detaching) detach(div2)
      destroy_each(each_blocks_1, detaching)
      if (if_block0) if_block0.d()
      destroy_each(each_blocks, detaching)
      if_blocks[current_block_type_index].d()
    },
  }
}
function instance($$self, $$props, $$invalidate) {
  let thirdMenus
  const menus = [
    {
      key: "common",
      name: _("menu_common"),
      type: "internal",
      component: Setting_common,
    },
    {
      key: "list",
      name: _("menu_list"),
      type: "internal",
      component: Setting_list,
    },
    {
      key: "store",
      name: _("menu_store"),
      type: "internal",
      component: Setting_store,
    },
  ]
  const sm = container.get(TYPES.SettingManager)
  const sm1 = container.get(TYPES.StorageManager)
  const plugins = sm1.getThirdPartyPlugins()
  let settingRenders = sm.getSettingRenders()
  const getName = (key) => {
    var _a2
    return (_a2 = plugins.find((p) => p.key === key)) == null ? void 0 : _a2.name
  }
  const setCurrentSelection = (menu) => $$invalidate(0, (currentSelection = menu))
  const updateMenus = () => {
    $$invalidate(5, (settingRenders = [...sm.getSettingRenders()]))
  }
  let currentSelection = menus[0]
  const click_handler = (menu) => setCurrentSelection(menu)
  const click_handler_1 = (menu) => setCurrentSelection(menu)
  const update_handler = () => updateMenus()
  $$self.$$.update = () => {
    if ($$self.$$.dirty /*settingRenders*/ & 32) {
      $$invalidate(
        1,
        (thirdMenus = settingRenders.map((s) => {
          return {
            key: s.key,
            name: getName(s.key),
            component: Setting_common,
            type: "custom",
            render: s.value,
          }
        }))
      )
    }
  }
  return [
    currentSelection,
    thirdMenus,
    menus,
    setCurrentSelection,
    updateMenus,
    settingRenders,
    click_handler,
    click_handler_1,
    update_handler,
  ]
}
class Setting extends SvelteComponent {
  constructor(options) {
    super()
    init(this, options, instance, create_fragment, safe_not_equal, {})
  }
}
class InternalSettingPlugin extends Plugin {
  constructor() {
    super()
    this.svg =
      '<svg t="1679703027227" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="24715" width="200" height="200"><path d="M512 1023.99984a75.519988 75.519988 0 0 1-53.679992-22.207997L22.368077 565.455912c-29.487995-29.679995-29.487995-77.919988-0.064-107.519984l159.711975-159.839975a31.951995 31.951995 0 0 1 54.047991 28.207996 131.10398 131.10398 0 0 0-2.368 23.135996c0 69.951989 56.895991 128.11198 126.847981 128.11198 69.999989 0 121.119981-58.159991 121.119981-128.11198 0-70.079989-51.119992-127.07198-121.119981-127.07198a130.87998 130.87998 0 0 0-23.007997 2.384 31.759995 31.759995 0 0 1-33.919994-16.671998 31.999995 31.999995 0 0 1 5.743999-37.423994l148.895976-149.103976c28.847995-28.719996 78.719988-28.655996 107.423984-0.064l109.023983 109.183983C697.439971 59.887991 763.871961 8.479999 842.015948 8.479999c96.911985 0 175.743973 78.959988 175.743973 175.967972 0 78.239988-51.295992 144.719977-122.063981 167.471974l105.887984 105.951983a76.351988 76.351988 0 0 1 0.031999 107.551984L565.743992 1001.775843A75.759988 75.759988 0 0 1 512 1023.99984z" fill="" p-id="24716"></path></svg>'
  }
  onload() {
    const internalSettingButton = document.createElement("button")
    internalSettingButton.setAttribute("aria-label", _("plugin_system"))
    internalSettingButton.classList.add("toolbar__item", "b3-tooltips", "b3-tooltips__sw")
    internalSettingButton.insertAdjacentHTML("beforeend", this.svg)
    internalSettingButton.addEventListener("click", (event) => {
      new Menu("internalSettingButton")
        .addItem(
          new MenuItem({
            label: _("plugin_system_setting"),
            icon: "iconEdit",
            click: () => showSettingDialog(),
          })
        )
        .addSeparator()
        .addItem(
          new MenuItem({
            label: _("reload"),
            icon: "iconRefresh",
            click: () => window.location.reload(),
          })
        )
        .showAtMouseEvent(event)
      event.stopPropagation()
    })
    addToolbarRight(internalSettingButton)
    this.registerCommand({
      command: "Show plugin system conifg",
      description: _("show_plugin_system_config"),
      shortcut: "command+option+p",
      callback: () => showSettingDialog(),
    })
    this.registerCommand({
      command: "Reload Window",
      description: _("reload_window"),
      callback: () => window.location.reload(),
    })
  }
}
function showSettingDialog() {
  new Dialog({
    title: _("plugin_system_setting"),
    content: '<div id="plugin-settings"></div>',
    width: "90vw",
    height: "80vh",
  })
  setTimeout(() => {
    new Setting({
      target: document.getElementById("plugin-settings"),
    })
  })
}
const internalPlugins = [
  { key: "setting", name: "setting", plugin: InternalSettingPlugin, enabled: true, hidden: true, version: "1.0.0" },
  {
    key: "commandPanel",
    name: "commandPanel",
    plugin: CommandPanelPlugin,
    enabled: true,
    hidden: true,
    version: "1.0.0",
  },
]
function isHighSurrogate$1(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319
}
function isLowSurrogate$1(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343
}
var truncate$2 = function truncate2(getLength2, string, byteLength) {
  if (typeof string !== "string") {
    throw new Error("Input must be string")
  }
  var charLength = string.length
  var curByteLength = 0
  var codePoint
  var segment
  for (var i = 0; i < charLength; i += 1) {
    codePoint = string.charCodeAt(i)
    segment = string[i]
    if (isHighSurrogate$1(codePoint) && isLowSurrogate$1(string.charCodeAt(i + 1))) {
      i += 1
      segment += string[i]
    }
    curByteLength += getLength2(segment)
    if (curByteLength === byteLength) {
      return string.slice(0, i + 1)
    } else if (curByteLength > byteLength) {
      return string.slice(0, i - segment.length + 1)
    }
  }
  return string
}
function isHighSurrogate(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319
}
function isLowSurrogate(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343
}
var browser$1 = function getByteLength(string) {
  if (typeof string !== "string") {
    throw new Error("Input must be string")
  }
  var charLength = string.length
  var byteLength = 0
  var codePoint = null
  var prevCodePoint = null
  for (var i = 0; i < charLength; i++) {
    codePoint = string.charCodeAt(i)
    if (isLowSurrogate(codePoint)) {
      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
        byteLength += 1
      } else {
        byteLength += 3
      }
    } else if (codePoint <= 127) {
      byteLength += 1
    } else if (codePoint >= 128 && codePoint <= 2047) {
      byteLength += 2
    } else if (codePoint >= 2048 && codePoint <= 65535) {
      byteLength += 3
    }
    prevCodePoint = codePoint
  }
  return byteLength
}
var truncate$1 = truncate$2
var getLength = browser$1
var browser = truncate$1.bind(null, getLength)
var truncate = browser
var illegalRe = /[\/\?<>\\:\*\|"]/g
var controlRe = /[\x00-\x1f\x80-\x9f]/g
var reservedRe = /^\.+$/
var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i
var windowsTrailingRe = /[\. ]+$/
function sanitize(input, replacement) {
  if (typeof input !== "string") {
    throw new Error("Input must be string")
  }
  var sanitized = input
    .replace(illegalRe, replacement)
    .replace(controlRe, replacement)
    .replace(reservedRe, replacement)
    .replace(windowsReservedRe, replacement)
    .replace(windowsTrailingRe, replacement)
  return truncate(sanitized, 255)
}
var sanitizeFilename = function (input, options) {
  var replacement = (options && options.replacement) || ""
  var output = sanitize(input, replacement)
  if (replacement === "") {
    return output
  }
  return sanitize(output, "")
}
var __defProp$8 = Object.defineProperty
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor
var __decorateClass$8 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$8(target, key, result)
  return result
}
var __decorateParam$5 = (index, decorator) => (target, key) => decorator(target, key, index)
let StorageManager = class {
  constructor(pluginFileManager) {
    this.config = Object.assign({}, defaultConfig)
    this.pluginFileManager = pluginFileManager
  }
  get(key) {
    return this.config[key]
  }
  async set(key, val) {
    this.config[key] = val
    return setStorageVal(key, val)
  }
  async initStorage() {
    const all2 = await getLocalStorage()
    const configKeys = Object.keys(defaultConfig)
    for (const key of configKeys) {
      if (all2[key] !== void 0) {
        this.config[key] = all2[key]
      } else {
        await setStorageVal(key, defaultConfig[key])
      }
    }
    this.thirdPartyPlugins = await this.pluginFileManager.getAllPlugins()
    this.internalPlugins = [...internalPlugins]
    this.init3rdPartyEnabled()
    this.initInternalEnabled()
    await this.savePluginsEnabled()
    return this
  }
  init3rdPartyEnabled() {
    const enabledPlugins = this.get(PLUGIN_SYSTEM_THIRD_PARTY_PLUGIN)
    for (const ep of enabledPlugins) {
      for (const p of this.thirdPartyPlugins) {
        if (p.key === ep.key) {
          p.enabled = ep.enabled || false
          break
        }
      }
    }
  }
  initInternalEnabled() {
    const enabledPlugins = this.get(PLUGIN_SYSTEM_PLUGIN)
    for (const ep of enabledPlugins) {
      for (const p of this.internalPlugins) {
        if (p.key === ep.key) {
          p.enabled = ep.enabled || false
          break
        }
      }
    }
  }
  getPlugins() {
    return [...this.internalPlugins, ...this.thirdPartyPlugins]
  }
  getInternalPlugins() {
    return this.internalPlugins
  }
  getThirdPartyPlugins() {
    return this.thirdPartyPlugins
  }
  getPluginByKey(key) {
    return this.getPlugins().find((p) => p.key === key)
  }
  async setPluginEnabled(key, enabled) {
    for (const p of [...this.internalPlugins, ...this.thirdPartyPlugins]) {
      if (p.key === key) {
        p.enabled = enabled
        break
      }
    }
    await this.savePluginsEnabled()
  }
  async setSafeModeEnabled(enabled) {
    return this.set(PLUGIN_SYSTEM_SAFE_MODE_ENABLED, enabled)
  }
  async savePluginsEnabled() {
    await this.set(
      PLUGIN_SYSTEM_PLUGIN,
      this.internalPlugins.map((p) => ({ key: p.key, enabled: p.enabled }))
    )
    return this.set(
      PLUGIN_SYSTEM_THIRD_PARTY_PLUGIN,
      this.thirdPartyPlugins.map((p) => ({ key: p.key, enabled: p.enabled }))
    )
  }
  async setPluginStorage(pluginKey, filename, content) {
    try {
      if (this.isFileNameIllegal(filename)) {
        showErrorMessage(`插件${pluginKey}存储文件名不合法`)
        return
      }
      await this.addPluginStorageFolderIfNotExist(pluginKey)
      await FileClient.getInstanceApi().fileApi.putFile(`/data/plugins/.storage/${pluginKey}/${filename}`, content)
    } catch (e) {
      showErrorMessage(`插件${pluginKey}存储保存失败`, 2e3)
    }
  }
  async getPluginStorage(pluginKey, filename) {
    try {
      return await FileClient.getInstanceApi().fileApi.getFile(`/data/plugins/.storage/${pluginKey}/${filename}`)
    } catch (e) {
      showErrorMessage(`插件${pluginKey}存储保存失败`, 2e3)
      return null
    }
  }
  async uninstallPlugin(pluginKey) {
    await FileClient.getInstanceApi().fileApi.removeFile(`/data/plugins/${pluginKey}`)
    await FileClient.getInstanceApi().fileApi.removeFile(`/data/plugins//.storage/${pluginKey}`)
  }
  async addPluginStorageFolderIfNotExist(pluginKey) {
    const folder = `/data/plugins/.storage/${pluginKey}`
    await FileClient.getInstanceApi().fileApi.putFile(folder, null, true)
  }
  isFileNameIllegal(filename) {
    return filename !== sanitizeFilename(filename)
  }
}
StorageManager = __decorateClass$8(
  [injectable(), __decorateParam$5(0, inject(TYPES.PluginFileManager))],
  StorageManager
)
var __defProp$7 = Object.defineProperty
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor
var __decorateClass$7 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$7(target, key, result)
  return result
}
var __decorateParam$4 = (index, decorator) => (target, key) => decorator(target, key, index)
let PluginSystem = class {
  constructor(pluginLoader, pslm, storageManager, commandManager, store) {
    this.pluginLoader = pluginLoader
    this.pslm = pslm
    this.storageManager = storageManager
    this.commandManager = commandManager
    this.store = store
    this.version = VERSION$1
  }
  async init() {
    await this.storageManager.initStorage()
    const internalPlugins2 = this.storageManager.getInternalPlugins()
    this.pluginLoader.loadEnabledPlugins(internalPlugins2)
    log(`Loading internal enabled plugins: ${internalPlugins2.map((p) => p.key).join(",")}`)
    const securityModeEnabled = this.storageManager.get(PLUGIN_SYSTEM_SAFE_MODE_ENABLED)
    if (!securityModeEnabled) {
      const plugins = this.storageManager.getThirdPartyPlugins()
      log(`Loading 3rd party enabled plugins: ${plugins.map((p) => p.key).join(",")}`)
      this.pluginLoader.loadEnabledPlugins(plugins)
    }
    this.pslm.localCacheInit()
    return this
  }
  async loadPlugin(key) {
    this.storageManager.setPluginEnabled(key, true)
    const plugin2 = this.storageManager.getPluginByKey(key)
    this.pluginLoader.loadPlugin(plugin2)
  }
  async unloadPlugin(key) {
    this.storageManager.setPluginEnabled(key, false)
    this.pluginLoader.unloadPlugin(key)
  }
  async turnOffSafeMode() {
    this.storageManager.setSafeModeEnabled(false)
    const plugins = this.storageManager.getThirdPartyPlugins()
    return this.pluginLoader.loadEnabledPlugins(plugins)
  }
  async turnOnSafeMode() {
    this.storageManager.setSafeModeEnabled(true)
    const plugins = this.storageManager.getThirdPartyPlugins()
    return this.pluginLoader.unloadThirdPartyPlugins(plugins)
  }
}
PluginSystem = __decorateClass$7(
  [
    injectable(),
    __decorateParam$4(0, inject(TYPES.PluginLoader)),
    __decorateParam$4(1, inject(TYPES.SystemManager)),
    __decorateParam$4(2, inject(TYPES.StorageManager)),
    __decorateParam$4(3, inject(TYPES.CommandManager)),
    __decorateParam$4(4, inject(TYPES.Store)),
  ],
  PluginSystem
)
const migrate = async () => {
  const SNIPPET_NAME = "plugin-system-bazzar"
  const content = `(async () => {
        window.pluginSystemSource = 'bazzar';
        const response = await fetch('/api/file/getFile', {
            method: 'POST',
            mode: 'cors',
            cache: 'no-cache',
            credentials: 'same-origin',
            headers: {
                'Content-Type': 'application/json',
            },
            redirect: 'follow',
            referrerPolicy: 'no-referrer',
            body: JSON.stringify({ path: '/data/widgets/插件系统/plugin.js' }),
        });
        const js = await response.text();
        eval(js);
    })()`
  const request2 = async (url2, body) => {
    const response = await fetch(url2, {
      method: "POST",
      mode: "cors",
      cache: "no-cache",
      credentials: "same-origin",
      headers: {
        "Content-Type": "application/json",
      },
      redirect: "follow",
      referrerPolicy: "no-referrer",
      body: JSON.stringify(body),
    })
    return response.json()
  }
  const res = await request2("/api/snippet/getSnippet", { enabled: 2, type: "all" })
  const snippets = res.data.snippets
  for (const snippet of snippets) {
    if (snippet.type !== "js") {
      continue
    }
    if (snippet.content.indexOf("https://gitee.com/zuoez02/siyuan-plugin-system/raw/main/main.js") !== -1) {
      snippet.enabled = false
    }
    if (snippet.name === SNIPPET_NAME) {
      snippet.enabled = true
      snippet.content = content
      await request2("/api/snippet/setSnippet", { snippets })
      return
    }
  }
  snippets.splice(0, 0, {
    id: "20230324100959-plugind",
    name: SNIPPET_NAME,
    type: "js",
    enabled: true,
    content,
  })
  await request2("/api/snippet/setSnippet", { snippets })
  setTimeout(() => window.parent.location.reload(), 1e3)
}
var __defProp$6 = Object.defineProperty
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$6(target, key, result)
  return result
}
var __decorateParam$3 = (index, decorator) => (target, key) => decorator(target, key, index)
const pluginScriptPosition = PLUGIN_SYS_ABS_PATH
let SystemManager = class {
  constructor(storageManager) {
    this.storageMangager = storageManager
  }
  async saveToLocal(p, content) {
    FileClient.getInstanceApi().fileApi.putFile(p, content)
  }
  async localCacheInit() {
    try {
      const plugin2 = FileClient.getInstanceApi().fileApi.getFile(pluginScriptPosition)
      if (plugin2 !== null) {
        this.delayAutoUpgrade()
      }
      return
    } catch (e) {
      log("Plugin system not found")
    }
    const script2 = window.siyuanPluginScript
    if (!script2) {
      return
    }
    await this.saveToLocal(pluginScriptPosition, script2)
    this.delayAutoUpgrade()
  }
  delayAutoUpgrade() {
    return false
  }
  async tryUpgrade() {
    log("Plugin bundled with zhi theme, upgrade skip")
    return
    if (window.pluginSystemSource === "bazzar") {
      log("Plugin installed from bazzar version, upgrade skip")
      this.compareWidgetVersion()
      return
    }
    log("Try getting online version")
    const onlineVersion = await this.getOnlineVersion()
    if (onlineVersion !== VERSION$1) {
      showInfoMessage(`插件系统获取到最新版本 ${onlineVersion}，即将自动更新`)
      log("Online Version: " + onlineVersion + ", local version: " + VERSION$1)
      log("Downloading new version of Plugin System")
      this.upgrade()
    } else {
      log("Version is " + VERSION$1 + ", OK")
    }
  }
  async getOnlineVersion() {
    return fetch(VERSION_URL, { cache: "no-cache" }).then((res) => res.text())
  }
  async upgrade() {
    const script2 = await fetch(SCRIPT_URL, { cache: "no-cache" }).then((res) => res.text())
    if (!script2) {
      return
    }
    migrate()
    showInfoMessage("插件系统升级中，即将自动重载...")
    await this.saveToLocal(pluginScriptPosition, script2)
    log("Plugin system upgraded, reloading...")
    setTimeout(() => reloadWindow(), 3e3)
  }
  async compareWidgetVersion() {
    const res = await getBazzarWidget()
    const packages = res.packages
    const ps = packages.find((p) => p.name === "插件系统")
    if (!ps) {
      return
    }
    const latestVersion = ps.version
    const result = new semver.SemVer(VERSION$1).compare(latestVersion)
    if (result < 0) {
      new Notification({ message: _("new_version_widget"), type: "info" }).show()
    }
  }
}
SystemManager = __decorateClass$6([injectable(), __decorateParam$3(0, inject(TYPES.StorageManager))], SystemManager)
var __defProp$5 = Object.defineProperty
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$5(target, key, result)
  return result
}
var __decorateParam$2 = (index, decorator) => (target, key) => decorator(target, key, index)
let components
let PluginLoader = class {
  constructor(pluginFileManager) {
    this.pluginFileManager = pluginFileManager
    this.loadedPlugins = /* @__PURE__ */ new Map()
  }
  async loadEnabledPlugins(plugins) {
    if (!plugins || !plugins.length) {
      return
    }
    for (const p of plugins) {
      if (!p.enabled) {
        continue
      }
      await this.loadPlugin(p)
    }
  }
  async loadAllInternalPlugins() {
    internalPlugins.forEach(async (p) => {
      const plug2 = new p.plugin()
      if (!(plug2 instanceof Plugin)) {
        throw new Error(`Failed to load plugin ${p.name}`)
      }
      log(`Load internal plugin: ${p.key}(${p.name})`)
      this.addAdditionalMethod(plug2, p.key, p.name)
      await plug2.onload()
      this.loadedPlugins.set(p.key, plug2)
    })
  }
  async loadAllLocalPlugins() {
    const plugins = await this.pluginFileManager.getAllPlugins()
    if (!plugins) {
      return
    }
    for (const p of plugins) {
      await this.loadPlugin(p)
    }
  }
  async loadPlugin(plugin) {
    if (!components) {
      this.generateRequiredModules()
    }
    if (!plugin.enabled || (!plugin.plugin && !plugin.script)) {
      return
    }
    if (plugin.plugin) {
      const plug2 = new plugin.plugin()
      if (!(plug2 instanceof Plugin)) {
        throw new Error(`Failed to load plugin ${plugin.name}`)
      }
      log(`Load internal plugin: ${plugin.key}(${plugin.name})`)
      this.addAdditionalMethod(plug2, plugin.key, plugin.name)
      await plug2.onload()
      this.loadedPlugins.set(plugin.key, plug2)
      return
    }
    const exports = {}
    const module = { exports }
    function run(script, name) {
      return eval(
        "(function anonymous(require,module,exports){".concat(script, "\n})\n//# sourceURL=").concat(name, "\n")
      )
    }
    const __require = (name2) => {
      if (components[name2]) {
        return components[name2]
      }
      throw new Error(`module ${name2} not found`)
    }
    const pluginName = plugin.key
    try {
      run(plugin.script, plugin.key)(__require, module, exports)
    } catch (e) {
      error("Error plugin:" + plugin.key + " ->", e)
      return
    }
    let pluginConstructor
    if (!(pluginConstructor = (module.exports || exports).default || module.exports)) {
      throw new Error(`Failed to load plugin ${pluginName}. No exports detected.`)
    }
    const plug = new pluginConstructor()
    if (!(plug instanceof Plugin)) {
      throw new Error(`Failed to load plugin ${pluginName}`)
    }
    this.addAdditionalMethod(plug, plugin.key, pluginName)
    try {
      await plug.onload()
      this.loadedPlugins.set(plugin.key, plug)
    } catch (e) {
      error("Error plugin:" + plugin.key + " ->", e)
    }
  }
  async unloadPlugin(key) {
    const plugin2 = this.loadedPlugins.get(key)
    if (!plugin2) {
      return
    }
    plugin2.onunload()
    container.get(TYPES.CommandManager).unregisterCommandByPlugin(key)
    container.get(TYPES.SettingManager).unregisterSetting(key)
    this.loadedPlugins.delete(key)
  }
  async unloadThirdPartyPlugins(plugins) {
    const keys = plugins.filter((p) => p.enabled).map((p) => p.key)
    for (const k2 of keys) {
      log(`unload third party plugin: ${k2}`)
      await this.unloadPlugin(k2)
    }
  }
  async loadThirdPartyEnabledPlugins(plugins) {
    return this.loadEnabledPlugins(plugins)
  }
  generateRequiredModules() {
    components = {
      siyuan: api,
      axios: axios$1,
    }
  }
  addAdditionalMethod(plugin2, pluginKey, pluginName2) {
    plugin2.registerCommand = (command) => {
      const cm = container.get(TYPES.CommandManager)
      cm.registerCommand({
        ...command,
        plugin: pluginKey,
        pluginName: pluginName2,
      })
    }
    const sm = container.get(TYPES.StorageManager)
    plugin2.writeStorage = async (filename, content) => {
      return await sm.setPluginStorage(pluginKey, filename, content)
    }
    plugin2.loadStorage = async (filename) => {
      return await sm.getPluginStorage(pluginKey, filename)
    }
    plugin2.registerSettingRender = (settingRender) => {
      const cm = container.get(TYPES.SettingManager)
      cm.registerSetting(pluginKey, settingRender)
    }
  }
}
PluginLoader = __decorateClass$5([injectable(), __decorateParam$2(0, inject(TYPES.PluginFileManager))], PluginLoader)
var __defProp$4 = Object.defineProperty
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$4(target, key, result)
  return result
}
let PluginFileManager = class {
  async scanPlugins(pluginFolder) {
    const res = await FileClient.getInstanceApi().fileApi.readDir(pluginFolder)
    if (!res) {
      return []
    }
    const files = res
    const result = []
    for (const f of files) {
      if (f.name.startsWith(".")) {
        continue
      }
      if (
        f.isDir &&
        (await isExists(`/data/plugins/${f.name}/manifest.json`)) &&
        (await isExists(`/data/plugins/${f.name}/main.js`))
      ) {
        result.push(`/data/plugins/${f.name}`)
      }
    }
    return result
  }
  async getFileContent(f) {
    const res = await FileClient.getInstanceApi().fileApi.getFile(f)
    return res || ""
  }
  async getManifest(manifest) {
    const content = await this.getFileContent(manifest)
    try {
      return JSON.parse(content)
    } catch (e) {
      error("loading manifest: " + manifest, e)
      return null
    }
  }
  async getScript(script2) {
    return await this.getFileContent(script2)
  }
  async getAllPlugins() {
    const plugins = await this.scanPlugins("/data/plugins")
    if (!plugins || !plugins.length) {
      log("No plugin found in /data/plugins")
      return []
    }
    const req = []
    for (const p of plugins) {
      log("Reading plugin from filesystem: " + p)
      const key = this.getFolderName(p)
      const f = async () => {
        const [manifest, script2] = await Promise.all([
          this.getManifest(`${p}/manifest.json`),
          this.getScript(`${p}/main.js`),
        ])
        return { ...manifest, script: script2, enabled: false, key }
      }
      req.push(f())
    }
    const result = await Promise.all(req)
    return result || []
  }
  getFolderName(p) {
    const f = p.split("/")
    for (let i = f.length - 1; i >= 0; i--) {
      if (f[i]) {
        return f[i]
      }
    }
    return ""
  }
}
PluginFileManager = __decorateClass$4([injectable()], PluginFileManager)
var __defProp$3 = Object.defineProperty
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$3(target, key, result)
  return result
}
let EventBus = class {
  constructor() {
    this.eventListeners = {}
  }
  destroy() {
    delete this.eventListeners
  }
  on(eventName, callback) {
    if (!this.eventListeners[eventName]) {
      this.eventListeners[eventName] = []
    }
    this.eventListeners[eventName].push(callback)
    return () => this.off(eventName, callback)
  }
  off(eventName, callback) {
    if (!callback) {
      delete this.eventListeners[eventName]
      return
    }
    for (let i = 0; i < this.eventListeners[eventName].length; i++) {
      if (this.eventListeners[eventName][i] === callback) {
        this.eventListeners[eventName].splice(i, 1)
        return
      }
    }
  }
  emit(eventName, ...args) {
    if (this.eventListeners[eventName]) {
      this.eventListeners[eventName].forEach((cb) => {
        cb(...args)
      })
    }
  }
}
EventBus = __decorateClass$3([injectable()], EventBus)
var __defProp$2 = Object.defineProperty
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$2(target, key, result)
  return result
}
var __decorateParam$1 = (index, decorator) => (target, key) => decorator(target, key, index)
let CommandManager = class {
  constructor(shortcut2) {
    this.commandList = []
    this.shortcut = shortcut2
  }
  registerCommand(command) {
    if (
      this.commandList.some((com) => {
        com.plugin === command.plugin && com.command === command.command
      })
    ) {
      return new Error$1("Command is already registered, do not register command repeatly")
    }
    if (
      command.shortcut &&
      this.commandList.some((com) => {
        com.shortcut === command.shortcut
      })
    ) {
      return new Warning("shortcut has already registered")
    }
    this.commandList.push(command)
    this.shortcut.registerKeyboardEventFromPlugin(command)
    log(`Register plugin: ${command.plugin} command: ${command.command}`)
  }
  unregisterCommandByPlugin(plugin2) {
    for (let i = 0; i < this.commandList.length; i++) {
      if (plugin2 === this.commandList[i].plugin) {
        const com = this.commandList[i]
        log(`Unregister plugin: ${plugin2} command: ${com.command}`)
        this.commandList.splice(i, 1)
        if (com.shortcut) {
          this.shortcut.unregisterKeyboardEvent(com.shortcut)
        }
      }
    }
  }
  unregisterCommand(command) {
    for (let i = 0; i < this.commandList.length; i++) {
      if (command.command === this.commandList[i].command && command.plugin === this.commandList[i].plugin) {
        this.commandList.splice(i, 1)
        break
      }
    }
    this.shortcut.registerKeyboardEventFromPlugin(command)
  }
  getCommands() {
    return this.commandList
  }
}
CommandManager = __decorateClass$2([injectable(), __decorateParam$1(0, inject(TYPES.Shortcut))], CommandManager)
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false
function addEvent(object, event, method, useCapture) {
  if (object.addEventListener) {
    object.addEventListener(event, method, useCapture)
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function () {
      method(window.event)
    })
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1)
  for (var i = 0; i < mods.length; i++) {
    mods[i] = modifier[mods[i].toLowerCase()]
  }
  return mods
}
function getKeys(key) {
  if (typeof key !== "string") key = ""
  key = key.replace(/\s/g, "")
  var keys = key.split(",")
  var index = keys.lastIndexOf("")
  for (; index >= 0; ) {
    keys[index - 1] += ","
    keys.splice(index, 1)
    index = keys.lastIndexOf("")
  }
  return keys
}
function compareArray(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2
  var arr2 = a1.length >= a2.length ? a2 : a1
  var isIndex = true
  for (var i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1) isIndex = false
  }
  return isIndex
}
var _keyMap = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220,
}
var _modifier = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91,
}
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91,
}
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false,
}
var _handlers = {}
for (var k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k
}
var _downKeys = []
var winListendFocus = false
var _scope = "all"
var elementHasBindEvent = []
var code = function code2(x) {
  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0)
}
var getKey = function getKey2(x) {
  return Object.keys(_keyMap).find(function (k2) {
    return _keyMap[k2] === x
  })
}
var getModifier = function getModifier2(x) {
  return Object.keys(_modifier).find(function (k2) {
    return _modifier[k2] === x
  })
}
function setScope(scope) {
  _scope = scope || "all"
}
function getScope() {
  return _scope || "all"
}
function getPressedKeyCodes() {
  return _downKeys.slice(0)
}
function getPressedKeyString() {
  return _downKeys.map(function (c) {
    return getKey(c) || getModifier(c) || String.fromCharCode(c)
  })
}
function filter(event) {
  var target = event.target || event.srcElement
  var tagName = target.tagName
  var flag = true
  if (
    target.isContentEditable ||
    ((tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly)
  ) {
    flag = false
  }
  return flag
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode)
  }
  return _downKeys.indexOf(keyCode) !== -1
}
function deleteScope(scope, newScope) {
  var handlers
  var i
  if (!scope) scope = getScope()
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key]
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope) handlers.splice(i, 1)
        else i++
      }
    }
  }
  if (getScope() === scope) setScope(newScope || "all")
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode
  var i = _downKeys.indexOf(key)
  if (i >= 0) {
    _downKeys.splice(i, 1)
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length)
  }
  if (key === 93 || key === 224) key = 91
  if (key in _mods) {
    _mods[key] = false
    for (var k2 in _modifier) {
      if (_modifier[k2] === key) hotkeys[k2] = false
    }
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach(function (key) {
      return delete _handlers[key]
    })
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function (info) {
      if (info.key) eachUnbind(info)
    })
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key) eachUnbind(keysInfo)
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key]
    }
    var scope = args[0],
      method = args[1]
    if (typeof scope === "function") {
      method = scope
      scope = ""
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+",
    })
  }
}
var eachUnbind = function eachUnbind2(_ref) {
  var key = _ref.key,
    scope = _ref.scope,
    method = _ref.method,
    _ref$splitKey = _ref.splitKey,
    splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey
  var multipleKeys = getKeys(key)
  multipleKeys.forEach(function (originKey) {
    var unbindKeys = originKey.split(splitKey)
    var len = unbindKeys.length
    var lastKey = unbindKeys[len - 1]
    var keyCode = lastKey === "*" ? "*" : code(lastKey)
    if (!_handlers[keyCode]) return
    if (!scope) scope = getScope()
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : []
    _handlers[keyCode] = _handlers[keyCode].filter(function (record) {
      var isMatchingMethod = method ? record.method === method : true
      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods))
    })
  })
}
function eventHandler(event, handler, scope, element2) {
  if (handler.element !== element2) {
    return
  }
  var modifiersMatch
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0
    for (var y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if ((!_mods[y] && handler.mods.indexOf(+y) > -1) || (_mods[y] && handler.mods.indexOf(+y) === -1)) {
          modifiersMatch = false
        }
      }
    }
    if (
      (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) ||
      modifiersMatch ||
      handler.shortcut === "*"
    ) {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault) event.preventDefault()
        else event.returnValue = false
        if (event.stopPropagation) event.stopPropagation()
        if (event.cancelBubble) event.cancelBubble = true
      }
    }
  }
}
function dispatch(event, element2) {
  var asterisk = _handlers["*"]
  var key = event.keyCode || event.which || event.charCode
  if (!hotkeys.filter.call(this, event)) return
  if (key === 93 || key === 224) key = 91
  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key)
  ;["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function (keyName) {
    var keyNum = modifierMap[keyName]
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum)
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1)
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum))
      }
    }
  })
  if (key in _mods) {
    _mods[key] = true
    for (var k2 in _modifier) {
      if (_modifier[k2] === key) hotkeys[k2] = true
    }
    if (!asterisk) return
  }
  for (var e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]]
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17)
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18)
    }
    _mods[17] = true
    _mods[18] = true
  }
  var scope = getScope()
  if (asterisk) {
    for (var i = 0; i < asterisk.length; i++) {
      if (
        asterisk[i].scope === scope &&
        ((event.type === "keydown" && asterisk[i].keydown) || (event.type === "keyup" && asterisk[i].keyup))
      ) {
        eventHandler(event, asterisk[i], scope, element2)
      }
    }
  }
  if (!(key in _handlers)) return
  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (
      (event.type === "keydown" && _handlers[key][_i].keydown) ||
      (event.type === "keyup" && _handlers[key][_i].keyup)
    ) {
      if (_handlers[key][_i].key) {
        var record = _handlers[key][_i]
        var splitKey = record.splitKey
        var keyShortcut = record.key.split(splitKey)
        var _downKeysCurrent = []
        for (var a2 = 0; a2 < keyShortcut.length; a2++) {
          _downKeysCurrent.push(code(keyShortcut[a2]))
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element2)
        }
      }
    }
  }
}
function isElementBind(element2) {
  return elementHasBindEvent.indexOf(element2) > -1
}
function hotkeys(key, option, method) {
  _downKeys = []
  var keys = getKeys(key)
  var mods = []
  var scope = "all"
  var element2 = document
  var i = 0
  var keyup = false
  var keydown = true
  var splitKey = "+"
  var capture = false
  if (method === void 0 && typeof option === "function") {
    method = option
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope) scope = option.scope
    if (option.element) element2 = option.element
    if (option.keyup) keyup = option.keyup
    if (option.keydown !== void 0) keydown = option.keydown
    if (option.capture !== void 0) capture = option.capture
    if (typeof option.splitKey === "string") splitKey = option.splitKey
  }
  if (typeof option === "string") scope = option
  for (; i < keys.length; i++) {
    key = keys[i].split(splitKey)
    mods = []
    if (key.length > 1) mods = getMods(_modifier, key)
    key = key[key.length - 1]
    key = key === "*" ? "*" : code(key)
    if (!(key in _handlers)) _handlers[key] = []
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys[i],
      method,
      key: keys[i],
      splitKey,
      element: element2,
    })
  }
  if (typeof element2 !== "undefined" && !isElementBind(element2) && window) {
    elementHasBindEvent.push(element2)
    addEvent(
      element2,
      "keydown",
      function (e) {
        dispatch(e, element2)
      },
      capture
    )
    if (!winListendFocus) {
      winListendFocus = true
      addEvent(
        window,
        "focus",
        function () {
          _downKeys = []
        },
        capture
      )
    }
    addEvent(
      element2,
      "keyup",
      function (e) {
        dispatch(e, element2)
        clearModifier(e)
      },
      capture
    )
  }
}
function trigger(shortcut2) {
  var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all"
  Object.keys(_handlers).forEach(function (key) {
    var dataList = _handlers[key].filter(function (item) {
      return item.scope === scope && item.shortcut === shortcut2
    })
    dataList.forEach(function (data) {
      if (data && data.method) {
        data.method()
      }
    })
  })
}
var _api = {
  getPressedKeyString,
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap,
}
for (var a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a]
  }
}
if (typeof window !== "undefined") {
  var _hotkeys = window.hotkeys
  hotkeys.noConflict = function (deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys
    }
    return hotkeys
  }
  window.hotkeys = hotkeys
}
var __defProp$1 = Object.defineProperty
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp$1(target, key, result)
  return result
}
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index)
hotkeys.filter = function () {
  return true
}
let Shortcut = class {
  constructor(eventBus) {
    this.option = {
      capture: true,
    }
    log("Initialize shortcut subsystem")
    this.eventBus = eventBus
  }
  registerKeyboardEvent(shortcut2, callback) {
    hotkeys(shortcut2, this.option, callback)
    this.eventBus.on(shortcut2.toString(), callback)
  }
  unregisterKeyboardEvent(shortcut2) {
    hotkeys.unbind(shortcut2)
    this.eventBus.off(shortcut2.toString())
  }
  registerKeyboardEventFromPlugin(command) {
    if (command.shortcut && command.callback) {
      this.registerKeyboardEvent(command.shortcut, command.callback)
    }
  }
  unregisterKeyboardEventFromPlugin(command) {
    if (command.shortcut && command.callback) {
      this.unregisterKeyboardEvent(command.shortcut)
    }
  }
}
Shortcut = __decorateClass$1([injectable(), __decorateParam(0, inject(TYPES.EventBus))], Shortcut)
var __defProp = Object.defineProperty
var __getOwnPropDesc = Object.getOwnPropertyDescriptor
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if ((decorator = decorators[i])) result = (kind ? decorator(target, key, result) : decorator(result)) || result
  if (kind && result) __defProp(target, key, result)
  return result
}
let SettingManager = class {
  constructor() {
    this.settingRenders = /* @__PURE__ */ new Map()
  }
  registerSetting(pluginKey, settingRender) {
    this.settingRenders.set(pluginKey, settingRender)
  }
  unregisterSetting(key) {
    this.settingRenders.delete(key)
  }
  getSettingRenders() {
    const result = []
    this.settingRenders.forEach((value, key) => {
      result.push({ key, value })
    })
    return result
  }
}
SettingManager = __decorateClass([injectable()], SettingManager)
const container = new Container()
container.bind(TYPES.StorageManager).to(StorageManager).inSingletonScope()
container.bind(TYPES.SystemManager).to(SystemManager).inSingletonScope()
container.bind(TYPES.PluginSystem).to(PluginSystem).inSingletonScope()
container.bind(TYPES.PluginLoader).to(PluginLoader).inSingletonScope()
container.bind(TYPES.PluginFileManager).to(PluginFileManager).inSingletonScope()
container.bind(TYPES.EventBus).to(EventBus)
container.bind(TYPES.Shortcut).to(Shortcut).inSingletonScope()
container.bind(TYPES.CommandManager).to(CommandManager).inSingletonScope()
container.bind(TYPES.Store).to(Store).inSingletonScope()
container.bind(TYPES.SettingManager).to(SettingManager).inSingletonScope()
function initPluginSystem() {
  if (!window.pluginSystem) {
    log("Siyuan Plugin System loading...")
    window.pluginSystemVersion = VERSION$1
    window.pluginSystem = container.get(TYPES.PluginSystem).init()
    window.pluginSystemIocContainer = container
  }
}
export { initPluginSystem as default, initPluginSystem }
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5lc20uanMiLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy8ucG5wbS9yZWZsZWN0LW1ldGFkYXRhQDAuMS4xMy9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwic3JjL2NvbmZpZy50cyIsInNyYy9hcGkvc2VydmVyLWFwaS50cyIsInNyYy9pbnRlcm5hbC9jbGFzc2VzL25vdGlmaWNhdGlvbi50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS96aGktbG9nQDEuNi4xL25vZGVfbW9kdWxlcy96aGktbG9nL2xpYi9pbmRleC5qcyIsInNyYy9hcGkvY2xpZW50LWFwaS50cyIsInNyYy9pbnRlcm5hbC9jbGFzc2VzL21lbnUudHMiLCJzcmMvaW50ZXJuYWwvY2xhc3Nlcy9kaWFsb2cudHMiLCJzcmMvYXBpL3BsdWdpbi50cyIsInNyYy9hcGkudHMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21ham9yLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ByZXJlbGVhc2UuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3QuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9uZXEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvZXJjZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS95YWxsaXN0QDQuMC4wL25vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3lhbGxpc3RANC4wLjAvbm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9scnUtY2FjaGVANi4wLjAvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWF4LXNhdGlzZnlpbmcuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdmFsaWQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2VtdmVyQDcuMy44L25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbHRyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zZW12ZXJANy4zLjgvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc3Vic2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3NlbXZlckA3LjMuOC9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwic3JjL2FwaS9maWxlLWFwaS50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9udWxsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvRm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvQmxvYi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2Jyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvVVJMRW5jb2RlZEZvcm0uanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VQcm90b2NvbC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy9hZGFwdGVycy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2F4aW9zQDEuMy40L25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9heGlvc0AxLjMuNC9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMiLCJub2RlX21vZHVsZXMvLnBucG0vYXhpb3NAMS4zLjQvbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsInNyYy91dGlsL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2NvbnN0YW50cy9tZXRhZGF0YV9rZXlzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2NvbnN0YW50cy9saXRlcmFsX3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3V0aWxzL2lkLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2JpbmRpbmdzL2JpbmRpbmcuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvY29uc3RhbnRzL2Vycm9yX21zZ3MuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvcGxhbm5pbmcvbWV0YWRhdGFfcmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2JpbmRpbmdzL2JpbmRpbmdfY291bnQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvdXRpbHMvZXhjZXB0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy91dGlscy9zZXJpYWxpemF0aW9uLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3BsYW5uaW5nL2NvbnRleHQuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvcGxhbm5pbmcvbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvcGxhbm5pbmcvcGxhbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9hbm5vdGF0aW9uL2xhenlfc2VydmljZV9pZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3BsYW5uaW5nL3F1ZXJ5YWJsZV9zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvcGxhbm5pbmcvdGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3BsYW5uaW5nL3JlZmxlY3Rpb25fdXRpbHMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvcGxhbm5pbmcvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9wbGFubmluZy9wbGFubmVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3V0aWxzL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3Njb3BlL3Njb3BlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3V0aWxzL2ZhY3RvcnlfdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy91dGlscy9iaW5kaW5nX3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3Jlc29sdXRpb24vaW5zdGFudGlhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9yZXNvbHV0aW9uL3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3N5bnRheC9jb25zdHJhaW50X2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvc3ludGF4L2JpbmRpbmdfd2hlbl9zeW50YXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvc3ludGF4L2JpbmRpbmdfb25fc3ludGF4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3N5bnRheC9iaW5kaW5nX3doZW5fb25fc3ludGF4LmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3N5bnRheC9iaW5kaW5nX2luX3N5bnRheC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9zeW50YXgvYmluZGluZ19pbl93aGVuX29uX3N5bnRheC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9zeW50YXgvYmluZGluZ190b19zeW50YXguanMiLCJub2RlX21vZHVsZXMvLnBucG0vaW52ZXJzaWZ5QDYuMC4xL25vZGVfbW9kdWxlcy9pbnZlcnNpZnkvZXMvY29udGFpbmVyL2NvbnRhaW5lcl9zbmFwc2hvdC5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy91dGlscy9jbG9uYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9jb250YWluZXIvbG9va3VwLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2NvbnRhaW5lci9tb2R1bGVfYWN0aXZhdGlvbl9zdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9jb250YWluZXIvY29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL3V0aWxzL2pzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2Fubm90YXRpb24vZGVjb3JhdG9yX3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2Fubm90YXRpb24vaW5qZWN0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9pbnZlcnNpZnlANi4wLjEvbm9kZV9tb2R1bGVzL2ludmVyc2lmeS9lcy9hbm5vdGF0aW9uL2luamVjdF9iYXNlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2ludmVyc2lmeUA2LjAuMS9ub2RlX21vZHVsZXMvaW52ZXJzaWZ5L2VzL2Fubm90YXRpb24vaW5qZWN0LmpzIiwic3JjL2NvcmUvcGx1Z2luLWNvbmZpZy50cyIsIm5vZGVfbW9kdWxlcy8ucG5wbS9zdmVsdGVAMy41NS4xL25vZGVfbW9kdWxlcy9zdmVsdGUvaW50ZXJuYWwvaW5kZXgubWpzIiwic3JjL2ludGVybmFsL3BsdWdpbnMvY29tbWFuZC1wYW5lbC9jb21tYW5kLXBhbmVsLnN2ZWx0ZSIsInNyYy9pbnRlcm5hbC9wbHVnaW5zL2NvbW1hbmQtcGFuZWwvaW5kZXgudHMiLCJzcmMvaW50ZXJuYWwvcGx1Z2lucy9zZXR0aW5nL3NldHRpbmctY29tbW9uLnN2ZWx0ZSIsInNyYy9pbnRlcm5hbC9wbHVnaW5zL3NldHRpbmcvc2V0dGluZy1saXN0LnN2ZWx0ZSIsInNyYy9jb3JlL3N0b3JlLnRzIiwic3JjL2ludGVybmFsL2NvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSIsInNyYy9pbnRlcm5hbC9wbHVnaW5zL3NldHRpbmcvc2V0dGluZy1wcmV2aWV3LnN2ZWx0ZSIsInNyYy9pbnRlcm5hbC9wbHVnaW5zL3NldHRpbmcvc2V0dGluZy1zdG9yZS5zdmVsdGUiLCJzcmMvaW50ZXJuYWwvcGx1Z2lucy9zZXR0aW5nL3NldHRpbmctY3VzdG9tLnN2ZWx0ZSIsInNyYy9pbnRlcm5hbC9wbHVnaW5zL3NldHRpbmcvc2V0dGluZy5zdmVsdGUiLCJzcmMvaW50ZXJuYWwvcGx1Z2lucy9zZXR0aW5nL2luZGV4LnRzIiwic3JjL2ludGVybmFsL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3RydW5jYXRlLXV0ZjgtYnl0ZXNAMS4wLjIvbm9kZV9tb2R1bGVzL3RydW5jYXRlLXV0ZjgtYnl0ZXMvbGliL3RydW5jYXRlLmpzIiwibm9kZV9tb2R1bGVzLy5wbnBtL3V0ZjgtYnl0ZS1sZW5ndGhAMS4wLjQvbm9kZV9tb2R1bGVzL3V0ZjgtYnl0ZS1sZW5ndGgvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy8ucG5wbS90cnVuY2F0ZS11dGY4LWJ5dGVzQDEuMC4yL25vZGVfbW9kdWxlcy90cnVuY2F0ZS11dGY4LWJ5dGVzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvLnBucG0vc2FuaXRpemUtZmlsZW5hbWVAMS42LjMvbm9kZV9tb2R1bGVzL3Nhbml0aXplLWZpbGVuYW1lL2luZGV4LmpzIiwic3JjL2NvcmUvc3RvcmFnZS1tYW5hZ2VyLnRzIiwic3JjL2NvcmUvaW5kZXgudHMiLCJzcmMvdXRpbC9taWdyYXRlLnRzIiwic3JjL2NvcmUvc3lzdGVtLW1hbmFnZXIudHMiLCJzcmMvY29yZS9sb2FkZXIudHMiLCJzcmMvY29yZS9wbHVnaW4tZmlsZS1tYW5hZ2VyLnRzIiwic3JjL2NvcmUvZXZlbnQtYnVzLnRzIiwic3JjL2NvcmUvY29tbWFuZC1tYW5hZ2VyLnRzIiwibm9kZV9tb2R1bGVzLy5wbnBtL2hvdGtleXMtanNAMy4xMC4xL25vZGVfbW9kdWxlcy9ob3RrZXlzLWpzL2Rpc3QvaG90a2V5cy5lc20uanMiLCJzcmMvY29yZS9zaG9ydGN1dC50cyIsInNyYy9jb3JlL3NldHRpbmctbWFuYWdlci50cyIsInNyYy9jb250YWluZXIudHMiLCJzcmMvZXhwb3J0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cblxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xudmFyIFJlZmxlY3Q7XG4oZnVuY3Rpb24gKFJlZmxlY3QpIHtcbiAgICAvLyBNZXRhZGF0YSBQcm9wb3NhbFxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvXG4gICAgKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6XG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCk7XG4gICAgICAgIHZhciBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihSZWZsZWN0KTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290LlJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJvb3QuUmVmbGVjdCA9IFJlZmxlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihyb290LlJlZmxlY3QsIGV4cG9ydGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmYWN0b3J5KGV4cG9ydGVyKTtcbiAgICAgICAgZnVuY3Rpb24gbWFrZUV4cG9ydGVyKHRhcmdldCwgcHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMpXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pKGZ1bmN0aW9uIChleHBvcnRlcikge1xuICAgICAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgLy8gZmVhdHVyZSB0ZXN0IGZvciBTeW1ib2wgc3VwcG9ydFxuICAgICAgICB2YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIHZhciB0b1ByaW1pdGl2ZVN5bWJvbCA9IHN1cHBvcnRzU3ltYm9sICYmIHR5cGVvZiBTeW1ib2wudG9QcmltaXRpdmUgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wudG9QcmltaXRpdmUgOiBcIkBAdG9QcmltaXRpdmVcIjtcbiAgICAgICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC5pdGVyYXRvciA6IFwiQEBpdGVyYXRvclwiO1xuICAgICAgICB2YXIgc3VwcG9ydHNDcmVhdGUgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiOyAvLyBmZWF0dXJlIHRlc3QgZm9yIE9iamVjdC5jcmVhdGUgc3VwcG9ydFxuICAgICAgICB2YXIgc3VwcG9ydHNQcm90byA9IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXk7IC8vIGZlYXR1cmUgdGVzdCBmb3IgX19wcm90b19fIHN1cHBvcnRcbiAgICAgICAgdmFyIGRvd25MZXZlbCA9ICFzdXBwb3J0c0NyZWF0ZSAmJiAhc3VwcG9ydHNQcm90bztcbiAgICAgICAgdmFyIEhhc2hNYXAgPSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gb2JqZWN0IGluIGRpY3Rpb25hcnkgbW9kZSAoYS5rLmEuIFwic2xvd1wiIG1vZGUgaW4gdjgpXG4gICAgICAgICAgICBjcmVhdGU6IHN1cHBvcnRzQ3JlYXRlXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeShPYmplY3QuY3JlYXRlKG51bGwpKTsgfVxuICAgICAgICAgICAgICAgIDogc3VwcG9ydHNQcm90b1xuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KHsgX19wcm90b19fOiBudWxsIH0pOyB9XG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoe30pOyB9LFxuICAgICAgICAgICAgaGFzOiBkb3duTGV2ZWxcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGtleSBpbiBtYXA7IH0sXG4gICAgICAgICAgICBnZXQ6IGRvd25MZXZlbFxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBoYXNPd24uY2FsbChtYXAsIGtleSkgPyBtYXBba2V5XSA6IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBtYXBba2V5XTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTG9hZCBnbG9iYWwgb3Igc2hpbSB2ZXJzaW9ucyBvZiBNYXAsIFNldCwgYW5kIFdlYWtNYXBcbiAgICAgICAgdmFyIGZ1bmN0aW9uUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uKTtcbiAgICAgICAgdmFyIHVzZVBvbHlmaWxsID0gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnZbXCJSRUZMRUNUX01FVEFEQVRBX1VTRV9NQVBfUE9MWUZJTExcIl0gPT09IFwidHJ1ZVwiO1xuICAgICAgICB2YXIgX01hcCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gTWFwIDogQ3JlYXRlTWFwUG9seWZpbGwoKTtcbiAgICAgICAgdmFyIF9TZXQgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IFNldCA6IENyZWF0ZVNldFBvbHlmaWxsKCk7XG4gICAgICAgIHZhciBfV2Vha01hcCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgV2Vha01hcCA9PT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpO1xuICAgICAgICAvLyBbW01ldGFkYXRhXV0gaW50ZXJuYWwgc2xvdFxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcbiAgICAgICAgdmFyIE1ldGFkYXRhID0gbmV3IF9XZWFrTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIGEgc2V0IG9mIGRlY29yYXRvcnMgdG8gYSBwcm9wZXJ0eSBvZiBhIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBkZWNvcmF0b3JzIEFuIGFycmF5IG9mIGRlY29yYXRvcnMuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgdG8gZGVjb3JhdGUuXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIHRoZSB0YXJnZXQga2V5LlxuICAgICAgICAgKiBAcmVtYXJrcyBEZWNvcmF0b3JzIGFyZSBhcHBsaWVkIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIEV4YW1wbGUgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXG4gICAgICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIikpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxuICAgICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIixcbiAgICAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIikpKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFJc0FycmF5KGRlY29yYXRvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChhdHRyaWJ1dGVzKSAmJiAhSXNVbmRlZmluZWQoYXR0cmlidXRlcykgJiYgIUlzTnVsbChhdHRyaWJ1dGVzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmIChJc051bGwoYXR0cmlidXRlcykpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGVQcm9wZXJ0eShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3Rvcih0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImRlY29yYXRlXCIsIGRlY29yYXRlKTtcbiAgICAgICAgLy8gNC4xLjIgUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSlcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jcmVmbGVjdC5tZXRhZGF0YVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBkZWZhdWx0IG1ldGFkYXRhIGRlY29yYXRvciBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgb24gYSBjbGFzcywgY2xhc3MgbWVtYmVyLCBvciBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBUaGUga2V5IGZvciB0aGUgbWV0YWRhdGEgZW50cnkuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxuICAgICAgICAgKiBAcmV0dXJucyBBIGRlY29yYXRvciBmdW5jdGlvbi5cbiAgICAgICAgICogQHJlbWFya3NcbiAgICAgICAgICogSWYgYG1ldGFkYXRhS2V5YCBpcyBhbHJlYWR5IGRlZmluZWQgZm9yIHRoZSB0YXJnZXQgYW5kIHRhcmdldCBrZXksIHRoZVxuICAgICAgICAgKiBtZXRhZGF0YVZhbHVlIGZvciB0aGF0IGtleSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvciwgVHlwZVNjcmlwdCBvbmx5KVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlLCBUeXBlU2NyaXB0IG9ubHkpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgICAgIHByb3BlcnR5O1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZCgpIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZCgpIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkgJiYgIUlzUHJvcGVydHlLZXkocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwibWV0YWRhdGFcIiwgbWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIGEgdW5pcXVlIG1ldGFkYXRhIGVudHJ5IG9uIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhVmFsdWUgQSB2YWx1ZSB0aGF0IGNvbnRhaW5zIGF0dGFjaGVkIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGRlY29yYXRvciBmYWN0b3J5IGFzIG1ldGFkYXRhLXByb2R1Y2luZyBhbm5vdGF0aW9uLlxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gTXlBbm5vdGF0aW9uKG9wdGlvbnMpOiBEZWNvcmF0b3Ige1xuICAgICAgICAgKiAgICAgICAgIHJldHVybiAodGFyZ2V0LCBrZXk/KSA9PiBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgdGFyZ2V0LCBrZXkpO1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZGVmaW5lTWV0YWRhdGFcIiwgZGVmaW5lTWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluIGhhcyB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbjsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiaGFzTWV0YWRhdGFcIiwgaGFzTWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0OyBvdGhlcndpc2UsIGBmYWxzZWAuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJoYXNPd25NZXRhZGF0YVwiLCBoYXNPd25NZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImdldE1ldGFkYXRhXCIsIGdldE1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImdldE93bk1ldGFkYXRhXCIsIGdldE93bk1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRNZXRhZGF0YUtleXNcIiwgZ2V0TWV0YWRhdGFLZXlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHVuaXF1ZSBtZXRhZGF0YSBrZXlzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHVuaXF1ZSBtZXRhZGF0YSBrZXlzLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImdldE93bk1ldGFkYXRhS2V5c1wiLCBnZXRPd25NZXRhZGF0YUtleXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyB0aGUgbWV0YWRhdGEgZW50cnkgZnJvbSB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBlbnRyeSB3YXMgZm91bmQgYW5kIGRlbGV0ZWQ7IG90aGVyd2lzZSwgZmFsc2UuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgcHJvcGVydHlLZXksIC8qQ3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhTWFwLmRlbGV0ZShtZXRhZGF0YUtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhTWFwLnNpemUgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXRNZXRhZGF0YS5kZWxldGUocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgaWYgKHRhcmdldE1ldGFkYXRhLnNpemUgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVsZXRlKHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImRlbGV0ZU1ldGFkYXRhXCIsIGRlbGV0ZU1ldGFkYXRhKTtcbiAgICAgICAgZnVuY3Rpb24gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc0NvbnN0cnVjdG9yKGRlY29yYXRlZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRlY29yYXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChkZWNvcmF0ZWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVjb3JhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgQ3JlYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQoTyk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQodGFyZ2V0TWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgIE1ldGFkYXRhLnNldChPLCB0YXJnZXRNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSB0YXJnZXRNZXRhZGF0YS5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFNYXAgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLnNldChQLCBtZXRhZGF0YU1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjEuMSBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWhhc21ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgICAgICAgICAgIGlmIChoYXNPd24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcbiAgICAgICAgICAgIGlmICghSXNOdWxsKHBhcmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWhhc293bm1ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBUb0Jvb2xlYW4obWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjMuMSBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgICAgICAgICAgIGlmIChoYXNPd24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNC4xIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0b3dubWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlkZWZpbmVvd25tZXRhZGF0YVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gdHJ1ZSk7XG4gICAgICAgICAgICBtZXRhZGF0YU1hcC5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS42LjEgT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnltZXRhZGF0YWtleXNcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUCkge1xuICAgICAgICAgICAgdmFyIG93bktleXMgPSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duS2V5cztcbiAgICAgICAgICAgIHZhciBwYXJlbnRLZXlzID0gT3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRLZXlzLmxlbmd0aCA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xuICAgICAgICAgICAgaWYgKG93bktleXMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudEtleXM7XG4gICAgICAgICAgICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG93bktleXNfMSA9IG93bktleXM7IF9pIDwgb3duS2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvd25LZXlzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHBhcmVudEtleXNfMSA9IHBhcmVudEtleXM7IF9hIDwgcGFyZW50S2V5c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwYXJlbnRLZXlzXzFbX2FdO1xuICAgICAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNy4xIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5b3dubWV0YWRhdGFrZXlzXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgIHZhciBrZXlzT2JqID0gbWV0YWRhdGFNYXAua2V5cygpO1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gR2V0SXRlcmF0b3Ioa2V5c09iaik7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSBrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5c1trXSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNiBFQ01BU2NyaXB0IERhdGEgVHlwMGVzIGFuZCBWYWx1ZXNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1kYXRhLXR5cGVzLWFuZC12YWx1ZXNcbiAgICAgICAgZnVuY3Rpb24gVHlwZSh4KSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBOdWxsICovO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjogcmV0dXJuIDAgLyogVW5kZWZpbmVkICovO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6IHJldHVybiAyIC8qIEJvb2xlYW4gKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gMyAvKiBTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOiByZXR1cm4gNCAvKiBTeW1ib2wgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gNSAvKiBOdW1iZXIgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiByZXR1cm4geCA9PT0gbnVsbCA/IDEgLyogTnVsbCAqLyA6IDYgLyogT2JqZWN0ICovO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiA2IC8qIE9iamVjdCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA2LjEuMSBUaGUgVW5kZWZpbmVkIFR5cGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy11bmRlZmluZWQtdHlwZVxuICAgICAgICBmdW5jdGlvbiBJc1VuZGVmaW5lZCh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS4yIFRoZSBOdWxsIFR5cGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1udWxsLXR5cGVcbiAgICAgICAgZnVuY3Rpb24gSXNOdWxsKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS41IFRoZSBTeW1ib2wgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXN5bWJvbC10eXBlXG4gICAgICAgIGZ1bmN0aW9uIElzU3ltYm9sKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA2LjEuNyBUaGUgT2JqZWN0IFR5cGVcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LXR5cGVcbiAgICAgICAgZnVuY3Rpb24gSXNPYmplY3QoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiID8geCAhPT0gbnVsbCA6IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xIFR5cGUgQ29udmVyc2lvblxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlLWNvbnZlcnNpb25cbiAgICAgICAgLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG4gICAgICAgIGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKFR5cGUoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFVuZGVmaW5lZCAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBOdWxsICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIEJvb2xlYW4gKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU3RyaW5nICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBOdW1iZXIgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoaW50ID0gUHJlZmVycmVkVHlwZSA9PT0gMyAvKiBTdHJpbmcgKi8gPyBcInN0cmluZ1wiIDogUHJlZmVycmVkVHlwZSA9PT0gNSAvKiBOdW1iZXIgKi8gPyBcIm51bWJlclwiIDogXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICB2YXIgZXhvdGljVG9QcmltID0gR2V0TWV0aG9kKGlucHV0LCB0b1ByaW1pdGl2ZVN5bWJvbCk7XG4gICAgICAgICAgICBpZiAoZXhvdGljVG9QcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xuICAgICAgICAgICAgICAgIGlmIChJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSBcImRlZmF1bHRcIiA/IFwibnVtYmVyXCIgOiBoaW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEuMS4xIE9yZGluYXJ5VG9QcmltaXRpdmUoTywgaGludClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcbiAgICAgICAgICAgIGlmIChoaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvU3RyaW5nXzEgPSBPLnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18xLmNhbGwoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZU9mLmNhbGwoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlT2YgPSBPLnZhbHVlT2Y7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRvU3RyaW5nXzIgPSBPLnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18yLmNhbGwoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4yIFRvQm9vbGVhbihhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy10b2Jvb2xlYW5cbiAgICAgICAgZnVuY3Rpb24gVG9Cb29sZWFuKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gISFhcmd1bWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEuMTIgVG9TdHJpbmcoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvc3RyaW5nXG4gICAgICAgIGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIGFyZ3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4xNCBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG4gICAgICAgIGZ1bmN0aW9uIFRvUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBUb1ByaW1pdGl2ZShhcmd1bWVudCwgMyAvKiBTdHJpbmcgKi8pO1xuICAgICAgICAgICAgaWYgKElzU3ltYm9sKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIHJldHVybiBUb1N0cmluZyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMiBUZXN0aW5nIGFuZCBDb21wYXJpc29uIE9wZXJhdGlvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVzdGluZy1hbmQtY29tcGFyaXNvbi1vcGVyYXRpb25zXG4gICAgICAgIC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbiAgICAgICAgZnVuY3Rpb24gSXNBcnJheShhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoYXJndW1lbnQpXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudCBpbnN0YW5jZW9mIE9iamVjdFxuICAgICAgICAgICAgICAgICAgICA/IGFyZ3VtZW50IGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4yLjMgSXNDYWxsYWJsZShhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxuICAgICAgICBmdW5jdGlvbiBJc0NhbGxhYmxlKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4yLjQgSXNDb25zdHJ1Y3Rvcihhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxuICAgICAgICBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjIuNyBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc3Byb3BlcnR5a2V5XG4gICAgICAgIGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShhcmd1bWVudCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU3RyaW5nICovOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4zIE9wZXJhdGlvbnMgb24gT2JqZWN0c1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcGVyYXRpb25zLW9uLW9iamVjdHNcbiAgICAgICAgLy8gNy4zLjkgR2V0TWV0aG9kKFYsIFApXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxuICAgICAgICBmdW5jdGlvbiBHZXRNZXRob2QoViwgUCkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBWW1BdO1xuICAgICAgICAgICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUoZnVuYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy40IE9wZXJhdGlvbnMgb24gSXRlcmF0b3IgT2JqZWN0c1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcGVyYXRpb25zLW9uLWl0ZXJhdG9yLW9iamVjdHNcbiAgICAgICAgZnVuY3Rpb24gR2V0SXRlcmF0b3Iob2JqKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgaXRlcmF0b3JTeW1ib2wpO1xuICAgICAgICAgICAgaWYgKCFJc0NhbGxhYmxlKG1ldGhvZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBmcm9tIENhbGxcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG9iaik7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGl0ZXJhdG9yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy40LjQgSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLWl0ZXJhdG9ydmFsdWVcbiAgICAgICAgZnVuY3Rpb24gSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQuNSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yc3RlcFxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyBmYWxzZSA6IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcmNsb3NlXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBmID0gaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICBmLmNhbGwoaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDkuMSBPcmRpbmFyeSBPYmplY3QgSW50ZXJuYWwgTWV0aG9kcyBhbmQgSW50ZXJuYWwgU2xvdHNcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXG4gICAgICAgIC8vIDkuMS4xLjEgT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeWdldHByb3RvdHlwZW9mXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTykge1xuICAgICAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBPICE9PSBcImZ1bmN0aW9uXCIgfHwgTyA9PT0gZnVuY3Rpb25Qcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHNldCBfX3Byb3RvX18gaW4gRVM1LCBhcyBpdCdzIG5vbi1zdGFuZGFyZC5cbiAgICAgICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuIENvbXBhdGlibGUgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICAvLyBtdXN0IGVpdGhlciBzZXQgX19wcm90b19fIG9uIGEgc3ViY2xhc3MgY29uc3RydWN0b3IgdG8gdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IsXG4gICAgICAgICAgICAvLyBvciBlbnN1cmUgZWFjaCBjbGFzcyBoYXMgYSB2YWxpZCBgY29uc3RydWN0b3JgIHByb3BlcnR5IG9uIGl0cyBwcm90b3R5cGUgdGhhdFxuICAgICAgICAgICAgLy8gcG9pbnRzIGJhY2sgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgRnVuY3Rpb24uW1tQcm90b3R5cGVdXSwgdGhlbiB0aGlzIGlzIGRlZmluYXRlbHkgaW5oZXJpdGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVuIGluIEVTNiBvciB3aGVuIHVzaW5nIF9fcHJvdG9fXyBpbiBhIGNvbXBhdGlibGUgYnJvd3Nlci5cbiAgICAgICAgICAgIGlmIChwcm90byAhPT0gZnVuY3Rpb25Qcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHN1cGVyIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlLCBudWxsLCBvciB1bmRlZmluZWQsIHRoZW4gd2UgY2Fubm90IGRldGVybWluZSB0aGUgaGVyaXRhZ2UuXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gTy5wcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlUHJvdG8gPSBwcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XG4gICAgICAgICAgICBpZiAocHJvdG90eXBlUHJvdG8gPT0gbnVsbCB8fCBwcm90b3R5cGVQcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdCBhIGZ1bmN0aW9uLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvdG90eXBlUHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzb21lIGtpbmQgb2Ygc2VsZi1yZWZlcmVuY2UsIHRoZW4gd2UgY2Fubm90IGRldGVybWluZSB0aGUgaGVyaXRhZ2UuXG4gICAgICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXR0eSBnb29kIGd1ZXNzIGF0IHRoZSBoZXJpdGFnZS5cbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBNYXAgc2hpbVxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVNYXBQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZVNlbnRpbmVsID0ge307XG4gICAgICAgICAgICB2YXIgYXJyYXlTZW50aW5lbCA9IFtdO1xuICAgICAgICAgICAgdmFyIE1hcEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKGtleXMsIHZhbHVlcywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zZWxlY3Rvcih0aGlzLl9rZXlzW2luZGV4XSwgdGhpcy5fdmFsdWVzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggKyAxID49IHRoaXMuX2tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleXMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKSA+PSAwOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5fdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzW2kgLSAxXSA9IHRoaXMuX2tleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2kgLSAxXSA9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB0aGlzLl9jYWNoZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldEtleSk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRWYWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0RW50cnkpOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzKCk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLl9maW5kID0gZnVuY3Rpb24gKGtleSwgaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5pbmRleE9mKHRoaXMuX2NhY2hlS2V5ID0ga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVJbmRleCA8IDAgJiYgaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlSW5kZXg7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFwO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEtleShrZXksIF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoXywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRFbnRyeShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBTZXQgc2hpbVxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVTZXRQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuc2l6ZTsgfSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSksIHRoaXM7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21hcC5jbGVhcigpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmFpdmUgV2Vha01hcCBzaGltXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHZhciBVVUlEX1NJWkUgPSAxNjtcbiAgICAgICAgICAgIHZhciBrZXlzID0gSGFzaE1hcC5jcmVhdGUoKTtcbiAgICAgICAgICAgIHZhciByb290S2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZSAhPT0gdW5kZWZpbmVkID8gSGFzaE1hcC5oYXModGFibGUsIHRoaXMuX2tleSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmdldCh0YWJsZSwgdGhpcy5fa2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVbdGhpcy5fa2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBkZWxldGUgdGFibGVbdGhpcy5fa2V5XSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCBhIHJlYWwgY2xlYXIsIGp1c3QgbWFrZXMgdGhlIHByZXZpb3VzIGRhdGEgdW5yZWFjaGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gV2Vha01hcDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBDcmVhdGVVbmlxdWVLZXkoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBcIkBAV2Vha01hcEBAXCIgKyBDcmVhdGVVVUlEKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKEhhc2hNYXAuaGFzKGtleXMsIGtleSkpO1xuICAgICAgICAgICAgICAgIGtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh0YXJnZXQsIHJvb3RLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcm9vdEtleSwgeyB2YWx1ZTogSGFzaE1hcC5jcmVhdGUoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtyb290S2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbGxSYW5kb21CeXRlcyhidWZmZXIsIHNpemUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gTWF0aC5yYW5kb20oKSAqIDB4ZmYgfCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBHZW5SYW5kb21CeXRlcyhzaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgVWludDhBcnJheShzaXplKSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IEFycmF5KHNpemUpLCBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVVSUQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBHZW5SYW5kb21CeXRlcyhVVUlEX1NJWkUpO1xuICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgcmFuZG9tIC0gUkZDIDQxMjIgwqcgNC40XG4gICAgICAgICAgICAgICAgZGF0YVs2XSA9IGRhdGFbNl0gJiAweDRmIHwgMHg0MDtcbiAgICAgICAgICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSAmIDB4YmYgfCAweDgwO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IFVVSURfU0laRTsgKytvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGUgPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IDQgfHwgb2Zmc2V0ID09PSA2IHx8IG9mZnNldCA9PT0gOClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGUgPCAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlcyBhIGhldXJpc3RpYyB1c2VkIGJ5IHY4IGFuZCBjaGFrcmEgdG8gZm9yY2UgYW4gb2JqZWN0IGludG8gZGljdGlvbmFyeSBtb2RlLlxuICAgICAgICBmdW5jdGlvbiBNYWtlRGljdGlvbmFyeShvYmopIHtcbiAgICAgICAgICAgIG9iai5fXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX187XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSk7XG59KShSZWZsZWN0IHx8IChSZWZsZWN0ID0ge30pKTtcbiIsImV4cG9ydCBjb25zdCBQTFVHSU5fRk9MREVSID0gJ3BsdWdpbnMnO1xuXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICdfX1ZFUlNJT05fXyc7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OX1VSTCA9ICdodHRwczovL2dpdGVlLmNvbS96dW9lejAyL3NpeXVhbi1wbHVnaW4tc3lzdGVtL3Jhdy9tYWluL1ZFUlNJT04nO1xuXG5leHBvcnQgY29uc3QgU0NSSVBUX1VSTCA9ICdodHRwczovL2dpdGVlLmNvbS96dW9lejAyL3NpeXVhbi1wbHVnaW4tc3lzdGVtL3Jhdy9tYWluL21haW4uanMnO1xuXG5leHBvcnQgY29uc3QgUExVR0lOX1NZU19BQlNfUEFUSCA9ICcvZGF0YS93aWRnZXRzL+aPkuS7tuezu+e7ny9wbHVnaW4uanMnO1xuXG5leHBvcnQgY29uc3QgY29uZmlnID0gKCkgPT4gKHsgdG9rZW46IHdpbmRvdy5zaXl1YW4uY29uZmlnLmFwaS50b2tlbiB9KTtcblxuZXhwb3J0IGNvbnN0IFRZUEVTID0ge1xuICAgIFN0b3JhZ2VNYW5hZ2VyOiAnU3RvcmFnZU1hbmFnZXInLFxuICAgIFBsdWdpblN5c3RlbTogJ1BsdWdpblN5c3RlbScsXG4gICAgU3lzdGVtTWFuYWdlcjogJ1BsdWdpblN5c3RlbUxvY2FsTWFuYWdlcicsXG4gICAgUGx1Z2luTG9hZGVyOiAnUGx1Z2luTG9hZGVyJyxcbiAgICBQbHVnaW5GaWxlTWFuYWdlcjogJ1BsdWdpbkZpbGVNYW5hZ2VyJyxcbiAgICBFdmVudEJ1czogJ0V2ZW50QnVzJyxcbiAgICBTaG9ydGN1dDogJ1Nob3J0Y3V0JyxcbiAgICBDb21tYW5kTWFuYWdlcjogJ0NvbW1hbmRNYW5hZ2VyJyxcbiAgICBTdG9yZTogJ1N0b3JlJyxcbiAgICBTZXR0aW5nTWFuYWdlcjogJ1NldHRpbmdNYW5hZ2VyJyxcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IGdlblVVSUQgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBkYXRhKSB7XG4gICAgbGV0IHJlc0RhdGEgPSBudWxsO1xuICAgIGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBUb2tlbiAke2NvbmZpZygpLnRva2VufWAsXG4gICAgICAgIH0sXG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmVzRGF0YSA9IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzRGF0YTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlQm9keShyZXNwb25zZSkge1xuICAgIGxldCByID0gYXdhaXQgcmVzcG9uc2U7XG4gICAgcmV0dXJuIHIuY29kZSA9PT0gMCA/IHIuZGF0YSA6IG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFuc2FjdGlvbnMocHJvdHlsZSwgdHJhbnNhY3Rpb25zID0gW10pIHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS90cmFuc2FjdGlvbnMnO1xuICAgIGNvbnN0IHdzX3VybCA9IG5ldyBVUkwocHJvdHlsZS53cy53cy51cmwpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGFwcDogd3NfdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2FwcCcpLFxuICAgICAgICBzZXNzaW9uOiB3c191cmwuc2VhcmNoUGFyYW1zLmdldCgnaWQnKSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMsXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzcWwoc3FsKSB7XG4gICAgbGV0IHNxbGRhdGEgPSB7XG4gICAgICAgIHN0bXQ6IHNxbCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9xdWVyeS9zcWwnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIHNxbGRhdGEpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxzTm90ZWJvb2tzKHNxbCkge1xuICAgIGxldCBzcWxkYXRhID0geyBzdG10OiBzcWwgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvbm90ZWJvb2svbHNOb3RlYm9va3MnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIHNxbGRhdGEpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFuY2hvcihhbmNob3JUZXh0LCBuYW1lKSB7XG4gICAgYW5jaG9yVGV4dCA9IGFuY2hvclRleHQucmVwbGFjZSgnKCgnLCAnJykucmVwbGFjZSgnKSknLCAnJyk7XG4gICAgbGV0IHNxbFNjcmlwdCA9IGBzZWxlY3QgKiBmcm9tIGJsb2NrcyB3aGVyZSBpZCA9ICcke2FuY2hvclRleHR9J2A7XG4gICAgbGV0IHNxbFJlcyA9IGF3YWl0IHNxbChzcWxTY3JpcHQpO1xuICAgIGxldCBhbmNob3IgPSAnJztcbiAgICBpZiAoc3FsUmVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc3FsUmVzWzBdW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gc3FsUmVzWzBdW25hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcWxSZXNbMF1bJ2NvbnRlbnQnXSkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHNxbFJlc1swXVsnY29udGVudCddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBhbmNob3JUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhbmNob3IgPSAn6Kej5p6Q6ZSZ6K+vJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5jaG9yO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb3Blbk5vdGVib29rKG5vdGVib29rSWQpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgbm90ZWJvb2s6IG5vdGVib29rSWQsXG4gICAgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvbm90ZWJvb2svb3Blbk5vdGVib29rJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG4gICAgLy/ov5Tlm57nqbrmlbDmja5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb3NlTm90ZWJvb2sobm90ZWJvb2tJZCkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBub3RlYm9vazogbm90ZWJvb2tJZCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9ub3RlYm9vay9jbG9zZU5vdGVib29rJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG4gICAgLy/ov5Tlm57nqbrmlbDmja5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmFtZU5vdGVib29rKG5vdGVib29rSWQsIG5vdGVib29rTmV3TmFtZSkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBub3RlYm9vazogbm90ZWJvb2tJZCxcbiAgICAgICAgbmFtZTogbm90ZWJvb2tOZXdOYW1lLFxuICAgIH07XG4gICAgbGV0IHVybCA9ICcvYXBpL25vdGVib29rL3JlbmFtZU5vdGVib29rJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG4gICAgLy/ov5Tlm57nqbrmlbDmja5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5vdGVib29rKG5vdGVib29rTmFtZSkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBuYW1lOiBub3RlYm9va05hbWUsXG4gICAgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvbm90ZWJvb2svY3JlYXRlTm90ZWJvb2snO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbiAgICAvL+i/lOWbnuepuuaVsOaNrlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlTm90ZWJvb2sobm90ZWJvb2tJZCkge1xuICAgIGxldCBkYXRhID0geyBub3RlYm9vazogbm90ZWJvb2tJZCB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9ub3RlYm9vay9yZW1vdmVOb3RlYm9vayc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xuICAgIC8v6L+U5Zue56m65pWw5o2uXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROb3RlYm9va0NvbmYobm90ZWJvb2tJZCkge1xuICAgIGxldCBkYXRhID0geyBub3RlYm9vazogbm90ZWJvb2tJZCB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9ub3RlYm9vay9nZXROb3RlYm9va0NvbmYnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbiAgICAvL+i/lOWbnueslOiusOacrOmFjee9rlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0Tm90ZWJvb2tDb25mKG5vdGVib29rSWQpIHtcbiAgICBsZXQgZGF0YSA9IHsgbm90ZWJvb2s6IG5vdGVib29rSWQgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvbm90ZWJvb2svc2V0Tm90ZWJvb2tDb25mJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG4gICAgLy/ov5Tlm57nrJTorrDmnKzphY3nva5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmFtZURvYyhub3RlYm9va0lkLCBwYXRoLCB0aXRsZSkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBub3RlYm9vazogbm90ZWJvb2tJZCxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgIH07XG4gICAgbGV0IHVybCA9ICcvYXBpL2ZpbGV0cmVlL3JlbmFtZURvYyc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xuICAgIC8v6L+U5Zue56m65pWw5o2uXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVEb2Mobm90ZWJvb2tJZCwgcGF0aCkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBub3RlYm9vazogbm90ZWJvb2tJZCxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9maWxldHJlZS9yZW1vdmVEb2MnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbiAgICAvL+i/lOWbnuepuuaVsOaNrlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbW92ZURvYyhzcmNOb3RlYm9va0lkLCBzcmNQYXRoLCB0YXJnZXROb3RlYm9va0lkLCB0YXJnZXRQYXRoKSB7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAgIGZyb21Ob3RlYm9vazogc3JjTm90ZWJvb2tJZCxcbiAgICAgICAgZnJvbVBhdGg6IHNyY1BhdGgsXG4gICAgICAgIHRvTm90ZWJvb2s6IHRhcmdldE5vdGVib29rSWQsXG4gICAgICAgIHRvUGF0aDogdGFyZ2V0UGF0aCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9maWxldHJlZS9tb3ZlRG9jJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG4gICAgLy/ov5Tlm57nqbrmlbDmja5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEhQYXRoQnlQYXRoKG5vdGVib29rSWQsIHBhdGgpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgTm90ZWJvb2s6IG5vdGVib29rSWQsXG4gICAgICAgIFBhdGg6IHBhdGgsXG4gICAgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvZmlsZXRyZWUvZ2V0SFBhdGhCeVBhdGgnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbiAgICAvL+i/lOWbnui3r+W+hFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SFBhdGhCeUlEKElEKSB7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAgIGlkOiBJRCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9maWxldHJlZS9nZXRIUGF0aEJ5SUQnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbn1cblxuLy/mmoLnvLrkuIrkvKDmlofku7ZcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrQXR0cnMoYmxvY2tJZCkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBpZDogYmxvY2tJZCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9hdHRyL2dldEJsb2NrQXR0cnMnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrQnlJRChibG9ja0lkKSB7XG4gICAgbGV0IHNxbFNjcmlwdCA9IGBzZWxlY3QgKiBmcm9tIGJsb2NrcyB3aGVyZSBpZCA9JyR7YmxvY2tJZH0nYDtcbiAgICBsZXQgZGF0YSA9IGF3YWl0IHNxbChzcWxTY3JpcHQpO1xuICAgIHJldHVybiBkYXRhWzBdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QmxvY2tLcmFtZG93bihibG9ja0lkKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgaWQ6IGJsb2NrSWQsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS9ibG9jay9nZXRCbG9ja0tyYW1kb3duJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCbG9ja0JyZWFkY3J1bWIoSUQpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBpZDogSUQsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS9ibG9jay9nZXRCbG9ja0JyZWFkY3J1bWInO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldEJsb2NrQXR0cnMoYmxvY2tJZCwgYXR0cnMpIHtcbiAgICBsZXQgdXJsID0gJy9hcGkvYXR0ci9zZXRCbG9ja0F0dHJzJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KFxuICAgICAgICByZXF1ZXN0KHVybCwge1xuICAgICAgICAgICAgaWQ6IGJsb2NrSWQsXG4gICAgICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgIH0pXG4gICAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydE1kQ29udGVudChkb2NJZCkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBpZDogZG9jSWQsXG4gICAgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvZXhwb3J0L2V4cG9ydE1kQ29udGVudCc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xuICAgIC8v5paH5qGjaGVwYXRo5LiOTWFya2Rvd24g5YaF5a65XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREb2NPdXRsaW5lKGRvY0lkKSB7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAgIGlkOiBkb2NJZCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9vdXRsaW5lL2dldERvY091dGxpbmUnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3REb2NzQnlQYXRoKHBhdGgpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9maWxldHJlZS9saXN0RG9jc0J5UGF0aCc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xuICAgIC8v5paH5qGjaGVwYXRo5LiOTWFya2Rvd24g5YaF5a65XG59XG5cbmZ1bmN0aW9uIGh0bWzovazkuYkodGV4dCkge1xuICAgIHZhciB0ZW1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0ZW1wRWwuaW5uZXJIVE1MID0gdGV4dDtcbiAgICB2YXIgb3V0cHV0ID0gdGVtcEVsLmlubmVyVGV4dCB8fCB0ZW1wRWwudGV4dENvbnRlbnQ7XG4gICAgdGVtcEVsID0gbnVsbDtcbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QmFja2xpbmsoaWQpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBiZWZvcmVMZW46IDEwLFxuICAgICAgICBrOiAnJyxcbiAgICAgICAgbWs6ICcnLFxuICAgIH07XG4gICAgbGV0IHVybCA9ICcvYXBpL3JlZi9nZXRCYWNrbGluayc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoRW1iZWRCbG9jayhleGNsdWRlSWRzLCBzcWwpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgc3RtdDogc3FsLFxuICAgICAgICBleGNsdWRlSURzOiBleGNsdWRlSWRzLFxuICAgIH07XG4gICAgbGV0IHVybCA9ICcvYXBpL3NlYXJjaC9zZWFyY2hFbWJlZEJsb2NrJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RG9jKGlkKSB7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgazogJycsXG4gICAgICAgIG1vZGU6IDIsXG4gICAgICAgIHNpemU6IDM2LFxuICAgIH07XG4gICAgbGV0IHVybCA9ICcvYXBpL2ZpbGV0cmVlL2dldERvYyc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZvY3VzZWREb2MoaWQpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBrOiAnJyxcbiAgICAgICAgbW9kZTogMCxcbiAgICAgICAgc2l6ZTogMzYsXG4gICAgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvZmlsZXRyZWUvZ2V0RG9jJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGFnKCkge1xuICAgIGxldCBkYXRhID0ge307XG4gICAgbGV0IHVybCA9ICcvYXBpL3RhZy9nZXRUYWcnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMb2NhbEdyYXBoKGssIGlkLCBjb25mLCByZXFJZCkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGs6IGssXG4gICAgICAgIGNvbmY6IGNvbmYsXG4gICAgICAgIHJlcUlkOiByZXFJZCxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9ncmFwaC9nZXRMb2NhbEdyYXBoJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0R3JhcGgoaywgY29uZiwgcmVxSWQpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgazogayxcbiAgICAgICAgY29uZjogY29uZixcbiAgICAgICAgcmVxSWQ6IHJlcUlkLFxuICAgIH07XG4gICAgbGV0IHVybCA9ICcvYXBpL2dyYXBoL2dldEdyYXBoJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hEb2NzKGspIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgazogayxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9maWxldHJlZS9zZWFyY2hEb2NzJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoQmxvY2socXVlcnkpIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgIH07XG4gICAgbGV0IHVybCA9ICcvYXBpL3NlYXJjaC9zZWFyY2hCbG9jayc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaFRlbXBsYXRlKGspIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgazogayxcbiAgICB9O1xuICAgIGxldCB1cmwgPSAnL2FwaS9zZWFyY2gvc2VhcmNoVGVtcGxhdGUnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIGRhdGEpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURvY1dpdGhNZChub3RlYm9vaywgcGF0aCwgbWFya2Rvd24pIHtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgbm90ZWJvb2s6IG5vdGVib29rLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBtYXJrZG93bjogbWFya2Rvd24sXG4gICAgfTtcbiAgICBsZXQgdXJsID0gJy9hcGkvZmlsZXRyZWUvY3JlYXRlRG9jV2l0aE1kJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkb2NTYXZlQXNUZW1wbGF0ZShpZCwgb3ZlcndyaXRlID0gZmFsc2UpIHtcbiAgICBsZXQgdXJsID0gJy9hcGkvdGVtcGxhdGUvZG9jU2F2ZUFzVGVtcGxhdGUnO1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIG92ZXJ3cml0ZTogb3ZlcndyaXRlLFxuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgZGF0YSkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyKGRhdGEpIHtcbiAgICBsZXQgdXJsID0gJy9hcGkvdGVtcGxhdGUvcmVuZGVyJztcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnNlcnRCbG9jayhwcmV2aW91c0lELCBkYXRhVHlwZSwgZGF0YSkge1xuICAgIGxldCB1cmwgPSAnL2FwaS9ibG9jay9pbnNlcnRCbG9jayc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShcbiAgICAgICAgcmVxdWVzdChcbiAgICAgICAgICAgICh1cmwgPSB1cmwpLFxuICAgICAgICAgICAgKGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNJRDogcHJldmlvdXNJRCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGVuZEJsb2NrKHBhcmVudElELCBkYXRhVHlwZSwgZGF0YSkge1xuICAgIGxldCB1cmwgPSAnL2FwaS9ibG9jay9wcmVwZW5kQmxvY2snO1xuICAgIHJldHVybiBwYXJzZUJvZHkoXG4gICAgICAgIHJlcXVlc3QoXG4gICAgICAgICAgICAodXJsID0gdXJsKSxcbiAgICAgICAgICAgIChkYXRhID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICApO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGVuZEJsb2NrKHBhcmVudElELCBkYXRhVHlwZSwgZGF0YSkge1xuICAgIGxldCB1cmwgPSAnL2FwaS9ibG9jay9hcHBlbmRCbG9jayc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShcbiAgICAgICAgcmVxdWVzdChcbiAgICAgICAgICAgICh1cmwgPSB1cmwpLFxuICAgICAgICAgICAgKGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVCbG9jayhpZCwgZGF0YVR5cGUsIGRhdGEpIHtcbiAgICBsZXQgdXJsID0gJy9hcGkvYmxvY2svdXBkYXRlQmxvY2snO1xuICAgIHJldHVybiBwYXJzZUJvZHkoXG4gICAgICAgIHJlcXVlc3QoXG4gICAgICAgICAgICAodXJsID0gdXJsKSxcbiAgICAgICAgICAgIChkYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQmxvY2soaWQpIHtcbiAgICBsZXQgdXJsID0gJy9hcGkvYmxvY2svZGVsZXRlQmxvY2snO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIHsgaWQgfSkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbW92ZUJsb2NrKGlkOiBzdHJpbmcsIHByZXZpb3VzSUQ6IHN0cmluZywgcGFyZW50SUQ6IHN0cmluZykge1xuICAgIGxldCB1cmwgPSAnL2FwaS9ibG9jay9tb3ZlQmxvY2snO1xuICAgIHJldHVybiBwYXJzZUJvZHkoXG4gICAgICAgIHJlcXVlc3QodXJsLCB7IGlkOiBpZCwgcHJldmlvdXNJRDogcHJldmlvdXNJRCwgcGFyZW50SUQ6IHBhcmVudElEIH0pXG4gICAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN5c0ZvbnRzKCkge1xuICAgIGxldCB1cmwgPSAnL2FwaS9zeXN0ZW0vZ2V0U3lzRm9udHMnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIG51bGwpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGUocGF0aDogc3RyaW5nLCB0eXBlOiAnanNvbicgfCAndGV4dCcgPSAndGV4dCcpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2ZpbGUvZ2V0RmlsZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBUb2tlbiAke2NvbmZpZygpLnRva2VufWAsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIH0pLFxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHV0RmlsZShwYXRoLCBmaWxlZGF0YSwgaXNEaXIgPSBmYWxzZSwgbW9kVGltZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtmaWxlZGF0YV0pO1xuICAgIGxldCBmaWxlID0gbmV3IEZpbGUoW2Jsb2JdLCBwYXRoLnNwbGl0KCcvJykucG9wKCkpO1xuICAgIGxldCBmb3JtZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1kYXRhLmFwcGVuZCgncGF0aCcsIHBhdGgpO1xuICAgIGZvcm1kYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgIGZvcm1kYXRhLmFwcGVuZCgnaXNEaXInLCBTdHJpbmcoaXNEaXIpKTtcbiAgICBmb3JtZGF0YS5hcHBlbmQoJ21vZFRpbWUnLCBTdHJpbmcobW9kVGltZSkpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZmlsZS9wdXRGaWxlJywge1xuICAgICAgICBib2R5OiBmb3JtZGF0YSxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBUb2tlbiAke2NvbmZpZygpLnRva2VufWAsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGVsc2UgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkRGlyKHBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZmlsZS9yZWFkRGlyJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYFRva2VuICR7Y29uZmlnKCkudG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgfSksXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5kYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVGaWxlKHBhdGgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2ZpbGUvcmVtb3ZlRmlsZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBUb2tlbiAke2NvbmZpZygpLnRva2VufWAsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIH0pLFxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkgcmV0dXJuO1xuICAgIGVsc2UgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGxhbmd1YWdlID0gd2luZG93LnRoZW1lPy5sYW5ndWFnZU1vZGU7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXNoTXNnKG1lc3NhZ2UgPSBudWxsLCB0ZXh0ID0gbnVsbCwgdGltZW91dCA9IDcwMDApIHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS9ub3RpZmljYXRpb24vcHVzaE1zZyc7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgbXNnOiBtZXNzYWdlID8gbWVzc2FnZVtsYW5ndWFnZV0gfHwgbWVzc2FnZS5vdGhlciA6IHRleHQsXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXNoRXJyTXNnKG1lc3NhZ2UgPSBudWxsLCB0ZXh0ID0gbnVsbCwgdGltZW91dCA9IDcwMDApIHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS9ub3RpZmljYXRpb24vcHVzaEVyck1zZyc7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgbXNnOiBtZXNzYWdlID8gbWVzc2FnZVtsYW5ndWFnZV0gfHwgbWVzc2FnZS5vdGhlciA6IHRleHQsXG4gICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRTdG9yYWdlVmFsKGtleTogc3RyaW5nLCB2YWw6IGFueSkge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3N0b3JhZ2Uvc2V0TG9jYWxTdG9yYWdlVmFsJztcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBhcHA6IGdlblVVSUQoKSxcbiAgICAgICAga2V5LFxuICAgICAgICB2YWwsXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VCb2R5KHJlcXVlc3QodXJsLCBkYXRhKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2UoKSB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvc3RvcmFnZS9nZXRMb2NhbFN0b3JhZ2UnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIG51bGwpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlclNwcmlnKHNwcmlnOiBzdHJpbmcpIHtcbiAgICBsZXQgdXJsID0gJy9hcGkvdGVtcGxhdGUvcmVuZGVyU3ByaWcnO1xuICAgIHJldHVybiBwYXJzZUJvZHkocmVxdWVzdCh1cmwsIHt0ZW1wbGF0ZTogc3ByaWd9KSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCYXp6YXJXaWRnZXQoKSB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvYmF6YWFyL2dldEJhemFhcldpZGdldCc7XG4gICAgcmV0dXJuIHBhcnNlQm9keShyZXF1ZXN0KHVybCwgbnVsbCkpO1xufVxuIiwiaW1wb3J0ICogYXMgc2VydmVyQXBpIGZyb20gJy4uLy4uL2FwaS9zZXJ2ZXItYXBpJztcbmltcG9ydCB7IElOb3RpY2F0aW9uT3B0aW9uLCBJTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uIGltcGxlbWVudHMgSU5vdGlmaWNhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHRpb246IElOb3RpY2F0aW9uT3B0aW9uKSB7fVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHNlcnZlckFwaS5wdXNoRXJyTXNnKG51bGwsIHRoaXMub3B0aW9uLm1lc3NhZ2UsIHRoaXMub3B0aW9uLnRpbWVvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VydmVyQXBpLnB1c2hNc2cobnVsbCwgdGhpcy5vcHRpb24ubWVzc2FnZSwgdGhpcy5vcHRpb24udGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJ2YXIgeiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBEID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IHooaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0O1xudmFyIF8gPSAoaSwgZSwgdCkgPT4gKEQoaSwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgdCksIHQpO1xudmFyIFAgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge30sIGIgPSB7fSwgVyA9IHtcbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIGI7XG4gIH0sXG4gIHNldCBleHBvcnRzKGkpIHtcbiAgICBiID0gaTtcbiAgfVxufTtcbihmdW5jdGlvbihpKSB7XG4gIChmdW5jdGlvbihlLCB0KSB7XG4gICAgaS5leHBvcnRzID8gaS5leHBvcnRzID0gdCgpIDogZS5sb2cgPSB0KCk7XG4gIH0pKFAsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gZnVuY3Rpb24oKSB7XG4gICAgfSwgdCA9IFwidW5kZWZpbmVkXCIsIGwgPSB0eXBlb2Ygd2luZG93ICE9PSB0ICYmIHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB0ICYmIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSwgcCA9IFtcbiAgICAgIFwidHJhY2VcIixcbiAgICAgIFwiZGVidWdcIixcbiAgICAgIFwiaW5mb1wiLFxuICAgICAgXCJ3YXJuXCIsXG4gICAgICBcImVycm9yXCJcbiAgICBdO1xuICAgIGZ1bmN0aW9uIGMoYSwgcykge1xuICAgICAgdmFyIGYgPSBhW3NdO1xuICAgICAgaWYgKHR5cGVvZiBmLmJpbmQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZi5iaW5kKGEpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoZiwgYSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoZiwgW2EsIGFyZ3VtZW50c10pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgY29uc29sZS5sb2cgJiYgKGNvbnNvbGUubG9nLmFwcGx5ID8gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKSA6IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pKSwgY29uc29sZS50cmFjZSAmJiBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHcoYSkge1xuICAgICAgcmV0dXJuIGEgPT09IFwiZGVidWdcIiAmJiAoYSA9IFwibG9nXCIpLCB0eXBlb2YgY29uc29sZSA9PT0gdCA/ICExIDogYSA9PT0gXCJ0cmFjZVwiICYmIGwgPyBnIDogY29uc29sZVthXSAhPT0gdm9pZCAwID8gYyhjb25zb2xlLCBhKSA6IGNvbnNvbGUubG9nICE9PSB2b2lkIDAgPyBjKGNvbnNvbGUsIFwibG9nXCIpIDogZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRShhLCBzKSB7XG4gICAgICBmb3IgKHZhciBmID0gMDsgZiA8IHAubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgdmFyIG8gPSBwW2ZdO1xuICAgICAgICB0aGlzW29dID0gZiA8IGEgPyBlIDogdGhpcy5tZXRob2RGYWN0b3J5KG8sIGEsIHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGKGEsIHMsIGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IHQgJiYgKEUuY2FsbCh0aGlzLCBzLCBmKSwgdGhpc1thXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHIoYSwgcywgZikge1xuICAgICAgcmV0dXJuIHcoYSkgfHwgRi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2KGEsIHMsIGYpIHtcbiAgICAgIHZhciBvID0gdGhpcywgTztcbiAgICAgIHMgPSBzID8/IFwiV0FSTlwiO1xuICAgICAgdmFyIHUgPSBcImxvZ2xldmVsXCI7XG4gICAgICB0eXBlb2YgYSA9PSBcInN0cmluZ1wiID8gdSArPSBcIjpcIiArIGEgOiB0eXBlb2YgYSA9PSBcInN5bWJvbFwiICYmICh1ID0gdm9pZCAwKTtcbiAgICAgIGZ1bmN0aW9uIEMobikge1xuICAgICAgICB2YXIgZCA9IChwW25dIHx8IFwic2lsZW50XCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmICghKHR5cGVvZiB3aW5kb3cgPT09IHQgfHwgIXUpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbdV0gPSBkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudCh1KSArIFwiPVwiICsgZCArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgdmFyIG47XG4gICAgICAgIGlmICghKHR5cGVvZiB3aW5kb3cgPT09IHQgfHwgIXUpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG4gPSB3aW5kb3cubG9jYWxTdG9yYWdlW3VdO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIG4gPT09IHQpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgZCA9IHdpbmRvdy5kb2N1bWVudC5jb29raWUsIG0gPSBkLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHUpICsgXCI9XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbSAhPT0gLTEgJiYgKG4gPSAvXihbXjtdKykvLmV4ZWMoZC5zbGljZShtKSlbMV0pO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG8ubGV2ZWxzW25dID09PSB2b2lkIDAgJiYgKG4gPSB2b2lkIDApLCBuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBWKCkge1xuICAgICAgICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSB0IHx8ICF1KSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHUpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvLm5hbWUgPSBhLCBvLmxldmVscyA9IHtcbiAgICAgICAgVFJBQ0U6IDAsXG4gICAgICAgIERFQlVHOiAxLFxuICAgICAgICBJTkZPOiAyLFxuICAgICAgICBXQVJOOiAzLFxuICAgICAgICBFUlJPUjogNCxcbiAgICAgICAgU0lMRU5UOiA1XG4gICAgICB9LCBvLm1ldGhvZEZhY3RvcnkgPSBmIHx8IHIsIG8uZ2V0TGV2ZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9LCBvLnNldExldmVsID0gZnVuY3Rpb24obiwgZCkge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiBvLmxldmVsc1tuLnRvVXBwZXJDYXNlKCldICE9PSB2b2lkIDAgJiYgKG4gPSBvLmxldmVsc1tuLnRvVXBwZXJDYXNlKCldKSwgdHlwZW9mIG4gPT0gXCJudW1iZXJcIiAmJiBuID49IDAgJiYgbiA8PSBvLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICBpZiAoTyA9IG4sIGQgIT09ICExICYmIEMobiksIEUuY2FsbChvLCBuLCBhKSwgdHlwZW9mIGNvbnNvbGUgPT09IHQgJiYgbiA8IG8ubGV2ZWxzLlNJTEVOVClcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBuO1xuICAgICAgfSwgby5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHMgPSBuLCBrKCkgfHwgby5zZXRMZXZlbChuLCAhMSk7XG4gICAgICB9LCBvLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgby5zZXRMZXZlbChzLCAhMSksIFYoKTtcbiAgICAgIH0sIG8uZW5hYmxlQWxsID0gZnVuY3Rpb24obikge1xuICAgICAgICBvLnNldExldmVsKG8ubGV2ZWxzLlRSQUNFLCBuKTtcbiAgICAgIH0sIG8uZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgby5zZXRMZXZlbChvLmxldmVscy5TSUxFTlQsIG4pO1xuICAgICAgfTtcbiAgICAgIHZhciB5ID0gaygpO1xuICAgICAgeSA9PSBudWxsICYmICh5ID0gcyksIG8uc2V0TGV2ZWwoeSwgITEpO1xuICAgIH1cbiAgICB2YXIgTCA9IG5ldyB2KCksIGggPSB7fTtcbiAgICBMLmdldExvZ2dlciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcyAhPSBcInN5bWJvbFwiICYmIHR5cGVvZiBzICE9IFwic3RyaW5nXCIgfHwgcyA9PT0gXCJcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICB2YXIgZiA9IGhbc107XG4gICAgICByZXR1cm4gZiB8fCAoZiA9IGhbc10gPSBuZXcgdihcbiAgICAgICAgcyxcbiAgICAgICAgTC5nZXRMZXZlbCgpLFxuICAgICAgICBMLm1ldGhvZEZhY3RvcnlcbiAgICAgICkpLCBmO1xuICAgIH07XG4gICAgdmFyIEcgPSB0eXBlb2Ygd2luZG93ICE9PSB0ID8gd2luZG93LmxvZyA6IHZvaWQgMDtcbiAgICByZXR1cm4gTC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gdCAmJiB3aW5kb3cubG9nID09PSBMICYmICh3aW5kb3cubG9nID0gRyksIEw7XG4gICAgfSwgTC5nZXRMb2dnZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaDtcbiAgICB9LCBMLmRlZmF1bHQgPSBMLCBMO1xuICB9KTtcbn0pKFcpO1xudmFyIFIgPSB7fSwgQiA9IHtcbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIFI7XG4gIH0sXG4gIHNldCBleHBvcnRzKGkpIHtcbiAgICBSID0gaTtcbiAgfVxufTtcbihmdW5jdGlvbihpKSB7XG4gIChmdW5jdGlvbihlLCB0KSB7XG4gICAgaS5leHBvcnRzID8gaS5leHBvcnRzID0gdCgpIDogZS5wcmVmaXggPSB0KGUpO1xuICB9KShQLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSBmdW5jdGlvbihyKSB7XG4gICAgICBmb3IgKHZhciB2ID0gMSwgTCA9IGFyZ3VtZW50cy5sZW5ndGgsIGg7IHYgPCBMOyB2KyspXG4gICAgICAgIGZvciAoaCBpbiBhcmd1bWVudHNbdl0pXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1t2XSwgaCkgJiYgKHJbaF0gPSBhcmd1bWVudHNbdl1baF0pO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgbCA9IHtcbiAgICAgIHRlbXBsYXRlOiBcIlsldF0gJWw6XCIsXG4gICAgICBsZXZlbEZvcm1hdHRlcjogZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSxcbiAgICAgIG5hbWVGb3JtYXR0ZXI6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHIgfHwgXCJyb290XCI7XG4gICAgICB9LFxuICAgICAgdGltZXN0YW1wRm9ybWF0dGVyOiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiByLnRvVGltZVN0cmluZygpLnJlcGxhY2UoLy4qKFxcZHsyfTpcXGR7Mn06XFxkezJ9KS4qLywgXCIkMVwiKTtcbiAgICAgIH0sXG4gICAgICBmb3JtYXQ6IHZvaWQgMFxuICAgIH0sIHAsIGMgPSB7fSwgZyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGlmICghciB8fCAhci5nZXRMb2dnZXIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSByb290IGxvZ2dlclwiKTtcbiAgICAgIHAgPSByO1xuICAgIH0sIHcgPSBmdW5jdGlvbihyLCB2KSB7XG4gICAgICBpZiAoIXIgfHwgIXIuc2V0TGV2ZWwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSBsb2dnZXJcIik7XG4gICAgICB2YXIgTCA9IHIubWV0aG9kRmFjdG9yeSwgaCA9IHIubmFtZSB8fCBcIlwiLCBHID0gY1toXSB8fCBjW1wiXCJdIHx8IGw7XG4gICAgICBmdW5jdGlvbiBhKHMsIGYsIG8pIHtcbiAgICAgICAgdmFyIE8gPSBMKHMsIGYsIG8pLCB1ID0gY1tvXSB8fCBjW1wiXCJdLCBDID0gdS50ZW1wbGF0ZS5pbmRleE9mKFwiJXRcIikgIT09IC0xLCBrID0gdS50ZW1wbGF0ZS5pbmRleE9mKFwiJWxcIikgIT09IC0xLCBWID0gdS50ZW1wbGF0ZS5pbmRleE9mKFwiJW5cIikgIT09IC0xO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IFwiXCIsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBkID0gQXJyYXkobiksIG0gPSAwOyBtIDwgbjsgbSsrKVxuICAgICAgICAgICAgZFttXSA9IGFyZ3VtZW50c1ttXTtcbiAgICAgICAgICBpZiAoaCB8fCAhY1tvXSkge1xuICAgICAgICAgICAgdmFyIHggPSB1LnRpbWVzdGFtcEZvcm1hdHRlcihuZXcgRGF0ZSgpKSwgVSA9IHUubGV2ZWxGb3JtYXR0ZXIocyksIEEgPSB1Lm5hbWVGb3JtYXR0ZXIobyk7XG4gICAgICAgICAgICB1LmZvcm1hdCA/IHkgKz0gdS5mb3JtYXQoVSwgQSwgeCkgOiAoeSArPSB1LnRlbXBsYXRlLCBDICYmICh5ID0geS5yZXBsYWNlKC8ldC8sIHgpKSwgayAmJiAoeSA9IHkucmVwbGFjZSgvJWwvLCBVKSksIFYgJiYgKHkgPSB5LnJlcGxhY2UoLyVuLywgQSkpKSwgZC5sZW5ndGggJiYgdHlwZW9mIGRbMF0gPT0gXCJzdHJpbmdcIiA/IGRbMF0gPSB5ICsgXCIgXCIgKyBkWzBdIDogZC51bnNoaWZ0KHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPLmFwcGx5KHZvaWQgMCwgZCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gY1toXSB8fCAoci5tZXRob2RGYWN0b3J5ID0gYSksIHYgPSB2IHx8IHt9LCB2LnRlbXBsYXRlICYmICh2LmZvcm1hdCA9IHZvaWQgMCksIGNbaF0gPSB0KHt9LCBHLCB2KSwgci5zZXRMZXZlbChyLmdldExldmVsKCkpLCBwIHx8IHIud2FybihcbiAgICAgICAgXCJJdCBpcyBuZWNlc3NhcnkgdG8gY2FsbCB0aGUgZnVuY3Rpb24gcmVnKCkgb2YgbG9nbGV2ZWwtcGx1Z2luLXByZWZpeCBiZWZvcmUgY2FsbGluZyBhcHBseS4gRnJvbSB0aGUgbmV4dCByZWxlYXNlLCBpdCB3aWxsIHRocm93IGFuIGVycm9yLiBTZWUgbW9yZTogaHR0cHM6Ly9naXRodWIuY29tL2t1dHVsdWsvbG9nbGV2ZWwtcGx1Z2luLXByZWZpeC9ibG9iL21hc3Rlci9SRUFETUUubWRcIlxuICAgICAgKSwgcjtcbiAgICB9LCBFID0ge1xuICAgICAgcmVnOiBnLFxuICAgICAgYXBwbHk6IHdcbiAgICB9LCBGO1xuICAgIHJldHVybiBlICYmIChGID0gZS5wcmVmaXgsIEUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGUucHJlZml4ID09PSBFICYmIChlLnByZWZpeCA9IEYpLCBFO1xuICAgIH0pLCBFO1xuICB9KTtcbn0pKEIpO1xuY2xhc3MgVCB7XG59XG5fKFQsIFwiTE9HX0xFVkVMX0tFWVwiLCBcIlZJVEVfTE9HX0xFVkVMXCIpLCBfKFQsIFwiTE9HX1BSRUZJWF9LRVlcIiwgXCJWSVRFX0xPR19QUkVGSVhcIik7XG52YXIgUyA9IC8qIEBfX1BVUkVfXyAqLyAoKGkpID0+IChpLkxPR19MRVZFTF9ERUJVRyA9IFwiREVCVUdcIiwgaS5MT0dfTEVWRUxfSU5GTyA9IFwiSU5GT1wiLCBpLkxPR19MRVZFTF9XQVJOID0gXCJXQVJOXCIsIGkuTE9HX0xFVkVMX0VSUk9SID0gXCJFUlJPUlwiLCBpKSkoUyB8fCB7fSk7XG5mdW5jdGlvbiBLKCkge1xuICBjb25zdCBpID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gKHQsIGwpID0+IGw7XG4gIGNvbnN0IGUgPSBuZXcgRXJyb3IoKS5zdGFjay5zbGljZSgxKTtcbiAgcmV0dXJuIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gaSwgZTtcbn1cbmNsYXNzIEkge1xuICAvKipcbiAgICog6Kej5p6Q5pel5b+X57qn5Yir5Li65p6a5Li+XG4gICAqXG4gICAqIEBwYXJhbSBlbnVtT2JqIOaemuS4vuWvueixoVxuICAgKiBAcGFyYW0gdmFsdWUg6YWN572u55qE5YC8XG4gICAqL1xuICBzdGF0aWMgc3RyaW5nVG9FbnVtVmFsdWUoZSwgdCkge1xuICAgIHJldHVybiBlW09iamVjdC5rZXlzKGUpLmZpbHRlcihcbiAgICAgIChsKSA9PiBlW2xdLnRvU3RyaW5nKCkgPT09IHRcbiAgICApWzBdXTtcbiAgfVxuICAvKipcbiAgICog6I635Y+W6YWN572u55qE5pel5b+X57qn5YirXG4gICAqL1xuICBzdGF0aWMgZ2V0RW52TGV2ZWwoZSkge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZS5nZXRFbnZPckRlZmF1bHQoXG4gICAgICBULkxPR19MRVZFTF9LRVksXG4gICAgICBTLkxPR19MRVZFTF9JTkZPXG4gICAgKSwgbCA9IEkuc3RyaW5nVG9FbnVtVmFsdWUoXG4gICAgICBTLFxuICAgICAgdC50b1VwcGVyQ2FzZSgpXG4gICAgKTtcbiAgICByZXR1cm4gbCB8fCBjb25zb2xlLndhcm4oXG4gICAgICBcIlt6aGktbG9nXSBMT0dfTEVWRUwgaXMgaW52YWxpZCBpbiB5b3UgLmVudiBmaWxlLk11c3QgYmUgZWl0aGVyIGRlYnVnLCBpbmZvLCB3YXJuIG9yIGVycm9yLCBmYWxsYmFjayB0byBkZWZhdWx0IGluZm8gbGV2ZWxcIlxuICAgICksIGw7XG4gIH1cbiAgLyoqXG4gICAqIOiOt+WPlum7mOiupOaXpeW/l1xuICAgKi9cbiAgc3RhdGljIGdldEVudkxvZ2dlcihlKSB7XG4gICAgaWYgKGUpXG4gICAgICByZXR1cm4gZS5nZXRFbnYoVC5MT0dfUFJFRklYX0tFWSk7XG4gIH1cbn1cbmNsYXNzIFkge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBsKSB7XG4gICAgXyh0aGlzLCBcImNvbnNvbGVMb2dnZXJcIiwgXCJjb25zb2xlXCIpO1xuICAgIF8odGhpcywgXCJzdGFja1NpemVcIiwgMSk7XG4gICAgLyoqXG4gICAgICog6I635Y+W5pel5b+X6K6w5b2V5ZmoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9nZ2VyTmFtZSAtIOaXpeW/l+iusOW9leWZqO+8jOm7mOiupOS4uiBjb25zb2xlXG4gICAgICogQGF1dGhvciB0ZXJ3ZXJcbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKi9cbiAgICBfKHRoaXMsIFwiZ2V0TG9nZ2VyXCIsIChlKSA9PiB7XG4gICAgICBsZXQgdDtcbiAgICAgIGlmIChlKVxuICAgICAgICB0ID0gZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5nZXRDYWxsU3RhY2soKSwgcCA9IFtdLCBjID0gW107XG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgbC5sZW5ndGg7IGcrKykge1xuICAgICAgICAgIGNvbnN0IHcgPSBsW2ddLCBFID0gdy5nZXRGaWxlTmFtZSgpID8/IFwibm9uZVwiO1xuICAgICAgICAgIGlmIChnID4gdGhpcy5zdGFja1NpemUgLSAxKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY29uc3QgRiA9IEUgKyBcIi1cIiArIHcuZ2V0TGluZU51bWJlcigpICsgXCI6XCIgKyB3LmdldENvbHVtbk51bWJlcigpO1xuICAgICAgICAgIHAucHVzaChGKTtcbiAgICAgICAgfVxuICAgICAgICBjLmxlbmd0aCA+IDAgJiYgKHQgPSBwLmpvaW4oXCIgLT4gXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoIXQgfHwgdC50cmltKCkubGVuZ3RoID09PSAwKSAmJiAodCA9IHRoaXMuY29uc29sZUxvZ2dlciksIGIuZ2V0TG9nZ2VyKHQpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhY2tTaXplID0gMTtcbiAgICBsZXQgcDtcbiAgICBlID8gcCA9IGUgOiBwID0gSS5nZXRFbnZMZXZlbChsKSwgcCA9IHAgPz8gUy5MT0dfTEVWRUxfSU5GTywgYi5zZXRMZXZlbChwKTtcbiAgICBjb25zdCBjID0ge1xuICAgICAgZ3JheTogKGcpID0+IGcudG9TdHJpbmcoKSxcbiAgICAgIGdyZWVuOiAoZykgPT4gZy50b1N0cmluZygpLFxuICAgICAgeWVsbG93OiAoZykgPT4gZy50b1N0cmluZygpLFxuICAgICAgcmVkOiAoZykgPT4gZy50b1N0cmluZygpXG4gICAgfTtcbiAgICBSLnJlZyhiKSwgUi5hcHBseShiLCB7XG4gICAgICBmb3JtYXQoZywgdywgRSkge1xuICAgICAgICBjb25zdCByID0gW1wiW1wiICsgKHQgPz8gSS5nZXRFbnZMb2dnZXIobCkgPz8gXCJ6aGlcIikgKyBcIl1cIl07XG4gICAgICAgIHN3aXRjaCAoci5wdXNoKFxuICAgICAgICAgIGMuZ3JheShcIltcIikgKyBjLmdyZWVuKEUpLnRvU3RyaW5nKCkgKyBjLmdyYXkoXCJdXCIpXG4gICAgICAgICksIGcpIHtcbiAgICAgICAgICBjYXNlIFMuTE9HX0xFVkVMX0RFQlVHOlxuICAgICAgICAgICAgci5wdXNoKGMuZ3JheShnLnRvVXBwZXJDYXNlKCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTLkxPR19MRVZFTF9JTkZPOlxuICAgICAgICAgICAgci5wdXNoKGMuZ3JlZW4oZy50b1VwcGVyQ2FzZSgpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUy5MT0dfTEVWRUxfV0FSTjpcbiAgICAgICAgICAgIHIucHVzaChjLnllbGxvdyhnLnRvVXBwZXJDYXNlKCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTLkxPR19MRVZFTF9FUlJPUjpcbiAgICAgICAgICAgIHIucHVzaChjLnJlZChnLnRvVXBwZXJDYXNlKCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIucHVzaChjLmdyZWVuKHcpLnRvU3RyaW5nKCkpLCByLnB1c2goYy5ncmF5KFwiOlwiKSksIHIuam9pbihcIiBcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIOiuvue9rui+k+WHuuagiOeahOa3seW6pu+8jOm7mOiupDFcbiAgICpcbiAgICogQHBhcmFtIHN0YWNrU2l6ZSAtIOagiOeahOa3seW6plxuICAgKi9cbiAgc2V0U3RhY2tTaXplKGUpIHtcbiAgICB0aGlzLnN0YWNrU2l6ZSA9IGUgPz8gMTtcbiAgfVxuICAvKipcbiAgICog6I635Y+W6LCD55So5aCG5qCI77yM6Iul5pyq6I635Y+W5Yiw55u05o6l6L+U5Zue56m65pWw57uEXG4gICAqXG4gICAqIEBhdXRob3IgdGVyd2VyXG4gICAqIEBzaW5jZSAxLjYuMFxuICAgKi9cbiAgZ2V0Q2FsbFN0YWNrKCkge1xuICAgIGxldCBlO1xuICAgIHRyeSB7XG4gICAgICBlID0gSygpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgZSA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxufVxuY2xhc3MgWCB7XG4gIC8qKlxuICAgKiDpu5jorqTml6Xlv5fnuqfliKtcbiAgICpcbiAgICogQHBhcmFtIGxldmVsIC0g5Y+v6YCJ77yM5pyq6K6+572u6buY6K6kSU5GT1xuICAgKiBAcGFyYW0gc2lnbiAtIOWPr+mAieWJjee8gO+8jOm7mOiupHpoaVxuICAgKiBAcGFyYW0gZW52IC0g5Y+v6YCJ546v5aKD5Y+Y6YeP5a6e5L6LXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0LCBsKSB7XG4gICAgXyh0aGlzLCBcImxvZ2dlclwiKTtcbiAgICB0aGlzLmxvZ2dlciA9IG5ldyBZKGUsIHQsIGwpO1xuICB9XG4gIC8qKlxuICAgKiDojrflj5bml6Xlv5forrDlvZXlmahcbiAgICpcbiAgICogQHBhcmFtIGxvZ2dlck5hbWUgLSDml6Xlv5forrDlvZXlmajlkI3np7BcbiAgICogQHBhcmFtIHN0YWNrU2l6ZSAtIOaJk+WNsOagiOeahOa3seW6plxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRMb2dnZXIoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlci5zZXRTdGFja1NpemUodCksIHRoaXMubG9nZ2VyLmdldExvZ2dlcihlKTtcbiAgfVxufVxuY2xhc3MgTiBleHRlbmRzIFgge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBsKSB7XG4gICAgc3VwZXIoZSwgdCwgbCk7XG4gIH1cbiAgLyoqXG4gICAqIOiOt+WPlum7mOiupOeahOaXpeW/l+iusOW9leWZqFxuICAgKlxuICAgKiBAcGFyYW0gbG9nZ2VyTmFtZSAtIOaXpeW/l+iusOW9leWZqOWQjeensFxuICAgKiBAcGFyYW0gc3RhY2tTaXplIC0g5omT5Y2w5qCI55qE5rex5bqmXG4gICAqL1xuICBnZXRMb2dnZXIoZSwgdCkge1xuICAgIHJldHVybiBzdXBlci5nZXRMb2dnZXIoZSwgdCk7XG4gIH1cbn1cbmNsYXNzIE0ge1xuICAvKipcbiAgICog6buY6K6k5pel5b+X6K6w5b2V5ZmoXG4gICAqXG4gICAqIEBwYXJhbSBzdGFja1NpemUgLSDmoIjnmoTmt7HluqZcbiAgICogQHBhcmFtIGVudiAtIOeOr+Wig+WPmOmHj+WunuS+i1xuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRMb2dnZXIoZSwgdCkge1xuICAgIHJldHVybiBNLmN1c3RvbUxvZ0ZhY3Rvcnkodm9pZCAwLCB2b2lkIDAsIGUpLmdldExvZ2dlcihcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiDoh6rlrprkuYnml6Xlv5flt6XljoJcbiAgICovXG4gIHN0YXRpYyBjdXN0b21Mb2dGYWN0b3J5KGUsIHQsIGwpIHtcbiAgICByZXR1cm4gbmV3IE4oZSwgdCwgbCk7XG4gIH1cbiAgLyoqXG4gICAqIOiHquWumuS5ieaXpeW/l+W3peWOgu+8jOiHquWumuS5ieWJjee8gFxuICAgKi9cbiAgc3RhdGljIGN1c3RvbVNpZ25Mb2dGYWN0b3J5KGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IE4odm9pZCAwLCBlLCB0KTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgWCBhcyBBYnN0cmFjdExvZ0ZhY3RvcnksXG4gIE4gYXMgQ3VzdG9tTG9nRmFjdG9yeSxcbiAgUyBhcyBMb2dMZXZlbEVudW0sXG4gIE0gYXMgZGVmYXVsdFxufTtcbiIsImltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4uL3V0aWwnO1xuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocG9zaXRpb25FbDogRWxlbWVudCwgZWw6IEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25FbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2JlZm9yZWJlZ2luJywgZWwpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBZnRlcihwb3NpdGlvbkVsOiBFbGVtZW50LCBlbDogRWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbkVsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBlbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRUb29sYmFyTGVmdChlbDogRWxlbWVudCkge1xuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2xiYXInKT8uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZm5fX2VsbGlwc2lzJyk7XG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc2VydEJlZm9yZSh0aXRsZVswXSwgZWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkVG9vbGJhclJpZ2h0KGVsOiBFbGVtZW50KSB7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9vbGJhcicpPy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmbl9fZWxsaXBzaXMnKTtcbiAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zZXJ0QWZ0ZXIodGl0bGVbMF0sIGVsKTtcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUxvZ2dlciA9IChuYW1lOiBzdHJpbmcpID0+IGdldExvZ2dlcihuYW1lKTtcbiIsImV4cG9ydCBpbnRlcmZhY2UgSU1lbnVJdGVtT3B0aW9uIHtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBjbGljaz86IChlbGVtZW50OiBIVE1MRWxlbWVudCkgPT4gdm9pZDtcbiAgICB0eXBlPzogJ3NlcGFyYXRvcicgfCAnc3VibWVudScgfCAncmVhZG9ubHknO1xuICAgIGFjY2VsZXJhdG9yPzogc3RyaW5nO1xuICAgIGFjdGlvbj86IHN0cmluZztcbiAgICBpZD86IHN0cmluZztcbiAgICBzdWJtZW51PzogSU1lbnVJdGVtT3B0aW9uW107XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGljb24/OiBzdHJpbmc7XG4gICAgaWNvbkhUTUw/OiBzdHJpbmc7XG4gICAgY3VycmVudD86IGJvb2xlYW47XG4gICAgYmluZD86IChlbGVtZW50OiBIVE1MRWxlbWVudCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIE1lbnUge1xuICAgIG1lbnU6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGlkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWVudSA9IHdpbmRvdy5zaXl1YW4/Lm1lbnVzPy5tZW51O1xuICAgICAgICBpZiAoIW1lbnUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTaXl1YW4gaW50ZXJuYWwgbWVudSBub3QgZm91bmQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW51ID0gbWVudTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01lbnUgbXVzdCBoYXMgYW4gaWQsIGdvdCBlbXB0eSBvciB1bmRlZmluZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbWVudS5yZW1vdmUoKTtcbiAgICAgICAgbWVudS5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJywgaWQpO1xuICAgIH1cblxuICAgIGFkZEl0ZW0oaXRlbTogTWVudUl0ZW0pIHtcbiAgICAgICAgdGhpcy5tZW51LmFwcGVuZChpdGVtLmVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhZGRTZXBhcmF0b3IoKSB7XG4gICAgICAgIHRoaXMuYWRkSXRlbShuZXcgTWVudUl0ZW0oeyB0eXBlOiAnc2VwYXJhdG9yJyB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNob3dBdE1vdXNlRXZlbnQoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5tZW51LnBvcHVwKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2hvd0F0UG9zaXRpb24ocG9zaXRpb246IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSkge1xuICAgICAgICB0aGlzLm1lbnUucG9wdXAoeyB4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5tZW51LnJlbW92ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb3B5IGZyb20gc2l5dWFuIHNvdXJjZSBjb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBNZW51SXRlbSB7XG4gICAgcHVibGljIGVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogSU1lbnVJdGVtT3B0aW9uKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAnc2VwYXJhdG9yJykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2IzLW1lbnVfX3NlcGFyYXRvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiMy1tZW51X19pdGVtJyk7XG4gICAgICAgIGlmIChvcHRpb25zLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiMy1tZW51X19pdGVtLS1zZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNsaWNrKSB7XG4gICAgICAgICAgICAvLyDpnIDkvb/nlKggY2xpY2vvvIzlkKbliJnnp7vliqjnq6/ml6Dms5Xmu5rliqhcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jbGljayh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgd2luZG93LnNpeXVhbi5tZW51cy5tZW51LnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGh0bWwgPSBgPHNwYW4gY2xhc3M9XCJiMy1tZW51X19sYWJlbFwiPiR7b3B0aW9ucy5sYWJlbH08L3NwYW4+YDtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWNvbkhUTUwpIHtcbiAgICAgICAgICAgIGh0bWwgPSBvcHRpb25zLmljb25IVE1MICsgaHRtbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgPSBgPHN2ZyBjbGFzcz1cImIzLW1lbnVfX2ljb24ke1xuICAgICAgICAgICAgICAgIFsnSFRNTCAoU2lZdWFuKScsIHdpbmRvdy5zaXl1YW4ubGFuZ3VhZ2VzLnRlbXBsYXRlXS5pbmNsdWRlcyhvcHRpb25zLmxhYmVsKSA/ICcgZnRfX2Vycm9yJyA6ICcnXG4gICAgICAgICAgICB9XCIgc3R5bGU9XCIke29wdGlvbnMuaWNvbiA9PT0gJ2ljb25DbG9zZScgPyAnaGVpZ2h0OjEwcHg7JyA6ICcnfVwiPjx1c2UgeGxpbms6aHJlZj1cIiMke29wdGlvbnMuaWNvbiB8fCAnJ31cIj48L3VzZT48L3N2Zz4ke2h0bWx9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAob3B0aW9ucy5hY2NlbGVyYXRvcikge1xuICAgICAgICAvLyAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCJiMy1tZW51X19hY2NlbGVyYXRvclwiPiR7dXBkYXRlSG90a2V5VGlwKG9wdGlvbnMuYWNjZWxlcmF0b3IpfTwvc3Bhbj5gO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChvcHRpb25zLmFjdGlvbikge1xuICAgICAgICAgICAgaHRtbCArPSBgPHN2ZyBjbGFzcz1cImIzLW1lbnVfX2FjdGlvblwiPjx1c2UgeGxpbms6aHJlZj1cIiMke29wdGlvbnMuYWN0aW9ufVwiPjwvdXNlPjwvc3ZnPmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCBvcHRpb25zLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAncmVhZG9ubHknKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYjMtbWVudV9faXRlbS0tcmVhZG9ubHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkge1xuICAgICAgICAgICAgLy8g5Li76aKYIHJlbSBjcmFmdCDpnIDopoHkvb/nlKggYjMtbWVudV9faXRlbS0tY3VzdG9tIOadpeWMuuWIhuiHquWumuS5ieiPnOWNlSBieSAyODEyNjEzNjFcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiMy1tZW51X19pdGVtLS1jdXN0b20nKTtcbiAgICAgICAgICAgIG9wdGlvbnMuYmluZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnN1Ym1lbnUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Ym1lbnVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzdWJtZW51RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiMy1tZW51X19zdWJtZW51Jyk7XG4gICAgICAgICAgICBvcHRpb25zLnN1Ym1lbnUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHN1Ym1lbnVFbGVtZW50LmFwcGVuZChuZXcgTWVudUl0ZW0oaXRlbSkuZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsICc8c3ZnIGNsYXNzPVwiYjMtbWVudV9faWNvbiBiMy1tZW51X19pY29uLS1hcnJvd1wiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uUmlnaHRcIj48L3VzZT48L3N2Zz4nKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmQoc3VibWVudUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVudVNlcGFyYXRvciB7fVxuIiwiLyoqXG4gKiBDb3B5IGZyb20gc2l5dWFuIHNvdXJjZSBjb2RlXG4gKi9cbmltcG9ydCB7IGdlblVVSUQgfSBmcm9tICcuLi8uLi91dGlsJztcblxuZXhwb3J0IGNsYXNzIERpYWxvZyB7XG4gICAgcHJpdmF0ZSBkZXN0cm95Q2FsbGJhY2s6ICgpID0+IHZvaWQ7XG4gICAgcHVibGljIGVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgaWQ6IHN0cmluZztcbiAgICBwcml2YXRlIGRpc2FibGVDbG9zZTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IHtcbiAgICAgICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgICAgIHRyYW5zcGFyZW50PzogYm9vbGVhbjtcbiAgICAgICAgY29udGVudDogc3RyaW5nO1xuICAgICAgICB3aWR0aD86IHN0cmluZztcbiAgICAgICAgaGVpZ2h0Pzogc3RyaW5nO1xuICAgICAgICBkZXN0cm95Q2FsbGJhY2s/OiAoKSA9PiB2b2lkO1xuICAgICAgICBkaXNhYmxlQ2xvc2U/OiBib29sZWFuO1xuICAgICAgICBkaXNhYmxlQW5pbWF0aW9uPzogYm9vbGVhbjtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsb3NlID0gb3B0aW9ucy5kaXNhYmxlQ2xvc2U7XG4gICAgICAgIHRoaXMuaWQgPSBnZW5VVUlEKCk7XG4gICAgICAgIHdpbmRvdy5zaXl1YW4uZGlhbG9ncy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lDYWxsYmFjayA9IG9wdGlvbnMuZGVzdHJveUNhbGxiYWNrO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSBhcyBIVE1MRWxlbWVudDtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJiMy1kaWFsb2dcIj5cbjxkaXYgY2xhc3M9XCJiMy1kaWFsb2dfX3NjcmltXCIke29wdGlvbnMudHJhbnNwYXJlbnQgPyAnc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50XCInIDogJyd9PjwvZGl2PlxuPGRpdiBjbGFzcz1cImIzLWRpYWxvZ19fY29udGFpbmVyXCIgc3R5bGU9XCJ3aWR0aDoke29wdGlvbnMud2lkdGggfHwgJ2F1dG8nfVwiPlxuICA8c3ZnIGNsYXNzPVwiYjMtZGlhbG9nX19jbG9zZSBmbl9fYSR7dGhpcy5kaXNhYmxlQ2xvc2UgPyAnIGZuX19ub25lJyA6ICcnfVwiPjx1c2UgeGxpbms6aHJlZj1cIiNpY29uQ2xvc2VcIj48L3VzZT48L3N2Zz5cbiAgPGRpdiBjbGFzcz1cImIzLWRpYWxvZ19faGVhZGVyJHtvcHRpb25zLnRpdGxlID8gJycgOiAnIGZuX19ub25lJ31cIiBvbnNlbGVjdHN0YXJ0PVwicmV0dXJuIGZhbHNlO1wiPiR7b3B0aW9ucy50aXRsZSB8fCAnJ308L2Rpdj5cbiAgPGRpdiBzdHlsZT1cImhlaWdodDoke29wdGlvbnMuaGVpZ2h0IHx8ICdhdXRvJ31cIj4ke29wdGlvbnMuY29udGVudH08L2Rpdj5cbjwvZGl2PjwvZGl2PmA7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5iMy1kaWFsb2dfX3NjcmltJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbGQyNDYuY29tL2FydGljbGUvMTY1Nzk2OTI5MjcwMC9jb21tZW50LzE2NTgxNDcwMDY2NjkjY29tbWVudHNcbiAgICAgICAgICAgIHdpbmRvdy5zaXl1YW4ubWVudXMubWVudS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYjMtZGlhbG9nX19jbG9zZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiMy1kaWFsb2ctLW9wZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiMy1kaWFsb2ctLW9wZW4nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaXl1YW4tbm90ZS9zaXl1YW4vaXNzdWVzLzY3ODNcbiAgICAgICAgd2luZG93LnNpeXVhbi5tZW51cy5tZW51LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBkZXN0cm95QWxsKCkge1xuICAgICAgICB3aW5kb3cuc2l5dWFuLmRpYWxvZ3MuZm9yRWFjaCgocCkgPT4gcC5kZXN0cm95KCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaXl1YW4tbm90ZS9zaXl1YW4vaXNzdWVzLzY3ODNcbiAgICAgICAgd2luZG93LnNpeXVhbi5tZW51cy5tZW51LnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnNpeXVhbi5kaWFsb2dzLmZpbmQoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zaXl1YW4uZGlhbG9ncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYmluZElucHV0KGlucHV0RWxlbWVudDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQsIGVudGVyRXZlbnQ/OiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGlucHV0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICBpbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiBlbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZW50ZXJFdmVudCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBJUGx1Z2luLCBJUGx1Z2luQ29tbWFuZCwgU2V0dGluZ1JlbmRlciB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFBsdWdpbiBpbXBsZW1lbnRzIElQbHVnaW4ge1xuICAgIF9pZDogc3RyaW5nO1xuICAgIG9ubG9hZCgpIHt9XG4gICAgb251bmxvYWQoKSB7fVxuICAgIHJlZ2lzdGVyQ29tbWFuZChjb21tYW5kOiBJUGx1Z2luQ29tbWFuZCkge31cbiAgICByZWdpc3RlclNldHRpbmdSZW5kZXIoc2V0dGluZ1JlbmRlcjogU2V0dGluZ1JlbmRlcikge31cbiAgICBhc3luYyBsb2FkU3RvcmFnZShmaWxlbmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZVN0b3JhZ2UoZmlsZW5hbWU6IHN0cmluZywgY29udGVudDogYW55KSB7fVxufVxuIiwiaW1wb3J0ICogYXMgc2VydmVyQXBpIGZyb20gJy4vYXBpL3NlcnZlci1hcGknO1xuaW1wb3J0ICogYXMgY2xpZW50QXBpIGZyb20gJy4vYXBpL2NsaWVudC1hcGknO1xuaW1wb3J0IHsgTWVudSwgTWVudUl0ZW0sIE1lbnVTZXBhcmF0b3IgfSBmcm9tICcuL2ludGVybmFsL2NsYXNzZXMvbWVudSc7XG5pbXBvcnQgeyBEaWFsb2cgfSBmcm9tICcuL2ludGVybmFsL2NsYXNzZXMvZGlhbG9nJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvbiB9IGZyb20gJy4vaW50ZXJuYWwvY2xhc3Nlcy9ub3RpZmljYXRpb24nO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnLi9hcGkvcGx1Z2luJztcblxuZXhwb3J0IHsgY2xpZW50QXBpLCBzZXJ2ZXJBcGksIE1lbnUsIE1lbnVJdGVtLCBNZW51U2VwYXJhdG9yLCBOb3RpZmljYXRpb24sIERpYWxvZywgUGx1Z2luIH07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjbGllbnRBcGksXG4gICAgc2VydmVyQXBpLFxuICAgIFBsdWdpbixcbiAgICBNZW51LFxuICAgIE1lbnVJdGVtLFxuICAgIE1lbnVTZXBhcmF0b3IsXG4gICAgTm90aWZpY2F0aW9uLFxuICAgIERpYWxvZyxcbn07XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgeyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcobmFtZSwgaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxufVxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVInLCAnMHxbMS05XVxcXFxkKicpXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVJMT09TRScsICdbMC05XSsnKVxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignTk9OTlVNRVJJQ0lERU5USUZJRVInLCAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKicpXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OTE9PU0UnLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgYCg/Oi0oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUxPT1NFJywgYCg/Oi0/KCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRElERU5USUZJRVInLCAnWzAtOUEtWmEtei1dKycpXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiQnKVxuIiwiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dCBzbyB3ZSBhbHdheXMgZ2V0IGEgY29uc2lzdGVudFxuLy8gb2JqIHdpdGgga2V5cyBpbiBhIGNvbnNpc3RlbnQgb3JkZXIuXG5jb25zdCBvcHRzID0gWydpbmNsdWRlUHJlcmVsZWFzZScsICdsb29zZScsICdydGwnXVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PlxuICAhb3B0aW9ucyA/IHt9XG4gIDogdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnID8geyBsb29zZTogdHJ1ZSB9XG4gIDogb3B0cy5maWx0ZXIoayA9PiBvcHRpb25zW2tdKS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgICBvW2tdID0gdHJ1ZVxuICAgIHJldHVybiBvXG4gIH0sIHt9KVxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZU9wdGlvbnNcbiIsImNvbnN0IG51bWVyaWMgPSAvXlswLTldKyQvXG5jb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIGNvbnN0IGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iLCJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICAvLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4gIC8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cbiAgaW5jIChyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLmZvcm1hdCgpXG4gICAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb25cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iLCJjb25zdCB7IE1BWF9MRU5HVEggfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllcikgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIoXG4gICAgICB2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyID8gdmVyc2lvbi52ZXJzaW9uIDogdmVyc2lvbixcbiAgICAgIG9wdGlvbnNcbiAgICApLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSlcbiAgICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yKVxuICAgIGNvbnN0IGhhc1ByZSA9IHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgY29uc3QgcHJlZml4ID0gaGFzUHJlID8gJ3ByZScgOiAnJ1xuICAgIGNvbnN0IGRlZmF1bHRSZXN1bHQgPSBoYXNQcmUgPyAncHJlcmVsZWFzZScgOiAnJ1xuICAgIGZvciAoY29uc3Qga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsga2V5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQgLy8gbWF5IGJlIHVuZGVmaW5lZFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXRjaCA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2hcbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGIsIGEsIGxvb3NlKVxubW9kdWxlLmV4cG9ydHMgPSByY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTG9vc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYSwgYiwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSBzb3J0XG4iLCJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IG5lcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbm1vZHVsZS5leHBvcnRzID0gbmVxXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMFxubW9kdWxlLmV4cG9ydHMgPSBndGVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwiY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vbmVxJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9ndCcpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2d0ZScpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9sdGUnKVxuXG5jb25zdCBjbXAgPSAoYSwgb3AsIGIsIGxvb3NlKSA9PiB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIHJldHVybiBhID09PSBiXG5cbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgY29lcmNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJykge1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbilcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBsZXQgbWF0Y2ggPSBudWxsXG4gIGlmICghb3B0aW9ucy5ydGwpIHtcbiAgICBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBsZXQgbmV4dFxuICAgIHdoaWxlICgobmV4dCA9IHJlW3QuQ09FUkNFUlRMXS5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGhcbiAgICB9XG4gICAgLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSAtMVxuICB9XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiBwYXJzZShgJHttYXRjaFsyXX0uJHttYXRjaFszXSB8fCAnMCd9LiR7bWF0Y2hbNF0gfHwgJzAnfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbmNvbnN0IE1BWCA9IFN5bWJvbCgnbWF4JylcbmNvbnN0IExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJylcbmNvbnN0IExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbmNvbnN0IEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJylcbmNvbnN0IE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpXG5jb25zdCBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJylcbmNvbnN0IE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpXG5jb25zdCBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKVxuY29uc3QgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0JylcblxuY29uc3QgbmFpdmVMZW5ndGggPSAoKSA9PiAxXG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIGNvbnN0IG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG5cbiAgICBjb25zdCBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSA/IG5haXZlTGVuZ3RoIDogbGNcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2VcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXggKG1MKSB7XG4gICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXggKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfVxuXG4gIHNldCBhbGxvd1N0YWxlIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH1cblxuICBzZXQgbWF4QWdlIChtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4QWdlICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpXG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG5cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IgKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfVxuXG4gIGdldCBsZW5ndGggKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH1cbiAgZ2V0IGl0ZW1Db3VudCAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLmtleSlcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4gdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpKVxuICAgIH1cblxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gICAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChoaXQgPT5cbiAgICAgIGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSkudG9BcnJheSgpLmZpbHRlcihoID0+IGgpXG4gIH1cblxuICBkdW1wTHJ1ICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG5cbiAgICBjb25zdCBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICAgIGNvbnN0IGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgICBjb25zdCBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSlcbiAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaXRlbS5ub3cgPSBub3dcbiAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICAgIHRoaXMuZ2V0KGtleSlcbiAgICAgIHRyaW0odGhpcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBoYXMgKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG4gIH1cblxuICBwZWVrIChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGRlbCh0aGlzLCBub2RlKVxuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cblxuICBkZWwgKGtleSkge1xuICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgY29uc3QgaGl0ID0gYXJyW2xdXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgICBpZiAoZXhwaXJlc0F0ID09PSAwKVxuICAgICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJ1bmUgKCkge1xuICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSlcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoc2VsZiwga2V5LCBkb1VzZSkgPT4ge1xuICBjb25zdCBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBpZiAoc2VsZltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpXG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQudmFsdWVcbiAgfVxufVxuXG5jb25zdCBpc1N0YWxlID0gKHNlbGYsIGhpdCkgPT4ge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICByZXR1cm4gaGl0Lm1heEFnZSA/IGRpZmYgPiBoaXQubWF4QWdlXG4gICAgOiBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbn1cblxuY29uc3QgdHJpbSA9IHNlbGYgPT4ge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVsID0gKHNlbGYsIG5vZGUpID0+IHtcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pXG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcblxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbmNsYXNzIEVudHJ5IHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5ub3cgPSBub3dcbiAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG4gIH1cbn1cblxuY29uc3QgZm9yRWFjaFN0ZXAgPSAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSA9PiB7XG4gIGxldCBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKGhpdClcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsIi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBSYW5nZSB7XG4gIGNvbnN0cnVjdG9yIChyYW5nZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICB0aGlzLnJhdyA9IHJhbmdlLnZhbHVlXG4gICAgICB0aGlzLnNldCA9IFtbcmFuZ2VdXVxuICAgICAgdGhpcy5mb3JtYXQoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gICAgdGhpcy5yYXcgPSByYW5nZVxuICAgIHRoaXMuc2V0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnfHwnKVxuICAgICAgLy8gbWFwIHRoZSByYW5nZSB0byBhIDJkIGFycmF5IG9mIGNvbXBhcmF0b3JzXG4gICAgICAubWFwKHIgPT4gdGhpcy5wYXJzZVJhbmdlKHIudHJpbSgpKSlcbiAgICAgIC8vIHRocm93IG91dCBhbnkgY29tcGFyYXRvciBsaXN0cyB0aGF0IGFyZSBlbXB0eVxuICAgICAgLy8gdGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCBpdCB3YXMgbm90IGEgdmFsaWQgcmFuZ2UsIHdoaWNoIGlzIGFsbG93ZWRcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIGJ1dCB3aWxsIHN0aWxsIHRocm93IGlmIHRoZSBXSE9MRSByYW5nZSBpcyBpbnZhbGlkLlxuICAgICAgLmZpbHRlcihjID0+IGMubGVuZ3RoKVxuXG4gICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgU2VtVmVyIFJhbmdlOiAke3JhbmdlfWApXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgbm90IHRoZSBudWxsIHNldCwgdGhyb3cgb3V0IG51bGwgc2V0cy5cbiAgICBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgLy8ga2VlcCB0aGUgZmlyc3Qgb25lLCBpbiBjYXNlIHRoZXkncmUgYWxsIG51bGwgc2V0c1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLnNldFswXVxuICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5maWx0ZXIoYyA9PiAhaXNOdWxsU2V0KGNbMF0pKVxuICAgICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJylcbiAgICBjb25zdCBtZW1vS2V5ID0gYHBhcnNlUmFuZ2U6JHttZW1vT3B0c306JHtyYW5nZX1gXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuXG4gICAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJylcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGxldCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICBpZiAobG9vc2UpIHtcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICByYW5nZUxpc3QgPSByYW5nZUxpc3QuZmlsdGVyKGNvbXAgPT4ge1xuICAgICAgICBkZWJ1ZygnbG9vc2UgaW52YWxpZCBmaWx0ZXInLCBjb21wLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmVbdC5DT01QQVJBVE9STE9PU0VdKVxuICAgICAgfSlcbiAgICB9XG4gICAgZGVidWcoJ3JhbmdlIGxpc3QnLCByYW5nZUxpc3QpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlTGlzdC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wYXJhdG9ycykge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSkge1xuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICB9XG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpIHtcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2UsXG59ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjAuMC4xIC0tPiA+PTAuMC4xIDwwLjEuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMC4wLjEgLS0+ID49MC4wLjEgPDAuMC4yLTBcbi8vIF4wLjEuMCAtLT4gPj0wLjEuMCA8MC4yLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKChjKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoYywgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICBwciA9ICctMCdcbiAgICAgIH1cblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgICBjb25zdCBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8XG4gICAgICBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJylcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSAocmFuZ2UsIG9wdGlvbnMpID0+XG4gIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykuc2V0XG4gICAgLm1hcChjb21wID0+IGNvbXAubWFwKGMgPT4gYy52YWx1ZSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQ29tcGFyYXRvcnNcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbmNvbnN0IG1heFNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtYXggPSBudWxsXG4gIGxldCBtYXhTViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdlxuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heFxufVxubW9kdWxlLmV4cG9ydHMgPSBtYXhTYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IG1pblNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cbm1vZHVsZS5leHBvcnRzID0gbWluU2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcblxuY29uc3QgbWluVmVyc2lvbiA9IChyYW5nZSwgbG9vc2UpID0+IHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKVxuXG4gIGxldCBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG51bGxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IHNldE1pbiA9IG51bGxcbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAvLyBDbG9uZSB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNvbXBhcmF0b3IncyBzZW12ZXIgb2JqZWN0LlxuICAgICAgY29uc3QgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbilcbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB2ZXIucmF3ID0gY29tcHZlci5mb3JtYXQoKVxuICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBpZiAoIXNldE1pbiB8fCBndChjb21wdmVyLCBzZXRNaW4pKSB7XG4gICAgICAgICAgICBzZXRNaW4gPSBjb21wdmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi9cbiAgICAgICAgICBicmVha1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvcGVyYXRpb246ICR7Y29tcGFyYXRvci5vcGVyYXRvcn1gKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHNldE1pbiAmJiAoIW1pbnZlciB8fCBndChtaW52ZXIsIHNldE1pbikpKSB7XG4gICAgICBtaW52ZXIgPSBzZXRNaW5cbiAgICB9XG4gIH1cblxuICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblZlcnNpb25cbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCB2YWxpZFJhbmdlID0gKHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJ1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRSYW5nZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsIi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuY29uc3QgZ3RyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGd0clxuIiwiY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmNvbnN0IGx0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBsdHJcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCIvLyBnaXZlbiBhIHNldCBvZiB2ZXJzaW9ucyBhbmQgYSByYW5nZSwgY3JlYXRlIGEgXCJzaW1wbGlmaWVkXCIgcmFuZ2Vcbi8vIHRoYXQgaW5jbHVkZXMgdGhlIHNhbWUgdmVyc2lvbnMgdGhhdCB0aGUgb3JpZ2luYWwgcmFuZ2UgZG9lc1xuLy8gSWYgdGhlIG9yaWdpbmFsIHJhbmdlIGlzIHNob3J0ZXIgdGhhbiB0aGUgc2ltcGxpZmllZCBvbmUsIHJldHVybiB0aGF0LlxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxubW9kdWxlLmV4cG9ydHMgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHNldCA9IFtdXG4gIGxldCBmaXJzdCA9IG51bGxcbiAgbGV0IHByZXYgPSBudWxsXG4gIGNvbnN0IHYgPSB2ZXJzaW9ucy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKVxuICAgIGlmIChpbmNsdWRlZCkge1xuICAgICAgcHJldiA9IHZlcnNpb25cbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSB2ZXJzaW9uXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHNldC5wdXNoKFtmaXJzdCwgcHJldl0pXG4gICAgICB9XG4gICAgICBwcmV2ID0gbnVsbFxuICAgICAgZmlyc3QgPSBudWxsXG4gICAgfVxuICB9XG4gIGlmIChmaXJzdCkge1xuICAgIHNldC5wdXNoKFtmaXJzdCwgbnVsbF0pXG4gIH1cblxuICBjb25zdCByYW5nZXMgPSBbXVxuICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2Ygc2V0KSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICByYW5nZXMucHVzaChtaW4pXG4gICAgfSBlbHNlIGlmICghbWF4ICYmIG1pbiA9PT0gdlswXSkge1xuICAgICAgcmFuZ2VzLnB1c2goJyonKVxuICAgIH0gZWxzZSBpZiAoIW1heCkge1xuICAgICAgcmFuZ2VzLnB1c2goYD49JHttaW59YClcbiAgICB9IGVsc2UgaWYgKG1pbiA9PT0gdlswXSkge1xuICAgICAgcmFuZ2VzLnB1c2goYDw9JHttYXh9YClcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApXG4gICAgfVxuICB9XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSByYW5nZXMuam9pbignIHx8ICcpXG4gIGNvbnN0IG9yaWdpbmFsID0gdHlwZW9mIHJhbmdlLnJhdyA9PT0gJ3N0cmluZycgPyByYW5nZS5yYXcgOiBTdHJpbmcocmFuZ2UpXG4gIHJldHVybiBzaW1wbGlmaWVkLmxlbmd0aCA8IG9yaWdpbmFsLmxlbmd0aCA/IHNpbXBsaWZpZWQgOiByYW5nZVxufVxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlLmpzJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3IuanMnKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcblxuLy8gQ29tcGxleCByYW5nZSBgcjEgfHwgcjIgfHwgLi4uYCBpcyBhIHN1YnNldCBvZiBgUjEgfHwgUjIgfHwgLi4uYCBpZmY6XG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIGlzIGEgbnVsbCBzZXQsIE9SXG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIHdoaWNoIGlzIG5vdCBhIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mXG4vLyAgIHNvbWUgYFIxLCBSMiwgLi4uYFxuLy9cbi8vIFNpbXBsZSByYW5nZSBgYzEgYzIgLi4uYCBpcyBhIHN1YnNldCBvZiBzaW1wbGUgcmFuZ2UgYEMxIEMyIC4uLmAgaWZmOlxuLy8gLSBJZiBjIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvciwgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIGZhbHNlXG4vLyAgIC0gZWxzZSByZXBsYWNlIGMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gdHJ1ZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBDIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gTGV0IEVRIGJlIHRoZSBzZXQgb2YgPSBjb21wYXJhdG9ycyBpbiBjXG4vLyAtIElmIEVRIGlzIG1vcmUgdGhhbiBvbmUsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gTGV0IEdUIGJlIHRoZSBoaWdoZXN0ID4gb3IgPj0gY29tcGFyYXRvciBpbiBjXG4vLyAtIExldCBMVCBiZSB0aGUgbG93ZXN0IDwgb3IgPD0gY29tcGFyYXRvciBpbiBjXG4vLyAtIElmIEdUIGFuZCBMVCwgYW5kIEdULnNlbXZlciA+IExULnNlbXZlciwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBJZiBhbnkgQyBpcyBhID0gcmFuZ2UsIGFuZCBHVCBvciBMVCBhcmUgc2V0LCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgRVFcbi8vICAgLSBJZiBHVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgR1QsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBMVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgTFQsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBFUSBzYXRpc2ZpZXMgZXZlcnkgQywgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIHJldHVybiBmYWxzZVxuLy8gLSBJZiBHVFxuLy8gICAtIElmIEdULnNlbXZlciBpcyBsb3dlciB0aGFuIGFueSA+IG9yID49IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1QgaXMgPj0sIGFuZCBHVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIEdULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIExUXG4vLyAgIC0gSWYgTFQuc2VtdmVyIGlzIGdyZWF0ZXIgdGhhbiBhbnkgPCBvciA8PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIExUIGlzIDw9LCBhbmQgTFQuc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBMVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBFbHNlIHJldHVybiB0cnVlXG5cbmNvbnN0IHN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdWIgPSBuZXcgUmFuZ2Uoc3ViLCBvcHRpb25zKVxuICBkb20gPSBuZXcgUmFuZ2UoZG9tLCBvcHRpb25zKVxuICBsZXQgc2F3Tm9uTnVsbCA9IGZhbHNlXG5cbiAgT1VURVI6IGZvciAoY29uc3Qgc2ltcGxlU3ViIG9mIHN1Yi5zZXQpIHtcbiAgICBmb3IgKGNvbnN0IHNpbXBsZURvbSBvZiBkb20uc2V0KSB7XG4gICAgICBjb25zdCBpc1N1YiA9IHNpbXBsZVN1YnNldChzaW1wbGVTdWIsIHNpbXBsZURvbSwgb3B0aW9ucylcbiAgICAgIHNhd05vbk51bGwgPSBzYXdOb25OdWxsIHx8IGlzU3ViICE9PSBudWxsXG4gICAgICBpZiAoaXNTdWIpIHtcbiAgICAgICAgY29udGludWUgT1VURVJcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhlIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mIGV2ZXJ5dGhpbmcsIGJ1dCBudWxsIHNpbXBsZSByYW5nZXMgaW5cbiAgICAvLyBhIGNvbXBsZXggcmFuZ2Ugc2hvdWxkIGJlIGlnbm9yZWQuICBzbyBpZiB3ZSBzYXcgYSBub24tbnVsbCByYW5nZSxcbiAgICAvLyB0aGVuIHdlIGtub3cgdGhpcyBpc24ndCBhIHN1YnNldCwgYnV0IGlmIEVWRVJZIHNpbXBsZSByYW5nZSB3YXMgbnVsbCxcbiAgICAvLyB0aGVuIGl0IGlzIGEgc3Vic2V0LlxuICAgIGlmIChzYXdOb25OdWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3ViLmxlbmd0aCA9PT0gMSAmJiBzdWJbMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICBzdWIgPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpXVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKV1cbiAgICB9XG4gIH1cblxuICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXFTZXQgPSBuZXcgU2V0KClcbiAgbGV0IGd0LCBsdFxuICBmb3IgKGNvbnN0IGMgb2Ygc3ViKSB7XG4gICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICAgIH1cbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgZ3RsdENvbXBcbiAgaWYgKGd0ICYmIGx0KSB7XG4gICAgZ3RsdENvbXAgPSBjb21wYXJlKGd0LnNlbXZlciwgbHQuc2VtdmVyLCBvcHRpb25zKVxuICAgIGlmIChndGx0Q29tcCA+IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGhpZ2hlciwgbG93ZXJcbiAgbGV0IGhhc0RvbUxULCBoYXNEb21HVFxuICAvLyBpZiB0aGUgc3Vic2V0IGhhcyBhIHByZXJlbGVhc2UsIHdlIG5lZWQgYSBjb21wYXJhdG9yIGluIHRoZSBzdXBlcnNldFxuICAvLyB3aXRoIHRoZSBzYW1lIHR1cGxlIGFuZCBhIHByZXJlbGVhc2UsIG9yIGl0J3Mgbm90IGEgc3Vic2V0XG4gIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgbHQuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gbHQuc2VtdmVyIDogZmFsc2VcbiAgbGV0IG5lZWREb21HVFByZSA9IGd0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZVxuICAvLyBleGNlcHRpb246IDwxLjIuMy0wIGlzIHRoZSBzYW1lIGFzIDwxLjIuM1xuICBpZiAobmVlZERvbUxUUHJlICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbHQub3BlcmF0b3IgPT09ICc8JyAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49J1xuICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PSdcbiAgICBpZiAoZ3QpIHtcbiAgICAgIGlmIChuZWVkRG9tR1RQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tR1RQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tR1RQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChoaWdoZXIgPT09IGMgJiYgaGlnaGVyICE9PSBndCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobHQpIHtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tTFRQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tTFRQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgICAgbG93ZXIgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAobG93ZXIgPT09IGMgJiYgbG93ZXIgIT09IGx0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYy5vcGVyYXRvciAmJiAobHQgfHwgZ3QpICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgYSA8IG9yID4sIGFuZCBub3RoaW5nIGluIHRoZSBkb20sIHRoZW4gbXVzdCBiZSBmYWxzZVxuICAvLyBVTkxFU1MgaXQgd2FzIGxpbWl0ZWQgYnkgYW5vdGhlciByYW5nZSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAvLyBFZywgPjEuMC4wIDwxLjAuMSBpcyBzdGlsbCBhIHN1YnNldCBvZiA8Mi4wLjBcbiAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA+PTEuMi4zIGlzIGxvd2VyIHRoYW4gPjEuMi4zXG5jb25zdCBoaWdoZXJHVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIiwiLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgaWRlbnRpZmllcnMgPSByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGFyc2UnKVxuY29uc3QgdmFsaWQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpXG5jb25zdCBjbGVhbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJylcbmNvbnN0IGluYyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2luYycpXG5jb25zdCBkaWZmID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpXG5jb25zdCBtYWpvciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJylcbmNvbnN0IG1pbm9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWlub3InKVxuY29uc3QgcGF0Y2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpXG5jb25zdCBwcmVyZWxlYXNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpXG5jb25zdCByc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL25lcScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBjb2VyY2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKVxuY29uc3QgbWF4U2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21heC1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpXG5jb25zdCBtaW5WZXJzaW9uID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKVxuY29uc3QgdmFsaWRSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3ZhbGlkJylcbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJylcbmNvbnN0IGd0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpXG5jb25zdCBsdHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9sdHInKVxuY29uc3QgaW50ZXJzZWN0cyA9IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKVxuY29uc3Qgc2ltcGxpZnlSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JylcbmNvbnN0IHN1YnNldCA9IHJlcXVpcmUoJy4vcmFuZ2VzL3N1YnNldCcpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2UsXG4gIHZhbGlkLFxuICBjbGVhbixcbiAgaW5jLFxuICBkaWZmLFxuICBtYWpvcixcbiAgbWlub3IsXG4gIHBhdGNoLFxuICBwcmVyZWxlYXNlLFxuICBjb21wYXJlLFxuICByY29tcGFyZSxcbiAgY29tcGFyZUxvb3NlLFxuICBjb21wYXJlQnVpbGQsXG4gIHNvcnQsXG4gIHJzb3J0LFxuICBndCxcbiAgbHQsXG4gIGVxLFxuICBuZXEsXG4gIGd0ZSxcbiAgbHRlLFxuICBjbXAsXG4gIGNvZXJjZSxcbiAgQ29tcGFyYXRvcixcbiAgUmFuZ2UsXG4gIHNhdGlzZmllcyxcbiAgdG9Db21wYXJhdG9ycyxcbiAgbWF4U2F0aXNmeWluZyxcbiAgbWluU2F0aXNmeWluZyxcbiAgbWluVmVyc2lvbixcbiAgdmFsaWRSYW5nZSxcbiAgb3V0c2lkZSxcbiAgZ3RyLFxuICBsdHIsXG4gIGludGVyc2VjdHMsXG4gIHNpbXBsaWZ5UmFuZ2UsXG4gIHN1YnNldCxcbiAgU2VtVmVyLFxuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IGNvbnN0YW50cy5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMucmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsImltcG9ydCB7IHNlcnZlckFwaSB9IGZyb20gJy4uL2FwaSc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IFN0YXRzIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5leHBvcnQgY2xhc3MgRmlsZUNsaWVudCB7XG4gICAgc3RhdGljIGZpbGVDbGllbnQ6IEZpbGVDbGllbnQ7XG5cbiAgICBnZXRWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNpeXVhbi5jb25maWcuc3lzdGVtLmtlcm5lbFZlcnNpb247XG4gICAgfVxuXG4gICAgZmlsZUFwaToge1xuICAgICAgICByZWFkRGlyOiAocGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPEFycmF5PHsgaXNEaXI6IGJvb2xlYW47IG5hbWU6IHN0cmluZyB9Pj47XG4gICAgICAgIGdldEZpbGU6IChwYXRoOiBzdHJpbmcsIHR5cGU/OiAnanNvbicgfCAndGV4dCcpID0+IFByb21pc2U8YW55PjtcbiAgICAgICAgcHV0RmlsZTogKHBhdGgsIGZpbGVkYXRhLCBpc0Rpcj86IGJvb2xlYW4sIG1vZFRpbWU/OiBudW1iZXIpID0+IFByb21pc2U8YW55PjtcbiAgICAgICAgcmVtb3ZlRmlsZTogKHBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuZ2V0VmVyc2lvbigpO1xuICAgICAgICBpZiAoc2VtdmVyLmNvbXBhcmUodiwgJzIuOC4xJykgPCAwKSB7XG4gICAgICAgICAgICAvLyBvbGQgdmVyc2lvbiwgZWxlY3Ryb24gYXBpIHN1cHBvcnRcbiAgICAgICAgICAgIHRoaXMuZmlsZUFwaSA9IHRoaXMuZWxlY3Ryb25BcGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgYXBpLCBmaWxlIGFwaSBzdXBwb3J0XG4gICAgICAgICAgICB0aGlzLmZpbGVBcGkgPSB0aGlzLnNlcnZlckFwaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZUFwaSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbGVDbGllbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNsaWVudCA9IG5ldyBGaWxlQ2xpZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZUNsaWVudDtcbiAgICB9XG5cbiAgICBlbGVjdHJvbkFwaSA9IHtcbiAgICAgICAgcmVhZERpcihwOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHsgaXNEaXI6IGJvb2xlYW47IG5hbWU6IHN0cmluZyB9Pj4ge1xuICAgICAgICAgICAgY29uc3QgZnMgPSB3aW5kb3cucmVxdWlyZSgnZnMnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3aW5kb3cucmVxdWlyZSgncGF0aCcpO1xuICAgICAgICAgICAgY29uc3QgU0lZVUFOX1dPUktTUEFDRSA9IHBhdGguam9pbih3aW5kb3cuc2l5dWFuLmNvbmZpZy5zeXN0ZW0uZGF0YURpciwgJy4uJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBmcy5yZWFkZGlyKHBhdGguam9pbihTSVlVQU5fV09SS1NQQUNFLCBwKSwgKGVyciwgZmlsZXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVzLm1hcDx7IGlzRGlyOiBib29sZWFuOyBuYW1lOiBzdHJpbmcgfT4oKGY6IHN0cmluZykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlyOiAoZnMuc3RhdFN5bmMocGF0aC5qb2luKFNJWVVBTl9XT1JLU1BBQ0UsIHAsIGYpKSBhcyBTdGF0cykuaXNEaXJlY3RvcnkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGYsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpbGUoZjogc3RyaW5nLCB0eXBlOiAnanNvbicgfCAndGV4dCcgPSAndGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnMgPSB3aW5kb3cucmVxdWlyZSgnZnMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gd2luZG93LnJlcXVpcmUoJ3BhdGgnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBTSVlVQU5fV09SS1NQQUNFID0gcGF0aC5qb2luKHdpbmRvdy5zaXl1YW4uY29uZmlnLnN5c3RlbS5kYXRhRGlyLCAnLi4nKTtcbiAgICAgICAgICAgICAgICBmcy5yZWFkRmlsZShwYXRoLmpvaW4oU0lZVUFOX1dPUktTUEFDRSwgZiksIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkYXRhLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoSlNPTi5wYXJzZSh0ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwdXRGaWxlOiBzZXJ2ZXJBcGkucHV0RmlsZSxcbiAgICAgICAgcmVtb3ZlRmlsZShmOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnMgPSB3aW5kb3cucmVxdWlyZSgnZnMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gd2luZG93LnJlcXVpcmUoJ3BhdGgnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBTSVlVQU5fV09SS1NQQUNFID0gcGF0aC5qb2luKHdpbmRvdy5zaXl1YW4uY29uZmlnLnN5c3RlbS5kYXRhRGlyLCAnLi4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF0aC5qb2luKFNJWVVBTl9XT1JLU1BBQ0UsIGYpO1xuICAgICAgICAgICAgICAgIGxvZygnUmVtb3ZlIGZpbGVzIGZyb20nLCBwKTtcbiAgICAgICAgICAgICAgICBmcy5ybShwLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBzZXJ2ZXJBcGkgPSB7XG4gICAgICAgIHJlYWREaXI6IHNlcnZlckFwaS5yZWFkRGlyLFxuICAgICAgICBnZXRGaWxlOiBzZXJ2ZXJBcGkuZ2V0RmlsZSxcbiAgICAgICAgcHV0RmlsZTogc2VydmVyQXBpLnB1dEZpbGUsXG4gICAgICAgIHJlbW92ZUZpbGU6IHNlcnZlckFwaS5yZW1vdmVGaWxlLFxuICAgIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBjb25zdCBwYXR0ZXJuID0gJ1tvYmplY3QgRm9ybURhdGFdJztcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8XG4gICAgdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IHBhdHRlcm4gfHxcbiAgICAoaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gcGF0dGVybilcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzXVxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5jb25zdCBleHRlbmQgPSAoYSwgYiwgdGhpc0FyZywge2FsbE93bktleXN9PSB7fSkgPT4ge1xuICBmb3JFYWNoKGIsICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuY29uc3Qgc3RyaXBCT00gPSAoY29udGVudCkgPT4ge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pID0+IHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbU3ltYm9sLml0ZXJhdG9yXTtcblxuICBjb25zdCBpdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKSkgJiYgIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgcGFpciA9IHJlc3VsdC52YWx1ZTtcbiAgICBmbi5jYWxsKG9iaiwgcGFpclswXSwgcGFpclsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKlxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxuICovXG5jb25zdCBtYXRjaEFsbCA9IChyZWdFeHAsIHN0cikgPT4ge1xuICBsZXQgbWF0Y2hlcztcbiAgY29uc3QgYXJyID0gW107XG5cbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBhcnIucHVzaChtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBpZiAocmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopICE9PSBmYWxzZSkge1xuICAgICAgcmVkdWNlZERlc2NyaXB0b3JzW25hbWVdID0gZGVzY3JpcHRvcjtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcmVkdWNlZERlc2NyaXB0b3JzKTtcbn1cblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuY29uc3QgQUxQSEEgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXG5cbmNvbnN0IERJR0lUID0gJzAxMjM0NTY3ODknO1xuXG5jb25zdCBBTFBIQUJFVCA9IHtcbiAgRElHSVQsXG4gIEFMUEhBLFxuICBBTFBIQV9ESUdJVDogQUxQSEEgKyBBTFBIQS50b1VwcGVyQ2FzZSgpICsgRElHSVRcbn1cblxuY29uc3QgZ2VuZXJhdGVTdHJpbmcgPSAoc2l6ZSA9IDE2LCBhbHBoYWJldCA9IEFMUEhBQkVULkFMUEhBX0RJR0lUKSA9PiB7XG4gIGxldCBzdHIgPSAnJztcbiAgY29uc3Qge2xlbmd0aH0gPSBhbHBoYWJldDtcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIHN0ciArPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogbGVuZ3RofDBdXG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIElmIHRoZSB0aGluZyBpcyBhIEZvcm1EYXRhIG9iamVjdCwgcmV0dXJuIHRydWUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB0aGluZyAtIFRoZSB0aGluZyB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGVjQ29tcGxpYW50Rm9ybSh0aGluZykge1xuICByZXR1cm4gISEodGhpbmcgJiYgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIHRoaW5nW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YScgJiYgdGhpbmdbU3ltYm9sLml0ZXJhdG9yXSk7XG59XG5cbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgQXJyYXkoMTApO1xuXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCEoJ3RvSlNPTicgaW4gc291cmNlKSkge1xuICAgICAgICBzdGFja1tpXSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXNBcnJheShzb3VyY2UpID8gW10gOiB7fTtcblxuICAgICAgICBmb3JFYWNoKHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VkVmFsdWUgPSB2aXNpdCh2YWx1ZSwgaSArIDEpO1xuICAgICAgICAgICFpc1VuZGVmaW5lZChyZWR1Y2VkVmFsdWUpICYmICh0YXJnZXRba2V5XSA9IHJlZHVjZWRWYWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0YWNrW2ldID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiB2aXNpdChvYmosIDApO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlLFxuICBpc0ZpbGUsXG4gIGlzQmxvYixcbiAgaXNSZWdFeHAsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBBTFBIQUJFVCxcbiAgZ2VuZXJhdGVTdHJpbmcsXG4gIGlzU3BlY0NvbXBsaWFudEZvcm0sXG4gIHRvSlNPTk9iamVjdFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICByZXNwb25zZSAmJiAodGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdXRpbHMudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3RyaWN0XG5leHBvcnQgZGVmYXVsdCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbi8vIHRlbXBvcmFyeSBob3RmaXggdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyB1bnRpbCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBpcyByZWZhY3RvcmVkXG5pbXBvcnQgUGxhdGZvcm1Gb3JtRGF0YSBmcm9tICcuLi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscy5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMudG9GbGF0T2JqZWN0KHV0aWxzLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChQbGF0Zm9ybUZvcm1EYXRhIHx8IEZvcm1EYXRhKSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscy5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZm9ybURhdGEpO1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMuaXNCbG9iKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUpO1xuICB9IDogZW5jb2RlO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5cbi8qKlxuICogSXQgcmVwbGFjZXMgYWxsIGluc3RhbmNlcyBvZiB0aGUgY2hhcmFjdGVycyBgOmAsIGAkYCwgYCxgLCBgK2AsIGBbYCwgYW5kIGBdYCB3aXRoIHRoZWlyXG4gKiBVUkkgZW5jb2RlZCBjb3VudGVycGFydHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIFRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHBhcmFtIHs/b2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBcbiAgY29uc3QgX2VuY29kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGNvbnN0IHNlcmlhbGl6ZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZTtcblxuICBsZXQgc2VyaWFsaXplZFBhcmFtcztcblxuICBpZiAoc2VyaWFsaXplRm4pIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gc2VyaWFsaXplRm4ocGFyYW1zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gdXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSA/XG4gICAgICBwYXJhbXMudG9TdHJpbmcoKSA6XG4gICAgICBuZXcgQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKS50b1N0cmluZyhfZW5jb2RlKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgY29uc3QgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcblxuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmNlcHRvciB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICBmbihoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uLy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgPyBVUkxTZWFyY2hQYXJhbXMgOiBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyA/IEZvcm1EYXRhIDogbnVsbDtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbFxuIiwiaW1wb3J0IFVSTFNlYXJjaFBhcmFtcyBmcm9tICcuL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzJ1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJy4vY2xhc3Nlcy9Gb3JtRGF0YS5qcydcbmltcG9ydCBCbG9iIGZyb20gJy4vY2xhc3Nlcy9CbG9iLmpzJ1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNTdGFuZGFyZEJyb3dzZXJFbnYgPSAoKCkgPT4ge1xuICBsZXQgcHJvZHVjdDtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICAocHJvZHVjdCA9IG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgIHByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgcHJvZHVjdCA9PT0gJ05TJylcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59KSgpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG4gY29uc3QgaXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNCcm93c2VyOiB0cnVlLFxuICBjbGFzc2VzOiB7XG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIEZvcm1EYXRhLFxuICAgIEJsb2JcbiAgfSxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGlzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmaWxlJywgJ2Jsb2InLCAndXJsJywgJ2RhdGEnXVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvRm9ybURhdGEoZGF0YSwgbmV3IHBsYXRmb3JtLmNsYXNzZXMuVVJMU2VhcmNoUGFyYW1zKCksIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5kZWZhdWx0VmlzaXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwgb3B0aW9ucykpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nIGxpa2UgYGZvb1t4XVt5XVt6XWAgYW5kIHJldHVybnMgYW4gYXJyYXkgbGlrZSBgWydmb28nLCAneCcsICd5JywgJ3onXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BQYXRoKG5hbWUpIHtcbiAgLy8gZm9vW3hdW3ldW3pdXG4gIC8vIGZvby54LnkuelxuICAvLyBmb28teC15LXpcbiAgLy8gZm9vIHggeSB6XG4gIHJldHVybiB1dGlscy5tYXRjaEFsbCgvXFx3K3xcXFsoXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XG4gICAgcmV0dXJuIG1hdGNoWzBdID09PSAnW10nID8gJycgOiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY29udmVydCB0byBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzIGFzIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICBsZXQgaTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgb2JqW2tleV0gPSBhcnJba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgRm9ybURhdGEgb2JqZWN0IGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgVGhlIEZvcm1EYXRhIG9iamVjdCB0byBjb252ZXJ0IHRvIEpTT04uXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0pTT04oZm9ybURhdGEpIHtcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XG4gICAgbGV0IG5hbWUgPSBwYXRoW2luZGV4KytdO1xuICAgIGNvbnN0IGlzTnVtZXJpY0tleSA9IE51bWJlci5pc0Zpbml0ZSgrbmFtZSk7XG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XG4gICAgbmFtZSA9ICFuYW1lICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xuXG4gICAgaWYgKGlzTGFzdCkge1xuICAgICAgaWYgKHV0aWxzLmhhc093blByb3AodGFyZ2V0LCBuYW1lKSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRbbmFtZV0gfHwgIXV0aWxzLmlzT2JqZWN0KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0W25hbWVdLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gYXJyYXlUb09iamVjdCh0YXJnZXRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzLmlzRnVuY3Rpb24oZm9ybURhdGEuZW50cmllcykpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2hFbnRyeShmb3JtRGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBidWlsZFBhdGgocGFyc2VQcm9wUGF0aChuYW1lKSwgdmFsdWUsIG9iaiwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1EYXRhVG9KU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHRvVVJMRW5jb2RlZEZvcm0gZnJvbSAnLi4vaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIGlmICghaGFzSlNPTkNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0pTT05Db250ZW50VHlwZSA/IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhVG9KU09OKGRhdGEpKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCB0aGlzLmZvcm1TZXJpYWxpemVyKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgPiAtMSkge1xuICAgICAgICBjb25zdCBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcblxuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YShcbiAgICAgICAgICBpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXG4gICAgICAgICAgdGhpcy5mb3JtU2VyaWFsaXplclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICBjb25zdCBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgY29uc3QgSlNPTlJlcXVlc3RlZCA9IHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoZGF0YSAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiAoKGZvcmNlZEpTT05QYXJzaW5nICYmICF0aGlzLnJlc3BvbnNlVHlwZSkgfHwgSlNPTlJlcXVlc3RlZCkpIHtcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICAgIGNvbnN0IHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIEpTT05SZXF1ZXN0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi4vaGVscGVycy9wYXJzZUhlYWRlcnMuanMnO1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb2tlbnMoc3RyKSB7XG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHRva2Vuc1JFID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbnNSRS5leGVjKHN0cikpKSB7XG4gICAgdG9rZW5zW21hdGNoWzFdXSA9IG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEhlYWRlck5hbWUoc3RyKSB7XG4gIHJldHVybiAvXlstX2EtekEtWl0rJC8udGVzdChzdHIudHJpbSgpKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc1N0cmluZyh2YWx1ZSkpIHJldHVybjtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XG5cbiAgWydnZXQnLCAnc2V0JywgJ2hhcyddLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCBoZWFkZXIsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaGVhZGVycykge1xuICAgIGhlYWRlcnMgJiYgdGhpcy5zZXQoaGVhZGVycyk7XG4gIH1cblxuICBzZXQoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSwgcmV3cml0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghbEhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChoZWFkZXIpIHx8IGhlYWRlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIHNldEhlYWRlcnMoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2UgaWYodXRpbHMuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcbiAgICAgIHNldEhlYWRlcnMocGFyc2VIZWFkZXJzKGhlYWRlciksIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlci5mb3JFYWNoKGRlZmluZUFjY2Vzc29yKSA6IGRlZmluZUFjY2Vzc29yKGhlYWRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5BeGlvc0hlYWRlcnMuYWNjZXNzb3IoWydDb250ZW50LVR5cGUnLCAnQ29udGVudC1MZW5ndGgnLCAnQWNjZXB0JywgJ0FjY2VwdC1FbmNvZGluZycsICdVc2VyLUFnZW50JywgJ0F1dGhvcml6YXRpb24nXSk7XG5cbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSk7XG51dGlscy5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zSGVhZGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICBjb25zdCBjb250ZXh0ID0gcmVzcG9uc2UgfHwgY29uZmlnO1xuICBjb25zdCBoZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29udGV4dC5oZWFkZXJzKTtcbiAgbGV0IGRhdGEgPSBjb250ZXh0LmRhdGE7XG5cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3Q9fSByZXF1ZXN0IFRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxlZEVycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQsIGNvbmZpZywgcmVxdWVzdCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsZWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9BeGlvc0Vycm9yLmpzJztcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICBbQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5pc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbi8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIGNvbnN0IGNvb2tpZSA9IFtdO1xuICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgfSxcblxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4vLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3Rcbi8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIGNvbnN0IG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGNvbnN0IHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxldCBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgbGV0IGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlUHJvdG9jb2wodXJsKSB7XG4gIGNvbnN0IG1hdGNoID0gL14oWy0rXFx3XXsxLDI1fSkoOj9cXC9cXC98OikvLmV4ZWModXJsKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkYXRhIG1heFJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlc0NvdW50PSAxMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPSAxMDAwXVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzcGVlZG9tZXRlcihzYW1wbGVzQ291bnQsIG1pbikge1xuICBzYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnQgfHwgMTA7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgbGV0IGhlYWQgPSAwO1xuICBsZXQgdGFpbCA9IDA7XG4gIGxldCBmaXJzdFNhbXBsZVRTO1xuXG4gIG1pbiA9IG1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogMTAwMDtcblxuICByZXR1cm4gZnVuY3Rpb24gcHVzaChjaHVua0xlbmd0aCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBzdGFydGVkQXQgPSB0aW1lc3RhbXBzW3RhaWxdO1xuXG4gICAgaWYgKCFmaXJzdFNhbXBsZVRTKSB7XG4gICAgICBmaXJzdFNhbXBsZVRTID0gbm93O1xuICAgIH1cblxuICAgIGJ5dGVzW2hlYWRdID0gY2h1bmtMZW5ndGg7XG4gICAgdGltZXN0YW1wc1toZWFkXSA9IG5vdztcblxuICAgIGxldCBpID0gdGFpbDtcbiAgICBsZXQgYnl0ZXNDb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoaSAhPT0gaGVhZCkge1xuICAgICAgYnl0ZXNDb3VudCArPSBieXRlc1tpKytdO1xuICAgICAgaSA9IGkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaGVhZCA9IChoZWFkICsgMSkgJSBzYW1wbGVzQ291bnQ7XG5cbiAgICBpZiAoaGVhZCA9PT0gdGFpbCkge1xuICAgICAgdGFpbCA9ICh0YWlsICsgMSkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKG5vdyAtIGZpcnN0U2FtcGxlVFMgPCBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXNzZWQgPSBzdGFydGVkQXQgJiYgbm93IC0gc3RhcnRlZEF0O1xuXG4gICAgcmV0dXJuIHBhc3NlZCA/IE1hdGgucm91bmQoYnl0ZXNDb3VudCAqIDEwMDAgLyBwYXNzZWQpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzcGVlZG9tZXRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHNldHRsZSBmcm9tICcuLy4uL2NvcmUvc2V0dGxlLmpzJztcbmltcG9ydCBjb29raWVzIGZyb20gJy4vLi4vaGVscGVycy9jb29raWVzLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSAnLi4vY29yZS9idWlsZEZ1bGxQYXRoLmpzJztcbmltcG9ydCBpc1VSTFNhbWVPcmlnaW4gZnJvbSAnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgcGFyc2VQcm90b2NvbCBmcm9tICcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IHNwZWVkb21ldGVyIGZyb20gJy4uL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMnO1xuXG5mdW5jdGlvbiBwcm9ncmVzc0V2ZW50UmVkdWNlcihsaXN0ZW5lciwgaXNEb3dubG9hZFN0cmVhbSkge1xuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XG4gIGNvbnN0IF9zcGVlZG9tZXRlciA9IHNwZWVkb21ldGVyKDUwLCAyNTApO1xuXG4gIHJldHVybiBlID0+IHtcbiAgICBjb25zdCBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICBjb25zdCB0b3RhbCA9IGUubGVuZ3RoQ29tcHV0YWJsZSA/IGUudG90YWwgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XG4gICAgY29uc3QgcmF0ZSA9IF9zcGVlZG9tZXRlcihwcm9ncmVzc0J5dGVzKTtcbiAgICBjb25zdCBpblJhbmdlID0gbG9hZGVkIDw9IHRvdGFsO1xuXG4gICAgYnl0ZXNOb3RpZmllZCA9IGxvYWRlZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsb2FkZWQsXG4gICAgICB0b3RhbCxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXG4gICAgICBieXRlczogcHJvZ3Jlc3NCeXRlcyxcbiAgICAgIHJhdGU6IHJhdGUgPyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiBlXG4gICAgfTtcblxuICAgIGRhdGFbaXNEb3dubG9hZFN0cmVhbSA/ICdkb3dubG9hZCcgOiAndXBsb2FkJ10gPSB0cnVlO1xuXG4gICAgbGlzdGVuZXIoZGF0YSk7XG4gIH07XG59XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGV0IHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG4gICAgY29uc3QgcmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkgJiYgKHBsYXRmb3JtLmlzU3RhbmRhcmRCcm93c2VyRW52IHx8IHBsYXRmb3JtLmlzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSkge1xuICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUoZmFsc2UpOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIGNvbnN0IHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICBjb25zdCBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oXG4gICAgICAgICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgJiYgcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyBBeGlvc0Vycm9yLkVUSU1FRE9VVCA6IEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHBsYXRmb3JtLmlzU3RhbmRhcmRCcm93c2VyRW52KSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIGNvbnN0IHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpXG4gICAgICAgICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKTtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVycy5zZXQoY29uZmlnLnhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihjb25maWcub25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKGZ1bGxQYXRoKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5cbmNvbnN0IGtub3duQWRhcHRlcnMgPSB7XG4gIGh0dHA6IGh0dHBBZGFwdGVyLFxuICB4aHI6IHhockFkYXB0ZXJcbn1cblxudXRpbHMuZm9yRWFjaChrbm93bkFkYXB0ZXJzLCAoZm4sIHZhbHVlKSA9PiB7XG4gIGlmKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7dmFsdWV9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnYWRhcHRlck5hbWUnLCB7dmFsdWV9KTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lT3JBZGFwdGVyID0gYWRhcHRlcnNbaV07XG4gICAgICBpZigoYWRhcHRlciA9IHV0aWxzLmlzU3RyaW5nKG5hbWVPckFkYXB0ZXIpID8ga25vd25BZGFwdGVyc1tuYW1lT3JBZGFwdGVyLnRvTG93ZXJDYXNlKCldIDogbmFtZU9yQWRhcHRlcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICBpZiAoYWRhcHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICAgYEFkYXB0ZXIgJHtuYW1lT3JBZGFwdGVyfSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudGAsXG4gICAgICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB1dGlscy5oYXNPd25Qcm9wKGtub3duQWRhcHRlcnMsIG5hbWVPckFkYXB0ZXIpID9cbiAgICAgICAgICBgQWRhcHRlciAnJHtuYW1lT3JBZGFwdGVyfScgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGRgIDpcbiAgICAgICAgICBgVW5rbm93biBhZGFwdGVyICcke25hbWVPckFkYXB0ZXJ9J2BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKGFkYXB0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhZGFwdGVyIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkYXB0ZXI7XG4gIH0sXG4gIGFkYXB0ZXJzOiBrbm93bkFkYXB0ZXJzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vdHJhbnNmb3JtRGF0YS5qcyc7XG5pbXBvcnQgaXNDYW5jZWwgZnJvbSAnLi4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBhZGFwdGVycyBmcm9tIFwiLi4vYWRhcHRlcnMvYWRhcHRlcnMuanNcIjtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbmZpZy5oZWFkZXJzKTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIGlmIChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uaW5kZXhPZihjb25maWcubWV0aG9kKSAhPT0gLTEpIHtcbiAgICBjb25maWcuaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgZmFsc2UpO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXIoY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcik7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vQXhpb3NIZWFkZXJzLmpzXCI7XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMgPyB0aGluZy50b0pTT04oKSA6IHRoaW5nO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICBjb25zdCBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgY2FzZWxlc3MpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlLmNhbGwoe2Nhc2VsZXNzfSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKGEsIGIsIGNhc2VsZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIGNhc2VsZXNzKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSwgY2FzZWxlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMoYSwgYiwgcHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVyZ2VNYXAgPSB7XG4gICAgdXJsOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIG1ldGhvZDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBkYXRhOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGJhc2VVUkw6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBwYXJhbXNTZXJpYWxpemVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dE1lc3NhZ2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGFkYXB0ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VUeXBlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZDb29raWVOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZIZWFkZXJOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGRlY29tcHJlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Q29udGVudExlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhCb2R5TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGJlZm9yZVJlZGlyZWN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zcG9ydDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cHNBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBjYW5jZWxUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBzb2NrZXRQYXRoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdmFsaWRhdGVTdGF0dXM6IG1lcmdlRGlyZWN0S2V5cyxcbiAgICBoZWFkZXJzOiAoYSwgYikgPT4gbWVyZ2VEZWVwUHJvcGVydGllcyhoZWFkZXJzVG9PYmplY3QoYSksIGhlYWRlcnNUb09iamVjdChiKSwgdHJ1ZSlcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKGNvbmZpZzEpLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSwgcHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuMy40XCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplciwgaGVhZGVyc30gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgc2VyaWFsaXplOiB2YWxpZGF0b3JzLmZ1bmN0aW9uXG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBjb250ZXh0SGVhZGVycztcblxuICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgIGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBjb250ZXh0SGVhZGVycyAmJiB1dGlscy5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmNvbmNhdChjb250ZXh0SGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICBsZXQgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgbGV0IHByb21pc2U7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW47XG5cbiAgICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LmJpbmQodGhpcyksIHVuZGVmaW5lZF07XG4gICAgICBjaGFpbi51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBjaGFpbi5wdXNoLmFwcGx5KGNoYWluLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgbGVuID0gY2hhaW4ubGVuZ3RoO1xuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIGxldCBuZXdDb25maWcgPSBjb25maWc7XG5cbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBvbkZ1bGZpbGxlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICBjb25zdCBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBvblJlamVjdGVkLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJvbWlzZSA9IGRpc3BhdGNoUmVxdWVzdC5jYWxsKHRoaXMsIG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgbGVuID0gcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBnZXRVcmkoY29uZmlnKSB7XG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuICB9XG59XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSFRUUE1ldGhvZChpc0Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaHR0cE1ldGhvZCh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YVxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2QgKyAnRm9ybSddID0gZ2VuZXJhdGVIVFRQTWV0aG9kKHRydWUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL0NhbmNlbGVkRXJyb3IuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn1cbiIsImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIdHRwU3RhdHVzQ29kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLkh0dHBTdGF0dXNDb2RlID0gSHR0cFN0YXR1c0NvZGU7XG5cbmF4aW9zLmRlZmF1bHQgPSBheGlvcztcblxuLy8gdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0XG5leHBvcnQgZGVmYXVsdCBheGlvc1xuIiwiaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xhc3Nlcy9ub3RpZmljYXRpb24nO1xuaW1wb3J0IExvZ2dlckZhY3RvcnksIHsgTG9nTGV2ZWxFbnVtIH0gZnJvbSAnemhpLWxvZyc7XG5pbXBvcnQgeyBGaWxlQ2xpZW50IH0gZnJvbSAnLi4vYXBpL2ZpbGUtYXBpJztcblxuaW1wb3J0IHpoX0NOIGZyb20gJy4uL2kxOG4vemhfQ04uanNvbic7XG5pbXBvcnQgZW5fVVMgZnJvbSAnLi4vaTE4bi9lbl9VUy5qc29uJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5cbmNvbnN0IGZhY3RvcnkgPSBMb2dnZXJGYWN0b3J5LmN1c3RvbUxvZ0ZhY3RvcnkoTG9nTGV2ZWxFbnVtLkxPR19MRVZFTF9JTkZPLCAnUGx1Z2luU3lzdGVtJyk7XG5jb25zdCBwbHVnaW5TeXN0ZW1Mb2dnZXIgPSBmYWN0b3J5LmdldExvZ2dlcigncGx1Z2luIHN5c3RlbScpO1xuXG5leHBvcnQgY29uc3QgbG9nID0gKC4uLnApID0+IHtcbiAgICBwbHVnaW5TeXN0ZW1Mb2dnZXIuaW5mbyguLi5wKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZXF1ZXN0ID0gYXhpb3MuY3JlYXRlKHtcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICBQcmFnbWE6ICduby1jYWNoZScsXG4gICAgICAgIEV4cGlyZXM6ICcwJyxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCBjb25zdCBzbGVlcCA9IGFzeW5jICh0OiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG51bGwpLCB0KTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBlcnJvciA9ICguLi5wKSA9PiBwbHVnaW5TeXN0ZW1Mb2dnZXIuZXJyb3IoLi4ucCk7XG5cbmV4cG9ydCBjb25zdCByZWxvYWRXaW5kb3cgPSAoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cbmV4cG9ydCBjb25zdCBnZXRDcm9zc1BsYXRmb3JtQXBwRGF0YUZvbGRlciA9ICgpID0+IHtcbiAgICBjb25zdCBQUk9DRVNTX0VOViA9IHdpbmRvdy5wcm9jZXNzPy5lbnY7XG4gICAgbGV0IGNvbmZpZ0ZpbGVQYXRoO1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgICBjb25maWdGaWxlUGF0aCA9IGAke1BST0NFU1NfRU5WLkhPTUV9L0xpYnJhcnkvQXBwbGljYXRpb24gU3VwcG9ydGA7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIC8vIFJvYW1pbmfljIXlkKvlnKhBUFBEQVRB5Lit5LqGXG4gICAgICAgIGNvbmZpZ0ZpbGVQYXRoID0gUFJPQ0VTU19FTlYuQVBQREFUQTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICAgICAgY29uZmlnRmlsZVBhdGggPSBQUk9DRVNTX0VOVi5IT01FO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnRmlsZVBhdGg7XG59O1xuXG4vKipcbiAqIGdlblVVSUQgIGdlbmVybmF0ZSBVVUlELCBjb3B5IGZyb20gc2l5dWFuXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgY29uc3QgZ2VuVVVJRCA9ICgpID0+XG4gICAgKFsxZTddLnRvU3RyaW5nKCkgKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgKGMpID0+XG4gICAgICAgIChwYXJzZUludChjLCAxMCkgXiAod2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXSAmICgxNSA+PiAocGFyc2VJbnQoYywgMTApIC8gNCkpKSkudG9TdHJpbmcoMTYpXG4gICAgKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlyKHA6IHN0cmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuIG5vdCBnZXQgZGlyIGJ5IHBhdGg6JyArIHApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNFeGlzdHMocDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgRmlsZUNsaWVudC5nZXRJbnN0YW5jZUFwaSgpLmZpbGVBcGkuZ2V0RmlsZShwKTtcbiAgICAgICAgcmV0dXJuIHJlcyAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbWVzc2FnZTogc3RyaW5nKSB7fVxufVxuZXhwb3J0IGNsYXNzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1lc3NhZ2U6IHN0cmluZykge31cbn1cbmV4cG9ydCBjbGFzcyBXYXJuaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1lc3NhZ2U6IHN0cmluZykge31cbn1cblxuZXhwb3J0IGNvbnN0IHNob3dJbmZvTWVzc2FnZSA9IChtZXNzYWdlOiBzdHJpbmcsIHRpbWVvdXQ/OiBudW1iZXIpID0+IG5ldyBOb3RpZmljYXRpb24oeyB0eXBlOiAnaW5mbycsIG1lc3NhZ2UsIHRpbWVvdXQgfSkuc2hvdygpO1xuZXhwb3J0IGNvbnN0IHNob3dFcnJvck1lc3NhZ2UgPSAobWVzc2FnZTogc3RyaW5nLCB0aW1lb3V0PzogbnVtYmVyKSA9PiBuZXcgTm90aWZpY2F0aW9uKHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZSwgdGltZW91dCB9KS5zaG93KCk7XG5cbmV4cG9ydCBjb25zdCBnZXRMb2dnZXIgPSAobmFtZTogc3RyaW5nKSA9PiBmYWN0b3J5LmdldExvZ2dlcihuYW1lKTtcblxuY29uc3QgbGFuZ3MgPSB7XG4gICAgemhfQ04sXG4gICAgZW5fVVMsXG59O1xuXG5leHBvcnQgY29uc3QgXyA9ICh2OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBsYW5nc1t3aW5kb3cuc2l5dWFuLmNvbmZpZy5sYW5nXVt2XSB8fCAnbm90IGRlZmluZWQnO1xufTtcbiIsImV4cG9ydCB2YXIgTkFNRURfVEFHID0gXCJuYW1lZFwiO1xuZXhwb3J0IHZhciBOQU1FX1RBRyA9IFwibmFtZVwiO1xuZXhwb3J0IHZhciBVTk1BTkFHRURfVEFHID0gXCJ1bm1hbmFnZWRcIjtcbmV4cG9ydCB2YXIgT1BUSU9OQUxfVEFHID0gXCJvcHRpb25hbFwiO1xuZXhwb3J0IHZhciBJTkpFQ1RfVEFHID0gXCJpbmplY3RcIjtcbmV4cG9ydCB2YXIgTVVMVElfSU5KRUNUX1RBRyA9IFwibXVsdGlfaW5qZWN0XCI7XG5leHBvcnQgdmFyIFRBR0dFRCA9IFwiaW52ZXJzaWZ5OnRhZ2dlZFwiO1xuZXhwb3J0IHZhciBUQUdHRURfUFJPUCA9IFwiaW52ZXJzaWZ5OnRhZ2dlZF9wcm9wc1wiO1xuZXhwb3J0IHZhciBQQVJBTV9UWVBFUyA9IFwiaW52ZXJzaWZ5OnBhcmFtdHlwZXNcIjtcbmV4cG9ydCB2YXIgREVTSUdOX1BBUkFNX1RZUEVTID0gXCJkZXNpZ246cGFyYW10eXBlc1wiO1xuZXhwb3J0IHZhciBQT1NUX0NPTlNUUlVDVCA9IFwicG9zdF9jb25zdHJ1Y3RcIjtcbmV4cG9ydCB2YXIgUFJFX0RFU1RST1kgPSBcInByZV9kZXN0cm95XCI7XG5mdW5jdGlvbiBnZXROb25DdXN0b21UYWdLZXlzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIElOSkVDVF9UQUcsXG4gICAgICAgIE1VTFRJX0lOSkVDVF9UQUcsXG4gICAgICAgIE5BTUVfVEFHLFxuICAgICAgICBVTk1BTkFHRURfVEFHLFxuICAgICAgICBOQU1FRF9UQUcsXG4gICAgICAgIE9QVElPTkFMX1RBRyxcbiAgICBdO1xufVxuZXhwb3J0IHZhciBOT05fQ1VTVE9NX1RBR19LRVlTID0gZ2V0Tm9uQ3VzdG9tVGFnS2V5cygpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGFfa2V5cy5qcy5tYXAiLCJ2YXIgQmluZGluZ1Njb3BlRW51bSA9IHtcbiAgICBSZXF1ZXN0OiBcIlJlcXVlc3RcIixcbiAgICBTaW5nbGV0b246IFwiU2luZ2xldG9uXCIsXG4gICAgVHJhbnNpZW50OiBcIlRyYW5zaWVudFwiXG59O1xudmFyIEJpbmRpbmdUeXBlRW51bSA9IHtcbiAgICBDb25zdGFudFZhbHVlOiBcIkNvbnN0YW50VmFsdWVcIixcbiAgICBDb25zdHJ1Y3RvcjogXCJDb25zdHJ1Y3RvclwiLFxuICAgIER5bmFtaWNWYWx1ZTogXCJEeW5hbWljVmFsdWVcIixcbiAgICBGYWN0b3J5OiBcIkZhY3RvcnlcIixcbiAgICBGdW5jdGlvbjogXCJGdW5jdGlvblwiLFxuICAgIEluc3RhbmNlOiBcIkluc3RhbmNlXCIsXG4gICAgSW52YWxpZDogXCJJbnZhbGlkXCIsXG4gICAgUHJvdmlkZXI6IFwiUHJvdmlkZXJcIlxufTtcbnZhciBUYXJnZXRUeXBlRW51bSA9IHtcbiAgICBDbGFzc1Byb3BlcnR5OiBcIkNsYXNzUHJvcGVydHlcIixcbiAgICBDb25zdHJ1Y3RvckFyZ3VtZW50OiBcIkNvbnN0cnVjdG9yQXJndW1lbnRcIixcbiAgICBWYXJpYWJsZTogXCJWYXJpYWJsZVwiXG59O1xuZXhwb3J0IHsgQmluZGluZ1Njb3BlRW51bSwgQmluZGluZ1R5cGVFbnVtLCBUYXJnZXRUeXBlRW51bSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0ZXJhbF90eXBlcy5qcy5tYXAiLCJ2YXIgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGlkKCkge1xuICAgIHJldHVybiBpZENvdW50ZXIrKztcbn1cbmV4cG9ydCB7IGlkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiLCJpbXBvcnQgeyBCaW5kaW5nU2NvcGVFbnVtLCBCaW5kaW5nVHlwZUVudW0gfSBmcm9tIFwiLi4vY29uc3RhbnRzL2xpdGVyYWxfdHlwZXNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL3V0aWxzL2lkXCI7XG52YXIgQmluZGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZyhzZXJ2aWNlSWRlbnRpZmllciwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VydmljZUlkZW50aWZpZXIgPSBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLnR5cGUgPSBCaW5kaW5nVHlwZUVudW0uSW52YWxpZDtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb25UeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQWN0aXZhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25EZWFjdGl2YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmR5bmFtaWNWYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIEJpbmRpbmcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgQmluZGluZyh0aGlzLnNlcnZpY2VJZGVudGlmaWVyLCB0aGlzLnNjb3BlKTtcbiAgICAgICAgY2xvbmUuYWN0aXZhdGVkID0gKGNsb25lLnNjb3BlID09PSBCaW5kaW5nU2NvcGVFbnVtLlNpbmdsZXRvbikgPyB0aGlzLmFjdGl2YXRlZCA6IGZhbHNlO1xuICAgICAgICBjbG9uZS5pbXBsZW1lbnRhdGlvblR5cGUgPSB0aGlzLmltcGxlbWVudGF0aW9uVHlwZTtcbiAgICAgICAgY2xvbmUuZHluYW1pY1ZhbHVlID0gdGhpcy5keW5hbWljVmFsdWU7XG4gICAgICAgIGNsb25lLnNjb3BlID0gdGhpcy5zY29wZTtcbiAgICAgICAgY2xvbmUudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgY2xvbmUuZmFjdG9yeSA9IHRoaXMuZmFjdG9yeTtcbiAgICAgICAgY2xvbmUucHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICBjbG9uZS5jb25zdHJhaW50ID0gdGhpcy5jb25zdHJhaW50O1xuICAgICAgICBjbG9uZS5vbkFjdGl2YXRpb24gPSB0aGlzLm9uQWN0aXZhdGlvbjtcbiAgICAgICAgY2xvbmUub25EZWFjdGl2YXRpb24gPSB0aGlzLm9uRGVhY3RpdmF0aW9uO1xuICAgICAgICBjbG9uZS5jYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nO1xufSgpKTtcbmV4cG9ydCB7IEJpbmRpbmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmcuanMubWFwIiwiZXhwb3J0IHZhciBEVVBMSUNBVEVEX0lOSkVDVEFCTEVfREVDT1JBVE9SID0gXCJDYW5ub3QgYXBwbHkgQGluamVjdGFibGUgZGVjb3JhdG9yIG11bHRpcGxlIHRpbWVzLlwiO1xuZXhwb3J0IHZhciBEVVBMSUNBVEVEX01FVEFEQVRBID0gXCJNZXRhZGF0YSBrZXkgd2FzIHVzZWQgbW9yZSB0aGFuIG9uY2UgaW4gYSBwYXJhbWV0ZXI6XCI7XG5leHBvcnQgdmFyIE5VTExfQVJHVU1FTlQgPSBcIk5VTEwgYXJndW1lbnRcIjtcbmV4cG9ydCB2YXIgS0VZX05PVF9GT1VORCA9IFwiS2V5IE5vdCBGb3VuZFwiO1xuZXhwb3J0IHZhciBBTUJJR1VPVVNfTUFUQ0ggPSBcIkFtYmlndW91cyBtYXRjaCBmb3VuZCBmb3Igc2VydmljZUlkZW50aWZpZXI6XCI7XG5leHBvcnQgdmFyIENBTk5PVF9VTkJJTkQgPSBcIkNvdWxkIG5vdCB1bmJpbmQgc2VydmljZUlkZW50aWZpZXI6XCI7XG5leHBvcnQgdmFyIE5PVF9SRUdJU1RFUkVEID0gXCJObyBtYXRjaGluZyBiaW5kaW5ncyBmb3VuZCBmb3Igc2VydmljZUlkZW50aWZpZXI6XCI7XG5leHBvcnQgdmFyIE1JU1NJTkdfSU5KRUNUQUJMRV9BTk5PVEFUSU9OID0gXCJNaXNzaW5nIHJlcXVpcmVkIEBpbmplY3RhYmxlIGFubm90YXRpb24gaW46XCI7XG5leHBvcnQgdmFyIE1JU1NJTkdfSU5KRUNUX0FOTk9UQVRJT04gPSBcIk1pc3NpbmcgcmVxdWlyZWQgQGluamVjdCBvciBAbXVsdGlJbmplY3QgYW5ub3RhdGlvbiBpbjpcIjtcbmV4cG9ydCB2YXIgVU5ERUZJTkVEX0lOSkVDVF9BTk5PVEFUSU9OID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gXCJAaW5qZWN0IGNhbGxlZCB3aXRoIHVuZGVmaW5lZCB0aGlzIGNvdWxkIG1lYW4gdGhhdCB0aGUgY2xhc3MgXCIgKyBuYW1lICsgXCIgaGFzIFwiICtcbiAgICAgICAgXCJhIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbS4gWW91IGNhbiB1c2UgYSBMYXp5U2VydmljZUlkZW50aWZlciB0byAgXCIgK1xuICAgICAgICBcIm92ZXJjb21lIHRoaXMgbGltaXRhdGlvbi5cIjtcbn07XG5leHBvcnQgdmFyIENJUkNVTEFSX0RFUEVOREVOQ1kgPSBcIkNpcmN1bGFyIGRlcGVuZGVuY3kgZm91bmQ6XCI7XG5leHBvcnQgdmFyIE5PVF9JTVBMRU1FTlRFRCA9IFwiU29ycnksIHRoaXMgZmVhdHVyZSBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQgeWV0LlwiO1xuZXhwb3J0IHZhciBJTlZBTElEX0JJTkRJTkdfVFlQRSA9IFwiSW52YWxpZCBiaW5kaW5nIHR5cGU6XCI7XG5leHBvcnQgdmFyIE5PX01PUkVfU05BUFNIT1RTX0FWQUlMQUJMRSA9IFwiTm8gc25hcHNob3QgYXZhaWxhYmxlIHRvIHJlc3RvcmUuXCI7XG5leHBvcnQgdmFyIElOVkFMSURfTUlERExFV0FSRV9SRVRVUk4gPSBcIkludmFsaWQgcmV0dXJuIHR5cGUgaW4gbWlkZGxld2FyZS4gTWlkZGxld2FyZSBtdXN0IHJldHVybiFcIjtcbmV4cG9ydCB2YXIgSU5WQUxJRF9GVU5DVElPTl9CSU5ESU5HID0gXCJWYWx1ZSBwcm92aWRlZCB0byBmdW5jdGlvbiBiaW5kaW5nIG11c3QgYmUgYSBmdW5jdGlvbiFcIjtcbmV4cG9ydCB2YXIgTEFaWV9JTl9TWU5DID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gXCJZb3UgYXJlIGF0dGVtcHRpbmcgdG8gY29uc3RydWN0ICdcIiArIGtleSArIFwiJyBpbiBhIHN5bmNocm9ub3VzIHdheVxcbiBidXQgaXQgaGFzIGFzeW5jaHJvbm91cyBkZXBlbmRlbmNpZXMuXCI7IH07XG5leHBvcnQgdmFyIElOVkFMSURfVE9fU0VMRl9WQUxVRSA9IFwiVGhlIHRvU2VsZiBmdW5jdGlvbiBjYW4gb25seSBiZSBhcHBsaWVkIHdoZW4gYSBjb25zdHJ1Y3RvciBpcyBcIiArXG4gICAgXCJ1c2VkIGFzIHNlcnZpY2UgaWRlbnRpZmllclwiO1xuZXhwb3J0IHZhciBJTlZBTElEX0RFQ09SQVRPUl9PUEVSQVRJT04gPSBcIlRoZSBAaW5qZWN0IEBtdWx0aUluamVjdCBAdGFnZ2VkIGFuZCBAbmFtZWQgZGVjb3JhdG9ycyBcIiArXG4gICAgXCJtdXN0IGJlIGFwcGxpZWQgdG8gdGhlIHBhcmFtZXRlcnMgb2YgYSBjbGFzcyBjb25zdHJ1Y3RvciBvciBhIGNsYXNzIHByb3BlcnR5LlwiO1xuZXhwb3J0IHZhciBBUkdVTUVOVFNfTEVOR1RIX01JU01BVENIID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIFwiVGhlIG51bWJlciBvZiBjb25zdHJ1Y3RvciBhcmd1bWVudHMgaW4gdGhlIGRlcml2ZWQgY2xhc3MgXCIgK1xuICAgICAgICAodmFsdWVzWzBdICsgXCIgbXVzdCBiZSA+PSB0aGFuIHRoZSBudW1iZXIgb2YgY29uc3RydWN0b3IgYXJndW1lbnRzIG9mIGl0cyBiYXNlIGNsYXNzLlwiKTtcbn07XG5leHBvcnQgdmFyIENPTlRBSU5FUl9PUFRJT05TX01VU1RfQkVfQU5fT0JKRUNUID0gXCJJbnZhbGlkIENvbnRhaW5lciBjb25zdHJ1Y3RvciBhcmd1bWVudC4gQ29udGFpbmVyIG9wdGlvbnMgXCIgK1xuICAgIFwibXVzdCBiZSBhbiBvYmplY3QuXCI7XG5leHBvcnQgdmFyIENPTlRBSU5FUl9PUFRJT05TX0lOVkFMSURfREVGQVVMVF9TQ09QRSA9IFwiSW52YWxpZCBDb250YWluZXIgb3B0aW9uLiBEZWZhdWx0IHNjb3BlIG11c3QgXCIgK1xuICAgIFwiYmUgYSBzdHJpbmcgKCdzaW5nbGV0b24nIG9yICd0cmFuc2llbnQnKS5cIjtcbmV4cG9ydCB2YXIgQ09OVEFJTkVSX09QVElPTlNfSU5WQUxJRF9BVVRPX0JJTkRfSU5KRUNUQUJMRSA9IFwiSW52YWxpZCBDb250YWluZXIgb3B0aW9uLiBBdXRvIGJpbmQgaW5qZWN0YWJsZSBtdXN0IFwiICtcbiAgICBcImJlIGEgYm9vbGVhblwiO1xuZXhwb3J0IHZhciBDT05UQUlORVJfT1BUSU9OU19JTlZBTElEX1NLSVBfQkFTRV9DSEVDSyA9IFwiSW52YWxpZCBDb250YWluZXIgb3B0aW9uLiBTa2lwIGJhc2UgY2hlY2sgbXVzdCBcIiArXG4gICAgXCJiZSBhIGJvb2xlYW5cIjtcbmV4cG9ydCB2YXIgTVVMVElQTEVfUFJFX0RFU1RST1lfTUVUSE9EUyA9IFwiQ2Fubm90IGFwcGx5IEBwcmVEZXN0cm95IGRlY29yYXRvciBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSBjbGFzc1wiO1xuZXhwb3J0IHZhciBNVUxUSVBMRV9QT1NUX0NPTlNUUlVDVF9NRVRIT0RTID0gXCJDYW5ub3QgYXBwbHkgQHBvc3RDb25zdHJ1Y3QgZGVjb3JhdG9yIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIGNsYXNzXCI7XG5leHBvcnQgdmFyIEFTWU5DX1VOQklORF9SRVFVSVJFRCA9IFwiQXR0ZW1wdGluZyB0byB1bmJpbmQgZGVwZW5kZW5jeSB3aXRoIGFzeW5jaHJvbm91cyBkZXN0cnVjdGlvbiAoQHByZURlc3Ryb3kgb3Igb25EZWFjdGl2YXRpb24pXCI7XG5leHBvcnQgdmFyIFBPU1RfQ09OU1RSVUNUX0VSUk9SID0gZnVuY3Rpb24gKGNsYXp6LCBlcnJvck1lc3NhZ2UpIHsgcmV0dXJuIFwiQHBvc3RDb25zdHJ1Y3QgZXJyb3IgaW4gY2xhc3MgXCIgKyBjbGF6eiArIFwiOiBcIiArIGVycm9yTWVzc2FnZTsgfTtcbmV4cG9ydCB2YXIgUFJFX0RFU1RST1lfRVJST1IgPSBmdW5jdGlvbiAoY2xhenosIGVycm9yTWVzc2FnZSkgeyByZXR1cm4gXCJAcHJlRGVzdHJveSBlcnJvciBpbiBjbGFzcyBcIiArIGNsYXp6ICsgXCI6IFwiICsgZXJyb3JNZXNzYWdlOyB9O1xuZXhwb3J0IHZhciBPTl9ERUFDVElWQVRJT05fRVJST1IgPSBmdW5jdGlvbiAoY2xhenosIGVycm9yTWVzc2FnZSkgeyByZXR1cm4gXCJvbkRlYWN0aXZhdGlvbigpIGVycm9yIGluIGNsYXNzIFwiICsgY2xhenogKyBcIjogXCIgKyBlcnJvck1lc3NhZ2U7IH07XG5leHBvcnQgdmFyIENJUkNVTEFSX0RFUEVOREVOQ1lfSU5fRkFDVE9SWSA9IGZ1bmN0aW9uIChmYWN0b3J5VHlwZSwgc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gXCJJdCBsb29rcyBsaWtlIHRoZXJlIGlzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpbiBvbmUgb2YgdGhlICdcIiArIGZhY3RvcnlUeXBlICsgXCInIGJpbmRpbmdzLiBQbGVhc2UgaW52ZXN0aWdhdGUgYmluZGluZ3Mgd2l0aFwiICtcbiAgICAgICAgKFwic2VydmljZSBpZGVudGlmaWVyICdcIiArIHNlcnZpY2VJZGVudGlmaWVyICsgXCInLlwiKTtcbn07XG5leHBvcnQgdmFyIFNUQUNLX09WRVJGTE9XID0gXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JfbXNncy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBNRVRBREFUQV9LRVkgZnJvbSBcIi4uL2NvbnN0YW50cy9tZXRhZGF0YV9rZXlzXCI7XG52YXIgTWV0YWRhdGFSZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ldGFkYXRhUmVhZGVyKCkge1xuICAgIH1cbiAgICBNZXRhZGF0YVJlYWRlci5wcm90b3R5cGUuZ2V0Q29uc3RydWN0b3JNZXRhZGF0YSA9IGZ1bmN0aW9uIChjb25zdHJ1Y3RvckZ1bmMpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVyR2VuZXJhdGVkTWV0YWRhdGEgPSBSZWZsZWN0LmdldE1ldGFkYXRhKE1FVEFEQVRBX0tFWS5QQVJBTV9UWVBFUywgY29uc3RydWN0b3JGdW5jKTtcbiAgICAgICAgdmFyIHVzZXJHZW5lcmF0ZWRNZXRhZGF0YSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoTUVUQURBVEFfS0VZLlRBR0dFRCwgY29uc3RydWN0b3JGdW5jKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXBpbGVyR2VuZXJhdGVkTWV0YWRhdGE6IGNvbXBpbGVyR2VuZXJhdGVkTWV0YWRhdGEsXG4gICAgICAgICAgICB1c2VyR2VuZXJhdGVkTWV0YWRhdGE6IHVzZXJHZW5lcmF0ZWRNZXRhZGF0YSB8fCB7fVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWV0YWRhdGFSZWFkZXIucHJvdG90eXBlLmdldFByb3BlcnRpZXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChjb25zdHJ1Y3RvckZ1bmMpIHtcbiAgICAgICAgdmFyIHVzZXJHZW5lcmF0ZWRNZXRhZGF0YSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoTUVUQURBVEFfS0VZLlRBR0dFRF9QUk9QLCBjb25zdHJ1Y3RvckZ1bmMpIHx8IFtdO1xuICAgICAgICByZXR1cm4gdXNlckdlbmVyYXRlZE1ldGFkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIE1ldGFkYXRhUmVhZGVyO1xufSgpKTtcbmV4cG9ydCB7IE1ldGFkYXRhUmVhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YV9yZWFkZXIuanMubWFwIiwidmFyIEJpbmRpbmdDb3VudCA9IHtcbiAgICBNdWx0aXBsZUJpbmRpbmdzQXZhaWxhYmxlOiAyLFxuICAgIE5vQmluZGluZ3NBdmFpbGFibGU6IDAsXG4gICAgT25seU9uZUJpbmRpbmdBdmFpbGFibGU6IDFcbn07XG5leHBvcnQgeyBCaW5kaW5nQ291bnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmdfY291bnQuanMubWFwIiwiaW1wb3J0ICogYXMgRVJST1JfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1N0YWNrT3ZlcmZsb3dFeGVwdGlvbihlcnJvcikge1xuICAgIHJldHVybiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPT09IEVSUk9SX01TR1MuU1RBQ0tfT1ZFUkZMT1cpO1xufVxuZXhwb3J0IHZhciB0cnlBbmRUaHJvd0Vycm9ySWZTdGFja092ZXJmbG93ID0gZnVuY3Rpb24gKGZuLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNTdGFja092ZXJmbG93RXhlcHRpb24oZXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9ucy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBFUlJPUl9NU0dTIGZyb20gXCIuLi9jb25zdGFudHMvZXJyb3JfbXNnc1wiO1xuZnVuY3Rpb24gZ2V0U2VydmljZUlkZW50aWZpZXJBc1N0cmluZyhzZXJ2aWNlSWRlbnRpZmllcikge1xuICAgIGlmICh0eXBlb2Ygc2VydmljZUlkZW50aWZpZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgX3NlcnZpY2VJZGVudGlmaWVyID0gc2VydmljZUlkZW50aWZpZXI7XG4gICAgICAgIHJldHVybiBfc2VydmljZUlkZW50aWZpZXIubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlcnZpY2VJZGVudGlmaWVyID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlSWRlbnRpZmllci50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9zZXJ2aWNlSWRlbnRpZmllciA9IHNlcnZpY2VJZGVudGlmaWVyO1xuICAgICAgICByZXR1cm4gX3NlcnZpY2VJZGVudGlmaWVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3RSZWdpc3RlcmVkQmluZGluZ3NGb3JTZXJ2aWNlSWRlbnRpZmllcihjb250YWluZXIsIHNlcnZpY2VJZGVudGlmaWVyLCBnZXRCaW5kaW5ncykge1xuICAgIHZhciByZWdpc3RlcmVkQmluZGluZ3NMaXN0ID0gXCJcIjtcbiAgICB2YXIgcmVnaXN0ZXJlZEJpbmRpbmdzID0gZ2V0QmluZGluZ3MoY29udGFpbmVyLCBzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgaWYgKHJlZ2lzdGVyZWRCaW5kaW5ncy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVnaXN0ZXJlZEJpbmRpbmdzTGlzdCA9IFwiXFxuUmVnaXN0ZXJlZCBiaW5kaW5nczpcIjtcbiAgICAgICAgcmVnaXN0ZXJlZEJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJPYmplY3RcIjtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmltcGxlbWVudGF0aW9uVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUoYmluZGluZy5pbXBsZW1lbnRhdGlvblR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnaXN0ZXJlZEJpbmRpbmdzTGlzdCA9IHJlZ2lzdGVyZWRCaW5kaW5nc0xpc3QgKyBcIlxcbiBcIiArIG5hbWU7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5jb25zdHJhaW50Lm1ldGFEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZEJpbmRpbmdzTGlzdCA9IHJlZ2lzdGVyZWRCaW5kaW5nc0xpc3QgKyBcIiAtIFwiICsgYmluZGluZy5jb25zdHJhaW50Lm1ldGFEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWRCaW5kaW5nc0xpc3Q7XG59XG5mdW5jdGlvbiBhbHJlYWR5RGVwZW5kZW5jeUNoYWluKHJlcXVlc3QsIHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgaWYgKHJlcXVlc3QucGFyZW50UmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcXVlc3QucGFyZW50UmVxdWVzdC5zZXJ2aWNlSWRlbnRpZmllciA9PT0gc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWxyZWFkeURlcGVuZGVuY3lDaGFpbihyZXF1ZXN0LnBhcmVudFJlcXVlc3QsIHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXBlbmRlbmN5Q2hhaW5Ub1N0cmluZyhyZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gX2NyZWF0ZVN0cmluZ0FycihyZXEsIHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gW107IH1cbiAgICAgICAgdmFyIHNlcnZpY2VJZGVudGlmaWVyID0gZ2V0U2VydmljZUlkZW50aWZpZXJBc1N0cmluZyhyZXEuc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICByZXN1bHQucHVzaChzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgICAgIGlmIChyZXEucGFyZW50UmVxdWVzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVTdHJpbmdBcnIocmVxLnBhcmVudFJlcXVlc3QsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIHN0cmluZ0FyciA9IF9jcmVhdGVTdHJpbmdBcnIocmVxdWVzdCk7XG4gICAgcmV0dXJuIHN0cmluZ0Fyci5yZXZlcnNlKCkuam9pbihcIiAtLT4gXCIpO1xufVxuZnVuY3Rpb24gY2lyY3VsYXJEZXBlbmRlbmN5VG9FeGNlcHRpb24ocmVxdWVzdCkge1xuICAgIHJlcXVlc3QuY2hpbGRSZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFJlcXVlc3QpIHtcbiAgICAgICAgaWYgKGFscmVhZHlEZXBlbmRlbmN5Q2hhaW4oY2hpbGRSZXF1ZXN0LCBjaGlsZFJlcXVlc3Quc2VydmljZUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB2YXIgc2VydmljZXMgPSBkZXBlbmRlbmN5Q2hhaW5Ub1N0cmluZyhjaGlsZFJlcXVlc3QpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuQ0lSQ1VMQVJfREVQRU5ERU5DWSArIFwiIFwiICsgc2VydmljZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2lyY3VsYXJEZXBlbmRlbmN5VG9FeGNlcHRpb24oY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gbGlzdE1ldGFkYXRhRm9yVGFyZ2V0KHNlcnZpY2VJZGVudGlmaWVyU3RyaW5nLCB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LmlzVGFnZ2VkKCkgfHwgdGFyZ2V0LmlzTmFtZWQoKSkge1xuICAgICAgICB2YXIgbV8xID0gXCJcIjtcbiAgICAgICAgdmFyIG5hbWVkVGFnID0gdGFyZ2V0LmdldE5hbWVkVGFnKCk7XG4gICAgICAgIHZhciBvdGhlclRhZ3MgPSB0YXJnZXQuZ2V0Q3VzdG9tVGFncygpO1xuICAgICAgICBpZiAobmFtZWRUYWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1fMSArPSBuYW1lZFRhZy50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJUYWdzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvdGhlclRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgbV8xICs9IHRhZy50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIiBcIiArIHNlcnZpY2VJZGVudGlmaWVyU3RyaW5nICsgXCJcXG4gXCIgKyBzZXJ2aWNlSWRlbnRpZmllclN0cmluZyArIFwiIC0gXCIgKyBtXzE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gXCIgXCIgKyBzZXJ2aWNlSWRlbnRpZmllclN0cmluZztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZnVuYykge1xuICAgIGlmIChmdW5jLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSBmdW5jLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBtYXRjaCA9IG5hbWVfMS5tYXRjaCgvXmZ1bmN0aW9uXFxzKihbXlxccyhdKykvKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBcIkFub255bW91cyBmdW5jdGlvbjogXCIgKyBuYW1lXzE7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3ltYm9sRGVzY3JpcHRpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHN5bWJvbC50b1N0cmluZygpLnNsaWNlKDcsIC0xKTtcbn1cbmV4cG9ydCB7IGdldEZ1bmN0aW9uTmFtZSwgZ2V0U2VydmljZUlkZW50aWZpZXJBc1N0cmluZywgbGlzdFJlZ2lzdGVyZWRCaW5kaW5nc0ZvclNlcnZpY2VJZGVudGlmaWVyLCBsaXN0TWV0YWRhdGFGb3JUYXJnZXQsIGNpcmN1bGFyRGVwZW5kZW5jeVRvRXhjZXB0aW9uLCBnZXRTeW1ib2xEZXNjcmlwdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXphdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBpZCB9IGZyb20gXCIuLi91dGlscy9pZFwiO1xudmFyIENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRleHQoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgQ29udGV4dC5wcm90b3R5cGUuYWRkUGxhbiA9IGZ1bmN0aW9uIChwbGFuKSB7XG4gICAgICAgIHRoaXMucGxhbiA9IHBsYW47XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS5zZXRDdXJyZW50UmVxdWVzdCA9IGZ1bmN0aW9uIChjdXJyZW50UmVxdWVzdCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0ID0gY3VycmVudFJlcXVlc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGV4dDtcbn0oKSk7XG5leHBvcnQgeyBDb250ZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcCIsImltcG9ydCAqIGFzIE1FVEFEQVRBX0tFWSBmcm9tIFwiLi4vY29uc3RhbnRzL21ldGFkYXRhX2tleXNcIjtcbnZhciBNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWV0YWRhdGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBNZXRhZGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmtleSA9PT0gTUVUQURBVEFfS0VZLk5BTUVEX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIFwibmFtZWQ6IFwiICsgU3RyaW5nKHRoaXMudmFsdWUpLnRvU3RyaW5nKCkgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcInRhZ2dlZDogeyBrZXk6XCIgKyB0aGlzLmtleS50b1N0cmluZygpICsgXCIsIHZhbHVlOiBcIiArIFN0cmluZyh0aGlzLnZhbHVlKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydCB7IE1ldGFkYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCJ2YXIgUGxhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhbihwYXJlbnRDb250ZXh0LCByb290UmVxdWVzdCkge1xuICAgICAgICB0aGlzLnBhcmVudENvbnRleHQgPSBwYXJlbnRDb250ZXh0O1xuICAgICAgICB0aGlzLnJvb3RSZXF1ZXN0ID0gcm9vdFJlcXVlc3Q7XG4gICAgfVxuICAgIHJldHVybiBQbGFuO1xufSgpKTtcbmV4cG9ydCB7IFBsYW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYW4uanMubWFwIiwidmFyIExhenlTZXJ2aWNlSWRlbnRpZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXp5U2VydmljZUlkZW50aWZlcihjYikge1xuICAgICAgICB0aGlzLl9jYiA9IGNiO1xuICAgIH1cbiAgICBMYXp5U2VydmljZUlkZW50aWZlci5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2IoKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXp5U2VydmljZUlkZW50aWZlcjtcbn0oKSk7XG5leHBvcnQgeyBMYXp5U2VydmljZUlkZW50aWZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eV9zZXJ2aWNlX2lkZW50aWZpZXIuanMubWFwIiwidmFyIFF1ZXJ5YWJsZVN0cmluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVlcnlhYmxlU3RyaW5nKHN0cikge1xuICAgICAgICB0aGlzLnN0ciA9IHN0cjtcbiAgICB9XG4gICAgUXVlcnlhYmxlU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcpID09PSAwO1xuICAgIH07XG4gICAgUXVlcnlhYmxlU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcpIHtcbiAgICAgICAgdmFyIHJldmVyc2VTdHJpbmcgPSBcIlwiO1xuICAgICAgICB2YXIgcmV2ZXJzZVNlYXJjaFN0cmluZyA9IHNlYXJjaFN0cmluZy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgcmV2ZXJzZVN0cmluZyA9IHRoaXMuc3RyLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoLmNhbGwoeyBzdHI6IHJldmVyc2VTdHJpbmcgfSwgcmV2ZXJzZVNlYXJjaFN0cmluZyk7XG4gICAgfTtcbiAgICBRdWVyeWFibGVTdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nKSAhPT0gLTEpO1xuICAgIH07XG4gICAgUXVlcnlhYmxlU3RyaW5nLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoY29tcGFyZVN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHIgPT09IGNvbXBhcmVTdHJpbmc7XG4gICAgfTtcbiAgICBRdWVyeWFibGVTdHJpbmcucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfTtcbiAgICByZXR1cm4gUXVlcnlhYmxlU3RyaW5nO1xufSgpKTtcbmV4cG9ydCB7IFF1ZXJ5YWJsZVN0cmluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlhYmxlX3N0cmluZy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBNRVRBREFUQV9LRVkgZnJvbSAnLi4vY29uc3RhbnRzL21ldGFkYXRhX2tleXMnO1xuaW1wb3J0IHsgaWQgfSBmcm9tICcuLi91dGlscy9pZCc7XG5pbXBvcnQgeyBnZXRTeW1ib2xEZXNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL3NlcmlhbGl6YXRpb24nO1xuaW1wb3J0IHsgTWV0YWRhdGEgfSBmcm9tICcuL21ldGFkYXRhJztcbmltcG9ydCB7IFF1ZXJ5YWJsZVN0cmluZyB9IGZyb20gJy4vcXVlcnlhYmxlX3N0cmluZyc7XG52YXIgVGFyZ2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYXJnZXQodHlwZSwgaWRlbnRpZmllciwgc2VydmljZUlkZW50aWZpZXIsIG5hbWVkT3JUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VydmljZUlkZW50aWZpZXIgPSBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgICAgdmFyIHF1ZXJ5YWJsZU5hbWUgPSB0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N5bWJvbCcgPyBnZXRTeW1ib2xEZXNjcmlwdGlvbihpZGVudGlmaWVyKSA6IGlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5ldyBRdWVyeWFibGVTdHJpbmcocXVlcnlhYmxlTmFtZSB8fCBcIlwiKTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB2YXIgbWV0YWRhdGFJdGVtID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lZE9yVGFnZ2VkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWV0YWRhdGFJdGVtID0gbmV3IE1ldGFkYXRhKE1FVEFEQVRBX0tFWS5OQU1FRF9UQUcsIG5hbWVkT3JUYWdnZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWVkT3JUYWdnZWQgaW5zdGFuY2VvZiBNZXRhZGF0YSkge1xuICAgICAgICAgICAgbWV0YWRhdGFJdGVtID0gbmFtZWRPclRhZ2dlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGFJdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnB1c2gobWV0YWRhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUYXJnZXQucHJvdG90eXBlLmhhc1RhZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubWV0YWRhdGE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChtLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGFyZ2V0LnByb3RvdHlwZS5pc0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUYWcoTUVUQURBVEFfS0VZLk1VTFRJX0lOSkVDVF9UQUcpO1xuICAgIH07XG4gICAgVGFyZ2V0LnByb3RvdHlwZS5tYXRjaGVzQXJyYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzVGFnKE1FVEFEQVRBX0tFWS5NVUxUSV9JTkpFQ1RfVEFHKShuYW1lKTtcbiAgICB9O1xuICAgIFRhcmdldC5wcm90b3R5cGUuaXNOYW1lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVGFnKE1FVEFEQVRBX0tFWS5OQU1FRF9UQUcpO1xuICAgIH07XG4gICAgVGFyZ2V0LnByb3RvdHlwZS5pc1RhZ2dlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEuc29tZShmdW5jdGlvbiAobWV0YWRhdGEpIHsgcmV0dXJuIE1FVEFEQVRBX0tFWS5OT05fQ1VTVE9NX1RBR19LRVlTLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG1ldGFkYXRhLmtleSAhPT0ga2V5OyB9KTsgfSk7XG4gICAgfTtcbiAgICBUYXJnZXQucHJvdG90eXBlLmlzT3B0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXNUYWcoTUVUQURBVEFfS0VZLk9QVElPTkFMX1RBRykodHJ1ZSk7XG4gICAgfTtcbiAgICBUYXJnZXQucHJvdG90eXBlLmdldE5hbWVkVGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc05hbWVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5rZXkgPT09IE1FVEFEQVRBX0tFWS5OQU1FRF9UQUc7IH0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFyZ2V0LnByb3RvdHlwZS5nZXRDdXN0b21UYWdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1RhZ2dlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5maWx0ZXIoZnVuY3Rpb24gKG1ldGFkYXRhKSB7IHJldHVybiBNRVRBREFUQV9LRVkuTk9OX0NVU1RPTV9UQUdfS0VZUy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBtZXRhZGF0YS5rZXkgIT09IGtleTsgfSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhcmdldC5wcm90b3R5cGUubWF0Y2hlc05hbWVkVGFnID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlc1RhZyhNRVRBREFUQV9LRVkuTkFNRURfVEFHKShuYW1lKTtcbiAgICB9O1xuICAgIFRhcmdldC5wcm90b3R5cGUubWF0Y2hlc1RhZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLm1ldGFkYXRhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBtID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChtLmtleSA9PT0ga2V5ICYmIG0udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUYXJnZXQ7XG59KCkpO1xuZXhwb3J0IHsgVGFyZ2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXJnZXQuanMubWFwIiwidmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuaW1wb3J0IHsgTGF6eVNlcnZpY2VJZGVudGlmZXIgfSBmcm9tIFwiLi4vYW5ub3RhdGlvbi9sYXp5X3NlcnZpY2VfaWRlbnRpZmllclwiO1xuaW1wb3J0ICogYXMgRVJST1JfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCB7IFRhcmdldFR5cGVFbnVtIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9saXRlcmFsX3R5cGVzXCI7XG5pbXBvcnQgKiBhcyBNRVRBREFUQV9LRVkgZnJvbSBcIi4uL2NvbnN0YW50cy9tZXRhZGF0YV9rZXlzXCI7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbk5hbWUgfSBmcm9tIFwiLi4vdXRpbHMvc2VyaWFsaXphdGlvblwiO1xuaW1wb3J0IHsgVGFyZ2V0IH0gZnJvbSBcIi4vdGFyZ2V0XCI7XG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMobWV0YWRhdGFSZWFkZXIsIGZ1bmMpIHtcbiAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gZ2V0RnVuY3Rpb25OYW1lKGZ1bmMpO1xuICAgIHJldHVybiBnZXRUYXJnZXRzKG1ldGFkYXRhUmVhZGVyLCBjb25zdHJ1Y3Rvck5hbWUsIGZ1bmMsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldHMobWV0YWRhdGFSZWFkZXIsIGNvbnN0cnVjdG9yTmFtZSwgZnVuYywgaXNCYXNlQ2xhc3MpIHtcbiAgICB2YXIgbWV0YWRhdGEgPSBtZXRhZGF0YVJlYWRlci5nZXRDb25zdHJ1Y3Rvck1ldGFkYXRhKGZ1bmMpO1xuICAgIHZhciBzZXJ2aWNlSWRlbnRpZmllcnMgPSBtZXRhZGF0YS5jb21waWxlckdlbmVyYXRlZE1ldGFkYXRhO1xuICAgIGlmIChzZXJ2aWNlSWRlbnRpZmllcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbXNnID0gRVJST1JfTVNHUy5NSVNTSU5HX0lOSkVDVEFCTEVfQU5OT1RBVElPTiArIFwiIFwiICsgY29uc3RydWN0b3JOYW1lICsgXCIuXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICB2YXIgY29uc3RydWN0b3JBcmdzTWV0YWRhdGEgPSBtZXRhZGF0YS51c2VyR2VuZXJhdGVkTWV0YWRhdGE7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25zdHJ1Y3RvckFyZ3NNZXRhZGF0YSk7XG4gICAgdmFyIGhhc1VzZXJEZWNsYXJlZFVua25vd25JbmplY3Rpb25zID0gKGZ1bmMubGVuZ3RoID09PSAwICYmIGtleXMubGVuZ3RoID4gMCk7XG4gICAgdmFyIGhhc09wdGlvbmFsUGFyYW1ldGVycyA9IGtleXMubGVuZ3RoID4gZnVuYy5sZW5ndGg7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAoaGFzVXNlckRlY2xhcmVkVW5rbm93bkluamVjdGlvbnMgfHwgaGFzT3B0aW9uYWxQYXJhbWV0ZXJzKSA/IGtleXMubGVuZ3RoIDogZnVuYy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yVGFyZ2V0cyA9IGdldENvbnN0cnVjdG9yQXJnc0FzVGFyZ2V0cyhpc0Jhc2VDbGFzcywgY29uc3RydWN0b3JOYW1lLCBzZXJ2aWNlSWRlbnRpZmllcnMsIGNvbnN0cnVjdG9yQXJnc01ldGFkYXRhLCBpdGVyYXRpb25zKTtcbiAgICB2YXIgcHJvcGVydHlUYXJnZXRzID0gZ2V0Q2xhc3NQcm9wc0FzVGFyZ2V0cyhtZXRhZGF0YVJlYWRlciwgZnVuYywgY29uc3RydWN0b3JOYW1lKTtcbiAgICB2YXIgdGFyZ2V0cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgY29uc3RydWN0b3JUYXJnZXRzLCB0cnVlKSwgcHJvcGVydHlUYXJnZXRzLCB0cnVlKTtcbiAgICByZXR1cm4gdGFyZ2V0cztcbn1cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yQXJnc0FzVGFyZ2V0KGluZGV4LCBpc0Jhc2VDbGFzcywgY29uc3RydWN0b3JOYW1lLCBzZXJ2aWNlSWRlbnRpZmllcnMsIGNvbnN0cnVjdG9yQXJnc01ldGFkYXRhKSB7XG4gICAgdmFyIHRhcmdldE1ldGFkYXRhID0gY29uc3RydWN0b3JBcmdzTWV0YWRhdGFbaW5kZXgudG9TdHJpbmcoKV0gfHwgW107XG4gICAgdmFyIG1ldGFkYXRhID0gZm9ybWF0VGFyZ2V0TWV0YWRhdGEodGFyZ2V0TWV0YWRhdGEpO1xuICAgIHZhciBpc01hbmFnZWQgPSBtZXRhZGF0YS51bm1hbmFnZWQgIT09IHRydWU7XG4gICAgdmFyIHNlcnZpY2VJZGVudGlmaWVyID0gc2VydmljZUlkZW50aWZpZXJzW2luZGV4XTtcbiAgICB2YXIgaW5qZWN0SWRlbnRpZmllciA9IChtZXRhZGF0YS5pbmplY3QgfHwgbWV0YWRhdGEubXVsdGlJbmplY3QpO1xuICAgIHNlcnZpY2VJZGVudGlmaWVyID0gKGluamVjdElkZW50aWZpZXIpID8gKGluamVjdElkZW50aWZpZXIpIDogc2VydmljZUlkZW50aWZpZXI7XG4gICAgaWYgKHNlcnZpY2VJZGVudGlmaWVyIGluc3RhbmNlb2YgTGF6eVNlcnZpY2VJZGVudGlmZXIpIHtcbiAgICAgICAgc2VydmljZUlkZW50aWZpZXIgPSBzZXJ2aWNlSWRlbnRpZmllci51bndyYXAoKTtcbiAgICB9XG4gICAgaWYgKGlzTWFuYWdlZCkge1xuICAgICAgICB2YXIgaXNPYmplY3QgPSBzZXJ2aWNlSWRlbnRpZmllciA9PT0gT2JqZWN0O1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHNlcnZpY2VJZGVudGlmaWVyID09PSBGdW5jdGlvbjtcbiAgICAgICAgdmFyIGlzVW5kZWZpbmVkID0gc2VydmljZUlkZW50aWZpZXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGlzVW5rbm93blR5cGUgPSAoaXNPYmplY3QgfHwgaXNGdW5jdGlvbiB8fCBpc1VuZGVmaW5lZCk7XG4gICAgICAgIGlmICghaXNCYXNlQ2xhc3MgJiYgaXNVbmtub3duVHlwZSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IEVSUk9SX01TR1MuTUlTU0lOR19JTkpFQ1RfQU5OT1RBVElPTiArIFwiIGFyZ3VtZW50IFwiICsgaW5kZXggKyBcIiBpbiBjbGFzcyBcIiArIGNvbnN0cnVjdG9yTmFtZSArIFwiLlwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldCA9IG5ldyBUYXJnZXQoVGFyZ2V0VHlwZUVudW0uQ29uc3RydWN0b3JBcmd1bWVudCwgbWV0YWRhdGEudGFyZ2V0TmFtZSwgc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICB0YXJnZXQubWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3RvckFyZ3NBc1RhcmdldHMoaXNCYXNlQ2xhc3MsIGNvbnN0cnVjdG9yTmFtZSwgc2VydmljZUlkZW50aWZpZXJzLCBjb25zdHJ1Y3RvckFyZ3NNZXRhZGF0YSwgaXRlcmF0aW9ucykge1xuICAgIHZhciB0YXJnZXRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldENvbnN0cnVjdG9yQXJnc0FzVGFyZ2V0KGluZGV4LCBpc0Jhc2VDbGFzcywgY29uc3RydWN0b3JOYW1lLCBzZXJ2aWNlSWRlbnRpZmllcnMsIGNvbnN0cnVjdG9yQXJnc01ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldHM7XG59XG5mdW5jdGlvbiBfZ2V0U2VydmljZUlkZW50aWZpZXJGb3JQcm9wZXJ0eShpbmplY3QsIG11bHRpSW5qZWN0LCBwcm9wZXJ0eU5hbWUsIGNsYXNzTmFtZSkge1xuICAgIHZhciBzZXJ2aWNlSWRlbnRpZmllciA9IChpbmplY3QgfHwgbXVsdGlJbmplY3QpO1xuICAgIGlmIChzZXJ2aWNlSWRlbnRpZmllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtc2cgPSBFUlJPUl9NU0dTLk1JU1NJTkdfSU5KRUNUQUJMRV9BTk5PVEFUSU9OICsgXCIgZm9yIHByb3BlcnR5IFwiICsgU3RyaW5nKHByb3BlcnR5TmFtZSkgKyBcIiBpbiBjbGFzcyBcIiArIGNsYXNzTmFtZSArIFwiLlwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcnZpY2VJZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gZ2V0Q2xhc3NQcm9wc0FzVGFyZ2V0cyhtZXRhZGF0YVJlYWRlciwgY29uc3RydWN0b3JGdW5jLCBjb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICB2YXIgY2xhc3NQcm9wc01ldGFkYXRhID0gbWV0YWRhdGFSZWFkZXIuZ2V0UHJvcGVydGllc01ldGFkYXRhKGNvbnN0cnVjdG9yRnVuYyk7XG4gICAgdmFyIHRhcmdldHMgPSBbXTtcbiAgICB2YXIgc3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoY2xhc3NQcm9wc01ldGFkYXRhKTtcbiAgICB2YXIgc3RyaW5nS2V5cyA9IE9iamVjdC5rZXlzKGNsYXNzUHJvcHNNZXRhZGF0YSk7XG4gICAgdmFyIGtleXMgPSBzdHJpbmdLZXlzLmNvbmNhdChzeW1ib2xLZXlzKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c18xW19pXTtcbiAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gY2xhc3NQcm9wc01ldGFkYXRhW2tleV07XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGZvcm1hdFRhcmdldE1ldGFkYXRhKHRhcmdldE1ldGFkYXRhKTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBtZXRhZGF0YS50YXJnZXROYW1lIHx8IGtleTtcbiAgICAgICAgdmFyIHNlcnZpY2VJZGVudGlmaWVyID0gX2dldFNlcnZpY2VJZGVudGlmaWVyRm9yUHJvcGVydHkobWV0YWRhdGEuaW5qZWN0LCBtZXRhZGF0YS5tdWx0aUluamVjdCwga2V5LCBjb25zdHJ1Y3Rvck5hbWUpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3IFRhcmdldChUYXJnZXRUeXBlRW51bS5DbGFzc1Byb3BlcnR5LCBpZGVudGlmaWVyLCBzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgICAgIHRhcmdldC5tZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhO1xuICAgICAgICB0YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGJhc2VDb25zdHJ1Y3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3RvckZ1bmMucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoYmFzZUNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgdmFyIGJhc2VUYXJnZXRzID0gZ2V0Q2xhc3NQcm9wc0FzVGFyZ2V0cyhtZXRhZGF0YVJlYWRlciwgYmFzZUNvbnN0cnVjdG9yLCBjb25zdHJ1Y3Rvck5hbWUpO1xuICAgICAgICB0YXJnZXRzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCB0YXJnZXRzLCB0cnVlKSwgYmFzZVRhcmdldHMsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0cztcbn1cbmZ1bmN0aW9uIGdldEJhc2VDbGFzc0RlcGVuZGVuY3lDb3VudChtZXRhZGF0YVJlYWRlciwgZnVuYykge1xuICAgIHZhciBiYXNlQ29uc3RydWN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuYy5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICAgIGlmIChiYXNlQ29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICB2YXIgYmFzZUNvbnN0cnVjdG9yTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShiYXNlQ29uc3RydWN0b3IpO1xuICAgICAgICB2YXIgdGFyZ2V0cyA9IGdldFRhcmdldHMobWV0YWRhdGFSZWFkZXIsIGJhc2VDb25zdHJ1Y3Rvck5hbWUsIGJhc2VDb25zdHJ1Y3RvciwgdHJ1ZSk7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHRhcmdldHMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Lm1ldGFkYXRhLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5rZXkgPT09IE1FVEFEQVRBX0tFWS5VTk1BTkFHRURfVEFHOyB9KTsgfSk7XG4gICAgICAgIHZhciB1bm1hbmFnZWRDb3VudCA9IFtdLmNvbmNhdC5hcHBseShbXSwgbWV0YWRhdGEpLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlcGVuZGVuY3lDb3VudCA9IHRhcmdldHMubGVuZ3RoIC0gdW5tYW5hZ2VkQ291bnQ7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jeUNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJhc2VDbGFzc0RlcGVuZGVuY3lDb3VudChtZXRhZGF0YVJlYWRlciwgYmFzZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0VGFyZ2V0TWV0YWRhdGEodGFyZ2V0TWV0YWRhdGEpIHtcbiAgICB2YXIgdGFyZ2V0TWV0YWRhdGFNYXAgPSB7fTtcbiAgICB0YXJnZXRNZXRhZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHRhcmdldE1ldGFkYXRhTWFwW20ua2V5LnRvU3RyaW5nKCldID0gbS52YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmplY3Q6IHRhcmdldE1ldGFkYXRhTWFwW01FVEFEQVRBX0tFWS5JTkpFQ1RfVEFHXSxcbiAgICAgICAgbXVsdGlJbmplY3Q6IHRhcmdldE1ldGFkYXRhTWFwW01FVEFEQVRBX0tFWS5NVUxUSV9JTkpFQ1RfVEFHXSxcbiAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TWV0YWRhdGFNYXBbTUVUQURBVEFfS0VZLk5BTUVfVEFHXSxcbiAgICAgICAgdW5tYW5hZ2VkOiB0YXJnZXRNZXRhZGF0YU1hcFtNRVRBREFUQV9LRVkuVU5NQU5BR0VEX1RBR11cbiAgICB9O1xufVxuZXhwb3J0IHsgZ2V0RGVwZW5kZW5jaWVzLCBnZXRCYXNlQ2xhc3NEZXBlbmRlbmN5Q291bnQsIGdldEZ1bmN0aW9uTmFtZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdGlvbl91dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBpZCB9IGZyb20gXCIuLi91dGlscy9pZFwiO1xudmFyIFJlcXVlc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3Qoc2VydmljZUlkZW50aWZpZXIsIHBhcmVudENvbnRleHQsIHBhcmVudFJlcXVlc3QsIGJpbmRpbmdzLCB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkKCk7XG4gICAgICAgIHRoaXMuc2VydmljZUlkZW50aWZpZXIgPSBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5wYXJlbnRDb250ZXh0ID0gcGFyZW50Q29udGV4dDtcbiAgICAgICAgdGhpcy5wYXJlbnRSZXF1ZXN0ID0gcGFyZW50UmVxdWVzdDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuY2hpbGRSZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0gKEFycmF5LmlzQXJyYXkoYmluZGluZ3MpID8gYmluZGluZ3MgOiBbYmluZGluZ3NdKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NvcGUgPSBwYXJlbnRSZXF1ZXN0ID09PSBudWxsXG4gICAgICAgICAgICA/IG5ldyBNYXAoKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5hZGRDaGlsZFJlcXVlc3QgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIsIGJpbmRpbmdzLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3IFJlcXVlc3Qoc2VydmljZUlkZW50aWZpZXIsIHRoaXMucGFyZW50Q29udGV4dCwgdGhpcywgYmluZGluZ3MsIHRhcmdldCk7XG4gICAgICAgIHRoaXMuY2hpbGRSZXF1ZXN0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcXVlc3Q7XG59KCkpO1xuZXhwb3J0IHsgUmVxdWVzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC5qcy5tYXAiLCJpbXBvcnQgeyBCaW5kaW5nQ291bnQgfSBmcm9tIFwiLi4vYmluZGluZ3MvYmluZGluZ19jb3VudFwiO1xuaW1wb3J0ICogYXMgRVJST1JfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCB7IEJpbmRpbmdUeXBlRW51bSwgVGFyZ2V0VHlwZUVudW0gfSBmcm9tIFwiLi4vY29uc3RhbnRzL2xpdGVyYWxfdHlwZXNcIjtcbmltcG9ydCAqIGFzIE1FVEFEQVRBX0tFWSBmcm9tIFwiLi4vY29uc3RhbnRzL21ldGFkYXRhX2tleXNcIjtcbmltcG9ydCB7IGlzU3RhY2tPdmVyZmxvd0V4ZXB0aW9uIH0gZnJvbSBcIi4uL3V0aWxzL2V4Y2VwdGlvbnNcIjtcbmltcG9ydCB7IGNpcmN1bGFyRGVwZW5kZW5jeVRvRXhjZXB0aW9uLCBnZXRTZXJ2aWNlSWRlbnRpZmllckFzU3RyaW5nLCBsaXN0TWV0YWRhdGFGb3JUYXJnZXQsIGxpc3RSZWdpc3RlcmVkQmluZGluZ3NGb3JTZXJ2aWNlSWRlbnRpZmllciB9IGZyb20gXCIuLi91dGlscy9zZXJpYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dFwiO1xuaW1wb3J0IHsgTWV0YWRhdGEgfSBmcm9tIFwiLi9tZXRhZGF0YVwiO1xuaW1wb3J0IHsgUGxhbiB9IGZyb20gXCIuL3BsYW5cIjtcbmltcG9ydCB7IGdldEJhc2VDbGFzc0RlcGVuZGVuY3lDb3VudCwgZ2V0RGVwZW5kZW5jaWVzLCBnZXRGdW5jdGlvbk5hbWUgfSBmcm9tIFwiLi9yZWZsZWN0aW9uX3V0aWxzXCI7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSBcIi4vcmVxdWVzdFwiO1xuaW1wb3J0IHsgVGFyZ2V0IH0gZnJvbSBcIi4vdGFyZ2V0XCI7XG5mdW5jdGlvbiBnZXRCaW5kaW5nRGljdGlvbmFyeShjbnRucikge1xuICAgIHJldHVybiBjbnRuci5fYmluZGluZ0RpY3Rpb25hcnk7XG59XG5mdW5jdGlvbiBfY3JlYXRlVGFyZ2V0KGlzTXVsdGlJbmplY3QsIHRhcmdldFR5cGUsIHNlcnZpY2VJZGVudGlmaWVyLCBuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIG1ldGFkYXRhS2V5ID0gaXNNdWx0aUluamVjdCA/IE1FVEFEQVRBX0tFWS5NVUxUSV9JTkpFQ1RfVEFHIDogTUVUQURBVEFfS0VZLklOSkVDVF9UQUc7XG4gICAgdmFyIGluamVjdE1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgdmFyIHRhcmdldCA9IG5ldyBUYXJnZXQodGFyZ2V0VHlwZSwgbmFtZSwgc2VydmljZUlkZW50aWZpZXIsIGluamVjdE1ldGFkYXRhKTtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRhZ01ldGFkYXRhID0gbmV3IE1ldGFkYXRhKGtleSwgdmFsdWUpO1xuICAgICAgICB0YXJnZXQubWV0YWRhdGEucHVzaCh0YWdNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfZ2V0QWN0aXZlQmluZGluZ3MobWV0YWRhdGFSZWFkZXIsIGF2b2lkQ29uc3RyYWludHMsIGNvbnRleHQsIHBhcmVudFJlcXVlc3QsIHRhcmdldCkge1xuICAgIHZhciBiaW5kaW5ncyA9IGdldEJpbmRpbmdzKGNvbnRleHQuY29udGFpbmVyLCB0YXJnZXQuc2VydmljZUlkZW50aWZpZXIpO1xuICAgIHZhciBhY3RpdmVCaW5kaW5ncyA9IFtdO1xuICAgIGlmIChiaW5kaW5ncy5sZW5ndGggPT09IEJpbmRpbmdDb3VudC5Ob0JpbmRpbmdzQXZhaWxhYmxlICYmXG4gICAgICAgIGNvbnRleHQuY29udGFpbmVyLm9wdGlvbnMuYXV0b0JpbmRJbmplY3RhYmxlICYmXG4gICAgICAgIHR5cGVvZiB0YXJnZXQuc2VydmljZUlkZW50aWZpZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBtZXRhZGF0YVJlYWRlci5nZXRDb25zdHJ1Y3Rvck1ldGFkYXRhKHRhcmdldC5zZXJ2aWNlSWRlbnRpZmllcikuY29tcGlsZXJHZW5lcmF0ZWRNZXRhZGF0YSkge1xuICAgICAgICBjb250ZXh0LmNvbnRhaW5lci5iaW5kKHRhcmdldC5zZXJ2aWNlSWRlbnRpZmllcikudG9TZWxmKCk7XG4gICAgICAgIGJpbmRpbmdzID0gZ2V0QmluZGluZ3MoY29udGV4dC5jb250YWluZXIsIHRhcmdldC5zZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfVxuICAgIGlmICghYXZvaWRDb25zdHJhaW50cykge1xuICAgICAgICBhY3RpdmVCaW5kaW5ncyA9IGJpbmRpbmdzLmZpbHRlcihmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChiaW5kaW5nLnNlcnZpY2VJZGVudGlmaWVyLCBjb250ZXh0LCBwYXJlbnRSZXF1ZXN0LCBiaW5kaW5nLCB0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmcuY29uc3RyYWludChyZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY3RpdmVCaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgIH1cbiAgICBfdmFsaWRhdGVBY3RpdmVCaW5kaW5nQ291bnQodGFyZ2V0LnNlcnZpY2VJZGVudGlmaWVyLCBhY3RpdmVCaW5kaW5ncywgdGFyZ2V0LCBjb250ZXh0LmNvbnRhaW5lcik7XG4gICAgcmV0dXJuIGFjdGl2ZUJpbmRpbmdzO1xufVxuZnVuY3Rpb24gX3ZhbGlkYXRlQWN0aXZlQmluZGluZ0NvdW50KHNlcnZpY2VJZGVudGlmaWVyLCBiaW5kaW5ncywgdGFyZ2V0LCBjb250YWluZXIpIHtcbiAgICBzd2l0Y2ggKGJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIEJpbmRpbmdDb3VudC5Ob0JpbmRpbmdzQXZhaWxhYmxlOlxuICAgICAgICAgICAgaWYgKHRhcmdldC5pc09wdGlvbmFsKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZGluZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VydmljZUlkZW50aWZpZXJTdHJpbmcgPSBnZXRTZXJ2aWNlSWRlbnRpZmllckFzU3RyaW5nKHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gRVJST1JfTVNHUy5OT1RfUkVHSVNURVJFRDtcbiAgICAgICAgICAgICAgICBtc2cgKz0gbGlzdE1ldGFkYXRhRm9yVGFyZ2V0KHNlcnZpY2VJZGVudGlmaWVyU3RyaW5nLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIG1zZyArPSBsaXN0UmVnaXN0ZXJlZEJpbmRpbmdzRm9yU2VydmljZUlkZW50aWZpZXIoY29udGFpbmVyLCBzZXJ2aWNlSWRlbnRpZmllclN0cmluZywgZ2V0QmluZGluZ3MpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEJpbmRpbmdDb3VudC5Pbmx5T25lQmluZGluZ0F2YWlsYWJsZTpcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5ncztcbiAgICAgICAgY2FzZSBCaW5kaW5nQ291bnQuTXVsdGlwbGVCaW5kaW5nc0F2YWlsYWJsZTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2aWNlSWRlbnRpZmllclN0cmluZyA9IGdldFNlcnZpY2VJZGVudGlmaWVyQXNTdHJpbmcoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBFUlJPUl9NU0dTLkFNQklHVU9VU19NQVRDSCArIFwiIFwiICsgc2VydmljZUlkZW50aWZpZXJTdHJpbmc7XG4gICAgICAgICAgICAgICAgbXNnICs9IGxpc3RSZWdpc3RlcmVkQmluZGluZ3NGb3JTZXJ2aWNlSWRlbnRpZmllcihjb250YWluZXIsIHNlcnZpY2VJZGVudGlmaWVyU3RyaW5nLCBnZXRCaW5kaW5ncyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZGluZ3M7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZVN1YlJlcXVlc3RzKG1ldGFkYXRhUmVhZGVyLCBhdm9pZENvbnN0cmFpbnRzLCBzZXJ2aWNlSWRlbnRpZmllciwgY29udGV4dCwgcGFyZW50UmVxdWVzdCwgdGFyZ2V0KSB7XG4gICAgdmFyIGFjdGl2ZUJpbmRpbmdzO1xuICAgIHZhciBjaGlsZFJlcXVlc3Q7XG4gICAgaWYgKHBhcmVudFJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgICAgYWN0aXZlQmluZGluZ3MgPSBfZ2V0QWN0aXZlQmluZGluZ3MobWV0YWRhdGFSZWFkZXIsIGF2b2lkQ29uc3RyYWludHMsIGNvbnRleHQsIG51bGwsIHRhcmdldCk7XG4gICAgICAgIGNoaWxkUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHNlcnZpY2VJZGVudGlmaWVyLCBjb250ZXh0LCBudWxsLCBhY3RpdmVCaW5kaW5ncywgdGFyZ2V0KTtcbiAgICAgICAgdmFyIHRoZVBsYW4gPSBuZXcgUGxhbihjb250ZXh0LCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICBjb250ZXh0LmFkZFBsYW4odGhlUGxhbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY3RpdmVCaW5kaW5ncyA9IF9nZXRBY3RpdmVCaW5kaW5ncyhtZXRhZGF0YVJlYWRlciwgYXZvaWRDb25zdHJhaW50cywgY29udGV4dCwgcGFyZW50UmVxdWVzdCwgdGFyZ2V0KTtcbiAgICAgICAgY2hpbGRSZXF1ZXN0ID0gcGFyZW50UmVxdWVzdC5hZGRDaGlsZFJlcXVlc3QodGFyZ2V0LnNlcnZpY2VJZGVudGlmaWVyLCBhY3RpdmVCaW5kaW5ncywgdGFyZ2V0KTtcbiAgICB9XG4gICAgYWN0aXZlQmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICB2YXIgc3ViQ2hpbGRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldC5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHN1YkNoaWxkUmVxdWVzdCA9IGNoaWxkUmVxdWVzdC5hZGRDaGlsZFJlcXVlc3QoYmluZGluZy5zZXJ2aWNlSWRlbnRpZmllciwgYmluZGluZywgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViQ2hpbGRSZXF1ZXN0ID0gY2hpbGRSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5kaW5nLnR5cGUgPT09IEJpbmRpbmdUeXBlRW51bS5JbnN0YW5jZSAmJiBiaW5kaW5nLmltcGxlbWVudGF0aW9uVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhtZXRhZGF0YVJlYWRlciwgYmluZGluZy5pbXBsZW1lbnRhdGlvblR5cGUpO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0LmNvbnRhaW5lci5vcHRpb25zLnNraXBCYXNlQ2xhc3NDaGVja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZUNsYXNzRGVwZW5kZW5jeUNvdW50ID0gZ2V0QmFzZUNsYXNzRGVwZW5kZW5jeUNvdW50KG1ldGFkYXRhUmVhZGVyLCBiaW5kaW5nLmltcGxlbWVudGF0aW9uVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY2llcy5sZW5ndGggPCBiYXNlQ2xhc3NEZXBlbmRlbmN5Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gRVJST1JfTVNHUy5BUkdVTUVOVFNfTEVOR1RIX01JU01BVENIKGdldEZ1bmN0aW9uTmFtZShiaW5kaW5nLmltcGxlbWVudGF0aW9uVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgX2NyZWF0ZVN1YlJlcXVlc3RzKG1ldGFkYXRhUmVhZGVyLCBmYWxzZSwgZGVwZW5kZW5jeS5zZXJ2aWNlSWRlbnRpZmllciwgY29udGV4dCwgc3ViQ2hpbGRSZXF1ZXN0LCBkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5ncyhjb250YWluZXIsIHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgdmFyIGJpbmRpbmdzID0gW107XG4gICAgdmFyIGJpbmRpbmdEaWN0aW9uYXJ5ID0gZ2V0QmluZGluZ0RpY3Rpb25hcnkoY29udGFpbmVyKTtcbiAgICBpZiAoYmluZGluZ0RpY3Rpb25hcnkuaGFzS2V5KHNlcnZpY2VJZGVudGlmaWVyKSkge1xuICAgICAgICBiaW5kaW5ncyA9IGJpbmRpbmdEaWN0aW9uYXJ5LmdldChzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRhaW5lci5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYmluZGluZ3MgPSBnZXRCaW5kaW5ncyhjb250YWluZXIucGFyZW50LCBzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBiaW5kaW5ncztcbn1cbmZ1bmN0aW9uIHBsYW4obWV0YWRhdGFSZWFkZXIsIGNvbnRhaW5lciwgaXNNdWx0aUluamVjdCwgdGFyZ2V0VHlwZSwgc2VydmljZUlkZW50aWZpZXIsIGtleSwgdmFsdWUsIGF2b2lkQ29uc3RyYWludHMpIHtcbiAgICBpZiAoYXZvaWRDb25zdHJhaW50cyA9PT0gdm9pZCAwKSB7IGF2b2lkQ29uc3RyYWludHMgPSBmYWxzZTsgfVxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoY29udGFpbmVyKTtcbiAgICB2YXIgdGFyZ2V0ID0gX2NyZWF0ZVRhcmdldChpc011bHRpSW5qZWN0LCB0YXJnZXRUeXBlLCBzZXJ2aWNlSWRlbnRpZmllciwgXCJcIiwga2V5LCB2YWx1ZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgX2NyZWF0ZVN1YlJlcXVlc3RzKG1ldGFkYXRhUmVhZGVyLCBhdm9pZENvbnN0cmFpbnRzLCBzZXJ2aWNlSWRlbnRpZmllciwgY29udGV4dCwgbnVsbCwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNTdGFja092ZXJmbG93RXhlcHRpb24oZXJyb3IpKSB7XG4gICAgICAgICAgICBjaXJjdWxhckRlcGVuZGVuY3lUb0V4Y2VwdGlvbihjb250ZXh0LnBsYW4ucm9vdFJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU1vY2tSZXF1ZXN0KGNvbnRhaW5lciwgc2VydmljZUlkZW50aWZpZXIsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gbmV3IFRhcmdldChUYXJnZXRUeXBlRW51bS5WYXJpYWJsZSwgXCJcIiwgc2VydmljZUlkZW50aWZpZXIsIG5ldyBNZXRhZGF0YShrZXksIHZhbHVlKSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChjb250YWluZXIpO1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qoc2VydmljZUlkZW50aWZpZXIsIGNvbnRleHQsIG51bGwsIFtdLCB0YXJnZXQpO1xuICAgIHJldHVybiByZXF1ZXN0O1xufVxuZXhwb3J0IHsgcGxhbiwgY3JlYXRlTW9ja1JlcXVlc3QsIGdldEJpbmRpbmdEaWN0aW9uYXJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGFubmVyLmpzLm1hcCIsImZ1bmN0aW9uIGlzUHJvbWlzZShvYmplY3QpIHtcbiAgICB2YXIgaXNPYmplY3RPckZ1bmN0aW9uID0gKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgICByZXR1cm4gaXNPYmplY3RPckZ1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlT3JDb250YWluc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgaWYgKGlzUHJvbWlzZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5zb21lKGlzUHJvbWlzZSk7XG59XG5leHBvcnQgeyBpc1Byb21pc2UsIGlzUHJvbWlzZU9yQ29udGFpbnNQcm9taXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXAiLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0IHsgQmluZGluZ1Njb3BlRW51bSB9IGZyb20gXCIuLi9pbnZlcnNpZnlcIjtcbmltcG9ydCB7IGlzUHJvbWlzZSB9IGZyb20gXCIuLi91dGlscy9hc3luY1wiO1xuZXhwb3J0IHZhciB0cnlHZXRGcm9tU2NvcGUgPSBmdW5jdGlvbiAocmVxdWVzdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgaWYgKChiaW5kaW5nLnNjb3BlID09PSBCaW5kaW5nU2NvcGVFbnVtLlNpbmdsZXRvbikgJiYgYmluZGluZy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmcuY2FjaGU7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nLnNjb3BlID09PSBCaW5kaW5nU2NvcGVFbnVtLlJlcXVlc3QgJiZcbiAgICAgICAgcmVxdWVzdFNjb3BlLmhhcyhiaW5kaW5nLmlkKSkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdFNjb3BlLmdldChiaW5kaW5nLmlkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0IHZhciBzYXZlVG9TY29wZSA9IGZ1bmN0aW9uIChyZXF1ZXN0U2NvcGUsIGJpbmRpbmcsIHJlc3VsdCkge1xuICAgIGlmIChiaW5kaW5nLnNjb3BlID09PSBCaW5kaW5nU2NvcGVFbnVtLlNpbmdsZXRvbikge1xuICAgICAgICBfc2F2ZVRvU2luZ2xldG9uU2NvcGUoYmluZGluZywgcmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmcuc2NvcGUgPT09IEJpbmRpbmdTY29wZUVudW0uUmVxdWVzdCkge1xuICAgICAgICBfc2F2ZVRvUmVxdWVzdFNjb3BlKHJlcXVlc3RTY29wZSwgYmluZGluZywgcmVzdWx0KTtcbiAgICB9XG59O1xudmFyIF9zYXZlVG9SZXF1ZXN0U2NvcGUgPSBmdW5jdGlvbiAocmVxdWVzdFNjb3BlLCBiaW5kaW5nLCByZXN1bHQpIHtcbiAgICBpZiAoIXJlcXVlc3RTY29wZS5oYXMoYmluZGluZy5pZCkpIHtcbiAgICAgICAgcmVxdWVzdFNjb3BlLnNldChiaW5kaW5nLmlkLCByZXN1bHQpO1xuICAgIH1cbn07XG52YXIgX3NhdmVUb1NpbmdsZXRvblNjb3BlID0gZnVuY3Rpb24gKGJpbmRpbmcsIHJlc3VsdCkge1xuICAgIGJpbmRpbmcuY2FjaGUgPSByZXN1bHQ7XG4gICAgYmluZGluZy5hY3RpdmF0ZWQgPSB0cnVlO1xuICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICB2b2lkIF9zYXZlQXN5bmNSZXN1bHRUb1NpbmdsZXRvblNjb3BlKGJpbmRpbmcsIHJlc3VsdCk7XG4gICAgfVxufTtcbnZhciBfc2F2ZUFzeW5jUmVzdWx0VG9TaW5nbGV0b25TY29wZSA9IGZ1bmN0aW9uIChiaW5kaW5nLCBhc3luY1Jlc3VsdCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0LCBleF8xO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBhc3luY1Jlc3VsdF07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuY2FjaGUgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBleF8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuY2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXhfMTtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJleHBvcnQgdmFyIEZhY3RvcnlUeXBlO1xuKGZ1bmN0aW9uIChGYWN0b3J5VHlwZSkge1xuICAgIEZhY3RvcnlUeXBlW1wiRHluYW1pY1ZhbHVlXCJdID0gXCJ0b0R5bmFtaWNWYWx1ZVwiO1xuICAgIEZhY3RvcnlUeXBlW1wiRmFjdG9yeVwiXSA9IFwidG9GYWN0b3J5XCI7XG4gICAgRmFjdG9yeVR5cGVbXCJQcm92aWRlclwiXSA9IFwidG9Qcm92aWRlclwiO1xufSkoRmFjdG9yeVR5cGUgfHwgKEZhY3RvcnlUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhY3RvcnlfdHlwZS5qcy5tYXAiLCJpbXBvcnQgeyBnZXRTZXJ2aWNlSWRlbnRpZmllckFzU3RyaW5nIH0gZnJvbSBcIi4uL2ludmVyc2lmeVwiO1xuaW1wb3J0ICogYXMgRVJST1JfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCB7IEJpbmRpbmdUeXBlRW51bSB9IGZyb20gXCIuLi9jb25zdGFudHMvbGl0ZXJhbF90eXBlc1wiO1xuaW1wb3J0IHsgRmFjdG9yeVR5cGUgfSBmcm9tIFwiLi9mYWN0b3J5X3R5cGVcIjtcbmV4cG9ydCB2YXIgbXVsdGlCaW5kVG9TZXJ2aWNlID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VydmljZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHR5cGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gY29udGFpbmVyLmJpbmQodCkudG9TZXJ2aWNlKHNlcnZpY2UpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydCB2YXIgZW5zdXJlRnVsbHlCb3VuZCA9IGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgdmFyIGJvdW5kVmFsdWUgPSBudWxsO1xuICAgIHN3aXRjaCAoYmluZGluZy50eXBlKSB7XG4gICAgICAgIGNhc2UgQmluZGluZ1R5cGVFbnVtLkNvbnN0YW50VmFsdWU6XG4gICAgICAgIGNhc2UgQmluZGluZ1R5cGVFbnVtLkZ1bmN0aW9uOlxuICAgICAgICAgICAgYm91bmRWYWx1ZSA9IGJpbmRpbmcuY2FjaGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCaW5kaW5nVHlwZUVudW0uQ29uc3RydWN0b3I6XG4gICAgICAgIGNhc2UgQmluZGluZ1R5cGVFbnVtLkluc3RhbmNlOlxuICAgICAgICAgICAgYm91bmRWYWx1ZSA9IGJpbmRpbmcuaW1wbGVtZW50YXRpb25UeXBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmluZGluZ1R5cGVFbnVtLkR5bmFtaWNWYWx1ZTpcbiAgICAgICAgICAgIGJvdW5kVmFsdWUgPSBiaW5kaW5nLmR5bmFtaWNWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJpbmRpbmdUeXBlRW51bS5Qcm92aWRlcjpcbiAgICAgICAgICAgIGJvdW5kVmFsdWUgPSBiaW5kaW5nLnByb3ZpZGVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmluZGluZ1R5cGVFbnVtLkZhY3Rvcnk6XG4gICAgICAgICAgICBib3VuZFZhbHVlID0gYmluZGluZy5mYWN0b3J5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChib3VuZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHZhciBzZXJ2aWNlSWRlbnRpZmllckFzU3RyaW5nID0gZ2V0U2VydmljZUlkZW50aWZpZXJBc1N0cmluZyhiaW5kaW5nLnNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuSU5WQUxJRF9CSU5ESU5HX1RZUEUgKyBcIiBcIiArIHNlcnZpY2VJZGVudGlmaWVyQXNTdHJpbmcpO1xuICAgIH1cbn07XG5leHBvcnQgdmFyIGdldEZhY3RvcnlEZXRhaWxzID0gZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKGJpbmRpbmcudHlwZSkge1xuICAgICAgICBjYXNlIEJpbmRpbmdUeXBlRW51bS5GYWN0b3J5OlxuICAgICAgICAgICAgcmV0dXJuIHsgZmFjdG9yeTogYmluZGluZy5mYWN0b3J5LCBmYWN0b3J5VHlwZTogRmFjdG9yeVR5cGUuRmFjdG9yeSB9O1xuICAgICAgICBjYXNlIEJpbmRpbmdUeXBlRW51bS5Qcm92aWRlcjpcbiAgICAgICAgICAgIHJldHVybiB7IGZhY3Rvcnk6IGJpbmRpbmcucHJvdmlkZXIsIGZhY3RvcnlUeXBlOiBGYWN0b3J5VHlwZS5Qcm92aWRlciB9O1xuICAgICAgICBjYXNlIEJpbmRpbmdUeXBlRW51bS5EeW5hbWljVmFsdWU6XG4gICAgICAgICAgICByZXR1cm4geyBmYWN0b3J5OiBiaW5kaW5nLmR5bmFtaWNWYWx1ZSwgZmFjdG9yeVR5cGU6IEZhY3RvcnlUeXBlLkR5bmFtaWNWYWx1ZSB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmYWN0b3J5IHR5cGUgXCIgKyBiaW5kaW5nLnR5cGUpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nX3V0aWxzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuaW1wb3J0IHsgT05fREVBQ1RJVkFUSU9OX0VSUk9SLCBQT1NUX0NPTlNUUlVDVF9FUlJPUiwgUFJFX0RFU1RST1lfRVJST1IgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCB7IEJpbmRpbmdTY29wZUVudW0sIFRhcmdldFR5cGVFbnVtIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9saXRlcmFsX3R5cGVzXCI7XG5pbXBvcnQgKiBhcyBNRVRBREFUQV9LRVkgZnJvbSBcIi4uL2NvbnN0YW50cy9tZXRhZGF0YV9rZXlzXCI7XG5pbXBvcnQgeyBpc1Byb21pc2UsIGlzUHJvbWlzZU9yQ29udGFpbnNQcm9taXNlIH0gZnJvbSBcIi4uL3V0aWxzL2FzeW5jXCI7XG5mdW5jdGlvbiBfcmVzb2x2ZVJlcXVlc3RzKGNoaWxkUmVxdWVzdHMsIHJlc29sdmVSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIGNoaWxkUmVxdWVzdHMucmVkdWNlKGZ1bmN0aW9uIChyZXNvbHZlZFJlcXVlc3RzLCBjaGlsZFJlcXVlc3QpIHtcbiAgICAgICAgdmFyIGluamVjdGlvbiA9IHJlc29sdmVSZXF1ZXN0KGNoaWxkUmVxdWVzdCk7XG4gICAgICAgIHZhciB0YXJnZXRUeXBlID0gY2hpbGRSZXF1ZXN0LnRhcmdldC50eXBlO1xuICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gVGFyZ2V0VHlwZUVudW0uQ29uc3RydWN0b3JBcmd1bWVudCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRSZXF1ZXN0cy5jb25zdHJ1Y3RvckluamVjdGlvbnMucHVzaChpbmplY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZWRSZXF1ZXN0cy5wcm9wZXJ0eVJlcXVlc3RzLnB1c2goY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJlc29sdmVkUmVxdWVzdHMucHJvcGVydHlJbmplY3Rpb25zLnB1c2goaW5qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc29sdmVkUmVxdWVzdHMuaXNBc3luYykge1xuICAgICAgICAgICAgcmVzb2x2ZWRSZXF1ZXN0cy5pc0FzeW5jID0gaXNQcm9taXNlT3JDb250YWluc1Byb21pc2UoaW5qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRSZXF1ZXN0cztcbiAgICB9LCB7IGNvbnN0cnVjdG9ySW5qZWN0aW9uczogW10sIHByb3BlcnR5SW5qZWN0aW9uczogW10sIHByb3BlcnR5UmVxdWVzdHM6IFtdLCBpc0FzeW5jOiBmYWxzZSB9KTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVJbnN0YW5jZShjb25zdHIsIGNoaWxkUmVxdWVzdHMsIHJlc29sdmVSZXF1ZXN0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoY2hpbGRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IF9yZXNvbHZlUmVxdWVzdHMoY2hpbGRSZXF1ZXN0cywgcmVzb2x2ZVJlcXVlc3QpO1xuICAgICAgICB2YXIgY3JlYXRlSW5zdGFuY2VXaXRoSW5qZWN0aW9uc0FyZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXNvbHZlZCksIHsgY29uc3RyOiBjb25zdHIgfSk7XG4gICAgICAgIGlmIChyZXNvbHZlZC5pc0FzeW5jKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVJbnN0YW5jZVdpdGhJbmplY3Rpb25zQXN5bmMoY3JlYXRlSW5zdGFuY2VXaXRoSW5qZWN0aW9uc0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVJbnN0YW5jZVdpdGhJbmplY3Rpb25zKGNyZWF0ZUluc3RhbmNlV2l0aEluamVjdGlvbnNBcmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgY29uc3RyKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVdpdGhJbmplY3Rpb25zKGFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3ICgoX2EgPSBhcmdzLmNvbnN0cikuYmluZC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgYXJncy5jb25zdHJ1Y3RvckluamVjdGlvbnMsIGZhbHNlKSkpKCk7XG4gICAgYXJncy5wcm9wZXJ0eVJlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHIsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHIudGFyZ2V0LmlkZW50aWZpZXI7XG4gICAgICAgIHZhciBpbmplY3Rpb24gPSBhcmdzLnByb3BlcnR5SW5qZWN0aW9uc1tpbmRleF07XG4gICAgICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IGluamVjdGlvbjtcbiAgICB9KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVdpdGhJbmplY3Rpb25zQXN5bmMoYXJncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9ySW5qZWN0aW9ucywgcHJvcGVydHlJbmplY3Rpb25zO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHBvc3NpYmx5V2FpdEluamVjdGlvbnMoYXJncy5jb25zdHJ1Y3RvckluamVjdGlvbnMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9ySW5qZWN0aW9ucyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBwb3NzaWJseVdhaXRJbmplY3Rpb25zKGFyZ3MucHJvcGVydHlJbmplY3Rpb25zKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUluamVjdGlvbnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgY3JlYXRlSW5zdGFuY2VXaXRoSW5qZWN0aW9ucyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYXJncyksIHsgY29uc3RydWN0b3JJbmplY3Rpb25zOiBjb25zdHJ1Y3RvckluamVjdGlvbnMsIHByb3BlcnR5SW5qZWN0aW9uczogcHJvcGVydHlJbmplY3Rpb25zIH0pKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcG9zc2libHlXYWl0SW5qZWN0aW9ucyhwb3NzaWJsZVByb21pc2VpbmplY3Rpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5qZWN0aW9ucywgX2ksIHBvc3NpYmxlUHJvbWlzZWluamVjdGlvbnNfMSwgaW5qZWN0aW9uO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBpbmplY3Rpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgcG9zc2libGVQcm9taXNlaW5qZWN0aW9uc18xID0gcG9zc2libGVQcm9taXNlaW5qZWN0aW9uczsgX2kgPCBwb3NzaWJsZVByb21pc2VpbmplY3Rpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0aW9uID0gcG9zc2libGVQcm9taXNlaW5qZWN0aW9uc18xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdGlvbnMucHVzaChQcm9taXNlLmFsbChpbmplY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdGlvbnMucHVzaChpbmplY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMiwgUHJvbWlzZS5hbGwoaW5qZWN0aW9ucyldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9nZXRJbnN0YW5jZUFmdGVyUG9zdENvbnN0cnVjdChjb25zdHIsIHJlc3VsdCkge1xuICAgIHZhciBwb3N0Q29uc3RydWN0UmVzdWx0ID0gX3Bvc3RDb25zdHJ1Y3QoY29uc3RyLCByZXN1bHQpO1xuICAgIGlmIChpc1Byb21pc2UocG9zdENvbnN0cnVjdFJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3RDb25zdHJ1Y3RSZXN1bHQudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHQ7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfcG9zdENvbnN0cnVjdChjb25zdHIsIGluc3RhbmNlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoUmVmbGVjdC5oYXNNZXRhZGF0YShNRVRBREFUQV9LRVkuUE9TVF9DT05TVFJVQ1QsIGNvbnN0cikpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBSZWZsZWN0LmdldE1ldGFkYXRhKE1FVEFEQVRBX0tFWS5QT1NUX0NPTlNUUlVDVCwgY29uc3RyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBpbnN0YW5jZSlbZGF0YS52YWx1ZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFBPU1RfQ09OU1RSVUNUX0VSUk9SKGNvbnN0ci5uYW1lLCBlLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF92YWxpZGF0ZUluc3RhbmNlUmVzb2x1dGlvbihiaW5kaW5nLCBjb25zdHIpIHtcbiAgICBpZiAoYmluZGluZy5zY29wZSAhPT0gQmluZGluZ1Njb3BlRW51bS5TaW5nbGV0b24pIHtcbiAgICAgICAgX3Rocm93SWZIYW5kbGluZ0RlYWN0aXZhdGlvbihiaW5kaW5nLCBjb25zdHIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF90aHJvd0lmSGFuZGxpbmdEZWFjdGl2YXRpb24oYmluZGluZywgY29uc3RyKSB7XG4gICAgdmFyIHNjb3BlRXJyb3JNZXNzYWdlID0gXCJDbGFzcyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkIGluIFwiICsgKGJpbmRpbmcuc2NvcGUgPT09IEJpbmRpbmdTY29wZUVudW0uUmVxdWVzdCA/XG4gICAgICAgIFwicmVxdWVzdFwiIDpcbiAgICAgICAgXCJ0cmFuc2llbnRcIikgKyBcIiBzY29wZS5cIjtcbiAgICBpZiAodHlwZW9mIGJpbmRpbmcub25EZWFjdGl2YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoT05fREVBQ1RJVkFUSU9OX0VSUk9SKGNvbnN0ci5uYW1lLCBzY29wZUVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAoUmVmbGVjdC5oYXNNZXRhZGF0YShNRVRBREFUQV9LRVkuUFJFX0RFU1RST1ksIGNvbnN0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFBSRV9ERVNUUk9ZX0VSUk9SKGNvbnN0ci5uYW1lLCBzY29wZUVycm9yTWVzc2FnZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVJbnN0YW5jZShiaW5kaW5nLCBjb25zdHIsIGNoaWxkUmVxdWVzdHMsIHJlc29sdmVSZXF1ZXN0KSB7XG4gICAgX3ZhbGlkYXRlSW5zdGFuY2VSZXNvbHV0aW9uKGJpbmRpbmcsIGNvbnN0cik7XG4gICAgdmFyIHJlc3VsdCA9IF9jcmVhdGVJbnN0YW5jZShjb25zdHIsIGNoaWxkUmVxdWVzdHMsIHJlc29sdmVSZXF1ZXN0KTtcbiAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZFJlc3VsdCkgeyByZXR1cm4gX2dldEluc3RhbmNlQWZ0ZXJQb3N0Q29uc3RydWN0KGNvbnN0ciwgcmVzb2x2ZWRSZXN1bHQpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5zdGFuY2VBZnRlclBvc3RDb25zdHJ1Y3QoY29uc3RyLCByZXN1bHQpO1xuICAgIH1cbn1cbmV4cG9ydCB7IHJlc29sdmVJbnN0YW5jZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdGFudGlhdGlvbi5qcy5tYXAiLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0ICogYXMgRVJST1JfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCB7IEJpbmRpbmdUeXBlRW51bSB9IGZyb20gXCIuLi9jb25zdGFudHMvbGl0ZXJhbF90eXBlc1wiO1xuaW1wb3J0IHsgZ2V0QmluZGluZ0RpY3Rpb25hcnkgfSBmcm9tIFwiLi4vcGxhbm5pbmcvcGxhbm5lclwiO1xuaW1wb3J0IHsgc2F2ZVRvU2NvcGUsIHRyeUdldEZyb21TY29wZSB9IGZyb20gXCIuLi9zY29wZS9zY29wZVwiO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSBcIi4uL3V0aWxzL2FzeW5jXCI7XG5pbXBvcnQgeyBnZXRGYWN0b3J5RGV0YWlscywgZW5zdXJlRnVsbHlCb3VuZCB9IGZyb20gXCIuLi91dGlscy9iaW5kaW5nX3V0aWxzXCI7XG5pbXBvcnQgeyB0cnlBbmRUaHJvd0Vycm9ySWZTdGFja092ZXJmbG93IH0gZnJvbSBcIi4uL3V0aWxzL2V4Y2VwdGlvbnNcIjtcbmltcG9ydCB7IHJlc29sdmVJbnN0YW5jZSB9IGZyb20gXCIuL2luc3RhbnRpYXRpb25cIjtcbnZhciBfcmVzb2x2ZVJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdFNjb3BlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJlcXVlc3QucGFyZW50Q29udGV4dC5zZXRDdXJyZW50UmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gcmVxdWVzdC5iaW5kaW5ncztcbiAgICAgICAgdmFyIGNoaWxkUmVxdWVzdHMgPSByZXF1ZXN0LmNoaWxkUmVxdWVzdHM7XG4gICAgICAgIHZhciB0YXJnZXRJc0FuQXJyYXkgPSByZXF1ZXN0LnRhcmdldCAmJiByZXF1ZXN0LnRhcmdldC5pc0FycmF5KCk7XG4gICAgICAgIHZhciB0YXJnZXRQYXJlbnRJc05vdEFuQXJyYXkgPSAhcmVxdWVzdC5wYXJlbnRSZXF1ZXN0IHx8XG4gICAgICAgICAgICAhcmVxdWVzdC5wYXJlbnRSZXF1ZXN0LnRhcmdldCB8fFxuICAgICAgICAgICAgIXJlcXVlc3QudGFyZ2V0IHx8XG4gICAgICAgICAgICAhcmVxdWVzdC5wYXJlbnRSZXF1ZXN0LnRhcmdldC5tYXRjaGVzQXJyYXkocmVxdWVzdC50YXJnZXQuc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICBpZiAodGFyZ2V0SXNBbkFycmF5ICYmIHRhcmdldFBhcmVudElzTm90QW5BcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUmVxdWVzdHMubWFwKGZ1bmN0aW9uIChjaGlsZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2YgPSBfcmVzb2x2ZVJlcXVlc3QocmVxdWVzdFNjb3BlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2YoY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QudGFyZ2V0LmlzT3B0aW9uYWwoKSAmJiBiaW5kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc1swXTtcbiAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZUJpbmRpbmcocmVxdWVzdFNjb3BlLCByZXF1ZXN0LCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xudmFyIF9yZXNvbHZlRmFjdG9yeUZyb21CaW5kaW5nID0gZnVuY3Rpb24gKGJpbmRpbmcsIGNvbnRleHQpIHtcbiAgICB2YXIgZmFjdG9yeURldGFpbHMgPSBnZXRGYWN0b3J5RGV0YWlscyhiaW5kaW5nKTtcbiAgICByZXR1cm4gdHJ5QW5kVGhyb3dFcnJvcklmU3RhY2tPdmVyZmxvdyhmdW5jdGlvbiAoKSB7IHJldHVybiBmYWN0b3J5RGV0YWlscy5mYWN0b3J5LmJpbmQoYmluZGluZykoY29udGV4dCk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBFcnJvcihFUlJPUl9NU0dTLkNJUkNVTEFSX0RFUEVOREVOQ1lfSU5fRkFDVE9SWShmYWN0b3J5RGV0YWlscy5mYWN0b3J5VHlwZSwgY29udGV4dC5jdXJyZW50UmVxdWVzdC5zZXJ2aWNlSWRlbnRpZmllci50b1N0cmluZygpKSk7IH0pO1xufTtcbnZhciBfZ2V0UmVzb2x2ZWRGcm9tQmluZGluZyA9IGZ1bmN0aW9uIChyZXF1ZXN0U2NvcGUsIHJlcXVlc3QsIGJpbmRpbmcpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBjaGlsZFJlcXVlc3RzID0gcmVxdWVzdC5jaGlsZFJlcXVlc3RzO1xuICAgIGVuc3VyZUZ1bGx5Qm91bmQoYmluZGluZyk7XG4gICAgc3dpdGNoIChiaW5kaW5nLnR5cGUpIHtcbiAgICAgICAgY2FzZSBCaW5kaW5nVHlwZUVudW0uQ29uc3RhbnRWYWx1ZTpcbiAgICAgICAgY2FzZSBCaW5kaW5nVHlwZUVudW0uRnVuY3Rpb246XG4gICAgICAgICAgICByZXN1bHQgPSBiaW5kaW5nLmNhY2hlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmluZGluZ1R5cGVFbnVtLkNvbnN0cnVjdG9yOlxuICAgICAgICAgICAgcmVzdWx0ID0gYmluZGluZy5pbXBsZW1lbnRhdGlvblR5cGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCaW5kaW5nVHlwZUVudW0uSW5zdGFuY2U6XG4gICAgICAgICAgICByZXN1bHQgPSByZXNvbHZlSW5zdGFuY2UoYmluZGluZywgYmluZGluZy5pbXBsZW1lbnRhdGlvblR5cGUsIGNoaWxkUmVxdWVzdHMsIF9yZXNvbHZlUmVxdWVzdChyZXF1ZXN0U2NvcGUpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0ID0gX3Jlc29sdmVGYWN0b3J5RnJvbUJpbmRpbmcoYmluZGluZywgcmVxdWVzdC5wYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX3Jlc29sdmVJblNjb3BlID0gZnVuY3Rpb24gKHJlcXVlc3RTY29wZSwgYmluZGluZywgcmVzb2x2ZUZyb21CaW5kaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUdldEZyb21TY29wZShyZXF1ZXN0U2NvcGUsIGJpbmRpbmcpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVzb2x2ZUZyb21CaW5kaW5nKCk7XG4gICAgc2F2ZVRvU2NvcGUocmVxdWVzdFNjb3BlLCBiaW5kaW5nLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9yZXNvbHZlQmluZGluZyA9IGZ1bmN0aW9uIChyZXF1ZXN0U2NvcGUsIHJlcXVlc3QsIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gX3Jlc29sdmVJblNjb3BlKHJlcXVlc3RTY29wZSwgYmluZGluZywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX2dldFJlc29sdmVkRnJvbUJpbmRpbmcocmVxdWVzdFNjb3BlLCByZXF1ZXN0LCBiaW5kaW5nKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHsgcmV0dXJuIF9vbkFjdGl2YXRpb24ocmVxdWVzdCwgYmluZGluZywgcmVzb2x2ZWQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IF9vbkFjdGl2YXRpb24ocmVxdWVzdCwgYmluZGluZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIF9vbkFjdGl2YXRpb24ocmVxdWVzdCwgYmluZGluZywgcmVzb2x2ZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gX2JpbmRpbmdBY3RpdmF0aW9uKHJlcXVlc3QucGFyZW50Q29udGV4dCwgYmluZGluZywgcmVzb2x2ZWQpO1xuICAgIHZhciBjb250YWluZXJzSXRlcmF0b3IgPSBfZ2V0Q29udGFpbmVyc0l0ZXJhdG9yKHJlcXVlc3QucGFyZW50Q29udGV4dC5jb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXI7XG4gICAgdmFyIGNvbnRhaW5lcnNJdGVyYXRvclJlc3VsdCA9IGNvbnRhaW5lcnNJdGVyYXRvci5uZXh0KCk7XG4gICAgZG8ge1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJzSXRlcmF0b3JSZXN1bHQudmFsdWU7XG4gICAgICAgIHZhciBjb250ZXh0XzEgPSByZXF1ZXN0LnBhcmVudENvbnRleHQ7XG4gICAgICAgIHZhciBzZXJ2aWNlSWRlbnRpZmllciA9IHJlcXVlc3Quc2VydmljZUlkZW50aWZpZXI7XG4gICAgICAgIHZhciBhY3RpdmF0aW9uc0l0ZXJhdG9yID0gX2dldENvbnRhaW5lckFjdGl2YXRpb25zRm9yU2VydmljZShjb250YWluZXIsIHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfYWN0aXZhdGVDb250YWluZXJBc3luYyhhY3RpdmF0aW9uc0l0ZXJhdG9yLCBjb250ZXh0XzEsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfYWN0aXZhdGVDb250YWluZXIoYWN0aXZhdGlvbnNJdGVyYXRvciwgY29udGV4dF8xLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lcnNJdGVyYXRvclJlc3VsdCA9IGNvbnRhaW5lcnNJdGVyYXRvci5uZXh0KCk7XG4gICAgfSB3aGlsZSAoY29udGFpbmVyc0l0ZXJhdG9yUmVzdWx0LmRvbmUgIT09IHRydWUgJiYgIWdldEJpbmRpbmdEaWN0aW9uYXJ5KGNvbnRhaW5lcikuaGFzS2V5KHJlcXVlc3Quc2VydmljZUlkZW50aWZpZXIpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIF9iaW5kaW5nQWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBiaW5kaW5nLCBwcmV2aW91c1Jlc3VsdCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBiaW5kaW5nLm9uQWN0aXZhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IGJpbmRpbmcub25BY3RpdmF0aW9uKGNvbnRleHQsIHByZXZpb3VzUmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHByZXZpb3VzUmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfYWN0aXZhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoYWN0aXZhdGlvbnNJdGVyYXRvciwgY29udGV4dCwgcmVzdWx0KSB7XG4gICAgdmFyIGFjdGl2YXRpb24gPSBhY3RpdmF0aW9uc0l0ZXJhdG9yLm5leHQoKTtcbiAgICB3aGlsZSAoIWFjdGl2YXRpb24uZG9uZSkge1xuICAgICAgICByZXN1bHQgPSBhY3RpdmF0aW9uLnZhbHVlKGNvbnRleHQsIHJlc3VsdCk7XG4gICAgICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIF9hY3RpdmF0ZUNvbnRhaW5lckFzeW5jKGFjdGl2YXRpb25zSXRlcmF0b3IsIGNvbnRleHQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZhdGlvbiA9IGFjdGl2YXRpb25zSXRlcmF0b3IubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfYWN0aXZhdGVDb250YWluZXJBc3luYyA9IGZ1bmN0aW9uIChhY3RpdmF0aW9uc0l0ZXJhdG9yLCBjb250ZXh0LCByZXN1bHRQcm9taXNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQsIGFjdGl2YXRpb247XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgcmVzdWx0UHJvbWlzZV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb24gPSBhY3RpdmF0aW9uc0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCEhYWN0aXZhdGlvbi5kb25lKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYWN0aXZhdGlvbi52YWx1ZShjb250ZXh0LCByZXN1bHQpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbiA9IGFjdGl2YXRpb25zSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiwgcmVzdWx0XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgX2dldENvbnRhaW5lckFjdGl2YXRpb25zRm9yU2VydmljZSA9IGZ1bmN0aW9uIChjb250YWluZXIsIHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgdmFyIGFjdGl2YXRpb25zID0gY29udGFpbmVyLl9hY3RpdmF0aW9ucztcbiAgICByZXR1cm4gYWN0aXZhdGlvbnMuaGFzS2V5KHNlcnZpY2VJZGVudGlmaWVyKSA/IGFjdGl2YXRpb25zLmdldChzZXJ2aWNlSWRlbnRpZmllcikudmFsdWVzKCkgOiBbXS52YWx1ZXMoKTtcbn07XG52YXIgX2dldENvbnRhaW5lcnNJdGVyYXRvciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICB2YXIgY29udGFpbmVyc1N0YWNrID0gW2NvbnRhaW5lcl07XG4gICAgdmFyIHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBjb250YWluZXJzU3RhY2sucHVzaChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0TmV4dENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRDb250YWluZXIgPSBjb250YWluZXJzU3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChuZXh0Q29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogbmV4dENvbnRhaW5lciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29udGFpbmVyc0l0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0OiBnZXROZXh0Q29udGFpbmVyLFxuICAgIH07XG4gICAgcmV0dXJuIGNvbnRhaW5lcnNJdGVyYXRvcjtcbn07XG5mdW5jdGlvbiByZXNvbHZlKGNvbnRleHQpIHtcbiAgICB2YXIgX2YgPSBfcmVzb2x2ZVJlcXVlc3QoY29udGV4dC5wbGFuLnJvb3RSZXF1ZXN0LnJlcXVlc3RTY29wZSk7XG4gICAgcmV0dXJuIF9mKGNvbnRleHQucGxhbi5yb290UmVxdWVzdCk7XG59XG5leHBvcnQgeyByZXNvbHZlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiLCJpbXBvcnQgKiBhcyBNRVRBREFUQV9LRVkgZnJvbSBcIi4uL2NvbnN0YW50cy9tZXRhZGF0YV9rZXlzXCI7XG5pbXBvcnQgeyBNZXRhZGF0YSB9IGZyb20gXCIuLi9wbGFubmluZy9tZXRhZGF0YVwiO1xudmFyIHRyYXZlcnNlQW5jZXJzdG9ycyA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBjb25zdHJhaW50KSB7XG4gICAgdmFyIHBhcmVudCA9IHJlcXVlc3QucGFyZW50UmVxdWVzdDtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50KHBhcmVudCkgPyB0cnVlIDogdHJhdmVyc2VBbmNlcnN0b3JzKHBhcmVudCwgY29uc3RyYWludCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbnZhciB0YWdnZWRDb25zdHJhaW50ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0LnRhcmdldCAhPT0gbnVsbCAmJiByZXF1ZXN0LnRhcmdldC5tYXRjaGVzVGFnKGtleSkodmFsdWUpO1xuICAgIH07XG4gICAgY29uc3RyYWludC5tZXRhRGF0YSA9IG5ldyBNZXRhZGF0YShrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gY29uc3RyYWludDtcbn07IH07XG52YXIgbmFtZWRDb25zdHJhaW50ID0gdGFnZ2VkQ29uc3RyYWludChNRVRBREFUQV9LRVkuTkFNRURfVEFHKTtcbnZhciB0eXBlQ29uc3RyYWludCA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHZhciBiaW5kaW5nID0gbnVsbDtcbiAgICBpZiAocmVxdWVzdCAhPT0gbnVsbCkge1xuICAgICAgICBiaW5kaW5nID0gcmVxdWVzdC5iaW5kaW5nc1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgc2VydmljZUlkZW50aWZpZXIgPSBiaW5kaW5nLnNlcnZpY2VJZGVudGlmaWVyO1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VJZGVudGlmaWVyID09PSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gcmVxdWVzdC5iaW5kaW5nc1swXS5pbXBsZW1lbnRhdGlvblR5cGU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTsgfTtcbmV4cG9ydCB7IHRyYXZlcnNlQW5jZXJzdG9ycywgdGFnZ2VkQ29uc3RyYWludCwgbmFtZWRDb25zdHJhaW50LCB0eXBlQ29uc3RyYWludCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RyYWludF9oZWxwZXJzLmpzLm1hcCIsImltcG9ydCB7IEJpbmRpbmdPblN5bnRheCB9IGZyb20gXCIuL2JpbmRpbmdfb25fc3ludGF4XCI7XG5pbXBvcnQgeyBuYW1lZENvbnN0cmFpbnQsIHRhZ2dlZENvbnN0cmFpbnQsIHRyYXZlcnNlQW5jZXJzdG9ycywgdHlwZUNvbnN0cmFpbnQgfSBmcm9tIFwiLi9jb25zdHJhaW50X2hlbHBlcnNcIjtcbnZhciBCaW5kaW5nV2hlblN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZ1doZW5TeW50YXgoYmluZGluZykge1xuICAgICAgICB0aGlzLl9iaW5kaW5nID0gYmluZGluZztcbiAgICB9XG4gICAgQmluZGluZ1doZW5TeW50YXgucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuU3ludGF4LnByb3RvdHlwZS53aGVuVGFyZ2V0TmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBuYW1lZENvbnN0cmFpbnQobmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ09uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5TeW50YXgucHJvdG90eXBlLndoZW5UYXJnZXRJc0RlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuY29uc3RyYWludCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXRJc0RlZmF1bHQgPSAocmVxdWVzdC50YXJnZXQgIT09IG51bGwpICYmXG4gICAgICAgICAgICAgICAgKCFyZXF1ZXN0LnRhcmdldC5pc05hbWVkKCkpICYmXG4gICAgICAgICAgICAgICAgKCFyZXF1ZXN0LnRhcmdldC5pc1RhZ2dlZCgpKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRJc0RlZmF1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ09uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5TeW50YXgucHJvdG90eXBlLndoZW5UYXJnZXRUYWdnZWQgPSBmdW5jdGlvbiAodGFnLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSB0YWdnZWRDb25zdHJhaW50KHRhZykodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuU3ludGF4LnByb3RvdHlwZS53aGVuSW5qZWN0ZWRJbnRvID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGwgJiYgdHlwZUNvbnN0cmFpbnQocGFyZW50KShyZXF1ZXN0LnBhcmVudFJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuU3ludGF4LnByb3RvdHlwZS53aGVuUGFyZW50TmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGwgJiYgbmFtZWRDb25zdHJhaW50KG5hbWUpKHJlcXVlc3QucGFyZW50UmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ09uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5TeW50YXgucHJvdG90eXBlLndoZW5QYXJlbnRUYWdnZWQgPSBmdW5jdGlvbiAodGFnLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGwgJiYgdGFnZ2VkQ29uc3RyYWludCh0YWcpKHZhbHVlKShyZXF1ZXN0LnBhcmVudFJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuU3ludGF4LnByb3RvdHlwZS53aGVuQW55QW5jZXN0b3JJcyA9IGZ1bmN0aW9uIChhbmNlc3Rvcikge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGwgJiYgdHJhdmVyc2VBbmNlcnN0b3JzKHJlcXVlc3QsIHR5cGVDb25zdHJhaW50KGFuY2VzdG9yKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ09uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5TeW50YXgucHJvdG90eXBlLndoZW5Ob0FuY2VzdG9ySXMgPSBmdW5jdGlvbiAoYW5jZXN0b3IpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy5jb25zdHJhaW50ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ICE9PSBudWxsICYmICF0cmF2ZXJzZUFuY2Vyc3RvcnMocmVxdWVzdCwgdHlwZUNvbnN0cmFpbnQoYW5jZXN0b3IpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nT25TeW50YXgodGhpcy5fYmluZGluZyk7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlblN5bnRheC5wcm90b3R5cGUud2hlbkFueUFuY2VzdG9yTmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGwgJiYgdHJhdmVyc2VBbmNlcnN0b3JzKHJlcXVlc3QsIG5hbWVkQ29uc3RyYWludChuYW1lKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ09uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5TeW50YXgucHJvdG90eXBlLndoZW5Ob0FuY2VzdG9yTmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGwgJiYgIXRyYXZlcnNlQW5jZXJzdG9ycyhyZXF1ZXN0LCBuYW1lZENvbnN0cmFpbnQobmFtZSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuU3ludGF4LnByb3RvdHlwZS53aGVuQW55QW5jZXN0b3JUYWdnZWQgPSBmdW5jdGlvbiAodGFnLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmNvbnN0cmFpbnQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGwgJiYgdHJhdmVyc2VBbmNlcnN0b3JzKHJlcXVlc3QsIHRhZ2dlZENvbnN0cmFpbnQodGFnKSh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuU3ludGF4LnByb3RvdHlwZS53aGVuTm9BbmNlc3RvclRhZ2dlZCA9IGZ1bmN0aW9uICh0YWcsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuY29uc3RyYWludCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdCAhPT0gbnVsbCAmJiAhdHJhdmVyc2VBbmNlcnN0b3JzKHJlcXVlc3QsIHRhZ2dlZENvbnN0cmFpbnQodGFnKSh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuU3ludGF4LnByb3RvdHlwZS53aGVuQW55QW5jZXN0b3JNYXRjaGVzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy5jb25zdHJhaW50ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ICE9PSBudWxsICYmIHRyYXZlcnNlQW5jZXJzdG9ycyhyZXF1ZXN0LCBjb25zdHJhaW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nT25TeW50YXgodGhpcy5fYmluZGluZyk7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlblN5bnRheC5wcm90b3R5cGUud2hlbk5vQW5jZXN0b3JNYXRjaGVzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy5jb25zdHJhaW50ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ICE9PSBudWxsICYmICF0cmF2ZXJzZUFuY2Vyc3RvcnMocmVxdWVzdCwgY29uc3RyYWludCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ09uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdXaGVuU3ludGF4O1xufSgpKTtcbmV4cG9ydCB7IEJpbmRpbmdXaGVuU3ludGF4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nX3doZW5fc3ludGF4LmpzLm1hcCIsImltcG9ydCB7IEJpbmRpbmdXaGVuU3ludGF4IH0gZnJvbSBcIi4vYmluZGluZ193aGVuX3N5bnRheFwiO1xudmFyIEJpbmRpbmdPblN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZ09uU3ludGF4KGJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZyA9IGJpbmRpbmc7XG4gICAgfVxuICAgIEJpbmRpbmdPblN5bnRheC5wcm90b3R5cGUub25BY3RpdmF0aW9uID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy5vbkFjdGl2YXRpb24gPSBoYW5kbGVyO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdXaGVuU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ09uU3ludGF4LnByb3RvdHlwZS5vbkRlYWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcub25EZWFjdGl2YXRpb24gPSBoYW5kbGVyO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdXaGVuU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdPblN5bnRheDtcbn0oKSk7XG5leHBvcnQgeyBCaW5kaW5nT25TeW50YXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmdfb25fc3ludGF4LmpzLm1hcCIsImltcG9ydCB7IEJpbmRpbmdPblN5bnRheCB9IGZyb20gXCIuL2JpbmRpbmdfb25fc3ludGF4XCI7XG5pbXBvcnQgeyBCaW5kaW5nV2hlblN5bnRheCB9IGZyb20gXCIuL2JpbmRpbmdfd2hlbl9zeW50YXhcIjtcbnZhciBCaW5kaW5nV2hlbk9uU3ludGF4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5kaW5nV2hlbk9uU3ludGF4KGJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZyA9IGJpbmRpbmc7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4ID0gbmV3IEJpbmRpbmdXaGVuU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgICAgICB0aGlzLl9iaW5kaW5nT25TeW50YXggPSBuZXcgQmluZGluZ09uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH1cbiAgICBCaW5kaW5nV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW4oY29uc3RyYWludCk7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuVGFyZ2V0TmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlblRhcmdldE5hbWVkKG5hbWUpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5PblN5bnRheC5wcm90b3R5cGUud2hlblRhcmdldElzRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5UYXJnZXRJc0RlZmF1bHQoKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuT25TeW50YXgucHJvdG90eXBlLndoZW5UYXJnZXRUYWdnZWQgPSBmdW5jdGlvbiAodGFnLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlblRhcmdldFRhZ2dlZCh0YWcsIHZhbHVlKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuT25TeW50YXgucHJvdG90eXBlLndoZW5JbmplY3RlZEludG8gPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuSW5qZWN0ZWRJbnRvKHBhcmVudCk7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuUGFyZW50TmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlblBhcmVudE5hbWVkKG5hbWUpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5PblN5bnRheC5wcm90b3R5cGUud2hlblBhcmVudFRhZ2dlZCA9IGZ1bmN0aW9uICh0YWcsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuUGFyZW50VGFnZ2VkKHRhZywgdmFsdWUpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5PblN5bnRheC5wcm90b3R5cGUud2hlbkFueUFuY2VzdG9ySXMgPSBmdW5jdGlvbiAoYW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5BbnlBbmNlc3RvcklzKGFuY2VzdG9yKTtcbiAgICB9O1xuICAgIEJpbmRpbmdXaGVuT25TeW50YXgucHJvdG90eXBlLndoZW5Ob0FuY2VzdG9ySXMgPSBmdW5jdGlvbiAoYW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5Ob0FuY2VzdG9ySXMoYW5jZXN0b3IpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5PblN5bnRheC5wcm90b3R5cGUud2hlbkFueUFuY2VzdG9yTmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlbkFueUFuY2VzdG9yTmFtZWQobmFtZSk7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuQW55QW5jZXN0b3JUYWdnZWQgPSBmdW5jdGlvbiAodGFnLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlbkFueUFuY2VzdG9yVGFnZ2VkKHRhZywgdmFsdWUpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5PblN5bnRheC5wcm90b3R5cGUud2hlbk5vQW5jZXN0b3JOYW1lZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuTm9BbmNlc3Rvck5hbWVkKG5hbWUpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5PblN5bnRheC5wcm90b3R5cGUud2hlbk5vQW5jZXN0b3JUYWdnZWQgPSBmdW5jdGlvbiAodGFnLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlbk5vQW5jZXN0b3JUYWdnZWQodGFnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuQW55QW5jZXN0b3JNYXRjaGVzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5BbnlBbmNlc3Rvck1hdGNoZXMoY29uc3RyYWludCk7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuTm9BbmNlc3Rvck1hdGNoZXMgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlbk5vQW5jZXN0b3JNYXRjaGVzKGNvbnN0cmFpbnQpO1xuICAgIH07XG4gICAgQmluZGluZ1doZW5PblN5bnRheC5wcm90b3R5cGUub25BY3RpdmF0aW9uID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdPblN5bnRheC5vbkFjdGl2YXRpb24oaGFuZGxlcik7XG4gICAgfTtcbiAgICBCaW5kaW5nV2hlbk9uU3ludGF4LnByb3RvdHlwZS5vbkRlYWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nT25TeW50YXgub25EZWFjdGl2YXRpb24oaGFuZGxlcik7XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ1doZW5PblN5bnRheDtcbn0oKSk7XG5leHBvcnQgeyBCaW5kaW5nV2hlbk9uU3ludGF4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nX3doZW5fb25fc3ludGF4LmpzLm1hcCIsImltcG9ydCB7IEJpbmRpbmdTY29wZUVudW0gfSBmcm9tIFwiLi4vY29uc3RhbnRzL2xpdGVyYWxfdHlwZXNcIjtcbmltcG9ydCB7IEJpbmRpbmdXaGVuT25TeW50YXggfSBmcm9tIFwiLi9iaW5kaW5nX3doZW5fb25fc3ludGF4XCI7XG52YXIgQmluZGluZ0luU3ludGF4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5kaW5nSW5TeW50YXgoYmluZGluZykge1xuICAgICAgICB0aGlzLl9iaW5kaW5nID0gYmluZGluZztcbiAgICB9XG4gICAgQmluZGluZ0luU3ludGF4LnByb3RvdHlwZS5pblJlcXVlc3RTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy5zY29wZSA9IEJpbmRpbmdTY29wZUVudW0uUmVxdWVzdDtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nV2hlbk9uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ0luU3ludGF4LnByb3RvdHlwZS5pblNpbmdsZXRvblNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLnNjb3BlID0gQmluZGluZ1Njb3BlRW51bS5TaW5nbGV0b247XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1doZW5PblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJblN5bnRheC5wcm90b3R5cGUuaW5UcmFuc2llbnRTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy5zY29wZSA9IEJpbmRpbmdTY29wZUVudW0uVHJhbnNpZW50O1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdXaGVuT25TeW50YXgodGhpcy5fYmluZGluZyk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ0luU3ludGF4O1xufSgpKTtcbmV4cG9ydCB7IEJpbmRpbmdJblN5bnRheCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGluZ19pbl9zeW50YXguanMubWFwIiwiaW1wb3J0IHsgQmluZGluZ0luU3ludGF4IH0gZnJvbSBcIi4vYmluZGluZ19pbl9zeW50YXhcIjtcbmltcG9ydCB7IEJpbmRpbmdPblN5bnRheCB9IGZyb20gXCIuL2JpbmRpbmdfb25fc3ludGF4XCI7XG5pbXBvcnQgeyBCaW5kaW5nV2hlblN5bnRheCB9IGZyb20gXCIuL2JpbmRpbmdfd2hlbl9zeW50YXhcIjtcbnZhciBCaW5kaW5nSW5XaGVuT25TeW50YXggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdJbldoZW5PblN5bnRheChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcgPSBiaW5kaW5nO1xuICAgICAgICB0aGlzLl9iaW5kaW5nV2hlblN5bnRheCA9IG5ldyBCaW5kaW5nV2hlblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICAgICAgdGhpcy5fYmluZGluZ09uU3ludGF4ID0gbmV3IEJpbmRpbmdPblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICAgICAgdGhpcy5fYmluZGluZ0luU3ludGF4ID0gbmV3IEJpbmRpbmdJblN5bnRheChiaW5kaW5nKTtcbiAgICB9XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS5pblJlcXVlc3RTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdJblN5bnRheC5pblJlcXVlc3RTY29wZSgpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS5pblNpbmdsZXRvblNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ0luU3ludGF4LmluU2luZ2xldG9uU2NvcGUoKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUuaW5UcmFuc2llbnRTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdJblN5bnRheC5pblRyYW5zaWVudFNjb3BlKCk7XG4gICAgfTtcbiAgICBCaW5kaW5nSW5XaGVuT25TeW50YXgucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlbihjb25zdHJhaW50KTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUud2hlblRhcmdldE5hbWVkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5UYXJnZXROYW1lZChuYW1lKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUud2hlblRhcmdldElzRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5UYXJnZXRJc0RlZmF1bHQoKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUud2hlblRhcmdldFRhZ2dlZCA9IGZ1bmN0aW9uICh0YWcsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuVGFyZ2V0VGFnZ2VkKHRhZywgdmFsdWUpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuSW5qZWN0ZWRJbnRvID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlbkluamVjdGVkSW50byhwYXJlbnQpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuUGFyZW50TmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlblBhcmVudE5hbWVkKG5hbWUpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuUGFyZW50VGFnZ2VkID0gZnVuY3Rpb24gKHRhZywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5QYXJlbnRUYWdnZWQodGFnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBCaW5kaW5nSW5XaGVuT25TeW50YXgucHJvdG90eXBlLndoZW5BbnlBbmNlc3RvcklzID0gZnVuY3Rpb24gKGFuY2VzdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuQW55QW5jZXN0b3JJcyhhbmNlc3Rvcik7XG4gICAgfTtcbiAgICBCaW5kaW5nSW5XaGVuT25TeW50YXgucHJvdG90eXBlLndoZW5Ob0FuY2VzdG9ySXMgPSBmdW5jdGlvbiAoYW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5Ob0FuY2VzdG9ySXMoYW5jZXN0b3IpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuQW55QW5jZXN0b3JOYW1lZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuQW55QW5jZXN0b3JOYW1lZChuYW1lKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUud2hlbkFueUFuY2VzdG9yVGFnZ2VkID0gZnVuY3Rpb24gKHRhZywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdXaGVuU3ludGF4LndoZW5BbnlBbmNlc3RvclRhZ2dlZCh0YWcsIHZhbHVlKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUud2hlbk5vQW5jZXN0b3JOYW1lZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuTm9BbmNlc3Rvck5hbWVkKG5hbWUpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuTm9BbmNlc3RvclRhZ2dlZCA9IGZ1bmN0aW9uICh0YWcsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuTm9BbmNlc3RvclRhZ2dlZCh0YWcsIHZhbHVlKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUud2hlbkFueUFuY2VzdG9yTWF0Y2hlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nV2hlblN5bnRheC53aGVuQW55QW5jZXN0b3JNYXRjaGVzKGNvbnN0cmFpbnQpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS53aGVuTm9BbmNlc3Rvck1hdGNoZXMgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1doZW5TeW50YXgud2hlbk5vQW5jZXN0b3JNYXRjaGVzKGNvbnN0cmFpbnQpO1xuICAgIH07XG4gICAgQmluZGluZ0luV2hlbk9uU3ludGF4LnByb3RvdHlwZS5vbkFjdGl2YXRpb24gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ09uU3ludGF4Lm9uQWN0aXZhdGlvbihoYW5kbGVyKTtcbiAgICB9O1xuICAgIEJpbmRpbmdJbldoZW5PblN5bnRheC5wcm90b3R5cGUub25EZWFjdGl2YXRpb24gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ09uU3ludGF4Lm9uRGVhY3RpdmF0aW9uKGhhbmRsZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdJbldoZW5PblN5bnRheDtcbn0oKSk7XG5leHBvcnQgeyBCaW5kaW5nSW5XaGVuT25TeW50YXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmdfaW5fd2hlbl9vbl9zeW50YXguanMubWFwIiwiaW1wb3J0ICogYXMgRVJST1JfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCB7IEJpbmRpbmdTY29wZUVudW0sIEJpbmRpbmdUeXBlRW51bSB9IGZyb20gXCIuLi9jb25zdGFudHMvbGl0ZXJhbF90eXBlc1wiO1xuaW1wb3J0IHsgQmluZGluZ0luV2hlbk9uU3ludGF4IH0gZnJvbSBcIi4vYmluZGluZ19pbl93aGVuX29uX3N5bnRheFwiO1xuaW1wb3J0IHsgQmluZGluZ1doZW5PblN5bnRheCB9IGZyb20gXCIuL2JpbmRpbmdfd2hlbl9vbl9zeW50YXhcIjtcbnZhciBCaW5kaW5nVG9TeW50YXggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdUb1N5bnRheChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcgPSBiaW5kaW5nO1xuICAgIH1cbiAgICBCaW5kaW5nVG9TeW50YXgucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcudHlwZSA9IEJpbmRpbmdUeXBlRW51bS5JbnN0YW5jZTtcbiAgICAgICAgdGhpcy5fYmluZGluZy5pbXBsZW1lbnRhdGlvblR5cGUgPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nSW5XaGVuT25TeW50YXgodGhpcy5fYmluZGluZyk7XG4gICAgfTtcbiAgICBCaW5kaW5nVG9TeW50YXgucHJvdG90eXBlLnRvU2VsZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9iaW5kaW5nLnNlcnZpY2VJZGVudGlmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgRVJST1JfTVNHUy5JTlZBTElEX1RPX1NFTEZfVkFMVUUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxmID0gdGhpcy5fYmluZGluZy5zZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oc2VsZik7XG4gICAgfTtcbiAgICBCaW5kaW5nVG9TeW50YXgucHJvdG90eXBlLnRvQ29uc3RhbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLnR5cGUgPSBCaW5kaW5nVHlwZUVudW0uQ29uc3RhbnRWYWx1ZTtcbiAgICAgICAgdGhpcy5fYmluZGluZy5jYWNoZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmR5bmFtaWNWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuaW1wbGVtZW50YXRpb25UeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmluZGluZy5zY29wZSA9IEJpbmRpbmdTY29wZUVudW0uU2luZ2xldG9uO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdXaGVuT25TeW50YXgodGhpcy5fYmluZGluZyk7XG4gICAgfTtcbiAgICBCaW5kaW5nVG9TeW50YXgucHJvdG90eXBlLnRvRHluYW1pY1ZhbHVlID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy50eXBlID0gQmluZGluZ1R5cGVFbnVtLkR5bmFtaWNWYWx1ZTtcbiAgICAgICAgdGhpcy5fYmluZGluZy5jYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuZHluYW1pY1ZhbHVlID0gZnVuYztcbiAgICAgICAgdGhpcy5fYmluZGluZy5pbXBsZW1lbnRhdGlvblR5cGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdJbldoZW5PblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdUb1N5bnRheC5wcm90b3R5cGUudG9Db25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLnR5cGUgPSBCaW5kaW5nVHlwZUVudW0uQ29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuaW1wbGVtZW50YXRpb25UeXBlID0gY29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuc2NvcGUgPSBCaW5kaW5nU2NvcGVFbnVtLlNpbmdsZXRvbjtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nV2hlbk9uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ1RvU3ludGF4LnByb3RvdHlwZS50b0ZhY3RvcnkgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nLnR5cGUgPSBCaW5kaW5nVHlwZUVudW0uRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fYmluZGluZy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5fYmluZGluZy5zY29wZSA9IEJpbmRpbmdTY29wZUVudW0uU2luZ2xldG9uO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdXaGVuT25TeW50YXgodGhpcy5fYmluZGluZyk7XG4gICAgfTtcbiAgICBCaW5kaW5nVG9TeW50YXgucHJvdG90eXBlLnRvRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuSU5WQUxJRF9GVU5DVElPTl9CSU5ESU5HKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmluZGluZ1doZW5PblN5bnRheCA9IHRoaXMudG9Db25zdGFudFZhbHVlKGZ1bmMpO1xuICAgICAgICB0aGlzLl9iaW5kaW5nLnR5cGUgPSBCaW5kaW5nVHlwZUVudW0uRnVuY3Rpb247XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuc2NvcGUgPSBCaW5kaW5nU2NvcGVFbnVtLlNpbmdsZXRvbjtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdXaGVuT25TeW50YXg7XG4gICAgfTtcbiAgICBCaW5kaW5nVG9TeW50YXgucHJvdG90eXBlLnRvQXV0b0ZhY3RvcnkgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZy50eXBlID0gQmluZGluZ1R5cGVFbnVtLkZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcuZmFjdG9yeSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYXV0b2ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0LmNvbnRhaW5lci5nZXQoc2VydmljZUlkZW50aWZpZXIpOyB9O1xuICAgICAgICAgICAgcmV0dXJuIGF1dG9mYWN0b3J5O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9iaW5kaW5nLnNjb3BlID0gQmluZGluZ1Njb3BlRW51bS5TaW5nbGV0b247XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1doZW5PblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdUb1N5bnRheC5wcm90b3R5cGUudG9BdXRvTmFtZWRGYWN0b3J5ID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcudHlwZSA9IEJpbmRpbmdUeXBlRW51bS5GYWN0b3J5O1xuICAgICAgICB0aGlzLl9iaW5kaW5nLmZhY3RvcnkgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lZCkgeyByZXR1cm4gY29udGV4dC5jb250YWluZXIuZ2V0TmFtZWQoc2VydmljZUlkZW50aWZpZXIsIG5hbWVkKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nV2hlbk9uU3ludGF4KHRoaXMuX2JpbmRpbmcpO1xuICAgIH07XG4gICAgQmluZGluZ1RvU3ludGF4LnByb3RvdHlwZS50b1Byb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcudHlwZSA9IEJpbmRpbmdUeXBlRW51bS5Qcm92aWRlcjtcbiAgICAgICAgdGhpcy5fYmluZGluZy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9iaW5kaW5nLnNjb3BlID0gQmluZGluZ1Njb3BlRW51bS5TaW5nbGV0b247XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1doZW5PblN5bnRheCh0aGlzLl9iaW5kaW5nKTtcbiAgICB9O1xuICAgIEJpbmRpbmdUb1N5bnRheC5wcm90b3R5cGUudG9TZXJ2aWNlID0gZnVuY3Rpb24gKHNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy50b0R5bmFtaWNWYWx1ZShmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gY29udGV4dC5jb250YWluZXIuZ2V0KHNlcnZpY2UpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nVG9TeW50YXg7XG59KCkpO1xuZXhwb3J0IHsgQmluZGluZ1RvU3ludGF4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nX3RvX3N5bnRheC5qcy5tYXAiLCJ2YXIgQ29udGFpbmVyU25hcHNob3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lclNuYXBzaG90KCkge1xuICAgIH1cbiAgICBDb250YWluZXJTbmFwc2hvdC5vZiA9IGZ1bmN0aW9uIChiaW5kaW5ncywgbWlkZGxld2FyZSwgYWN0aXZhdGlvbnMsIGRlYWN0aXZhdGlvbnMsIG1vZHVsZUFjdGl2YXRpb25TdG9yZSkge1xuICAgICAgICB2YXIgc25hcHNob3QgPSBuZXcgQ29udGFpbmVyU25hcHNob3QoKTtcbiAgICAgICAgc25hcHNob3QuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgc25hcHNob3QubWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XG4gICAgICAgIHNuYXBzaG90LmRlYWN0aXZhdGlvbnMgPSBkZWFjdGl2YXRpb25zO1xuICAgICAgICBzbmFwc2hvdC5hY3RpdmF0aW9ucyA9IGFjdGl2YXRpb25zO1xuICAgICAgICBzbmFwc2hvdC5tb2R1bGVBY3RpdmF0aW9uU3RvcmUgPSBtb2R1bGVBY3RpdmF0aW9uU3RvcmU7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICB9O1xuICAgIHJldHVybiBDb250YWluZXJTbmFwc2hvdDtcbn0oKSk7XG5leHBvcnQgeyBDb250YWluZXJTbmFwc2hvdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbmVyX3NuYXBzaG90LmpzLm1hcCIsImZ1bmN0aW9uIGlzQ2xvbmFibGUob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JylcbiAgICAgICAgJiYgKG9iaiAhPT0gbnVsbClcbiAgICAgICAgJiYgKCdjbG9uZScgaW4gb2JqKVxuICAgICAgICAmJiB0eXBlb2Ygb2JqLmNsb25lID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0IHsgaXNDbG9uYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmFibGUuanMubWFwIiwiaW1wb3J0ICogYXMgRVJST1JfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCB7IGlzQ2xvbmFibGUgfSBmcm9tIFwiLi4vdXRpbHMvY2xvbmFibGVcIjtcbnZhciBMb29rdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvb2t1cCgpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBMb29rdXAucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgICB9O1xuICAgIExvb2t1cC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoc2VydmljZUlkZW50aWZpZXIgPT09IG51bGwgfHwgc2VydmljZUlkZW50aWZpZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuTlVMTF9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dTLk5VTExfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21hcC5nZXQoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoZW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW50cnkucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KHNlcnZpY2VJZGVudGlmaWVyLCBbdmFsdWVdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9va3VwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKHNlcnZpY2VJZGVudGlmaWVyID09PSBudWxsIHx8IHNlcnZpY2VJZGVudGlmaWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dTLk5VTExfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21hcC5nZXQoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoZW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuS0VZX05PVF9GT1VORCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvb2t1cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlSWRlbnRpZmllciA9PT0gbnVsbCB8fCBzZXJ2aWNlSWRlbnRpZmllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHUy5OVUxMX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX21hcC5kZWxldGUoc2VydmljZUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHUy5LRVlfTk9UX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9va3VwLnByb3RvdHlwZS5yZW1vdmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAobG9va3VwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudHJhdmVyc2UoZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGxvb2t1cEFjdGl2YXRpb25zID0gbG9va3VwLmhhc0tleShzZXJ2aWNlSWRlbnRpZmllcikgPyBsb29rdXAuZ2V0KHNlcnZpY2VJZGVudGlmaWVyKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChsb29rdXBBY3RpdmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkVmFsdWVzID0gdmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChsb29rdXBWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWxvb2t1cEFjdGl2YXRpb25zLnNvbWUoZnVuY3Rpb24gKG1vZHVsZUFjdGl2YXRpb24pIHsgcmV0dXJuIGxvb2t1cFZhbHVlID09PSBtb2R1bGVBY3RpdmF0aW9uOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0VmFsdWUoc2VydmljZUlkZW50aWZpZXIsIGZpbHRlcmVkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb29rdXAucHJvdG90eXBlLnJlbW92ZUJ5Q29uZGl0aW9uID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWFwLmZvckVhY2goZnVuY3Rpb24gKGVudHJpZXMsIGtleSkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRFbnRyaWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9pIDwgZW50cmllc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZSA9IGNvbmRpdGlvbihlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmFscy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9zZXRWYWx1ZShrZXksIHVwZGF0ZWRFbnRyaWVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZW1vdmFscztcbiAgICB9O1xuICAgIExvb2t1cC5wcm90b3R5cGUuaGFzS2V5ID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlSWRlbnRpZmllciA9PT0gbnVsbCB8fCBzZXJ2aWNlSWRlbnRpZmllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHUy5OVUxMX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfTtcbiAgICBMb29rdXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBMb29rdXAoKTtcbiAgICAgICAgdGhpcy5fbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGNvcHkuYWRkKGtleSwgaXNDbG9uYWJsZShiKSA/IGIuY2xvbmUoKSA6IGIpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH07XG4gICAgTG9va3VwLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHRoaXMuX21hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBmdW5jKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvb2t1cC5wcm90b3R5cGUuX3NldFZhbHVlID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChzZXJ2aWNlSWRlbnRpZmllciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMb29rdXA7XG59KCkpO1xuZXhwb3J0IHsgTG9va3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb29rdXAuanMubWFwIiwiaW1wb3J0IHsgTG9va3VwIH0gZnJvbSBcIi4vbG9va3VwXCI7XG52YXIgTW9kdWxlQWN0aXZhdGlvblN0b3JlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2R1bGVBY3RpdmF0aW9uU3RvcmUoKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgTW9kdWxlQWN0aXZhdGlvblN0b3JlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcC5oYXMobW9kdWxlSWQpKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9tYXAuZ2V0KG1vZHVsZUlkKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUobW9kdWxlSWQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRFbXB0eUhhbmRsZXJzU3RvcmUoKTtcbiAgICB9O1xuICAgIE1vZHVsZUFjdGl2YXRpb25TdG9yZS5wcm90b3R5cGUuYWRkRGVhY3RpdmF0aW9uID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBzZXJ2aWNlSWRlbnRpZmllciwgb25EZWFjdGl2YXRpb24pIHtcbiAgICAgICAgdGhpcy5fZ2V0TW9kdWxlQWN0aXZhdGlvbkhhbmRsZXJzKG1vZHVsZUlkKVxuICAgICAgICAgICAgLm9uRGVhY3RpdmF0aW9ucy5hZGQoc2VydmljZUlkZW50aWZpZXIsIG9uRGVhY3RpdmF0aW9uKTtcbiAgICB9O1xuICAgIE1vZHVsZUFjdGl2YXRpb25TdG9yZS5wcm90b3R5cGUuYWRkQWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgc2VydmljZUlkZW50aWZpZXIsIG9uQWN0aXZhdGlvbikge1xuICAgICAgICB0aGlzLl9nZXRNb2R1bGVBY3RpdmF0aW9uSGFuZGxlcnMobW9kdWxlSWQpXG4gICAgICAgICAgICAub25BY3RpdmF0aW9ucy5hZGQoc2VydmljZUlkZW50aWZpZXIsIG9uQWN0aXZhdGlvbik7XG4gICAgfTtcbiAgICBNb2R1bGVBY3RpdmF0aW9uU3RvcmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgTW9kdWxlQWN0aXZhdGlvblN0b3JlKCk7XG4gICAgICAgIHRoaXMuX21hcC5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyc1N0b3JlLCBtb2R1bGVJZCkge1xuICAgICAgICAgICAgY2xvbmUuX21hcC5zZXQobW9kdWxlSWQsIHtcbiAgICAgICAgICAgICAgICBvbkFjdGl2YXRpb25zOiBoYW5kbGVyc1N0b3JlLm9uQWN0aXZhdGlvbnMuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBvbkRlYWN0aXZhdGlvbnM6IGhhbmRsZXJzU3RvcmUub25EZWFjdGl2YXRpb25zLmNsb25lKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIE1vZHVsZUFjdGl2YXRpb25TdG9yZS5wcm90b3R5cGUuX2dldE1vZHVsZUFjdGl2YXRpb25IYW5kbGVycyA9IGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgICAgICB2YXIgbW9kdWxlQWN0aXZhdGlvbkhhbmRsZXJzID0gdGhpcy5fbWFwLmdldChtb2R1bGVJZCk7XG4gICAgICAgIGlmIChtb2R1bGVBY3RpdmF0aW9uSGFuZGxlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbW9kdWxlQWN0aXZhdGlvbkhhbmRsZXJzID0gdGhpcy5fZ2V0RW1wdHlIYW5kbGVyc1N0b3JlKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KG1vZHVsZUlkLCBtb2R1bGVBY3RpdmF0aW9uSGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVBY3RpdmF0aW9uSGFuZGxlcnM7XG4gICAgfTtcbiAgICBNb2R1bGVBY3RpdmF0aW9uU3RvcmUucHJvdG90eXBlLl9nZXRFbXB0eUhhbmRsZXJzU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyc1N0b3JlID0ge1xuICAgICAgICAgICAgb25BY3RpdmF0aW9uczogbmV3IExvb2t1cCgpLFxuICAgICAgICAgICAgb25EZWFjdGl2YXRpb25zOiBuZXcgTG9va3VwKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzU3RvcmU7XG4gICAgfTtcbiAgICByZXR1cm4gTW9kdWxlQWN0aXZhdGlvblN0b3JlO1xufSgpKTtcbmV4cG9ydCB7IE1vZHVsZUFjdGl2YXRpb25TdG9yZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlX2FjdGl2YXRpb25fc3RvcmUuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5pbXBvcnQgeyBCaW5kaW5nIH0gZnJvbSBcIi4uL2JpbmRpbmdzL2JpbmRpbmdcIjtcbmltcG9ydCAqIGFzIEVSUk9SX01TR1MgZnJvbSBcIi4uL2NvbnN0YW50cy9lcnJvcl9tc2dzXCI7XG5pbXBvcnQgeyBCaW5kaW5nU2NvcGVFbnVtLCBUYXJnZXRUeXBlRW51bSB9IGZyb20gXCIuLi9jb25zdGFudHMvbGl0ZXJhbF90eXBlc1wiO1xuaW1wb3J0ICogYXMgTUVUQURBVEFfS0VZIGZyb20gXCIuLi9jb25zdGFudHMvbWV0YWRhdGFfa2V5c1wiO1xuaW1wb3J0IHsgTWV0YWRhdGFSZWFkZXIgfSBmcm9tIFwiLi4vcGxhbm5pbmcvbWV0YWRhdGFfcmVhZGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVNb2NrUmVxdWVzdCwgZ2V0QmluZGluZ0RpY3Rpb25hcnksIHBsYW4gfSBmcm9tIFwiLi4vcGxhbm5pbmcvcGxhbm5lclwiO1xuaW1wb3J0IHsgcmVzb2x2ZSB9IGZyb20gXCIuLi9yZXNvbHV0aW9uL3Jlc29sdmVyXCI7XG5pbXBvcnQgeyBCaW5kaW5nVG9TeW50YXggfSBmcm9tIFwiLi4vc3ludGF4L2JpbmRpbmdfdG9fc3ludGF4XCI7XG5pbXBvcnQgeyBpc1Byb21pc2UsIGlzUHJvbWlzZU9yQ29udGFpbnNQcm9taXNlIH0gZnJvbSBcIi4uL3V0aWxzL2FzeW5jXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi91dGlscy9pZFwiO1xuaW1wb3J0IHsgZ2V0U2VydmljZUlkZW50aWZpZXJBc1N0cmluZyB9IGZyb20gXCIuLi91dGlscy9zZXJpYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBDb250YWluZXJTbmFwc2hvdCB9IGZyb20gXCIuL2NvbnRhaW5lcl9zbmFwc2hvdFwiO1xuaW1wb3J0IHsgTG9va3VwIH0gZnJvbSBcIi4vbG9va3VwXCI7XG5pbXBvcnQgeyBNb2R1bGVBY3RpdmF0aW9uU3RvcmUgfSBmcm9tIFwiLi9tb2R1bGVfYWN0aXZhdGlvbl9zdG9yZVwiO1xudmFyIENvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNvbnRhaW5lck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250YWluZXJPcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgRVJST1JfTVNHUy5DT05UQUlORVJfT1BUSU9OU19NVVNUX0JFX0FOX09CSkVDVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdFNjb3BlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdFNjb3BlID0gQmluZGluZ1Njb3BlRW51bS5UcmFuc2llbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kZWZhdWx0U2NvcGUgIT09IEJpbmRpbmdTY29wZUVudW0uU2luZ2xldG9uICYmXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRTY29wZSAhPT0gQmluZGluZ1Njb3BlRW51bS5UcmFuc2llbnQgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdFNjb3BlICE9PSBCaW5kaW5nU2NvcGVFbnVtLlJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgRVJST1JfTVNHUy5DT05UQUlORVJfT1BUSU9OU19JTlZBTElEX0RFRkFVTFRfU0NPUEUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9CaW5kSW5qZWN0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmF1dG9CaW5kSW5qZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmF1dG9CaW5kSW5qZWN0YWJsZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgRVJST1JfTVNHUy5DT05UQUlORVJfT1BUSU9OU19JTlZBTElEX0FVVE9fQklORF9JTkpFQ1RBQkxFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5za2lwQmFzZUNsYXNzQ2hlY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcEJhc2VDbGFzc0NoZWNrcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnNraXBCYXNlQ2xhc3NDaGVja3MgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIEVSUk9SX01TR1MuQ09OVEFJTkVSX09QVElPTlNfSU5WQUxJRF9TS0lQX0JBU0VfQ0hFQ0spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGF1dG9CaW5kSW5qZWN0YWJsZTogb3B0aW9ucy5hdXRvQmluZEluamVjdGFibGUsXG4gICAgICAgICAgICBkZWZhdWx0U2NvcGU6IG9wdGlvbnMuZGVmYXVsdFNjb3BlLFxuICAgICAgICAgICAgc2tpcEJhc2VDbGFzc0NoZWNrczogb3B0aW9ucy5za2lwQmFzZUNsYXNzQ2hlY2tzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaWQgPSBpZCgpO1xuICAgICAgICB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeSA9IG5ldyBMb29rdXAoKTtcbiAgICAgICAgdGhpcy5fc25hcHNob3RzID0gW107XG4gICAgICAgIHRoaXMuX21pZGRsZXdhcmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9hY3RpdmF0aW9ucyA9IG5ldyBMb29rdXAoKTtcbiAgICAgICAgdGhpcy5fZGVhY3RpdmF0aW9ucyA9IG5ldyBMb29rdXAoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlYWRlciA9IG5ldyBNZXRhZGF0YVJlYWRlcigpO1xuICAgICAgICB0aGlzLl9tb2R1bGVBY3RpdmF0aW9uU3RvcmUgPSBuZXcgTW9kdWxlQWN0aXZhdGlvblN0b3JlKCk7XG4gICAgfVxuICAgIENvbnRhaW5lci5tZXJnZSA9IGZ1bmN0aW9uIChjb250YWluZXIxLCBjb250YWluZXIyKSB7XG4gICAgICAgIHZhciBjb250YWluZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjb250YWluZXJzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0YXJnZXRDb250YWluZXJzID0gX19zcHJlYWRBcnJheShbY29udGFpbmVyMSwgY29udGFpbmVyMl0sIGNvbnRhaW5lcnMsIHRydWUpLm1hcChmdW5jdGlvbiAodGFyZ2V0Q29udGFpbmVyKSB7IHJldHVybiBnZXRCaW5kaW5nRGljdGlvbmFyeSh0YXJnZXRDb250YWluZXIpOyB9KTtcbiAgICAgICAgdmFyIGJpbmRpbmdEaWN0aW9uYXJ5ID0gZ2V0QmluZGluZ0RpY3Rpb25hcnkoY29udGFpbmVyKTtcbiAgICAgICAgZnVuY3Rpb24gY29weURpY3Rpb25hcnkob3JpZ2luLCBkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgb3JpZ2luLnRyYXZlcnNlKGZ1bmN0aW9uIChfa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uYWRkKGJpbmRpbmcuc2VydmljZUlkZW50aWZpZXIsIGJpbmRpbmcuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRDb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldEJpbmRpbmdEaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICBjb3B5RGljdGlvbmFyeSh0YXJnZXRCaW5kaW5nRGljdGlvbmFyeSwgYmluZGluZ0RpY3Rpb25hcnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZHVsZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1vZHVsZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2V0SGVscGVycyA9IHRoaXMuX2dldENvbnRhaW5lck1vZHVsZUhlbHBlcnNGYWN0b3J5KCk7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgbW9kdWxlc18xID0gbW9kdWxlczsgX2EgPCBtb2R1bGVzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1vZHVsZSA9IG1vZHVsZXNfMVtfYV07XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyTW9kdWxlSGVscGVycyA9IGdldEhlbHBlcnMoY3VycmVudE1vZHVsZS5pZCk7XG4gICAgICAgICAgICBjdXJyZW50TW9kdWxlLnJlZ2lzdHJ5KGNvbnRhaW5lck1vZHVsZUhlbHBlcnMuYmluZEZ1bmN0aW9uLCBjb250YWluZXJNb2R1bGVIZWxwZXJzLnVuYmluZEZ1bmN0aW9uLCBjb250YWluZXJNb2R1bGVIZWxwZXJzLmlzYm91bmRGdW5jdGlvbiwgY29udGFpbmVyTW9kdWxlSGVscGVycy5yZWJpbmRGdW5jdGlvbiwgY29udGFpbmVyTW9kdWxlSGVscGVycy51bmJpbmRBc3luY0Z1bmN0aW9uLCBjb250YWluZXJNb2R1bGVIZWxwZXJzLm9uQWN0aXZhdGlvbkZ1bmN0aW9uLCBjb250YWluZXJNb2R1bGVIZWxwZXJzLm9uRGVhY3RpdmF0aW9uRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmxvYWRBc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZHVsZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1vZHVsZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2V0SGVscGVycywgX2EsIG1vZHVsZXNfMiwgY3VycmVudE1vZHVsZSwgY29udGFpbmVyTW9kdWxlSGVscGVycztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEhlbHBlcnMgPSB0aGlzLl9nZXRDb250YWluZXJNb2R1bGVIZWxwZXJzRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSAwLCBtb2R1bGVzXzIgPSBtb2R1bGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYSA8IG1vZHVsZXNfMi5sZW5ndGgpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1vZHVsZSA9IG1vZHVsZXNfMltfYV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJNb2R1bGVIZWxwZXJzID0gZ2V0SGVscGVycyhjdXJyZW50TW9kdWxlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY3VycmVudE1vZHVsZS5yZWdpc3RyeShjb250YWluZXJNb2R1bGVIZWxwZXJzLmJpbmRGdW5jdGlvbiwgY29udGFpbmVyTW9kdWxlSGVscGVycy51bmJpbmRGdW5jdGlvbiwgY29udGFpbmVyTW9kdWxlSGVscGVycy5pc2JvdW5kRnVuY3Rpb24sIGNvbnRhaW5lck1vZHVsZUhlbHBlcnMucmViaW5kRnVuY3Rpb24sIGNvbnRhaW5lck1vZHVsZUhlbHBlcnMudW5iaW5kQXN5bmNGdW5jdGlvbiwgY29udGFpbmVyTW9kdWxlSGVscGVycy5vbkFjdGl2YXRpb25GdW5jdGlvbiwgY29udGFpbmVyTW9kdWxlSGVscGVycy5vbkRlYWN0aXZhdGlvbkZ1bmN0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2ErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLnVubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1vZHVsZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1vZHVsZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgdmFyIGRlYWN0aXZhdGlvbnMgPSBfdGhpcy5fcmVtb3ZlTW9kdWxlQmluZGluZ3MobW9kdWxlLmlkKTtcbiAgICAgICAgICAgIF90aGlzLl9kZWFjdGl2YXRlU2luZ2xldG9ucyhkZWFjdGl2YXRpb25zKTtcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVNb2R1bGVIYW5kbGVycyhtb2R1bGUuaWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUudW5sb2FkQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2R1bGVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtb2R1bGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBtb2R1bGVzXzMsIG1vZHVsZV8xLCBkZWFjdGl2YXRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSAwLCBtb2R1bGVzXzMgPSBtb2R1bGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYSA8IG1vZHVsZXNfMy5sZW5ndGgpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlXzEgPSBtb2R1bGVzXzNbX2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVhY3RpdmF0aW9ucyA9IHRoaXMuX3JlbW92ZU1vZHVsZUJpbmRpbmdzKG1vZHVsZV8xLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5fZGVhY3RpdmF0ZVNpbmdsZXRvbnNBc3luYyhkZWFjdGl2YXRpb25zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU1vZHVsZUhhbmRsZXJzKG1vZHVsZV8xLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2ErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5vcHRpb25zLmRlZmF1bHRTY29wZSB8fCBCaW5kaW5nU2NvcGVFbnVtLlRyYW5zaWVudDtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBuZXcgQmluZGluZyhzZXJ2aWNlSWRlbnRpZmllciwgc2NvcGUpO1xuICAgICAgICB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeS5hZGQoc2VydmljZUlkZW50aWZpZXIsIGJpbmRpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdUb1N5bnRheChiaW5kaW5nKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmViaW5kID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMudW5iaW5kKHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZChzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLnJlYmluZEFzeW5jID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLnVuYmluZEFzeW5jKHNlcnZpY2VJZGVudGlmaWVyKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5iaW5kKHNlcnZpY2VJZGVudGlmaWVyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JpbmRpbmdEaWN0aW9uYXJ5Lmhhc0tleShzZXJ2aWNlSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdEaWN0aW9uYXJ5LmdldChzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICB0aGlzLl9kZWFjdGl2YXRlU2luZ2xldG9ucyhiaW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlU2VydmljZUZyb21EaWN0aW9uYXJ5KHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUudW5iaW5kQXN5bmMgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9iaW5kaW5nRGljdGlvbmFyeS5oYXNLZXkoc2VydmljZUlkZW50aWZpZXIpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeS5nZXQoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLl9kZWFjdGl2YXRlU2luZ2xldG9uc0FzeW5jKGJpbmRpbmdzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2VydmljZUZyb21EaWN0aW9uYXJ5KHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS51bmJpbmRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdEaWN0aW9uYXJ5LnRyYXZlcnNlKGZ1bmN0aW9uIChfa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMuX2RlYWN0aXZhdGVTaW5nbGV0b25zKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdEaWN0aW9uYXJ5ID0gbmV3IExvb2t1cCgpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS51bmJpbmRBbGxBc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeS50cmF2ZXJzZShmdW5jdGlvbiAoX2tleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKF90aGlzLl9kZWFjdGl2YXRlU2luZ2xldG9uc0FzeW5jKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgUHJvbWlzZS5hbGwocHJvbWlzZXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ0RpY3Rpb25hcnkgPSBuZXcgTG9va3VwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUub25BY3RpdmF0aW9uID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCBvbkFjdGl2YXRpb24pIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGlvbnMuYWRkKHNlcnZpY2VJZGVudGlmaWVyLCBvbkFjdGl2YXRpb24pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5vbkRlYWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllciwgb25EZWFjdGl2YXRpb24pIHtcbiAgICAgICAgdGhpcy5fZGVhY3RpdmF0aW9ucy5hZGQoc2VydmljZUlkZW50aWZpZXIsIG9uRGVhY3RpdmF0aW9uKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuaXNCb3VuZCA9IGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllcikge1xuICAgICAgICB2YXIgYm91bmQgPSB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeS5oYXNLZXkoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIWJvdW5kICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBib3VuZCA9IHRoaXMucGFyZW50LmlzQm91bmQoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuaXNDdXJyZW50Qm91bmQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdEaWN0aW9uYXJ5Lmhhc0tleShzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmlzQm91bmROYW1lZCA9IGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllciwgbmFtZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNCb3VuZFRhZ2dlZChzZXJ2aWNlSWRlbnRpZmllciwgTUVUQURBVEFfS0VZLk5BTUVEX1RBRywgbmFtZWQpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5pc0JvdW5kVGFnZ2VkID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBib3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fYmluZGluZ0RpY3Rpb25hcnkuaGFzS2V5KHNlcnZpY2VJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ0RpY3Rpb25hcnkuZ2V0KHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0XzEgPSBjcmVhdGVNb2NrUmVxdWVzdCh0aGlzLCBzZXJ2aWNlSWRlbnRpZmllciwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBib3VuZCA9IGJpbmRpbmdzLnNvbWUoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIuY29uc3RyYWludChyZXF1ZXN0XzEpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvdW5kICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBib3VuZCA9IHRoaXMucGFyZW50LmlzQm91bmRUYWdnZWQoc2VydmljZUlkZW50aWZpZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuc25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NuYXBzaG90cy5wdXNoKENvbnRhaW5lclNuYXBzaG90Lm9mKHRoaXMuX2JpbmRpbmdEaWN0aW9uYXJ5LmNsb25lKCksIHRoaXMuX21pZGRsZXdhcmUsIHRoaXMuX2FjdGl2YXRpb25zLmNsb25lKCksIHRoaXMuX2RlYWN0aXZhdGlvbnMuY2xvbmUoKSwgdGhpcy5fbW9kdWxlQWN0aXZhdGlvblN0b3JlLmNsb25lKCkpKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNuYXBzaG90ID0gdGhpcy5fc25hcHNob3RzLnBvcCgpO1xuICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuTk9fTU9SRV9TTkFQU0hPVFNfQVZBSUxBQkxFKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeSA9IHNuYXBzaG90LmJpbmRpbmdzO1xuICAgICAgICB0aGlzLl9hY3RpdmF0aW9ucyA9IHNuYXBzaG90LmFjdGl2YXRpb25zO1xuICAgICAgICB0aGlzLl9kZWFjdGl2YXRpb25zID0gc25hcHNob3QuZGVhY3RpdmF0aW9ucztcbiAgICAgICAgdGhpcy5fbWlkZGxld2FyZSA9IHNuYXBzaG90Lm1pZGRsZXdhcmU7XG4gICAgICAgIHRoaXMuX21vZHVsZUFjdGl2YXRpb25TdG9yZSA9IHNuYXBzaG90Lm1vZHVsZUFjdGl2YXRpb25TdG9yZTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuY3JlYXRlQ2hpbGQgPSBmdW5jdGlvbiAoY29udGFpbmVyT3B0aW9ucykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXcgQ29udGFpbmVyKGNvbnRhaW5lck9wdGlvbnMgfHwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5hcHBseU1pZGRsZXdhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaWRkbGV3YXJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbWlkZGxld2FyZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdGlhbCA9ICh0aGlzLl9taWRkbGV3YXJlKSA/IHRoaXMuX21pZGRsZXdhcmUgOiB0aGlzLl9wbGFuQW5kUmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlID0gbWlkZGxld2FyZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7IHJldHVybiBjdXJyKHByZXYpOyB9LCBpbml0aWFsKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuYXBwbHlDdXN0b21NZXRhZGF0YVJlYWRlciA9IGZ1bmN0aW9uIChtZXRhZGF0YVJlYWRlcikge1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlYWRlciA9IG1ldGFkYXRhUmVhZGVyO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgdmFyIGdldEFyZ3MgPSB0aGlzLl9nZXROb3RBbGxBcmdzKHNlcnZpY2VJZGVudGlmaWVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRCdXRUaHJvd0lmQXN5bmMoZ2V0QXJncyk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldEFzeW5jID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBnZXRBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGdldEFyZ3MgPSB0aGlzLl9nZXROb3RBbGxBcmdzKHNlcnZpY2VJZGVudGlmaWVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLl9nZXQoZ2V0QXJncyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRUYWdnZWQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGdldEFyZ3MgPSB0aGlzLl9nZXROb3RBbGxBcmdzKHNlcnZpY2VJZGVudGlmaWVyLCBmYWxzZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRCdXRUaHJvd0lmQXN5bmMoZ2V0QXJncyk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldFRhZ2dlZEFzeW5jID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBnZXRBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGdldEFyZ3MgPSB0aGlzLl9nZXROb3RBbGxBcmdzKHNlcnZpY2VJZGVudGlmaWVyLCBmYWxzZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLl9nZXQoZ2V0QXJncyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXROYW1lZCA9IGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllciwgbmFtZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFnZ2VkKHNlcnZpY2VJZGVudGlmaWVyLCBNRVRBREFUQV9LRVkuTkFNRURfVEFHLCBuYW1lZCk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldE5hbWVkQXN5bmMgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIsIG5hbWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRhZ2dlZEFzeW5jKHNlcnZpY2VJZGVudGlmaWVyLCBNRVRBREFUQV9LRVkuTkFNRURfVEFHLCBuYW1lZCk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllcikge1xuICAgICAgICB2YXIgZ2V0QXJncyA9IHRoaXMuX2dldEFsbEFyZ3Moc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnV0VGhyb3dJZkFzeW5jKGdldEFyZ3MpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRBbGxBc3luYyA9IGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllcikge1xuICAgICAgICB2YXIgZ2V0QXJncyA9IHRoaXMuX2dldEFsbEFyZ3Moc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWxsKGdldEFyZ3MpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRBbGxUYWdnZWQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGdldEFyZ3MgPSB0aGlzLl9nZXROb3RBbGxBcmdzKHNlcnZpY2VJZGVudGlmaWVyLCB0cnVlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ1dFRocm93SWZBc3luYyhnZXRBcmdzKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZ2V0QWxsVGFnZ2VkQXN5bmMgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGdldEFyZ3MgPSB0aGlzLl9nZXROb3RBbGxBcmdzKHNlcnZpY2VJZGVudGlmaWVyLCB0cnVlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFsbChnZXRBcmdzKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZ2V0QWxsTmFtZWQgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIsIG5hbWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbFRhZ2dlZChzZXJ2aWNlSWRlbnRpZmllciwgTUVUQURBVEFfS0VZLk5BTUVEX1RBRywgbmFtZWQpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5nZXRBbGxOYW1lZEFzeW5jID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCBuYW1lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxUYWdnZWRBc3luYyhzZXJ2aWNlSWRlbnRpZmllciwgTUVUQURBVEFfS0VZLk5BTUVEX1RBRywgbmFtZWQpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGlzQm91bmQgPSB0aGlzLmlzQm91bmQoY29uc3RydWN0b3JGdW5jdGlvbik7XG4gICAgICAgIGlmICghaXNCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kKGNvbnN0cnVjdG9yRnVuY3Rpb24pLnRvU2VsZigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvbHZlZCA9IHRoaXMuZ2V0KGNvbnN0cnVjdG9yRnVuY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kKGNvbnN0cnVjdG9yRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX3ByZURlc3Ryb3kgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IsIGluc3RhbmNlKSB7XG4gICAgICAgIGlmIChSZWZsZWN0Lmhhc01ldGFkYXRhKE1FVEFEQVRBX0tFWS5QUkVfREVTVFJPWSwgY29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoTUVUQURBVEFfS0VZLlBSRV9ERVNUUk9ZLCBjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbZGF0YS52YWx1ZV0oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fcmVtb3ZlTW9kdWxlSGFuZGxlcnMgPSBmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgICAgICAgdmFyIG1vZHVsZUFjdGl2YXRpb25zSGFuZGxlcnMgPSB0aGlzLl9tb2R1bGVBY3RpdmF0aW9uU3RvcmUucmVtb3ZlKG1vZHVsZUlkKTtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGlvbnMucmVtb3ZlSW50ZXJzZWN0aW9uKG1vZHVsZUFjdGl2YXRpb25zSGFuZGxlcnMub25BY3RpdmF0aW9ucyk7XG4gICAgICAgIHRoaXMuX2RlYWN0aXZhdGlvbnMucmVtb3ZlSW50ZXJzZWN0aW9uKG1vZHVsZUFjdGl2YXRpb25zSGFuZGxlcnMub25EZWFjdGl2YXRpb25zKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX3JlbW92ZU1vZHVsZUJpbmRpbmdzID0gZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeS5yZW1vdmVCeUNvbmRpdGlvbihmdW5jdGlvbiAoYmluZGluZykgeyByZXR1cm4gYmluZGluZy5tb2R1bGVJZCA9PT0gbW9kdWxlSWQ7IH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChiaW5kaW5nLCBpbnN0YW5jZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpLmNvbnN0cnVjdG9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlYWN0aXZhdGlvbnMuaGFzS2V5KGJpbmRpbmcuc2VydmljZUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlYWN0aXZhdGVDb250YWluZXIoaW5zdGFuY2UsIHRoaXMuX2RlYWN0aXZhdGlvbnMuZ2V0KGJpbmRpbmcuc2VydmljZUlkZW50aWZpZXIpLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZURlYWN0aXZhdGlvbkVycm9yKHJlc3VsdC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wcm9wYWdhdGVDb250YWluZXJEZWFjdGl2YXRpb25UaGVuQmluZGluZ0FuZFByZURlc3Ryb3lBc3luYyhiaW5kaW5nLCBpbnN0YW5jZSwgY29uc3RydWN0b3IpOyB9KSwgY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9wYWdhdGVEZWFjdGl2YXRpb25SZXN1bHQgPSB0aGlzLl9wcm9wYWdhdGVDb250YWluZXJEZWFjdGl2YXRpb25UaGVuQmluZGluZ0FuZFByZURlc3Ryb3koYmluZGluZywgaW5zdGFuY2UsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocHJvcGFnYXRlRGVhY3RpdmF0aW9uUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVEZWFjdGl2YXRpb25FcnJvcihwcm9wYWdhdGVEZWFjdGl2YXRpb25SZXN1bHQsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dTLk9OX0RFQUNUSVZBVElPTl9FUlJPUihjb25zdHJ1Y3Rvci5uYW1lLCBleC5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2hhbmRsZURlYWN0aXZhdGlvbkVycm9yID0gZnVuY3Rpb24gKGFzeW5jUmVzdWx0LCBjb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXhfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGFzeW5jUmVzdWx0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXhfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dTLk9OX0RFQUNUSVZBVElPTl9FUlJPUihjb25zdHJ1Y3Rvci5uYW1lLCBleF8xLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2RlYWN0aXZhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGRlYWN0aXZhdGlvbnNJdGVyYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVhY3RpdmF0aW9uID0gZGVhY3RpdmF0aW9uc0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKGRlYWN0aXZhdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRlYWN0aXZhdGlvbi52YWx1ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2RlYWN0aXZhdGVDb250YWluZXJBc3luYyhpbnN0YW5jZSwgZGVhY3RpdmF0aW9uc0l0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYWN0aXZhdGlvbiA9IGRlYWN0aXZhdGlvbnNJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2RlYWN0aXZhdGVDb250YWluZXJBc3luYyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZGVhY3RpdmF0aW9uc0l0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWFjdGl2YXRpb247XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWFjdGl2YXRpb24gPSBkZWFjdGl2YXRpb25zSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlYWN0aXZhdGlvbi52YWx1ZSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZGVhY3RpdmF0aW9uLnZhbHVlKGluc3RhbmNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYWN0aXZhdGlvbiA9IGRlYWN0aXZhdGlvbnNJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fZ2V0Q29udGFpbmVyTW9kdWxlSGVscGVyc0ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZXRNb2R1bGVJZCA9IGZ1bmN0aW9uIChiaW5kaW5nVG9TeW50YXgsIG1vZHVsZUlkKSB7XG4gICAgICAgICAgICBiaW5kaW5nVG9TeW50YXguX2JpbmRpbmcubW9kdWxlSWQgPSBtb2R1bGVJZDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEJpbmRGdW5jdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nVG9TeW50YXggPSBfdGhpcy5iaW5kKHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICBzZXRNb2R1bGVJZChiaW5kaW5nVG9TeW50YXgsIG1vZHVsZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZGluZ1RvU3ludGF4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFVuYmluZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy51bmJpbmQoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFVuYmluZEFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVuYmluZEFzeW5jKHNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRJc2JvdW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzQm91bmQoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFJlYmluZEZ1bmN0aW9uID0gZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdUb1N5bnRheCA9IF90aGlzLnJlYmluZChzZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgc2V0TW9kdWxlSWQoYmluZGluZ1RvU3ludGF4LCBtb2R1bGVJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdUb1N5bnRheDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRPbkFjdGl2YXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllciwgb25BY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21vZHVsZUFjdGl2YXRpb25TdG9yZS5hZGRBY3RpdmF0aW9uKG1vZHVsZUlkLCBzZXJ2aWNlSWRlbnRpZmllciwgb25BY3RpdmF0aW9uKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkFjdGl2YXRpb24oc2VydmljZUlkZW50aWZpZXIsIG9uQWN0aXZhdGlvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0T25EZWFjdGl2YXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZXJ2aWNlSWRlbnRpZmllciwgb25EZWFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbW9kdWxlQWN0aXZhdGlvblN0b3JlLmFkZERlYWN0aXZhdGlvbihtb2R1bGVJZCwgc2VydmljZUlkZW50aWZpZXIsIG9uRGVhY3RpdmF0aW9uKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRlYWN0aXZhdGlvbihzZXJ2aWNlSWRlbnRpZmllciwgb25EZWFjdGl2YXRpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtSWQpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBiaW5kRnVuY3Rpb246IGdldEJpbmRGdW5jdGlvbihtSWQpLFxuICAgICAgICAgICAgaXNib3VuZEZ1bmN0aW9uOiBnZXRJc2JvdW5kRnVuY3Rpb24oKSxcbiAgICAgICAgICAgIG9uQWN0aXZhdGlvbkZ1bmN0aW9uOiBnZXRPbkFjdGl2YXRpb25GdW5jdGlvbihtSWQpLFxuICAgICAgICAgICAgb25EZWFjdGl2YXRpb25GdW5jdGlvbjogZ2V0T25EZWFjdGl2YXRpb25GdW5jdGlvbihtSWQpLFxuICAgICAgICAgICAgcmViaW5kRnVuY3Rpb246IGdldFJlYmluZEZ1bmN0aW9uKG1JZCksXG4gICAgICAgICAgICB1bmJpbmRGdW5jdGlvbjogZ2V0VW5iaW5kRnVuY3Rpb24oKSxcbiAgICAgICAgICAgIHVuYmluZEFzeW5jRnVuY3Rpb246IGdldFVuYmluZEFzeW5jRnVuY3Rpb24oKVxuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2dldEFsbCA9IGZ1bmN0aW9uIChnZXRBcmdzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLl9nZXQoZ2V0QXJncykpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKGdldEFyZ3MpIHtcbiAgICAgICAgdmFyIHBsYW5BbmRSZXNvbHZlQXJncyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRBcmdzKSwgeyBjb250ZXh0SW50ZXJjZXB0b3I6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0OyB9LCB0YXJnZXRUeXBlOiBUYXJnZXRUeXBlRW51bS5WYXJpYWJsZSB9KTtcbiAgICAgICAgaWYgKHRoaXMuX21pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgIHZhciBtaWRkbGV3YXJlUmVzdWx0ID0gdGhpcy5fbWlkZGxld2FyZShwbGFuQW5kUmVzb2x2ZUFyZ3MpO1xuICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmVSZXN1bHQgPT09IHVuZGVmaW5lZCB8fCBtaWRkbGV3YXJlUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuSU5WQUxJRF9NSURETEVXQVJFX1JFVFVSTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGxhbkFuZFJlc29sdmUoKShwbGFuQW5kUmVzb2x2ZUFyZ3MpO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fZ2V0QnV0VGhyb3dJZkFzeW5jID0gZnVuY3Rpb24gKGdldEFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldChnZXRBcmdzKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZU9yQ29udGFpbnNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dTLkxBWllfSU5fU1lOQyhnZXRBcmdzLnNlcnZpY2VJZGVudGlmaWVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2dldEFsbEFyZ3MgPSBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgdmFyIGdldEFsbEFyZ3MgPSB7XG4gICAgICAgICAgICBhdm9pZENvbnN0cmFpbnRzOiB0cnVlLFxuICAgICAgICAgICAgaXNNdWx0aUluamVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHNlcnZpY2VJZGVudGlmaWVyOiBzZXJ2aWNlSWRlbnRpZmllcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGdldEFsbEFyZ3M7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLl9nZXROb3RBbGxBcmdzID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyLCBpc011bHRpSW5qZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBnZXROb3RBbGxBcmdzID0ge1xuICAgICAgICAgICAgYXZvaWRDb25zdHJhaW50czogZmFsc2UsXG4gICAgICAgICAgICBpc011bHRpSW5qZWN0OiBpc011bHRpSW5qZWN0LFxuICAgICAgICAgICAgc2VydmljZUlkZW50aWZpZXI6IHNlcnZpY2VJZGVudGlmaWVyLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBnZXROb3RBbGxBcmdzO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fcGxhbkFuZFJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwbGFuKF90aGlzLl9tZXRhZGF0YVJlYWRlciwgX3RoaXMsIGFyZ3MuaXNNdWx0aUluamVjdCwgYXJncy50YXJnZXRUeXBlLCBhcmdzLnNlcnZpY2VJZGVudGlmaWVyLCBhcmdzLmtleSwgYXJncy52YWx1ZSwgYXJncy5hdm9pZENvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzLmNvbnRleHRJbnRlcmNlcHRvcihjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2RlYWN0aXZhdGVJZlNpbmdsZXRvbiA9IGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghYmluZGluZy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9taXNlKGJpbmRpbmcuY2FjaGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZy5jYWNoZS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkgeyByZXR1cm4gX3RoaXMuX2RlYWN0aXZhdGUoYmluZGluZywgcmVzb2x2ZWQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVhY3RpdmF0ZShiaW5kaW5nLCBiaW5kaW5nLmNhY2hlKTtcbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2RlYWN0aXZhdGVTaW5nbGV0b25zID0gZnVuY3Rpb24gKGJpbmRpbmdzKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYmluZGluZ3NfMSA9IGJpbmRpbmdzOyBfaSA8IGJpbmRpbmdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlYWN0aXZhdGVJZlNpbmdsZXRvbihiaW5kaW5nKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dTLkFTWU5DX1VOQklORF9SRVFVSVJFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2RlYWN0aXZhdGVTaW5nbGV0b25zQXN5bmMgPSBmdW5jdGlvbiAoYmluZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBQcm9taXNlLmFsbChiaW5kaW5ncy5tYXAoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIF90aGlzLl9kZWFjdGl2YXRlSWZTaW5nbGV0b24oYik7IH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fcHJvcGFnYXRlQ29udGFpbmVyRGVhY3RpdmF0aW9uVGhlbkJpbmRpbmdBbmRQcmVEZXN0cm95ID0gZnVuY3Rpb24gKGJpbmRpbmcsIGluc3RhbmNlLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWFjdGl2YXRlLmJpbmQodGhpcy5wYXJlbnQpKGJpbmRpbmcsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nRGVhY3RpdmF0aW9uQW5kUHJlRGVzdHJveShiaW5kaW5nLCBpbnN0YW5jZSwgY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLl9wcm9wYWdhdGVDb250YWluZXJEZWFjdGl2YXRpb25UaGVuQmluZGluZ0FuZFByZURlc3Ryb3lBc3luYyA9IGZ1bmN0aW9uIChiaW5kaW5nLCBpbnN0YW5jZSwgY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5fZGVhY3RpdmF0ZS5iaW5kKHRoaXMucGFyZW50KShiaW5kaW5nLCBpbnN0YW5jZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgdGhpcy5fYmluZGluZ0RlYWN0aXZhdGlvbkFuZFByZURlc3Ryb3lBc3luYyhiaW5kaW5nLCBpbnN0YW5jZSwgY29uc3RydWN0b3IpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5fcmVtb3ZlU2VydmljZUZyb21EaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nRGljdGlvbmFyeS5yZW1vdmUoc2VydmljZUlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHUy5DQU5OT1RfVU5CSU5EICsgXCIgXCIgKyBnZXRTZXJ2aWNlSWRlbnRpZmllckFzU3RyaW5nKHNlcnZpY2VJZGVudGlmaWVyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX2JpbmRpbmdEZWFjdGl2YXRpb25BbmRQcmVEZXN0cm95ID0gZnVuY3Rpb24gKGJpbmRpbmcsIGluc3RhbmNlLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGJpbmRpbmcub25EZWFjdGl2YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJpbmRpbmcub25EZWFjdGl2YXRpb24oaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wcmVEZXN0cm95KGNvbnN0cnVjdG9yLCBpbnN0YW5jZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVEZXN0cm95KGNvbnN0cnVjdG9yLCBpbnN0YW5jZSk7XG4gICAgfTtcbiAgICBDb250YWluZXIucHJvdG90eXBlLl9iaW5kaW5nRGVhY3RpdmF0aW9uQW5kUHJlRGVzdHJveUFzeW5jID0gZnVuY3Rpb24gKGJpbmRpbmcsIGluc3RhbmNlLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgYmluZGluZy5vbkRlYWN0aXZhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYmluZGluZy5vbkRlYWN0aXZhdGlvbihpbnN0YW5jZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0LCB0aGlzLl9wcmVEZXN0cm95KGNvbnN0cnVjdG9yLCBpbnN0YW5jZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb250YWluZXI7XG59KCkpO1xuZXhwb3J0IHsgQ29udGFpbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWluZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGdldEZpcnN0QXJyYXlEdXBsaWNhdGUoYXJyYXkpIHtcbiAgICB2YXIgc2VlblZhbHVlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFycmF5XzEgPSBhcnJheTsgX2kgPCBhcnJheV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZW50cnkgPSBhcnJheV8xW19pXTtcbiAgICAgICAgaWYgKHNlZW5WYWx1ZXMuaGFzKGVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VlblZhbHVlcy5hZGQoZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qcy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBFUlJPUl9NU0dTIGZyb20gXCIuLi9jb25zdGFudHMvZXJyb3JfbXNnc1wiO1xuaW1wb3J0ICogYXMgTUVUQURBVEFfS0VZIGZyb20gXCIuLi9jb25zdGFudHMvbWV0YWRhdGFfa2V5c1wiO1xuaW1wb3J0IHsgZ2V0Rmlyc3RBcnJheUR1cGxpY2F0ZSB9IGZyb20gXCIuLi91dGlscy9qc1wiO1xuZnVuY3Rpb24gdGFyZ2V0SXNDb25zdHJ1Y3RvckZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQucHJvdG90eXBlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBfdGhyb3dJZk1ldGhvZFBhcmFtZXRlcihwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKHBhcmFtZXRlck5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHUy5JTlZBTElEX0RFQ09SQVRPUl9PUEVSQVRJT04pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRhZ1BhcmFtZXRlcihhbm5vdGF0aW9uVGFyZ2V0LCBwYXJhbWV0ZXJOYW1lLCBwYXJhbWV0ZXJJbmRleCwgbWV0YWRhdGEpIHtcbiAgICBfdGhyb3dJZk1ldGhvZFBhcmFtZXRlcihwYXJhbWV0ZXJOYW1lKTtcbiAgICBfdGFnUGFyYW1ldGVyT3JQcm9wZXJ0eShNRVRBREFUQV9LRVkuVEFHR0VELCBhbm5vdGF0aW9uVGFyZ2V0LCBwYXJhbWV0ZXJJbmRleC50b1N0cmluZygpLCBtZXRhZGF0YSk7XG59XG5mdW5jdGlvbiB0YWdQcm9wZXJ0eShhbm5vdGF0aW9uVGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHRhcmdldElzQ29uc3RydWN0b3JGdW5jdGlvbihhbm5vdGF0aW9uVGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTVNHUy5JTlZBTElEX0RFQ09SQVRPUl9PUEVSQVRJT04pO1xuICAgIH1cbiAgICBfdGFnUGFyYW1ldGVyT3JQcm9wZXJ0eShNRVRBREFUQV9LRVkuVEFHR0VEX1BST1AsIGFubm90YXRpb25UYXJnZXQuY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSwgbWV0YWRhdGEpO1xufVxuZnVuY3Rpb24gX2Vuc3VyZU5vTWV0YWRhdGFLZXlEdXBsaWNhdGVzKG1ldGFkYXRhKSB7XG4gICAgdmFyIG1ldGFkYXRhcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFkYXRhKSkge1xuICAgICAgICBtZXRhZGF0YXMgPSBtZXRhZGF0YTtcbiAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IGdldEZpcnN0QXJyYXlEdXBsaWNhdGUobWV0YWRhdGFzLm1hcChmdW5jdGlvbiAobWQpIHsgcmV0dXJuIG1kLmtleTsgfSkpO1xuICAgICAgICBpZiAoZHVwbGljYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dTLkRVUExJQ0FURURfTUVUQURBVEEgKyBcIiBcIiArIGR1cGxpY2F0ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0YWRhdGFzID0gW21ldGFkYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhcztcbn1cbmZ1bmN0aW9uIF90YWdQYXJhbWV0ZXJPclByb3BlcnR5KG1ldGFkYXRhS2V5LCBhbm5vdGF0aW9uVGFyZ2V0LCBrZXksIG1ldGFkYXRhKSB7XG4gICAgdmFyIG1ldGFkYXRhcyA9IF9lbnN1cmVOb01ldGFkYXRhS2V5RHVwbGljYXRlcyhtZXRhZGF0YSk7XG4gICAgdmFyIHBhcmFtc09yUHJvcGVydGllc01ldGFkYXRhID0ge307XG4gICAgaWYgKFJlZmxlY3QuaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFubm90YXRpb25UYXJnZXQpKSB7XG4gICAgICAgIHBhcmFtc09yUHJvcGVydGllc01ldGFkYXRhID0gUmVmbGVjdC5nZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5ub3RhdGlvblRhcmdldCk7XG4gICAgfVxuICAgIHZhciBwYXJhbU9yUHJvcGVydHlNZXRhZGF0YSA9IHBhcmFtc09yUHJvcGVydGllc01ldGFkYXRhW2tleV07XG4gICAgaWYgKHBhcmFtT3JQcm9wZXJ0eU1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1PclByb3BlcnR5TWV0YWRhdGEgPSBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YXMuc29tZShmdW5jdGlvbiAobWQpIHsgcmV0dXJuIG1kLmtleSA9PT0gbS5rZXk7IH0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SX01TR1MuRFVQTElDQVRFRF9NRVRBREFUQSArIFwiIFwiICsgbS5rZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFyYW1PclByb3BlcnR5TWV0YWRhdGFfMSA9IHBhcmFtT3JQcm9wZXJ0eU1ldGFkYXRhOyBfaSA8IHBhcmFtT3JQcm9wZXJ0eU1ldGFkYXRhXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHBhcmFtT3JQcm9wZXJ0eU1ldGFkYXRhXzFbX2ldO1xuICAgICAgICAgICAgX2xvb3BfMShtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhbU9yUHJvcGVydHlNZXRhZGF0YS5wdXNoLmFwcGx5KHBhcmFtT3JQcm9wZXJ0eU1ldGFkYXRhLCBtZXRhZGF0YXMpO1xuICAgIHBhcmFtc09yUHJvcGVydGllc01ldGFkYXRhW2tleV0gPSBwYXJhbU9yUHJvcGVydHlNZXRhZGF0YTtcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBwYXJhbXNPclByb3BlcnRpZXNNZXRhZGF0YSwgYW5ub3RhdGlvblRhcmdldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWdnZWREZWNvcmF0b3IobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5LCBpbmRleE9yUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhPclByb3BlcnR5RGVzY3JpcHRvciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGFnUGFyYW1ldGVyKHRhcmdldCwgdGFyZ2V0S2V5LCBpbmRleE9yUHJvcGVydHlEZXNjcmlwdG9yLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YWdQcm9wZXJ0eSh0YXJnZXQsIHRhcmdldEtleSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQpIHtcbiAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBfcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9O1xufVxuZnVuY3Rpb24gZGVjb3JhdGUoZGVjb3JhdG9yLCB0YXJnZXQsIHBhcmFtZXRlckluZGV4T3JQcm9wZXJ0eSkge1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVySW5kZXhPclByb3BlcnR5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIF9kZWNvcmF0ZShbX3BhcmFtKHBhcmFtZXRlckluZGV4T3JQcm9wZXJ0eSwgZGVjb3JhdG9yKV0sIHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbWV0ZXJJbmRleE9yUHJvcGVydHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShbZGVjb3JhdG9yXSwgdGFyZ2V0LCBwYXJhbWV0ZXJJbmRleE9yUHJvcGVydHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2RlY29yYXRlKFtkZWNvcmF0b3JdLCB0YXJnZXQpO1xuICAgIH1cbn1cbmV4cG9ydCB7IGRlY29yYXRlLCB0YWdQYXJhbWV0ZXIsIHRhZ1Byb3BlcnR5LCBjcmVhdGVUYWdnZWREZWNvcmF0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29yYXRvcl91dGlscy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBFUlJPUlNfTVNHUyBmcm9tIFwiLi4vY29uc3RhbnRzL2Vycm9yX21zZ3NcIjtcbmltcG9ydCAqIGFzIE1FVEFEQVRBX0tFWSBmcm9tIFwiLi4vY29uc3RhbnRzL21ldGFkYXRhX2tleXNcIjtcbmZ1bmN0aW9uIGluamVjdGFibGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoTUVUQURBVEFfS0VZLlBBUkFNX1RZUEVTLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTX01TR1MuRFVQTElDQVRFRF9JTkpFQ1RBQkxFX0RFQ09SQVRPUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGVzID0gUmVmbGVjdC5nZXRNZXRhZGF0YShNRVRBREFUQV9LRVkuREVTSUdOX1BBUkFNX1RZUEVTLCB0YXJnZXQpIHx8IFtdO1xuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKE1FVEFEQVRBX0tFWS5QQVJBTV9UWVBFUywgdHlwZXMsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbn1cbmV4cG9ydCB7IGluamVjdGFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdGFibGUuanMubWFwIiwiaW1wb3J0IHsgVU5ERUZJTkVEX0lOSkVDVF9BTk5PVEFUSU9OIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9lcnJvcl9tc2dzXCI7XG5pbXBvcnQgeyBNZXRhZGF0YSB9IGZyb20gXCIuLi9wbGFubmluZy9tZXRhZGF0YVwiO1xuaW1wb3J0IHsgY3JlYXRlVGFnZ2VkRGVjb3JhdG9yIH0gZnJvbSBcIi4vZGVjb3JhdG9yX3V0aWxzXCI7XG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0QmFzZShtZXRhZGF0YUtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VydmljZUlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSwgaW5kZXhPclByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VJZGVudGlmaWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiID8gdGFyZ2V0Lm5hbWUgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVU5ERUZJTkVEX0lOSkVDVF9BTk5PVEFUSU9OKGNsYXNzTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRhZ2dlZERlY29yYXRvcihuZXcgTWV0YWRhdGEobWV0YWRhdGFLZXksIHNlcnZpY2VJZGVudGlmaWVyKSkodGFyZ2V0LCB0YXJnZXRLZXksIGluZGV4T3JQcm9wZXJ0eURlc2NyaXB0b3IpO1xuICAgICAgICB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RfYmFzZS5qcy5tYXAiLCJpbXBvcnQgKiBhcyBNRVRBREFUQV9LRVkgZnJvbSBcIi4uL2NvbnN0YW50cy9tZXRhZGF0YV9rZXlzXCI7XG5pbXBvcnQgeyBpbmplY3RCYXNlIH0gZnJvbSBcIi4vaW5qZWN0X2Jhc2VcIjtcbnZhciBpbmplY3QgPSBpbmplY3RCYXNlKE1FVEFEQVRBX0tFWS5JTkpFQ1RfVEFHKTtcbmV4cG9ydCB7IGluamVjdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0LmpzLm1hcCIsImltcG9ydCB7IFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IFBMVUdJTl9TWVNURU1fQVVUT19VUERBVEUgPSAnUExVR0lOX1NZU1RFTV9BVVRPX1VQREFURSc7XG5leHBvcnQgY29uc3QgUExVR0lOX1NZU1RFTV9QTFVHSU4gPSAnUExVR0lOX1NZU1RFTV9QTFVHSU4nO1xuZXhwb3J0IGNvbnN0IFBMVUdJTl9TWVNURU1fVEhJUkRfUEFSVFlfUExVR0lOID0gJ1BMVUdJTl9TWVNURU1fVEhJUkRfUEFSVFlfUExVR0lOJztcbmV4cG9ydCBjb25zdCBQTFVHSU5fU1lTVEVNX1NBRkVfTU9ERV9FTkFCTEVEID0gJ1BMVUdJTl9TWVNURU1fU0FGRV9NT0RFX0VOQUJMRUQnO1xuZXhwb3J0IGNvbnN0IFBMVUdJTl9TVE9SRV9VUkwgPSAnUExVR0lOX1NUT1JFX1VSTCc7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29uZmlnOiBQbHVnaW5Db25maWcgPSB7XG4gICAgW1BMVUdJTl9TWVNURU1fU0FGRV9NT0RFX0VOQUJMRURdOiB0cnVlLFxuICAgIFtQTFVHSU5fU1lTVEVNX0FVVE9fVVBEQVRFXTogdHJ1ZSxcbiAgICBbUExVR0lOX1NZU1RFTV9QTFVHSU5dOiBbeyBrZXk6ICdzZXR0aW5nJywgZW5hYmxlZDogdHJ1ZSB9XSxcbiAgICBbUExVR0lOX1NZU1RFTV9USElSRF9QQVJUWV9QTFVHSU5dOiBbXSxcbiAgICBbUExVR0lOX1NUT1JFX1VSTF06ICdodHRwczovL2JpdGJ1Y2tldC5vcmcvc2l5dWFuLXBsdWdpbi9zaXl1YW4tcGx1Z2lucy9yYXcvbWFpbi8nLFxufTtcbiIsImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG4gICAgcmV0dXJuIHN0eWxlLnNoZWV0O1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nKSB7XG4gICAgICAgIGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQpIHx8ICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuICAgICAgICB3aGlsZSAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuICAgICAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJ1c3RlZClcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3JzW2tleV0gJiYgZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcChub2RlLCBkYXRhX21hcCkge1xuICAgIE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwga2V5LCBkYXRhX21hcFtrZXldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmNoZWNrZWQpXG4gICAgICAgICAgICB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgICB2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuICAgIGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc05vZGUsIGNyZWF0ZU5vZGUsIGRvbnRVcGRhdGVMYXN0SW5kZXggPSBmYWxzZSkge1xuICAgIC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCByZXN1bHROb2RlID0gKCgpID0+IHtcbiAgICAgICAgLy8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuICAgICAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoKTtcbiAgICB9KSgpO1xuICAgIHJlc3VsdE5vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlLmZvckVhY2godiA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSkpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhU3RyID0gJycgKyBkYXRhO1xuICAgICAgICBpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YVN0cikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhU3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgfSwgKCkgPT4gdGV4dChkYXRhKSwgdHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcbiAgICApO1xufVxuZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cbmZ1bmN0aW9uIGZpbmRfY29tbWVudChub2RlcywgdGV4dCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcbiAgICAvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcbiAgICBjb25zdCBzdGFydF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG4gICAgY29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuICAgIGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbih1bmRlZmluZWQsIGlzX3N2Zyk7XG4gICAgfVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuICAgICAgICBuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGNsYWltZWRfbm9kZXMsIGlzX3N2Zyk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgIT09IGRhdGEpXG4gICAgICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaW5wdXQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcbiAgICBjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKSB8fCBzZWxlY3Qub3B0aW9uc1swXTtcbiAgICByZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgb3B0aW9uID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxubGV0IGNyb3Nzb3JpZ2luO1xuZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Jvc3NvcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcm9zc29yaWdpbjtcbn1cbmZ1bmN0aW9uIGFkZF9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcbiAgICBjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgY29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcbiAgICAgICAgJ292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOycpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBpZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICBjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4od2luZG93LCAnbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmQobm9kZSwgaWZyYW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoKGlmcmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdFt0b2dnbGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbn1cbmZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuZnVuY3Rpb24gaGVhZF9zZWxlY3Rvcihub2RlSWQsIGhlYWQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgc3RhcnRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGhlYWQuY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBub2RlLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fRU5EYCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgLT0gMTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9TVEFSVGApIHtcbiAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnRlZCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGlzX3N2ZztcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICB9XG4gICAgbShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX3N2ZylcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBzdmdfZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuYyhodG1sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkoYW5jaG9yKTtcbiAgICB9XG4gICAgaChodG1sKSB7XG4gICAgICAgIHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB0aGlzLm4gPSBBcnJheS5mcm9tKHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMsIGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKGlzX3N2Zyk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBuZXcgY29tcG9uZW50KHByb3BzKTtcbn1cblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpIHtcbiAgICBjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG4gICAgbWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcbiAgICBjb25zdCB7IHN0eWxlc2hlZXQsIHJ1bGVzIH0gPSBtYW5hZ2VkX3N0eWxlcy5nZXQoZG9jKSB8fCBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKTtcbiAgICBpZiAoIXJ1bGVzW25hbWVdKSB7XG4gICAgICAgIHJ1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvd25lck5vZGUgfSA9IGluZm8uc3R5bGVzaGVldDtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG93bmVyTm9kZSBpZiBpdCBydW5zIG9uIGpzZG9tLlxuICAgICAgICAgICAgaWYgKG93bmVyTm9kZSlcbiAgICAgICAgICAgICAgICBkZXRhY2gob3duZXJOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWJlZm9yZXVwZGF0ZVxuICovXG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKC9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbm1vdW50XG4gKi9cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICovXG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbmRlc3Ryb3lcbiAqL1xuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKC9kb2NzI3RlbXBsYXRlLXN5bnRheC1jb21wb25lbnQtZGlyZWN0aXZlcy1vbi1ldmVudG5hbWUpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWNyZWF0ZWV2ZW50ZGlzcGF0Y2hlclxuICovXG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1zZXRjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWdldGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtZ2V0YWxsY29udGV4dHNcbiAqL1xuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWhhc2NvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICAgICAgdXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIC8vIERvIG5vdCByZWVudGVyIGZsdXNoIHdoaWxlIGRpcnR5IGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGFzIHRoaXMgY2FuXG4gICAgLy8gcmVzdWx0IGluIGFuIGluZmluaXRlIGxvb3AuIEluc3RlYWQsIGxldCB0aGUgaW5uZXIgZmx1c2ggaGFuZGxlIGl0LlxuICAgIC8vIFJlZW50cmFuY3kgaXMgb2sgYWZ0ZXJ3YXJkcyBmb3IgYmluZGluZ3MgZXRjLlxuICAgIGlmIChmbHVzaGlkeCAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIGRvIHtcbiAgICAgICAgLy8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuICAgICAgICAvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG4gICAgICAgICAgICAgICAgZmx1c2hpZHgrKztcbiAgICAgICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB1cGRhdGUoY29tcG9uZW50LiQkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZGlydHkgc3RhdGUgdG8gbm90IGVuZCB1cCBpbiBhIGRlYWRsb2NrZWQgc3RhdGUgYW5kIHRoZW4gcmV0aHJvd1xuICAgICAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgZmx1c2hpZHggPSAwO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgZmx1c2hpZHggPSAwO1xuICAgICAgICB3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgLy8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG4gICAgICAgIC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2VcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuICAgIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgIH1cbiAgICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgc2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAkJC51cGRhdGUoKTtcbiAgICAgICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAgICAgY29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcbiAgICAgICAgJCQuZGlydHkgPSBbLTFdO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuICAgICAgICAkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbiAgICB9XG59XG5cbmxldCBwcm9taXNlO1xuZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xubGV0IG91dHJvcztcbmZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcbiAgICBvdXRyb3MgPSB7XG4gICAgICAgIHI6IDAsXG4gICAgICAgIGM6IFtdLFxuICAgICAgICBwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcbiAgICBpZiAoIW91dHJvcy5yKSB7XG4gICAgICAgIHJ1bl9hbGwob3V0cm9zLmMpO1xuICAgIH1cbiAgICBvdXRyb3MgPSBvdXRyb3MucDtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcbiAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgYmxvY2suaShsb2NhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcbiAgICAgICAgaWYgKG91dHJvaW5nLmhhcyhibG9jaykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG91dHJvaW5nLmFkZChibG9jayk7XG4gICAgICAgIG91dHJvcy5jLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmQoMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJsb2NrLm8obG9jYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbmZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdpbicgfTtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBsZXQgdGFzaztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG4gICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRhc2spXG4gICAgICAgICAgICB0YXNrLmFib3J0KCk7XG4gICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcbiAgICAgICAgdGFzayA9IGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnb3V0JyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgY29uc3QgZ3JvdXAgPSBvdXRyb3M7XG4gICAgZ3JvdXAuciArPSAxO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG4gICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tZ3JvdXAucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxIC0gdCwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdvKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZChyZXNldCkge1xuICAgICAgICAgICAgaWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRpY2soMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnYm90aCcgfTtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBsZXQgdCA9IGludHJvID8gMCA6IDE7XG4gICAgbGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBkID0gKHByb2dyYW0uYiAtIHQpO1xuICAgICAgICBkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHQsXG4gICAgICAgICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydDogcHJvZ3JhbS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuICAgICAgICAgICAgZ3JvdXA6IHByb2dyYW0uZ3JvdXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oYikge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICAgICAgICBiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICAgICAgICBvdXRyb3MuciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgLy8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuICAgICAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iLCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludHJvIOKAlCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHJvIOKAlCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJ1bihiKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9wcm9taXNlKHByb21pc2UsIGluZm8pIHtcbiAgICBjb25zdCB0b2tlbiA9IGluZm8udG9rZW4gPSB7fTtcbiAgICBmdW5jdGlvbiB1cGRhdGUodHlwZSwgaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZm8udG9rZW4gIT09IHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbmZvLnJlc29sdmVkID0gdmFsdWU7XG4gICAgICAgIGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZF9jdHggPSBjaGlsZF9jdHguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkX2N0eFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgbmVlZHNfZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uYmxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBpbmRleCAmJiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrc1tpXSA9PT0gYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ibG9ja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2suZCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICAgICAgYmxvY2subShpbmZvLm1vdW50KCksIGluZm8uYW5jaG9yKTtcbiAgICAgICAgICAgIG5lZWRzX2ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrcylcbiAgICAgICAgICAgIGluZm8uYmxvY2tzW2luZGV4XSA9IGJsb2NrO1xuICAgICAgICBpZiAobmVlZHNfZmx1c2gpIHtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5jYXRjaCwgMiwgaW5mby5lcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICAgICAgaWYgKCFpbmZvLmhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby5wZW5kaW5nKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5wZW5kaW5nLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHByb21pc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaChpbmZvLCBjdHgsIGRpcnR5KSB7XG4gICAgY29uc3QgY2hpbGRfY3R4ID0gY3R4LnNsaWNlKCk7XG4gICAgY29uc3QgeyByZXNvbHZlZCB9ID0gaW5mbztcbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8udmFsdWVdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8uY2F0Y2gpIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8uZXJyb3JdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGluZm8uYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZCgxKTtcbiAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5mdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gICAgbGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcbiAgICBsZXQgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGxldCBpID0gbztcbiAgICBjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gICAgY29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuICAgIGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X2xvb2t1cC5zZXQoa2V5LCBuZXdfYmxvY2tzW2ldID0gYmxvY2spO1xuICAgICAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKVxuICAgICAgICAgICAgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgIGJsb2NrLm0obm9kZSwgbmV4dCk7XG4gICAgICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgICAgIG5leHQgPSBibG9jay5maXJzdDtcbiAgICAgICAgbi0tO1xuICAgIH1cbiAgICB3aGlsZSAobyAmJiBuKSB7XG4gICAgICAgIGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcbiAgICAgICAgY29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG4gICAgICAgIGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuICAgICAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGJsb2NrXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuICAgICAgICAgICAgZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChvLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcbiAgICAgICAgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSlcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgIH1cbiAgICB3aGlsZSAobilcbiAgICAgICAgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcbiAgICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgIGNvbnN0IHRvX251bGxfb3V0ID0ge307XG4gICAgY29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuICAgIGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsZXZlbHNbaV07XG4gICAgICAgIGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuKSlcbiAgICAgICAgICAgICAgICAgICAgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlW2tleV0gPSBuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB1cGRhdGUpKVxuICAgICAgICAgICAgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG5jb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICAnYWxsb3dmdWxsc2NyZWVuJyxcbiAgICAnYWxsb3dwYXltZW50cmVxdWVzdCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXV0b2ZvY3VzJyxcbiAgICAnYXV0b3BsYXknLFxuICAgICdjaGVja2VkJyxcbiAgICAnY29udHJvbHMnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZGVmZXInLFxuICAgICdkaXNhYmxlZCcsXG4gICAgJ2Zvcm1ub3ZhbGlkYXRlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaW5lcnQnLFxuICAgICdpc21hcCcsXG4gICAgJ2l0ZW1zY29wZScsXG4gICAgJ2xvb3AnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ211dGVkJyxcbiAgICAnbm9tb2R1bGUnLFxuICAgICdub3ZhbGlkYXRlJyxcbiAgICAnb3BlbicsXG4gICAgJ3BsYXlzaW5saW5lJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAnc2VsZWN0ZWQnXG5dKTtcblxuLyoqIHJlZ2V4IG9mIGFsbCBodG1sIHZvaWQgZWxlbWVudCBuYW1lcyAqL1xuY29uc3Qgdm9pZF9lbGVtZW50X25hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkLztcbmZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuICAgIHJldHVybiB2b2lkX2VsZW1lbnRfbmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGF0dHJzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoYXR0cnNfdG9fYWRkKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlc190b19hZGQgPSBhdHRyc190b19hZGQuc3R5bGVzO1xuICAgICAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBtZXJnZV9zc3Jfc3R5bGVzKHN0eWxlX2F0dHJpYnV0ZSwgc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgY29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG4gICAgICAgIGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKDAsIGNvbG9uX2luZGV4KS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVfZGlyZWN0aXZlW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG4vKipcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBhbmQgaGFzIGJlZW4gb3B0aW1pemVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvNTcwMVxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGVzY2FwZWQgPSAnJztcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyW2ldO1xuICAgICAgICBlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiAoY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7JykpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICAvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuICAgIGNvbnN0IHNob3VsZF9lc2NhcGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzLiBPdGhlcndpc2UgeW91IG1heSBuZWVkIHRvIGZpeCBhIDwke25hbWV9Pi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcbiAgICAgICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IChwcm9wcyA9IHt9LCB7ICQkc2xvdHMgPSB7fSwgY29udGV4dCA9IG5ldyBNYXAoKSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3kgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdGl0bGU6ICcnLCBoZWFkOiAnJywgY3NzOiBuZXcgU2V0KCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCB7fSwgJCRzbG90cywgY29udGV4dCk7XG4gICAgICAgICAgICBydW5fYWxsKG9uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpLm1hcChjc3MgPT4gY3NzLmNvZGUpLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG51bGwgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICQkcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZF9hdHRyaWJ1dGUobmFtZSwgdmFsdWUsIGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgYXNzaWdubWVudCA9IChib29sZWFuICYmIHZhbHVlID09PSB0cnVlKSA/ICcnIDogYD1cIiR7ZXNjYXBlKHZhbHVlLCB0cnVlKX1cImA7XG4gICAgcmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlX29iamVjdClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gc3R5bGVfb2JqZWN0W2tleV0pXG4gICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX06ICR7ZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShzdHlsZV9vYmplY3Rba2V5XSl9O2ApXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhZGRfc3R5bGVzKHN0eWxlX29iamVjdCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcbiAgICByZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuXG5mdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG4gICAgYmxvY2sgJiYgYmxvY2suYygpO1xufVxuZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcbiAgICBibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvciwgY3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBjb21wb25lbnQuJCQub25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuICAgICAgICAgICAgLy8gdGhlIGRlc3RydWN0dXJlZCBvbl9kZXN0cm95IG1heSBzdGlsbCByZWZlcmVuY2UgdG8gdGhlIG9sZCBhcnJheVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcbiAgICAgICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgJCQuY3R4ID0gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICAgIH1cbiAgICBjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAoMSA8PCAoaSAlIDMxKSk7XG59XG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcywgYXBwZW5kX3N0eWxlcywgZGlydHkgPSBbLTFdKSB7XG4gICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBbXSxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZSxcbiAgICAgICAgcm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG4gICAgfTtcbiAgICBhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBzdGFydF9oeWRyYXRpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRybylcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcbiAgICAgICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgICAgICBlbmRfaHlkcmF0aW5nKCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgaWYgKCFpc19mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgIH1cbiAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFpc19mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuNTUuMScgfSwgZGV0YWlsKSwgeyBidWJibGVzOiB0cnVlIH0pKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuICAgIGlmICh0YWcgJiYgIWlzX3N0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgaWYgKHRhZyAmJiBpc192b2lkKHRhZykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPiBpcyBzZWxmLWNsb3NpbmcgYW5kIGNhbm5vdCBoYXZlIGNvbnRlbnQuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2KGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBlcnJvcl9tZXNzYWdlID0gJ3RoaXM9ey4uLn0gb2YgPHN2ZWx0ZTpjb21wb25lbnQ+IHNob3VsZCBzcGVjaWZ5IGEgU3ZlbHRlIGNvbXBvbmVudC4nO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IGNvbXBvbmVudChwcm9wcyk7XG4gICAgICAgIGlmICghaW5zdGFuY2UuJCQgfHwgIWluc3RhbmNlLiRzZXQgfHwgIWluc3RhbmNlLiRvbiB8fCAhaW5zdGFuY2UuJGRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBlcnI7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZS5pbmRleE9mKCdpcyBub3QgYSBjb25zdHJ1Y3RvcicpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgU3ZlbHRlQ29tcG9uZW50LCBTdmVsdGVDb21wb25lbnREZXYsIFN2ZWx0ZUNvbXBvbmVudFR5cGVkLCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF9zdHlsZXMsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQsIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2RldiwgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGhlYWRfc2VsZWN0b3IsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGlzX3ZvaWQsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWVyZ2Vfc3NyX3N0eWxlcywgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCwgc2V0X2RhdGEsIHNldF9kYXRhX2Rldiwgc2V0X2lucHV0X3R5cGUsIHNldF9pbnB1dF92YWx1ZSwgc2V0X25vdywgc2V0X3JhZiwgc2V0X3N0b3JlX3ZhbHVlLCBzZXRfc3R5bGUsIHNldF9zdmdfYXR0cmlidXRlcywgc3BhY2UsIHNwcmVhZCwgc3JjX3VybF9lcXVhbCwgc3RhcnRfaHlkcmF0aW5nLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB0cnVzdGVkLCB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoLCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X2Jhc2UsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZHluYW1pY19lbGVtZW50LCB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50LCB2YWxpZGF0ZV9lYWNoX2tleXMsIHZhbGlkYXRlX3Nsb3RzLCB2YWxpZGF0ZV9zdG9yZSwgdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQsIHhsaW5rX2F0dHIgfTtcbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgSUNvbW1hbmRNYW5hZ2VyLCBDb21tYW5kIH0gZnJvbSAnQC90eXBlcyc7XG4gICAgaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSAnLi4vLi4vY2xhc3Nlcy9kaWFsb2cnO1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IGNvbnRhaW5lciB9IGZyb20gJy4uLy4uLy4uL2NvbnRhaW5lcic7XG4gICAgaW1wb3J0IHsgXyB9IGZyb20gJ0AvdXRpbCc7XG4gICAgY29uc3QgY29tbWFuZE1hbmFnZXIgPSBjb250YWluZXIuZ2V0PElDb21tYW5kTWFuYWdlcj4oJ0NvbW1hbmRNYW5hZ2VyJyk7XG5cbiAgICBsZXQgY29tbWFuZHM6IENvbW1hbmRbXSA9IFtdO1xuXG4gICAgbGV0IGNvbW1hbmQgPSAnJztcblxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuXG4gICAgbGV0IHJlc3VsdDogQ29tbWFuZFtdID0gW107XG5cbiAgICBjb25zdCBvbmtleXByZXNzID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIG9uRW50ZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vdmVVcFxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAzOCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRJbmRleC0tO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmVEb3duXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQwKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb25FbnRlciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgY29tID0gcmVzdWx0W2N1cnJlbnRJbmRleF07XG4gICAgICAgIERpYWxvZy5kZXN0cm95QWxsKCk7XG4gICAgICAgIGNvbS5jYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKGk6IG51bWJlcikgPT4ge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBpO1xuICAgICAgICBvbkVudGVyKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhc0NvbnRlbnQgPSAodjogc3RyaW5nIHwgdW5kZWZpbmVkLCBjOiBzdHJpbmcpID0+IHYgJiYgdi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoYy50b0xvd2VyQ2FzZSgpKSA+PSAwO1xuXG4gICAgJDoge1xuICAgICAgICBjdXJyZW50SW5kZXggPSAwO1xuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbW1hbmRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tbWFuZHMuZmlsdGVyKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudChjLnBsdWdpbiwgY29tbWFuZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudChjLnBsdWdpbk5hbWUsIGNvbW1hbmQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbnRlbnQoYy5jb21tYW5kLCBjb21tYW5kKSB8fFxuICAgICAgICAgICAgICAgICAgICBoYXNDb250ZW50KGMuZGVzY3JpcHRpb24sIGNvbW1hbmQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGNvbW1hbmRzID0gY29tbWFuZE1hbmFnZXIuZ2V0Q29tbWFuZHMoKTtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29tbWFuZFBhbmVsSW5wdXQnKTtcbiAgICAgICAgZWwuZm9jdXMoKTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiZm5fX2ZsZXgtY29sdW1uXCIgc3R5bGU9XCJib3JkZXItcmFkaXVzOiA0cHg7b3ZlcmZsb3c6IGhpZGRlbjtwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiBtYXgoODB2dywgMTAwMHB4KVwiPlxuICAgIDxkaXYgY2xhc3M9XCJiMy1mb3JtX19pY29uIHNlYXJjaF9faGVhZGVyXCI+XG4gICAgICAgIDxzdmdcbiAgICAgICAgICAgIHN0eWxlPVwibGVmdDogMTRweDtcIlxuICAgICAgICAgICAgY2xhc3M9XCJiMy1mb3JtX19pY29uLWljb25cIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAxMDI0IDEwMjRcIlxuICAgICAgICAgICAgdmVyc2lvbj1cIjEuMVwiXG4gICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgIHdpZHRoPVwiMjAwXCJcbiAgICAgICAgICAgIGhlaWdodD1cIjIwMFwiXG4gICAgICAgICAgICA+PHBhdGhcbiAgICAgICAgICAgICAgICBkPVwiTTY0IDExMnY4MDBoODk2VjExMkg2NHogbTg0NiA3NTBIMTE0VjE2Mmg3OTZ2NzAwek0yMzQuNiA2ODguOEw0MTEuMyA1MTIgMjM0LjYgMzM1LjJsMzUuNC0zNS40TDQ4Mi4xIDUxMiAyNjkuOSA3MjQuMWwtMzUuMy0zNS4zeiBtNTU0LjgtMTAuMmgtMzAwdi01MGgzMDB2NTB6XCJcbiAgICAgICAgICAgIC8+PC9zdmdcbiAgICAgICAgPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIGlkPVwiY29tbWFuZFBhbmVsSW5wdXRcIlxuICAgICAgICAgICAgY2xhc3M9XCJiMy10ZXh0LWZpZWxkIGIzLXRleHQtZmllbGQtLXRleHQgZm5fX2Jsb2NrIGIzLWZvcm1fX2ljb24taW5wdXRcIlxuICAgICAgICAgICAgYmluZDp2YWx1ZT17Y29tbWFuZH1cbiAgICAgICAgICAgIG9uOmtleWRvd249e29ua2V5cHJlc3N9XG4gICAgICAgIC8+XG4gICAgPC9kaXY+XG4gICAgeyNpZiByZXN1bHR9XG4gICAgICAgIHsjZWFjaCByZXN1bHQgYXMgY29tLCBpfVxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9e2kgPT09IGN1cnJlbnRJbmRleCA/ICdjb21tYW5kLXNlbGVjdGVkIGNvbW1hbmQnIDogJ2NvbW1hbmQnfSBvbjpjbGljaz17KCkgPT4gb25DbGljayhpKX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb21tYW5kLXBsdWdpblwiPntjb20ucGx1Z2luTmFtZX0geyc6J30gPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY29tbWFuZC1kZXNjcmlwdGlvblwiPntjb20uY29tbWFuZH0ge2NvbS5kZXNjcmlwdGlvbiB8fCAnJ308L3NwYW4+XG4gICAgICAgICAgICAgICAgeyNpZiBjb20uc2hvcnRjdXR9XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21tYW5kLXNob3J0Y3V0XCI+e18oJ3Nob3J0Y3V0Jyl9OiB7Y29tLnNob3J0Y3V0fTwvZGl2PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9lYWNofVxuICAgIHsvaWZ9XG48L2Rpdj5cblxuPHN0eWxlPlxuICAgIC5jb21tYW5kIHtcbiAgICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgfVxuICAgIC5jb21tYW5kOmhvdmVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1iMy10aGVtZS1wcmltYXJ5KTtcbiAgICB9XG4gICAgLmNvbW1hbmQtc2VsZWN0ZWQge1xuICAgICAgICBjb2xvcjogdmFyKC0tYjMtdGhlbWUtcHJpbWFyeSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICB9XG4gICAgLmNvbW1hbmQtcGx1Z2luIHtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgIH1cbiAgICAuY29tbWFuZC1zaG9ydGN1dCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgY29sb3I6IHZhcigtLWNvbG9yLXRleHQtMyk7XG4gICAgfVxuPC9zdHlsZT5cbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ0AvYXBpL3BsdWdpbic7XG5pbXBvcnQgeyBEaWFsb2cgfSBmcm9tICdAL2ludGVybmFsL2NsYXNzZXMnO1xuaW1wb3J0IHsgU2hvcnRjdXQgfSBmcm9tICdAL2NvcmUvc2hvcnRjdXQnO1xuaW1wb3J0IENvbW1hbmRQYW5lbF9fU3ZlbHRlQ29tcG9uZW50XyBmcm9tICcuL2NvbW1hbmQtcGFuZWwuc3ZlbHRlJztcbmltcG9ydCB7IF8gfSBmcm9tICdAL3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgQ29tbWFuZFBhbmVsUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzaG9ydGN1dDogU2hvcnRjdXQ7XG5cbiAgICBvbmxvYWQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb21tYW5kKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdTaG93IGNvbW1hbmQgcGFuZWwnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IF8oJ3Nob3dfY29tbWFuZF9wYW5lbCcpLFxuICAgICAgICAgICAgc2hvcnRjdXQ6ICdjdHJsK3NoaWZ0K28sY29tbWFuZCtzaGlmdCtvJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93UGFuZWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNob3dQYW5lbCgpIHtcbiAgICAgICAgRGlhbG9nLmRlc3Ryb3lBbGwoKTtcbiAgICAgICAgbmV3IERpYWxvZyh7IGNvbnRlbnQ6ICc8ZGl2IGlkPVwiY29tbWFuZC1wYW5lbFwiPjwvZGl2PicgfSk7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBuZXcgQ29tbWFuZFBhbmVsX19TdmVsdGVDb21wb25lbnRfKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb21tYW5kLXBhbmVsJyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBkZWZhdWx0Q29uZmlnLCBQTFVHSU5fU1RPUkVfVVJMLCBQTFVHSU5fU1lTVEVNX0FVVE9fVVBEQVRFLCBQTFVHSU5fU1lTVEVNX1NBRkVfTU9ERV9FTkFCTEVEIH0gZnJvbSAnQC9jb3JlL3BsdWdpbi1jb25maWcnO1xuICAgIGltcG9ydCB7IGNvbnRhaW5lciB9IGZyb20gJ0AvY29udGFpbmVyJztcbiAgICBpbXBvcnQgeyBUWVBFUyB9IGZyb20gJ0AvY29uZmlnJztcbiAgICBpbXBvcnQgeyBJUGx1Z2luU3lzdGVtLCBJU3RvcmFnZU1hbmFnZXIgfSBmcm9tICdAL3R5cGVzJztcbiAgICBpbXBvcnQgeyBfIH0gZnJvbSAnQC91dGlsJztcblxuICAgIGNvbnN0IHN0b3JhZ2VNYW5hZ2VyID0gY29udGFpbmVyLmdldDxJU3RvcmFnZU1hbmFnZXI+KFRZUEVTLlN0b3JhZ2VNYW5hZ2VyKTtcbiAgICBjb25zdCBwbHVnaW5TeXN0ZW0gPSBjb250YWluZXIuZ2V0PElQbHVnaW5TeXN0ZW0+KFRZUEVTLlBsdWdpblN5c3RlbSk7XG5cbiAgICBsZXQgY29uZmlncyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IF8oJ3NhZmVtb2RlJyksXG4gICAgICAgICAgICB0aXA6IF8oJ3NhZmVtb2RldGlwJyksXG4gICAgICAgICAgICBjaGVja2VkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luU3lzdGVtLnR1cm5PblNhZmVNb2RlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luU3lzdGVtLnR1cm5PZmZTYWZlTW9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGxhYmVsOiBfKCdhdXRvdXBncmFkZScpLFxuICAgICAgICAvLyAgICAgdGlwOiBfKCdhdXRvdXBncmFkZXRpcCcpLFxuICAgICAgICAvLyAgICAgY2hlY2tlZDogdHJ1ZSxcbiAgICAgICAgLy8gICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgIC8vICAgICBvbkNoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgc3RvcmFnZU1hbmFnZXIuc2V0KFBMVUdJTl9TWVNURU1fQVVUT19VUERBVEUsIGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiBfKCdzdG9yZV91cmwnKSxcbiAgICAgICAgICAgIHRpcDogYCR7Xygnc3RvcmVfdXJsX3RpcCcpfSAke2RlZmF1bHRDb25maWcuUExVR0lOX1NUT1JFX1VSTH1gLFxuICAgICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yYWdlTWFuYWdlci5nZXQoUExVR0lOX1NUT1JFX1VSTCksXG4gICAgICAgICAgICBvbkNoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZU1hbmFnZXIuc2V0KFBMVUdJTl9TVE9SRV9VUkwsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VjdXJpdHlNb2RlID0gc3RvcmFnZU1hbmFnZXIuZ2V0KFBMVUdJTl9TWVNURU1fU0FGRV9NT0RFX0VOQUJMRUQpO1xuICAgICAgICBjb25maWdzWzBdLmNoZWNrZWQgPSBzZWN1cml0eU1vZGU7XG4gICAgICAgIGNvbnN0IGF1dG9VcGRhdGUgPSBzdG9yYWdlTWFuYWdlci5nZXQoUExVR0lOX1NZU1RFTV9BVVRPX1VQREFURSk7XG4gICAgICAgIGNvbmZpZ3NbMV0uY2hlY2tlZCA9IGF1dG9VcGRhdGU7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNlYWNoIGNvbmZpZ3MgYXMgY29uZmlnfVxuICAgIDxsYWJlbCBjbGFzcz1cImZuX19mbGV4IGIzLWxhYmVsIGNvbmZpZ19faXRlbVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm5fX2ZsZXgtMVwiPlxuICAgICAgICAgICAge2NvbmZpZy5sYWJlbH1cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJiMy1sYWJlbF9fdGV4dFwiPntjb25maWcudGlwfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJmbl9fc3BhY2VcIiAvPlxuICAgICAgICB7I2lmIGNvbmZpZy50eXBlID09PSAnY2hlY2tib3gnfVxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiYjMtc3dpdGNoIGZuX19mbGV4LWNlbnRlclwiIHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD17Y29uZmlnLmNoZWNrZWR9IG9uOmNoYW5nZT17Y29uZmlnLm9uQ2hhbmdlfSAvPlxuICAgICAgICB7OmVsc2UgaWYgY29uZmlnLnR5cGUgPT09ICdpbnB1dCd9XG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJiMy10ZXh0LWZpZWxkIGZuX19mbGV4LWNlbnRlciBmbl9fc2l6ZTIwMFwiIHR5cGU9XCJpbnB1dFwiIGJpbmQ6dmFsdWU9e2NvbmZpZy52YWx1ZX0gb246Y2hhbmdlPXtjb25maWcub25DaGFuZ2V9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9sYWJlbD5cbnsvZWFjaH1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBjb250YWluZXIgfSBmcm9tICdAL2NvbnRhaW5lcic7XG4gICAgaW1wb3J0IHsgVFlQRVMgfSBmcm9tICdAL2NvbmZpZyc7XG4gICAgaW1wb3J0IHsgSVBsdWdpblN5c3RlbSwgSVN0b3JhZ2VNYW5hZ2VyLCBQbHVnaW5NYW5pZmVzdCB9IGZyb20gJ0AvdHlwZXMnO1xuICAgIGltcG9ydCB7IFBMVUdJTl9TWVNURU1fU0FGRV9NT0RFX0VOQUJMRUQgfSBmcm9tICdAL2NvcmUvcGx1Z2luLWNvbmZpZyc7XG4gICAgaW1wb3J0IHsgXyB9IGZyb20gJ0AvdXRpbCc7XG5cbiAgICBjb25zdCBzdG9yYWdlTWFuYWdlciA9IGNvbnRhaW5lci5nZXQ8SVN0b3JhZ2VNYW5hZ2VyPihUWVBFUy5TdG9yYWdlTWFuYWdlcik7XG4gICAgY29uc3QgcGx1Z2luU3lzdGVtID0gY29udGFpbmVyLmdldDxJUGx1Z2luU3lzdGVtPihUWVBFUy5QbHVnaW5TeXN0ZW0pO1xuXG4gICAgbGV0IHBsdWdpbnM6IFBsdWdpbk1hbmlmZXN0W10gPSBbXTtcblxuICAgICQ6IG91dHNpZGVQbHVnaW5zID0gcGx1Z2lucy5maWx0ZXIoKHApID0+IHAuc2NyaXB0KTtcblxuICAgIGNvbnN0IGxvYWRQbHVnaW5zID0gKCkgPT4ge1xuICAgICAgICBwbHVnaW5zID0gc3RvcmFnZU1hbmFnZXIuZ2V0UGx1Z2lucygpO1xuICAgIH07XG5cbiAgICBjb25zdCBkaXNwYXRjaGVyID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBjb25zdCBvblBsdWdpbkVuYWJsZWRDaGFuZ2UgPSAoa2V5OiBzdHJpbmcpID0+IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBzYWZlTW9kZSA9IHN0b3JhZ2VNYW5hZ2VyLmdldChQTFVHSU5fU1lTVEVNX1NBRkVfTU9ERV9FTkFCTEVEKTtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICBhd2FpdCBzdG9yYWdlTWFuYWdlci5zZXRQbHVnaW5FbmFibGVkKGtleSwgY2hlY2tlZCk7XG4gICAgICAgIGlmIChzYWZlTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICBwbHVnaW5TeXN0ZW0ubG9hZFBsdWdpbihrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGx1Z2luU3lzdGVtLnVubG9hZFBsdWdpbihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoZXIoJ3VwZGF0ZScpO1xuICAgIH07XG5cbiAgICBjb25zdCB1bmluc3RhbGwgPSBhc3luYyAoa2V5OiBzdHJpbmcsIGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBhd2FpdCBwbHVnaW5TeXN0ZW0udW5sb2FkUGx1Z2luKGtleSk7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2VNYW5hZ2VyLnVuaW5zdGFsbFBsdWdpbihrZXkpO1xuICAgICAgICBhd2FpdCBzdG9yYWdlTWFuYWdlci5pbml0U3RvcmFnZSgpO1xuICAgICAgICBsb2FkUGx1Z2lucygpO1xuICAgIH07XG5cbiAgICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgc3RvcmFnZU1hbmFnZXIuaW5pdFN0b3JhZ2UoKTtcbiAgICAgICAgbG9hZFBsdWdpbnMoKTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48bGFiZWwgY2xhc3M9XCJiMy1sYWJlbCBmbl9fZmxleFwiPlxuICAgIDxkaXYgY2xhc3M9XCJmbl9fZmxleC0xXCI+XG4gICAgICAgIHsjZWFjaCBvdXRzaWRlUGx1Z2lucyBhcyBwbHVnaW59XG4gICAgICAgICAgICB7I2lmICFwbHVnaW4uaGlkZGVufVxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZuX19mbGV4IGIzLWxhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4gZm5fX2ZsZXgtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge3BsdWdpbi5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAge3BsdWdpbi52ZXJzaW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicmVtb3ZlXCIgb246Y2xpY2s9eyhldmVudCkgPT4gdW5pbnN0YWxsKHBsdWdpbi5rZXksIGV2ZW50KX0+e18oJ3VuaW5zdGFsbCcpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJiMy1sYWJlbF9fdGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtwbHVnaW4uZGVzY3JpcHRpb24gfHwgXygnbm9kZXNjcmlwdGlvbicpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZuX19zcGFjZVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiMy1zd2l0Y2ggZm5fX2ZsZXgtY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwiZnVsbFdpZHRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kOmNoZWNrZWQ9e3BsdWdpbi5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlPXtvblBsdWdpbkVuYWJsZWRDaGFuZ2UocGx1Z2luLmtleSl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbjwvbGFiZWw+XG5cbjxzdHlsZT5cbiAgICAucGx1Z2luIHNwYW4ucmVtb3ZlIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgY29sb3I6IHZhcigtLWIzLXRoZW1lLWVycm9yKTtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcbiAgICB9XG4gICAgLnBsdWdpbjpob3ZlciBzcGFuLnJlbW92ZSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbiAgICAucGx1Z2luOmhvdmVyIHNwYW4ucmVtb3ZlOmhvdmVyIHtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgfVxuPC9zdHlsZT5cbiIsImltcG9ydCB7IFRZUEVTIH0gZnJvbSAnQC9jb25maWcnO1xuaW1wb3J0IHsgUExVR0lOX1NUT1JFX1VSTCB9IGZyb20gJ0AvY29yZS9wbHVnaW4tY29uZmlnJztcbmltcG9ydCB7IElTdG9yYWdlTWFuYWdlciwgSVN0b3JlLCBTdG9yZVBsdWdpbk1hbmlmZXN0LCBTdG9yZVBsdWdpblN0YXR1cyB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgQXhpb3NSZXNwb25zZSB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IGluamVjdCwgaW5qZWN0YWJsZSB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyBTZW1WZXIgfSBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgcmVxdWVzdCwgc2xlZXAgfSBmcm9tICdAL3V0aWwnO1xuaW1wb3J0IHsgRmlsZUNsaWVudCB9IGZyb20gJ0AvYXBpL2ZpbGUtYXBpJztcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0b3JlIGltcGxlbWVudHMgSVN0b3JlIHtcbiAgICBwcml2YXRlIHBsdWdpbnM6IFN0b3JlUGx1Z2luTWFuaWZlc3RbXTtcbiAgICBwcml2YXRlIHBsdWdpblN0YXR1czogU3RvcmVQbHVnaW5TdGF0dXNbXTtcblxuICAgIGNvbnN0cnVjdG9yKEBpbmplY3Q8SVN0b3JhZ2VNYW5hZ2VyPihUWVBFUy5TdG9yYWdlTWFuYWdlcikgcHJpdmF0ZSBzdG9yYWdlTWFuYWdlcjogSVN0b3JhZ2VNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpblN0YXR1cyA9IFtdO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBpbml0KCkge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5TdGF0dXMgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMubG9hZFBsdWdpbnNGcm9tVXJsKCksIHRoaXMuc3RvcmFnZU1hbmFnZXIuaW5pdFN0b3JhZ2UoKV0pO1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5zdG9yYWdlTWFuYWdlci5nZXRQbHVnaW5zKCk7XG4gICAgICAgIGNvbnN0IHN0b3JlUGx1Z2luczogU3RvcmVQbHVnaW5TdGF0dXNbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHA6IFN0b3JlUGx1Z2luU3RhdHVzID0geyAuLi5wbHVnaW4sIGlzRXhpc3Q6IGZhbHNlLCBuZWVkVXBncmFkZTogZmFsc2UgfTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFBsdWdpbiA9IHBsdWdpbnMuZmluZCgocCkgPT4gcC5rZXkgPT09IHBsdWdpbi5rZXkpO1xuICAgICAgICAgICAgaWYgKG9sZFBsdWdpbikge1xuICAgICAgICAgICAgICAgIHAuaXNFeGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcFYgPSBuZXcgU2VtVmVyKHAudmVyc2lvbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGx1Z2luViA9IG5ldyBTZW1WZXIob2xkUGx1Z2luLnZlcnNpb24pO1xuICAgICAgICAgICAgICAgIGlmIChwVi5jb21wYXJlKG9sZFBsdWdpblYpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHAubmVlZFVwZ3JhZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlUGx1Z2lucy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGx1Z2luU3RhdHVzID0gc3RvcmVQbHVnaW5zO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTdG9yZVVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KFBMVUdJTl9TVE9SRV9VUkwpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBsb2FkUGx1Z2lucygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBsdWdpbnNXaXRoU3RhdHVzKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFBsdWdpbnNXaXRoU3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5TdGF0dXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGxvYWRQbHVnaW5zRnJvbVVybCgpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVVcmwgPSB0aGlzLmdldFN0b3JlVXJsKCk7XG4gICAgICAgIGlmICghc3RvcmVVcmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzOiBBeGlvc1Jlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgcmVxdWVzdC5nZXQoc3RvcmVVcmwgKyAnL3BsdWdpbnMuanNvbicsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcy5kYXRhPy5wbHVnaW5zKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwbHVnaW5LZXkgb2YgcmVzLmRhdGE/LnBsdWdpbnMgfHwge30pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLmdldFBsdWdpbk1hbmlmZXN0KGAke3N0b3JlVXJsfS8ke3BsdWdpbktleX1gKTtcbiAgICAgICAgICAgICAgICByZXEucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldFBsdWdpbkJ5VXJsKHVybDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5nZXRQbHVnaW5NYW5pZmVzdCh1cmwpLCB0aGlzLmdldFBsdWdpbk1haW5Kcyh1cmwpXSkudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3Q6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIG1haW5KczogdmFsdWVbMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0UGx1Z2luTWFuaWZlc3QodXJsOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gYXdhaXQgcmVxdWVzdC5nZXQoYCR7dXJsfS9tYW5pZmVzdC5qc29uYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5kYXRhO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0UGx1Z2luTWFpbkpzKHVybDogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0LmdldChgJHt1cmx9L21haW4uanNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0UGx1Z2luUmVhZG1lKGtleTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuZ2V0U3RvcmVVcmwoKX0vJHtrZXl9YDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QuZ2V0KGAke3VybH0vUkVBRE1FLm1kYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXMuZGF0YSBhcyBzdHJpbmc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkb3dubG9hZFBsdWdpbihrZXk6IHN0cmluZykge1xuICAgICAgICBhd2FpdCBzbGVlcCg1MDApO1xuICAgICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMuZ2V0UGx1Z2luQnlVcmwoYCR7dGhpcy5nZXRTdG9yZVVybCgpfS8ke2tleX1gKTtcbiAgICAgICAgY29uc3QgbWFuaWZlc3RKc29uID0gZmlsZXMubWFuaWZlc3Q7XG4gICAgICAgIGNvbnN0IG1haW5KcyA9IGZpbGVzLm1haW5KcztcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIEZpbGVDbGllbnQuZ2V0SW5zdGFuY2VBcGkoKS5maWxlQXBpLnB1dEZpbGUoYC9kYXRhL3BsdWdpbnMvJHtrZXl9YCwgbnVsbCwgdHJ1ZSksXG4gICAgICAgICAgICBGaWxlQ2xpZW50LmdldEluc3RhbmNlQXBpKCkuZmlsZUFwaS5wdXRGaWxlKGAvZGF0YS9wbHVnaW5zLyR7a2V5fS9tYW5pZmVzdC5qc29uYCwgSlNPTi5zdHJpbmdpZnkobWFuaWZlc3RKc29uKSwgZmFsc2UpLFxuICAgICAgICAgICAgRmlsZUNsaWVudC5nZXRJbnN0YW5jZUFwaSgpLmZpbGVBcGkucHV0RmlsZShgL2RhdGEvcGx1Z2lucy8ke2tleX0vbWFpbi5qc2AsIG1haW5KcywgZmFsc2UpLFxuICAgICAgICBdKTtcbiAgICB9XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgIGV4cG9ydCBsZXQgb25DbGljazogKCkgPT4gdm9pZCA9IG51bGw7XG4gICAgZXhwb3J0IGxldCBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2s9e29uQ2xpY2t9IHtkaXNhYmxlZH0gY2xhc3M9XCJiMy1idXR0b25cIj48c2xvdCAvPjwvYnV0dG9uPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBjb250YWluZXIgfSBmcm9tICdAL2NvbnRhaW5lcic7XG4gICAgaW1wb3J0IHsgSVN0b3JlLCBQbHVnaW5NYW5pZmVzdCB9IGZyb20gJ0AvdHlwZXMnO1xuICAgIGltcG9ydCB7IF8gfSBmcm9tICdAL3V0aWwnO1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgbGV0IGxvYWRpbmcgPSB0cnVlO1xuXG4gICAgZXhwb3J0IGxldCBwbHVnaW46IFBsdWdpbk1hbmlmZXN0O1xuXG4gICAgY29uc3QgZ2V0UGx1Z2luUmVhZG1lID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICByZWFkbWUgPSBhd2FpdCBjb250YWluZXIuZ2V0PElTdG9yZT4oJ1N0b3JlJykuZ2V0UGx1Z2luUmVhZG1lKHBsdWdpbi5rZXkpO1xuICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGxldCByZWFkbWU6IHN0cmluZztcblxuICAgIGNvbnN0IEx1dGVNZENvbnZlcnRlciA9IHdpbmRvdy5MdXRlLk5ldygpO1xuXG4gICAgJDogcHJldmlld0hUTUwgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiByZWFkbWUgPyBMdXRlTWRDb252ZXJ0ZXIuTWQySFRNTChyZWFkbWUpIDogJyc7XG4gICAgfTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBnZXRQbHVnaW5SZWFkbWUoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdvQmFjayA9ICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goJ2dvYmFjaycpO1xuICAgIH07XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInBsdWdpbi1kZXRhaWxcIj5cbiAgICA8ZGl2IGNsYXNzPVwicGx1Z2luLWJhc2ljXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4taW5mb1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBsdWdpbi1uYW1lXCI+e3BsdWdpbi5uYW1lfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBsdWdpbi1rZXlcIj4oe3BsdWdpbi5rZXl9KTwvZGl2PlxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbiAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LW1pc3NpbmctYXR0cmlidXRlIC0tPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImdvLWJhY2sgYjMtYnV0dG9uXCIgb246Y2xpY2s9eygpID0+IGdvQmFjaygpfT48c3ZnIGNsYXNzPVwiZ28tYmFjay1pY29uXCI+PHVzZSB4bGluazpocmVmPVwiI2ljb25CYWNrXCIgLz48L3N2Zz57XygnZ29CYWNrJyl9PC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuIFxuICAgICAgICA8ZGl2IGNsYXNzPVwicGx1Z2luLW1hbmlmZXN0XCI+XG4gICAgICAgICAgICB7I2lmIHBsdWdpbi51cmx9PGRpdiBjbGFzcz1cInBsdWdpbi1pdGVtXCI+e18oJ3VybCcpfTogPGEgaHJlZj17cGx1Z2luLnVybH0gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9yZWZlcnJlclwiPntwbHVnaW4udXJsfTwvYT48L2Rpdj4gey9pZn1cbiAgICAgICAgICAgIHsjaWYgcGx1Z2luLmF1dGhvcn08ZGl2IGNsYXNzPVwicGx1Z2luLWl0ZW1cIj57XygnYXV0aG9yJyl9OiB7cGx1Z2luLmF1dGhvcn08L2Rpdj4gey9pZn1cbiAgICAgICAgICAgIHsjaWYgcGx1Z2luLnZlcnNpb259PGRpdiBjbGFzcz1cInBsdWdpbi1pdGVtXCI+e18oJ3ZlcnNpb24nKX06IHtwbHVnaW4udmVyc2lvbn08L2Rpdj4gey9pZn1cbiAgICAgICAgICAgIHsjaWYgcGx1Z2luLmRlc2NyaXB0aW9ufTxkaXYgY2xhc3M9XCJwbHVnaW4taXRlbVwiPntfKCdkZXNjcmlwdGlvbicpfToge3BsdWdpbi5kZXNjcmlwdGlvbn08L2Rpdj4gey9pZn1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGhyLz5cbiAgICA8ZGl2IGNsYXNzPVwicGx1Z2luLXJlYWRtZSBiMy10eXBvZ3JhcGh5XCI+XG4gICAgICAgIHsjaWYgbG9hZGluZ31cbiAgICAgICAgICAgIDxzcGFuPntfKCdyZWFkbWUnKX08L3NwYW4+XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIHtAaHRtbCBwcmV2aWV3SFRNTCgpfVxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAucGx1Z2luLWluZm8ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cbiAgICAucGx1Z2luLWRldGFpbCB7XG4gICAgICAgIG1hcmdpbi10b3A6IDEycHg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cbiAgICAucGx1Z2luLW5hbWUge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmU7XG4gICAgICAgIG1hcmdpbi1yaWdodDogNnB4O1xuICAgICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgfVxuICAgIC5wbHVnaW4ta2V5IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgfVxuICAgIC5wbHVnaW4tbWFuaWZlc3Qge1xuICAgICAgICBtYXJnaW4tdG9wOiAxMnB4O1xuICAgIH1cbiAgICAucGx1Z2luLXJlYWRtZSB7XG4gICAgICAgIG1hcmdpbi10b3A6IDIwcHg7XG4gICAgfVxuICAgIC5nby1iYWNrIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDEycHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgIH1cbiAgICAuZ28tYmFjay1pY29uIHtcbiAgICAgICAgaGVpZ2h0OiAxMnB4O1xuICAgICAgICB3aWR0aDogMTJweDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgVFlQRVMgfSBmcm9tICdAL2NvbmZpZyc7XG4gICAgaW1wb3J0IHsgY29udGFpbmVyIH0gZnJvbSAnQC9jb250YWluZXInO1xuICAgIGltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQC9jb3JlL3N0b3JlJztcbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJ0AvaW50ZXJuYWwvY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBTdG9yZVBsdWdpblN0YXR1cyB9IGZyb20gJ0AvdHlwZXMnO1xuICAgIGltcG9ydCB7IFN0b3JlUGx1Z2luTWFuaWZlc3QgfSBmcm9tICdAL3R5cGVzJztcbiAgICBpbXBvcnQgeyBfIH0gZnJvbSAnQC91dGlsJztcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgU2V0dGluZ1ByZXZpZXcgZnJvbSAnLi9zZXR0aW5nLXByZXZpZXcuc3ZlbHRlJztcblxuICAgIGNvbnN0IHN0b3JlID0gY29udGFpbmVyLmdldDxTdG9yZT4oVFlQRVMuU3RvcmUpO1xuICAgIGxldCBwbHVnaW5zOiBTdG9yZVBsdWdpblN0YXR1c1tdID0gW107XG4gICAgbGV0IGxvYWRpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgbG9hZGluZ01hcCA9IHt9O1xuXG4gICAgb25Nb3VudChhc3luYyAoKSA9PiB7XG4gICAgICAgIHBsdWdpbnMgPSBhd2FpdCBzdG9yZS5sb2FkUGx1Z2lucygpO1xuICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkb3dubG9hZFBsdWdpbiA9IGFzeW5jIChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAobG9hZGluZ01hcFtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvYWRpbmdNYXBba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCBzdG9yZS5kb3dubG9hZFBsdWdpbihrZXkpO1xuICAgICAgICAgICAgY29uc3QgcCA9IHBsdWdpbnMuZmluZCgoaykgPT4gay5rZXkgPT09IGtleSk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIHAuaXNFeGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcC5uZWVkVXBncmFkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgbG9hZGluZ01hcFtrZXldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IHNlbGVjdGVkUGx1Z2luOiBTdG9yZVBsdWdpbk1hbmlmZXN0ID0gbnVsbDtcblxuICAgIGNvbnN0IHByZXZpZXdQbHVnaW4gPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIHBsdWdpbjogU3RvcmVQbHVnaW5NYW5pZmVzdCkgPT4ge1xuICAgICAgICBzZWxlY3RlZFBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiYjMtbGFiZWwgZm5fX2ZsZXhcIj5cbiAgICB7I2lmIGxvYWRpbmd9XG4gICAgICAgIDxkaXY+e18oJ2xvYWRpbmcnKX08L2Rpdj5cbiAgICB7OmVsc2UgaWYgIXNlbGVjdGVkUGx1Z2lufVxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm5fX2ZsZXgtMVwiPlxuICAgICAgICAgICAgeyNlYWNoIHBsdWdpbnMgYXMgcGx1Z2lufVxuICAgICAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LWxhYmVsLWhhcy1hc3NvY2lhdGVkLWNvbnRyb2wgLS0+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm5fX2ZsZXggYjMtbGFiZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZuX19mbGV4LTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LWNsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMgLS0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1pbnZhbGlkLWF0dHJpYnV0ZSAtLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIlwiIG9uOmNsaWNrPXsoZXZlbnQpID0+IHByZXZpZXdQbHVnaW4oZXZlbnQsIHBsdWdpbil9PntwbHVnaW4ubmFtZX08L2E+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cGx1Z2luLnZlcnNpb259XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYjMtbGFiZWxfX3RleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cGx1Z2luLmRlc2NyaXB0aW9uIHx8ICcnfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZuX19zcGFjZVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgbG9hZGluZ01hcFtwbHVnaW4ua2V5XX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gZGlzYWJsZWQ9e3RydWV9PntfKCdkb3dubG9hZGluZycpfTwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICB7OmVsc2UgaWYgcGx1Z2luLmlzRXhpc3R9XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHBsdWdpbi5uZWVkVXBncmFkZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IGRvd25sb2FkUGx1Z2luKHBsdWdpbi5rZXkpfT57XygndXBncmFkZScpfTwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gZGlzYWJsZWQ9e3RydWV9PntfKCdkb3dubG9hZGVkJyl9PC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IGRvd25sb2FkUGx1Z2luKHBsdWdpbi5rZXkpfT57XygnZG93bmxvYWQnKX08L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L2Rpdj5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxTZXR0aW5nUHJldmlldyBvbjpnb2JhY2s9eygpID0+IHNlbGVjdGVkUGx1Z2luID0gbnVsbCB9IHBsdWdpbj17c2VsZWN0ZWRQbHVnaW59PjwvU2V0dGluZ1ByZXZpZXc+XG4gICAgey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBTZXR0aW5nUmVuZGVyIH0gZnJvbSAnQC90eXBlcyc7XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cbiAgICBsZXQgcm9vdDogSFRNTEVsZW1lbnQ7XG5cbiAgICBleHBvcnQgbGV0IHJlbmRlcjogU2V0dGluZ1JlbmRlcjtcblxuICAgICQ6IHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZy1jdXN0b20tcmVuZGVyJyk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgICByb290LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmctY3VzdG9tLXJlbmRlcicpLmFwcGVuZENoaWxkKHJvb3QpO1xuICAgICAgICAgICAgcmVuZGVyKHJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5nLWN1c3RvbS1yZW5kZXInKS5hcHBlbmRDaGlsZChyb290KTtcbiAgICAgICAgcmVuZGVyKHJvb3QpO1xuICAgIH0pO1xuICAgIFxuXG48L3NjcmlwdD5cblxuXG48ZGl2IGlkPVwic2V0dGluZy1jdXN0b20tcmVuZGVyXCI+PC9kaXY+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBfIH0gZnJvbSAnQC91dGlsJztcbiAgICBpbXBvcnQgU2V0dGluZ0NvbW1vbiBmcm9tICcuL3NldHRpbmctY29tbW9uLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IFNldHRpbmdMaXN0IGZyb20gJy4vc2V0dGluZy1saXN0LnN2ZWx0ZSc7XG4gICAgaW1wb3J0IFNldHRpbmdTdG9yZSBmcm9tICcuL3NldHRpbmctc3RvcmUuc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBjb250YWluZXIgfSBmcm9tICdAL2NvbnRhaW5lcic7XG4gICAgaW1wb3J0IHsgVFlQRVMgfSBmcm9tICdAL2NvbmZpZyc7XG4gICAgaW1wb3J0IHsgSVNldHRpbmdNYW5hZ2VyLCBJU3RvcmFnZU1hbmFnZXIsIFNldHRpbmdSZW5kZXIgfSBmcm9tICdAL3R5cGVzJztcbiAgICBpbXBvcnQgU2V0dGluZ0N1c3RvbSBmcm9tICcuL3NldHRpbmctY3VzdG9tLnN2ZWx0ZSc7XG5cbiAgICB0eXBlIE1lbnUgPSB7IGtleTogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IHR5cGU6ICdpbnRlcm5hbCcgfCAnY3VzdG9tJzsgY29tcG9uZW50PzogYW55OyByZW5kZXI/OiBTZXR0aW5nUmVuZGVyOyB9O1xuXG4gICAgY29uc3QgbWVudXM6IE1lbnVbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnY29tbW9uJyxcbiAgICAgICAgICAgIG5hbWU6IF8oJ21lbnVfY29tbW9uJyksXG4gICAgICAgICAgICB0eXBlOiAnaW50ZXJuYWwnLFxuICAgICAgICAgICAgY29tcG9uZW50OiBTZXR0aW5nQ29tbW9uLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdsaXN0JyxcbiAgICAgICAgICAgIG5hbWU6IF8oJ21lbnVfbGlzdCcpLFxuICAgICAgICAgICAgdHlwZTogJ2ludGVybmFsJyxcbiAgICAgICAgICAgIGNvbXBvbmVudDogU2V0dGluZ0xpc3QsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ3N0b3JlJyxcbiAgICAgICAgICAgIG5hbWU6IF8oJ21lbnVfc3RvcmUnKSxcbiAgICAgICAgICAgIHR5cGU6ICdpbnRlcm5hbCcsXG4gICAgICAgICAgICBjb21wb25lbnQ6IFNldHRpbmdTdG9yZSxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgY29uc3Qgc20gPSBjb250YWluZXIuZ2V0PElTZXR0aW5nTWFuYWdlcj4oVFlQRVMuU2V0dGluZ01hbmFnZXIpO1xuICAgIGNvbnN0IHNtMSA9IGNvbnRhaW5lci5nZXQ8SVN0b3JhZ2VNYW5hZ2VyPihUWVBFUy5TdG9yYWdlTWFuYWdlcik7XG4gICAgY29uc3QgcGx1Z2lucyA9IHNtMS5nZXRUaGlyZFBhcnR5UGx1Z2lucygpO1xuICAgIGxldCBzZXR0aW5nUmVuZGVycyA9IHNtLmdldFNldHRpbmdSZW5kZXJzKCk7XG4gICAgY29uc3QgZ2V0TmFtZSA9IChrZXk6IHN0cmluZykgPT4gcGx1Z2lucy5maW5kKChwKSA9PiBwLmtleSA9PT0ga2V5KT8ubmFtZTtcbiAgICBcbiAgICAkOiB0aGlyZE1lbnVzID0gc2V0dGluZ1JlbmRlcnMubWFwKChzKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHMua2V5LFxuICAgICAgICAgICAgbmFtZTogZ2V0TmFtZShzLmtleSksXG4gICAgICAgICAgICBjb21wb25lbnQ6IFNldHRpbmdDb21tb24sXG4gICAgICAgICAgICB0eXBlOiAnY3VzdG9tJyxcbiAgICAgICAgICAgIHJlbmRlcjogcy52YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNldEN1cnJlbnRTZWxlY3Rpb24gPSAobWVudSkgPT4gKGN1cnJlbnRTZWxlY3Rpb24gPSBtZW51KTtcbiAgICBjb25zdCB1cGRhdGVNZW51cyA9ICgpID0+IHtcbiAgICAgICAgc2V0dGluZ1JlbmRlcnMgPSBbLi4uc20uZ2V0U2V0dGluZ1JlbmRlcnMoKV07XG4gICAgfTtcbiAgICBsZXQgY3VycmVudFNlbGVjdGlvbiA9IG1lbnVzWzBdO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJmbl9fZmxleC1jb2x1bW5cIiBzdHlsZT1cImJvcmRlci1yYWRpdXM6IDRweDtvdmVyZmxvdzogYXV0bztwb3NpdGlvbjogcmVsYXRpdmU7IGhlaWdodDogODB2aFwiPlxuICAgIDxkaXYgY2xhc3M9XCJmbl9fZmxleC0xIGZuX19mbGV4IGNvbmZpZ19fcGFuZWxcIj5cbiAgICAgICAgPHVsIGNsYXNzPVwiYjMtdGFiLWJhciBiMy1saXN0IGIzLWxpc3QtLWJhY2tncm91bmRcIiBzdHlsZT1cImhlaWdodDogdW5zZXQgIWltcG9ydGFudDtcIj5cbiAgICAgICAgICAgIHsjZWFjaCBtZW51cyBhcyBtZW51fVxuICAgICAgICAgICAgICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LWNsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMgLS0+XG4gICAgICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtbmFtZT17bWVudS5rZXl9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPXtjdXJyZW50U2VsZWN0aW9uLmtleSA9PT0gbWVudS5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ2IzLWxpc3QtaXRlbS0tZm9jdXMgYjMtbGlzdC1pdGVtIGIzLWxpc3QtaXRlbS0tYmlnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnYjMtbGlzdC1pdGVtIGIzLWxpc3QtaXRlbS0tYmlnJ30gXG4gICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiBzZXRDdXJyZW50U2VsZWN0aW9uKG1lbnUpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJiMy1saXN0LWl0ZW1fX3RleHRcIj57bWVudS5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgeyNpZiB0aGlyZE1lbnVzLmxlbmd0aCA+IDB9XG4gICAgICAgICAgICAgICAgPGhyIHN0eWxlPVwibWFyZ2luOiAxMnB4O1wiPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCB0aGlyZE1lbnVzIGFzIG1lbnV9XG4gICAgICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbiAgICAgICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1uYW1lPXttZW51LmtleX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9e2N1cnJlbnRTZWxlY3Rpb24ua2V5ID09PSBtZW51LmtleVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYjMtbGlzdC1pdGVtLS1mb2N1cyBiMy1saXN0LWl0ZW0gYjMtbGlzdC1pdGVtLS1iaWcnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdiMy1saXN0LWl0ZW0gYjMtbGlzdC1pdGVtLS1iaWcnfSBcbiAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IHNldEN1cnJlbnRTZWxlY3Rpb24obWVudSl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImIzLWxpc3QtaXRlbV9fdGV4dFwiPnttZW51Lm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvdWw+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb25maWdfX3RhYi1jb250YWluZXJcIiBzdHlsZT1cImhlaWdodDogdW5zZXQgIWltcG9ydGFudDtcIiBkYXRhLW5hbWU9e2N1cnJlbnRTZWxlY3Rpb24ua2V5fT5cbiAgICAgICAgICAgIHsjaWYgY3VycmVudFNlbGVjdGlvbi50eXBlID09PSAnaW50ZXJuYWwnfVxuICAgICAgICAgICAgICAgIDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9e2N1cnJlbnRTZWxlY3Rpb24uY29tcG9uZW50fSBvbjp1cGRhdGU9eygpID0+IHVwZGF0ZU1lbnVzKCl9IC8+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPFNldHRpbmdDdXN0b20gcmVuZGVyPXtjdXJyZW50U2VsZWN0aW9uLnJlbmRlcn0gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCJpbXBvcnQgeyBNZW51LCBNZW51SXRlbSwgRGlhbG9nIH0gZnJvbSAnQC9pbnRlcm5hbCc7XG5pbXBvcnQgKiBhcyBjbGllbnRBcGkgZnJvbSAnQC9hcGkvY2xpZW50LWFwaSc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAL2FwaS9wbHVnaW4nO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4vc2V0dGluZy5zdmVsdGUnO1xuaW1wb3J0IHsgXyB9IGZyb20gJ0AvdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFNldHRpbmdQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBzdmcgPVxuICAgICAgICAnPHN2ZyB0PVwiMTY3OTcwMzAyNzIyN1wiIGNsYXNzPVwiaWNvblwiIHZpZXdCb3g9XCIwIDAgMTAyNCAxMDI0XCIgdmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBwLWlkPVwiMjQ3MTVcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiPjxwYXRoIGQ9XCJNNTEyIDEwMjMuOTk5ODRhNzUuNTE5OTg4IDc1LjUxOTk4OCAwIDAgMS01My42Nzk5OTItMjIuMjA3OTk3TDIyLjM2ODA3NyA1NjUuNDU1OTEyYy0yOS40ODc5OTUtMjkuNjc5OTk1LTI5LjQ4Nzk5NS03Ny45MTk5ODgtMC4wNjQtMTA3LjUxOTk4NGwxNTkuNzExOTc1LTE1OS44Mzk5NzVhMzEuOTUxOTk1IDMxLjk1MTk5NSAwIDAgMSA1NC4wNDc5OTEgMjguMjA3OTk2IDEzMS4xMDM5OCAxMzEuMTAzOTggMCAwIDAtMi4zNjggMjMuMTM1OTk2YzAgNjkuOTUxOTg5IDU2Ljg5NTk5MSAxMjguMTExOTggMTI2Ljg0Nzk4MSAxMjguMTExOTggNjkuOTk5OTg5IDAgMTIxLjExOTk4MS01OC4xNTk5OTEgMTIxLjExOTk4MS0xMjguMTExOTggMC03MC4wNzk5ODktNTEuMTE5OTkyLTEyNy4wNzE5OC0xMjEuMTE5OTgxLTEyNy4wNzE5OGExMzAuODc5OTggMTMwLjg3OTk4IDAgMCAwLTIzLjAwNzk5NyAyLjM4NCAzMS43NTk5OTUgMzEuNzU5OTk1IDAgMCAxLTMzLjkxOTk5NC0xNi42NzE5OTggMzEuOTk5OTk1IDMxLjk5OTk5NSAwIDAgMSA1Ljc0Mzk5OS0zNy40MjM5OTRsMTQ4Ljg5NTk3Ni0xNDkuMTAzOTc2YzI4Ljg0Nzk5NS0yOC43MTk5OTYgNzguNzE5OTg4LTI4LjY1NTk5NiAxMDcuNDIzOTg0LTAuMDY0bDEwOS4wMjM5ODMgMTA5LjE4Mzk4M0M2OTcuNDM5OTcxIDU5Ljg4Nzk5MSA3NjMuODcxOTYxIDguNDc5OTk5IDg0Mi4wMTU5NDggOC40Nzk5OTljOTYuOTExOTg1IDAgMTc1Ljc0Mzk3MyA3OC45NTk5ODggMTc1Ljc0Mzk3MyAxNzUuOTY3OTcyIDAgNzguMjM5OTg4LTUxLjI5NTk5MiAxNDQuNzE5OTc3LTEyMi4wNjM5ODEgMTY3LjQ3MTk3NGwxMDUuODg3OTg0IDEwNS45NTE5ODNhNzYuMzUxOTg4IDc2LjM1MTk4OCAwIDAgMSAwLjAzMTk5OSAxMDcuNTUxOTg0TDU2NS43NDM5OTIgMTAwMS43NzU4NDNBNzUuNzU5OTg4IDc1Ljc1OTk4OCAwIDAgMSA1MTIgMTAyMy45OTk4NHpcIiBmaWxsPVwiXCIgcC1pZD1cIjI0NzE2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgb25sb2FkKCkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbFNldHRpbmdCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgaW50ZXJuYWxTZXR0aW5nQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIF8oJ3BsdWdpbl9zeXN0ZW0nKSk7XG4gICAgICAgIGludGVybmFsU2V0dGluZ0J1dHRvbi5jbGFzc0xpc3QuYWRkKCd0b29sYmFyX19pdGVtJywgJ2IzLXRvb2x0aXBzJywgJ2IzLXRvb2x0aXBzX19zdycpO1xuICAgICAgICBpbnRlcm5hbFNldHRpbmdCdXR0b24uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0aGlzLnN2Zyk7XG4gICAgICAgIGludGVybmFsU2V0dGluZ0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbmV3IE1lbnUoJ2ludGVybmFsU2V0dGluZ0J1dHRvbicpXG4gICAgICAgICAgICAgICAgLmFkZEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIG5ldyBNZW51SXRlbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXygncGx1Z2luX3N5c3RlbV9zZXR0aW5nJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnaWNvbkVkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICgpID0+IHNob3dTZXR0aW5nRGlhbG9nKCksXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5hZGRTZXBhcmF0b3IoKVxuICAgICAgICAgICAgICAgIC5hZGRJdGVtKFxuICAgICAgICAgICAgICAgICAgICBuZXcgTWVudUl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IF8oJ3JlbG9hZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2ljb25SZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCksXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5zaG93QXRNb3VzZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xpZW50QXBpLmFkZFRvb2xiYXJSaWdodChpbnRlcm5hbFNldHRpbmdCdXR0b24pO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb21tYW5kKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdTaG93IHBsdWdpbiBzeXN0ZW0gY29uaWZnJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBfKCdzaG93X3BsdWdpbl9zeXN0ZW1fY29uZmlnJyksXG4gICAgICAgICAgICBzaG9ydGN1dDogJ2NvbW1hbmQrb3B0aW9uK3AnLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHNob3dTZXR0aW5nRGlhbG9nKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29tbWFuZCh7XG4gICAgICAgICAgICBjb21tYW5kOiAnUmVsb2FkIFdpbmRvdycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXygncmVsb2FkX3dpbmRvdycpLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaG93U2V0dGluZ0RpYWxvZygpIHtcbiAgICBuZXcgRGlhbG9nKHtcbiAgICAgICAgdGl0bGU6IF8oJ3BsdWdpbl9zeXN0ZW1fc2V0dGluZycpLFxuICAgICAgICBjb250ZW50OiAnPGRpdiBpZD1cInBsdWdpbi1zZXR0aW5nc1wiPjwvZGl2PicsXG4gICAgICAgIHdpZHRoOiAnOTB2dycsXG4gICAgICAgIGhlaWdodDogJzgwdmgnLFxuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBuZXcgU2V0dGluZ3Moe1xuICAgICAgICAgICAgdGFyZ2V0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGx1Z2luLXNldHRpbmdzJyksXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9jbGFzc2VzJztcbmltcG9ydCB7IFBsdWdpbk1hbmlmZXN0IH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyBDb21tYW5kUGFuZWxQbHVnaW4gfSBmcm9tICcuL3BsdWdpbnMvY29tbWFuZC1wYW5lbCc7XG5pbXBvcnQgeyBJbnRlcm5hbFNldHRpbmdQbHVnaW4gfSBmcm9tICcuL3BsdWdpbnMvc2V0dGluZyc7XG5cbmV4cG9ydCBjb25zdCBpbnRlcm5hbFBsdWdpbnM6IFBsdWdpbk1hbmlmZXN0W10gPSBbXG4gICAgeyBrZXk6ICdzZXR0aW5nJywgbmFtZTogJ3NldHRpbmcnLCBwbHVnaW46IEludGVybmFsU2V0dGluZ1BsdWdpbiwgZW5hYmxlZDogdHJ1ZSwgaGlkZGVuOiB0cnVlLCB2ZXJzaW9uOiAnMS4wLjAnIH0sXG4gICAgeyBrZXk6ICdjb21tYW5kUGFuZWwnLCBuYW1lOiAnY29tbWFuZFBhbmVsJywgcGx1Z2luOiBDb21tYW5kUGFuZWxQbHVnaW4sIGVuYWJsZWQ6IHRydWUsIGhpZGRlbjogdHJ1ZSwgdmVyc2lvbjogJzEuMC4wJyB9LFxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNvZGVQb2ludCkge1xuICByZXR1cm4gY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkYmZmO1xufVxuXG5mdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA+PSAweGRjMDAgJiYgY29kZVBvaW50IDw9IDB4ZGZmZjtcbn1cblxuLy8gVHJ1bmNhdGUgc3RyaW5nIGJ5IHNpemUgaW4gYnl0ZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJ1bmNhdGUoZ2V0TGVuZ3RoLCBzdHJpbmcsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgfVxuXG4gIHZhciBjaGFyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGN1ckJ5dGVMZW5ndGggPSAwO1xuICB2YXIgY29kZVBvaW50O1xuICB2YXIgc2VnbWVudDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJMZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIHNlZ21lbnQgPSBzdHJpbmdbaV07XG5cbiAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNvZGVQb2ludCkgJiYgaXNMb3dTdXJyb2dhdGUoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSkge1xuICAgICAgaSArPSAxO1xuICAgICAgc2VnbWVudCArPSBzdHJpbmdbaV07XG4gICAgfVxuXG4gICAgY3VyQnl0ZUxlbmd0aCArPSBnZXRMZW5ndGgoc2VnbWVudCk7XG5cbiAgICBpZiAoY3VyQnl0ZUxlbmd0aCA9PT0gYnl0ZUxlbmd0aCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBpICsgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1ckJ5dGVMZW5ndGggPiBieXRlTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGkgLSBzZWdtZW50Lmxlbmd0aCArIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGJmZjtcbn1cblxuZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY29kZVBvaW50KSB7XG4gIHJldHVybiBjb2RlUG9pbnQgPj0gMHhkYzAwICYmIGNvZGVQb2ludCA8PSAweGRmZmY7XG59XG5cbi8vIFRydW5jYXRlIHN0cmluZyBieSBzaXplIGluIGJ5dGVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJ5dGVMZW5ndGgoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSBzdHJpbmdcIik7XG4gIH1cblxuICB2YXIgY2hhckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBieXRlTGVuZ3RoID0gMDtcbiAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gIHZhciBwcmV2Q29kZVBvaW50ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyTGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAvLyBoYW5kbGUgNC1ieXRlIG5vbi1CTVAgY2hhcnNcbiAgICAvLyBsb3cgc3Vycm9nYXRlXG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNvZGVQb2ludCkpIHtcbiAgICAgIC8vIHdoZW4gcGFyc2luZyBwcmV2aW91cyBoaS1zdXJyb2dhdGUsIDMgaXMgYWRkZWQgdG8gYnl0ZUxlbmd0aFxuICAgICAgaWYgKHByZXZDb2RlUG9pbnQgIT0gbnVsbCAmJiBpc0hpZ2hTdXJyb2dhdGUocHJldkNvZGVQb2ludCkpIHtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJ5dGVMZW5ndGggKz0gMztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4N2YgKSB7XG4gICAgICBieXRlTGVuZ3RoICs9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVQb2ludCA+PSAweDgwICYmIGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgYnl0ZUxlbmd0aCArPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlUG9pbnQgPj0gMHg4MDAgJiYgY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgYnl0ZUxlbmd0aCArPSAzO1xuICAgIH1cbiAgICBwcmV2Q29kZVBvaW50ID0gY29kZVBvaW50O1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVMZW5ndGg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJ1bmNhdGUgPSByZXF1aXJlKFwiLi9saWIvdHJ1bmNhdGVcIik7XG52YXIgZ2V0TGVuZ3RoID0gcmVxdWlyZShcInV0ZjgtYnl0ZS1sZW5ndGgvYnJvd3NlclwiKTtcbm1vZHVsZS5leHBvcnRzID0gdHJ1bmNhdGUuYmluZChudWxsLCBnZXRMZW5ndGgpO1xuIiwiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXBsYWNlcyBjaGFyYWN0ZXJzIGluIHN0cmluZ3MgdGhhdCBhcmUgaWxsZWdhbC91bnNhZmUgZm9yIGZpbGVuYW1lcy5cbiAqIFVuc2FmZSBjaGFyYWN0ZXJzIGFyZSBlaXRoZXIgcmVtb3ZlZCBvciByZXBsYWNlZCBieSBhIHN1YnN0aXR1dGUgc2V0XG4gKiBpbiB0aGUgb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdC5cbiAqXG4gKiBJbGxlZ2FsIENoYXJhY3RlcnMgb24gVmFyaW91cyBPcGVyYXRpbmcgU3lzdGVtc1xuICogLyA/IDwgPiBcXCA6ICogfCBcIlxuICogaHR0cHM6Ly9rYi5hY3JvbmlzLmNvbS9jb250ZW50LzM5NzkwXG4gKlxuICogVW5pY29kZSBDb250cm9sIGNvZGVzXG4gKiBDMCAweDAwLTB4MWYgJiBDMSAoMHg4MC0weDlmKVxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DMF9hbmRfQzFfY29udHJvbF9jb2Rlc1xuICpcbiAqIFJlc2VydmVkIGZpbGVuYW1lcyBvbiBVbml4LWJhc2VkIHN5c3RlbXMgKFwiLlwiLCBcIi4uXCIpXG4gKiBSZXNlcnZlZCBmaWxlbmFtZXMgaW4gV2luZG93cyAoXCJDT05cIiwgXCJQUk5cIiwgXCJBVVhcIiwgXCJOVUxcIiwgXCJDT00xXCIsXG4gKiBcIkNPTTJcIiwgXCJDT00zXCIsIFwiQ09NNFwiLCBcIkNPTTVcIiwgXCJDT002XCIsIFwiQ09NN1wiLCBcIkNPTThcIiwgXCJDT005XCIsXG4gKiBcIkxQVDFcIiwgXCJMUFQyXCIsIFwiTFBUM1wiLCBcIkxQVDRcIiwgXCJMUFQ1XCIsIFwiTFBUNlwiLCBcIkxQVDdcIiwgXCJMUFQ4XCIsIGFuZFxuICogXCJMUFQ5XCIpIGNhc2UtaW5zZXNpdGl2ZWx5IGFuZCB3aXRoIG9yIHdpdGhvdXQgZmlsZW5hbWUgZXh0ZW5zaW9ucy5cbiAqXG4gKiBDYXBwZWQgYXQgMjU1IGNoYXJhY3RlcnMgaW4gbGVuZ3RoLlxuICogaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMyNzk1L3doYXQtaXMtdGhlLW1heGltdW0tYWxsb3dlZC1maWxlbmFtZS1hbmQtZm9sZGVyLXNpemUtd2l0aC1lY3J5cHRmc1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gaW5wdXQgICBPcmlnaW5hbCBmaWxlbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIHtyZXBsYWNlbWVudDogU3RyaW5nIHwgRnVuY3Rpb24gfVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIFNhbml0aXplZCBmaWxlbmFtZVxuICovXG5cbnZhciB0cnVuY2F0ZSA9IHJlcXVpcmUoXCJ0cnVuY2F0ZS11dGY4LWJ5dGVzXCIpO1xuXG52YXIgaWxsZWdhbFJlID0gL1tcXC9cXD88PlxcXFw6XFwqXFx8XCJdL2c7XG52YXIgY29udHJvbFJlID0gL1tcXHgwMC1cXHgxZlxceDgwLVxceDlmXS9nO1xudmFyIHJlc2VydmVkUmUgPSAvXlxcLiskLztcbnZhciB3aW5kb3dzUmVzZXJ2ZWRSZSA9IC9eKGNvbnxwcm58YXV4fG51bHxjb21bMC05XXxscHRbMC05XSkoXFwuLiopPyQvaTtcbnZhciB3aW5kb3dzVHJhaWxpbmdSZSA9IC9bXFwuIF0rJC87XG5cbmZ1bmN0aW9uIHNhbml0aXplKGlucHV0LCByZXBsYWNlbWVudCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBzdHJpbmcnKTtcbiAgfVxuICB2YXIgc2FuaXRpemVkID0gaW5wdXRcbiAgICAucmVwbGFjZShpbGxlZ2FsUmUsIHJlcGxhY2VtZW50KVxuICAgIC5yZXBsYWNlKGNvbnRyb2xSZSwgcmVwbGFjZW1lbnQpXG4gICAgLnJlcGxhY2UocmVzZXJ2ZWRSZSwgcmVwbGFjZW1lbnQpXG4gICAgLnJlcGxhY2Uod2luZG93c1Jlc2VydmVkUmUsIHJlcGxhY2VtZW50KVxuICAgIC5yZXBsYWNlKHdpbmRvd3NUcmFpbGluZ1JlLCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB0cnVuY2F0ZShzYW5pdGl6ZWQsIDI1NSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciByZXBsYWNlbWVudCA9IChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZW1lbnQpIHx8ICcnO1xuICB2YXIgb3V0cHV0ID0gc2FuaXRpemUoaW5wdXQsIHJlcGxhY2VtZW50KTtcbiAgaWYgKHJlcGxhY2VtZW50ID09PSAnJykge1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIHNhbml0aXplKG91dHB1dCwgJycpO1xufTtcbiIsImltcG9ydCB7IGluamVjdCwgaW5qZWN0YWJsZSB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyBnZXRMb2NhbFN0b3JhZ2UsIHNldFN0b3JhZ2VWYWwgfSBmcm9tICcuLi9hcGkvc2VydmVyLWFwaSc7XG5pbXBvcnQgeyBkZWZhdWx0Q29uZmlnLCBQTFVHSU5fU1lTVEVNX1BMVUdJTiwgUExVR0lOX1NZU1RFTV9TQUZFX01PREVfRU5BQkxFRCwgUExVR0lOX1NZU1RFTV9USElSRF9QQVJUWV9QTFVHSU4gfSBmcm9tICcuL3BsdWdpbi1jb25maWcnO1xuaW1wb3J0IHsgaW50ZXJuYWxQbHVnaW5zIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuaW1wb3J0IHsgVFlQRVMgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgSVBsdWdpbkZpbGVNYW5hZ2VyLCBJU3RvcmFnZU1hbmFnZXIsIFBsdWdpbkNvbmZpZywgUGx1Z2luRW5hYmxlQ29uZmlnLCBQbHVnaW5NYW5pZmVzdCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHNob3dFcnJvck1lc3NhZ2UgfSBmcm9tICdAL3V0aWwnO1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJztcbmltcG9ydCB7IEZpbGVDbGllbnQgfSBmcm9tICdAL2FwaS9maWxlLWFwaSc7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdG9yYWdlTWFuYWdlciBpbXBsZW1lbnRzIElTdG9yYWdlTWFuYWdlciB7XG4gICAgcHJpdmF0ZSBwbHVnaW5GaWxlTWFuYWdlcjogSVBsdWdpbkZpbGVNYW5hZ2VyO1xuXG4gICAgcHJpdmF0ZSBjb25maWc6IFBsdWdpbkNvbmZpZztcblxuICAgIHByaXZhdGUgaW50ZXJuYWxQbHVnaW5zOiBQbHVnaW5NYW5pZmVzdFtdO1xuXG4gICAgcHJpdmF0ZSB0aGlyZFBhcnR5UGx1Z2luczogUGx1Z2luTWFuaWZlc3RbXTtcblxuICAgIGNvbnN0cnVjdG9yKEBpbmplY3QoVFlQRVMuUGx1Z2luRmlsZU1hbmFnZXIpIHBsdWdpbkZpbGVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZyk7XG4gICAgICAgIHRoaXMucGx1Z2luRmlsZU1hbmFnZXIgPSBwbHVnaW5GaWxlTWFuYWdlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0KGtleToga2V5b2YgUGx1Z2luQ29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ1trZXldO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZXQoa2V5OiBzdHJpbmcsIHZhbDogYW55KSB7XG4gICAgICAgIHRoaXMuY29uZmlnW2tleV0gPSB2YWw7XG4gICAgICAgIHJldHVybiBzZXRTdG9yYWdlVmFsKGtleSwgdmFsKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbml0U3RvcmFnZSgpIHtcbiAgICAgICAgY29uc3QgYWxsID0gYXdhaXQgZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0Q29uZmlnKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY29uZmlnS2V5cykge1xuICAgICAgICAgICAgaWYgKGFsbFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1trZXldID0gYWxsW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNldFN0b3JhZ2VWYWwoa2V5LCBkZWZhdWx0Q29uZmlnW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvYWQgYWxsIHBsdWdpbnNcbiAgICAgICAgdGhpcy50aGlyZFBhcnR5UGx1Z2lucyA9IGF3YWl0IHRoaXMucGx1Z2luRmlsZU1hbmFnZXIuZ2V0QWxsUGx1Z2lucygpO1xuICAgICAgICB0aGlzLmludGVybmFsUGx1Z2lucyA9IFsuLi5pbnRlcm5hbFBsdWdpbnNdO1xuICAgICAgICB0aGlzLmluaXQzcmRQYXJ0eUVuYWJsZWQoKTtcbiAgICAgICAgdGhpcy5pbml0SW50ZXJuYWxFbmFibGVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZVBsdWdpbnNFbmFibGVkKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0M3JkUGFydHlFbmFibGVkKCkge1xuICAgICAgICBjb25zdCBlbmFibGVkUGx1Z2lucyA9IHRoaXMuZ2V0KFBMVUdJTl9TWVNURU1fVEhJUkRfUEFSVFlfUExVR0lOKSBhcyBQbHVnaW5FbmFibGVDb25maWdbXTtcbiAgICAgICAgZm9yIChjb25zdCBlcCBvZiBlbmFibGVkUGx1Z2lucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMudGhpcmRQYXJ0eVBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5rZXkgPT09IGVwLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBwLmVuYWJsZWQgPSBlcC5lbmFibGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRJbnRlcm5hbEVuYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRQbHVnaW5zID0gdGhpcy5nZXQoUExVR0lOX1NZU1RFTV9QTFVHSU4pIGFzIFBsdWdpbkVuYWJsZUNvbmZpZ1tdO1xuICAgICAgICBmb3IgKGNvbnN0IGVwIG9mIGVuYWJsZWRQbHVnaW5zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5pbnRlcm5hbFBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5rZXkgPT09IGVwLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBwLmVuYWJsZWQgPSBlcC5lbmFibGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLmludGVybmFsUGx1Z2lucywgLi4udGhpcy50aGlyZFBhcnR5UGx1Z2luc107XG4gICAgfVxuXG4gICAgcHVibGljIGdldEludGVybmFsUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxQbHVnaW5zO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRUaGlyZFBhcnR5UGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhpcmRQYXJ0eVBsdWdpbnM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFBsdWdpbkJ5S2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQbHVnaW5zKCkuZmluZCgocCkgPT4gcC5rZXkgPT09IGtleSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNldFBsdWdpbkVuYWJsZWQoa2V5OiBzdHJpbmcsIGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIFsuLi50aGlzLmludGVybmFsUGx1Z2lucywgLi4udGhpcy50aGlyZFBhcnR5UGx1Z2luc10pIHtcbiAgICAgICAgICAgIGlmIChwLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgcC5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVQbHVnaW5zRW5hYmxlZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZXRTYWZlTW9kZUVuYWJsZWQoZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoUExVR0lOX1NZU1RFTV9TQUZFX01PREVfRU5BQkxFRCwgZW5hYmxlZCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNhdmVQbHVnaW5zRW5hYmxlZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXQoXG4gICAgICAgICAgICBQTFVHSU5fU1lTVEVNX1BMVUdJTixcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxQbHVnaW5zLm1hcCgocCkgPT4gKHsga2V5OiBwLmtleSwgZW5hYmxlZDogcC5lbmFibGVkIH0pKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAgICAgICBQTFVHSU5fU1lTVEVNX1RISVJEX1BBUlRZX1BMVUdJTixcbiAgICAgICAgICAgIHRoaXMudGhpcmRQYXJ0eVBsdWdpbnMubWFwKChwKSA9PiAoeyBrZXk6IHAua2V5LCBlbmFibGVkOiBwLmVuYWJsZWQgfSkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNldFBsdWdpblN0b3JhZ2UocGx1Z2luS2V5OiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IGFueSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaWxlTmFtZUlsbGVnYWwoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgc2hvd0Vycm9yTWVzc2FnZShg5o+S5Lu2JHtwbHVnaW5LZXl95a2Y5YKo5paH5Lu25ZCN5LiN5ZCI5rOVYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRQbHVnaW5TdG9yYWdlRm9sZGVySWZOb3RFeGlzdChwbHVnaW5LZXkpO1xuICAgICAgICAgICAgYXdhaXQgRmlsZUNsaWVudC5nZXRJbnN0YW5jZUFwaSgpLmZpbGVBcGkucHV0RmlsZShgL2RhdGEvcGx1Z2lucy8uc3RvcmFnZS8ke3BsdWdpbktleX0vJHtmaWxlbmFtZX1gLCBjb250ZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2hvd0Vycm9yTWVzc2FnZShg5o+S5Lu2JHtwbHVnaW5LZXl95a2Y5YKo5L+d5a2Y5aSx6LSlYCwgMjAwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0UGx1Z2luU3RvcmFnZShwbHVnaW5LZXk6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBGaWxlQ2xpZW50LmdldEluc3RhbmNlQXBpKCkuZmlsZUFwaS5nZXRGaWxlKGAvZGF0YS9wbHVnaW5zLy5zdG9yYWdlLyR7cGx1Z2luS2V5fS8ke2ZpbGVuYW1lfWApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzaG93RXJyb3JNZXNzYWdlKGDmj5Lku7Yke3BsdWdpbktleX3lrZjlgqjkv53lrZjlpLHotKVgLCAyMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHVuaW5zdGFsbFBsdWdpbihwbHVnaW5LZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCBGaWxlQ2xpZW50LmdldEluc3RhbmNlQXBpKCkuZmlsZUFwaS5yZW1vdmVGaWxlKGAvZGF0YS9wbHVnaW5zLyR7cGx1Z2luS2V5fWApO1xuICAgICAgICBhd2FpdCBGaWxlQ2xpZW50LmdldEluc3RhbmNlQXBpKCkuZmlsZUFwaS5yZW1vdmVGaWxlKGAvZGF0YS9wbHVnaW5zLy8uc3RvcmFnZS8ke3BsdWdpbktleX1gKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGFkZFBsdWdpblN0b3JhZ2VGb2xkZXJJZk5vdEV4aXN0KHBsdWdpbktleTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IGAvZGF0YS9wbHVnaW5zLy5zdG9yYWdlLyR7cGx1Z2luS2V5fWA7XG4gICAgICAgIGF3YWl0IEZpbGVDbGllbnQuZ2V0SW5zdGFuY2VBcGkoKS5maWxlQXBpLnB1dEZpbGUoZm9sZGVyLCBudWxsLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzRmlsZU5hbWVJbGxlZ2FsKGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lICE9PSBzYW5pdGl6ZShmaWxlbmFtZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICdyZWZsZWN0LW1ldGFkYXRhJztcbmltcG9ydCB7IGluamVjdCwgaW5qZWN0YWJsZSB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyBUWVBFUywgVkVSU0lPTiB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBJUGx1Z2luU3lzdGVtLCBJU3RvcmFnZU1hbmFnZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBQTFVHSU5fU1lTVEVNX1NBRkVfTU9ERV9FTkFCTEVEIH0gZnJvbSAnLi9wbHVnaW4tY29uZmlnJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uL3V0aWwnO1xuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGx1Z2luU3lzdGVtIGltcGxlbWVudHMgSVBsdWdpblN5c3RlbSB7XG4gICAgcHVibGljIHZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBpbmplY3QoVFlQRVMuUGx1Z2luTG9hZGVyKSBwcml2YXRlIHBsdWdpbkxvYWRlcixcbiAgICAgICAgQGluamVjdChUWVBFUy5TeXN0ZW1NYW5hZ2VyKSBwcml2YXRlIHBzbG0sXG4gICAgICAgIEBpbmplY3QoVFlQRVMuU3RvcmFnZU1hbmFnZXIpIHByaXZhdGUgc3RvcmFnZU1hbmFnZXI6IElTdG9yYWdlTWFuYWdlcixcbiAgICAgICAgQGluamVjdChUWVBFUy5Db21tYW5kTWFuYWdlcikgcHJpdmF0ZSBjb21tYW5kTWFuYWdlcixcbiAgICAgICAgQGluamVjdChUWVBFUy5TdG9yZSkgcHJpdmF0ZSBzdG9yZVxuICAgICkge31cblxuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZU1hbmFnZXIuaW5pdFN0b3JhZ2UoKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxQbHVnaW5zID0gdGhpcy5zdG9yYWdlTWFuYWdlci5nZXRJbnRlcm5hbFBsdWdpbnMoKTtcbiAgICAgICAgdGhpcy5wbHVnaW5Mb2FkZXIubG9hZEVuYWJsZWRQbHVnaW5zKGludGVybmFsUGx1Z2lucyk7XG4gICAgICAgIGxvZyhgTG9hZGluZyBpbnRlcm5hbCBlbmFibGVkIHBsdWdpbnM6ICR7aW50ZXJuYWxQbHVnaW5zLm1hcCgocCkgPT4gcC5rZXkpLmpvaW4oJywnKX1gKTtcbiAgICAgICAgY29uc3Qgc2VjdXJpdHlNb2RlRW5hYmxlZCA9IHRoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KFBMVUdJTl9TWVNURU1fU0FGRV9NT0RFX0VOQUJMRUQpO1xuICAgICAgICBpZiAoIXNlY3VyaXR5TW9kZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnN0b3JhZ2VNYW5hZ2VyLmdldFRoaXJkUGFydHlQbHVnaW5zKCk7XG4gICAgICAgICAgICBsb2coYExvYWRpbmcgM3JkIHBhcnR5IGVuYWJsZWQgcGx1Z2luczogJHtwbHVnaW5zLm1hcCgocCkgPT4gcC5rZXkpLmpvaW4oJywnKX1gKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTG9hZGVyLmxvYWRFbmFibGVkUGx1Z2lucyhwbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBzbG0ubG9jYWxDYWNoZUluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFBsdWdpbihrZXk6IHN0cmluZykge1xuICAgICAgICB0aGlzLnN0b3JhZ2VNYW5hZ2VyLnNldFBsdWdpbkVuYWJsZWQoa2V5LCB0cnVlKTtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5zdG9yYWdlTWFuYWdlci5nZXRQbHVnaW5CeUtleShrZXkpO1xuICAgICAgICB0aGlzLnBsdWdpbkxvYWRlci5sb2FkUGx1Z2luKHBsdWdpbik7XG4gICAgfVxuXG4gICAgYXN5bmMgdW5sb2FkUGx1Z2luKGtleTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZU1hbmFnZXIuc2V0UGx1Z2luRW5hYmxlZChrZXksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5wbHVnaW5Mb2FkZXIudW5sb2FkUGx1Z2luKGtleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgdHVybk9mZlNhZmVNb2RlKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2VNYW5hZ2VyLnNldFNhZmVNb2RlRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnN0b3JhZ2VNYW5hZ2VyLmdldFRoaXJkUGFydHlQbHVnaW5zKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbkxvYWRlci5sb2FkRW5hYmxlZFBsdWdpbnMocGx1Z2lucyk7XG4gICAgfVxuXG4gICAgYXN5bmMgdHVybk9uU2FmZU1vZGUoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZU1hbmFnZXIuc2V0U2FmZU1vZGVFbmFibGVkKHRydWUpO1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5zdG9yYWdlTWFuYWdlci5nZXRUaGlyZFBhcnR5UGx1Z2lucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5Mb2FkZXIudW5sb2FkVGhpcmRQYXJ0eVBsdWdpbnMocGx1Z2lucyk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IG1pZ3JhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgU05JUFBFVF9OQU1FID0gJ3BsdWdpbi1zeXN0ZW0tYmF6emFyJztcbiAgICBjb25zdCBjb250ZW50ID0gYChhc3luYyAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5wbHVnaW5TeXN0ZW1Tb3VyY2UgPSAnYmF6emFyJztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9maWxlL2dldEZpbGUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgICAgIGNhY2hlOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogJ25vLXJlZmVycmVyJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGF0aDogJy9kYXRhL3dpZGdldHMv5o+S5Lu257O757ufL3BsdWdpbi5qcycgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqcyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgZXZhbChqcyk7XG4gICAgfSkoKWA7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gYXN5bmMgKHVybCwgYm9keSkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBtb2RlOiAnY29ycycsXG4gICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkaXJlY3Q6ICdmb2xsb3cnLFxuICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlcicsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoJy9hcGkvc25pcHBldC9nZXRTbmlwcGV0JywgeyBlbmFibGVkOiAyLCB0eXBlOiAnYWxsJyB9KTtcblxuICAgIGNvbnN0IHNuaXBwZXRzID0gcmVzLmRhdGEuc25pcHBldHM7XG5cbiAgICBmb3IgKGNvbnN0IHNuaXBwZXQgb2Ygc25pcHBldHMpIHtcbiAgICAgICAgaWYgKHNuaXBwZXQudHlwZSAhPT0gJ2pzJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuaXBwZXQuY29udGVudC5pbmRleE9mKCdodHRwczovL2dpdGVlLmNvbS96dW9lejAyL3NpeXVhbi1wbHVnaW4tc3lzdGVtL3Jhdy9tYWluL21haW4uanMnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHNuaXBwZXQuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbmlwcGV0Lm5hbWUgPT09IFNOSVBQRVRfTkFNRSkge1xuICAgICAgICAgICAgc25pcHBldC5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNuaXBwZXQuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICBhd2FpdCByZXF1ZXN0KCcvYXBpL3NuaXBwZXQvc2V0U25pcHBldCcsIHsgc25pcHBldHMgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzbmlwcGV0cy5zcGxpY2UoMCwgMCwge1xuICAgICAgICBpZDogJzIwMjMwMzI0MTAwOTU5LXBsdWdpbmQnLFxuICAgICAgICBuYW1lOiBTTklQUEVUX05BTUUsXG4gICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgfSk7XG4gICAgYXdhaXQgcmVxdWVzdCgnL2FwaS9zbmlwcGV0L3NldFNuaXBwZXQnLCB7IHNuaXBwZXRzIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gd2luZG93LnBhcmVudC5sb2NhdGlvbi5yZWxvYWQoKSwgMTAwMCk7XG59O1xuIiwiaW1wb3J0IHsgUExVR0lOX1NZU19BQlNfUEFUSCwgU0NSSVBUX1VSTCwgVkVSU0lPTiwgVkVSU0lPTl9VUkwgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgVFlQRVMgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgXywgbG9nLCByZWxvYWRXaW5kb3csIHNob3dJbmZvTWVzc2FnZSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgaW5qZWN0LCBpbmplY3RhYmxlIH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IFBMVUdJTl9TWVNURU1fQVVUT19VUERBVEUgfSBmcm9tICcuL3BsdWdpbi1jb25maWcnO1xuaW1wb3J0IHsgSVN0b3JhZ2VNYW5hZ2VyLCBJU3lzdGVtTWFuYWdlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEZpbGVDbGllbnQgfSBmcm9tICdAL2FwaS9maWxlLWFwaSc7XG5pbXBvcnQgeyBtaWdyYXRlIH0gZnJvbSAnQC91dGlsL21pZ3JhdGUnO1xuaW1wb3J0IHsgc2VydmVyQXBpIH0gZnJvbSAnQC9hcGknO1xuaW1wb3J0IHsgU2VtVmVyIH0gZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvbiB9IGZyb20gJ0AvaW50ZXJuYWwvY2xhc3Nlcy9ub3RpZmljYXRpb24nO1xuXG5jb25zdCBwbHVnaW5TY3JpcHRQb3NpdGlvbiA9IFBMVUdJTl9TWVNfQUJTX1BBVEg7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTeXN0ZW1NYW5hZ2VyIGltcGxlbWVudHMgSVN5c3RlbU1hbmFnZXIge1xuICAgIHN0b3JhZ2VNYW5nYWdlcjogSVN0b3JhZ2VNYW5hZ2VyO1xuXG4gICAgY29uc3RydWN0b3IoQGluamVjdChUWVBFUy5TdG9yYWdlTWFuYWdlcikgc3RvcmFnZU1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlTWFuZ2FnZXIgPSBzdG9yYWdlTWFuYWdlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgc2F2ZVRvTG9jYWwocDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgRmlsZUNsaWVudC5nZXRJbnN0YW5jZUFwaSgpLmZpbGVBcGkucHV0RmlsZShwLCBjb250ZW50KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2NhbENhY2hlSW5pdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbiA9IEZpbGVDbGllbnQuZ2V0SW5zdGFuY2VBcGkoKS5maWxlQXBpLmdldEZpbGUocGx1Z2luU2NyaXB0UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHBsdWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlBdXRvVXBncmFkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2coJ1BsdWdpbiBzeXN0ZW0gbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gd2luZG93LnNpeXVhblBsdWdpblNjcmlwdDtcbiAgICAgICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVUb0xvY2FsKHBsdWdpblNjcmlwdFBvc2l0aW9uLCBzY3JpcHQpO1xuICAgICAgICB0aGlzLmRlbGF5QXV0b1VwZ3JhZGUoKTtcbiAgICB9XG5cbiAgICBkZWxheUF1dG9VcGdyYWRlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXV0b1VwZGF0ZSA9IHRoaXMuc3RvcmFnZU1hbmdhZ2VyLmdldChQTFVHSU5fU1lTVEVNX0FVVE9fVVBEQVRFKTtcbiAgICAgICAgICAgIGlmICghYXV0b1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGxvZygnQXV0byBVcGRhdGUgc2tpcHBlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVVwZ3JhZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgdHJ5VXBncmFkZSgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5wbHVnaW5TeXN0ZW1Tb3VyY2UgPT09ICdiYXp6YXInKSB7XG4gICAgICAgICAgICBsb2coJ1BsdWdpbiBpbnN0YWxsZWQgZnJvbSBiYXp6YXIgdmVyc2lvbiwgdXBncmFkZSBza2lwJyk7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVXaWRnZXRWZXJzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdUcnkgZ2V0dGluZyBvbmxpbmUgdmVyc2lvbicpO1xuICAgICAgICBjb25zdCBvbmxpbmVWZXJzaW9uID0gYXdhaXQgdGhpcy5nZXRPbmxpbmVWZXJzaW9uKCk7XG4gICAgICAgIGlmIChvbmxpbmVWZXJzaW9uICE9PSBWRVJTSU9OKSB7XG4gICAgICAgICAgICBzaG93SW5mb01lc3NhZ2UoYOaPkuS7tuezu+e7n+iOt+WPluWIsOacgOaWsOeJiOacrCAke29ubGluZVZlcnNpb25977yM5Y2z5bCG6Ieq5Yqo5pu05pawYCk7XG4gICAgICAgICAgICBsb2coJ09ubGluZSBWZXJzaW9uOiAnICsgb25saW5lVmVyc2lvbiArICcsIGxvY2FsIHZlcnNpb246ICcgKyBWRVJTSU9OKTtcbiAgICAgICAgICAgIGxvZygnRG93bmxvYWRpbmcgbmV3IHZlcnNpb24gb2YgUGx1Z2luIFN5c3RlbScpO1xuICAgICAgICAgICAgdGhpcy51cGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2coJ1ZlcnNpb24gaXMgJyArIFZFUlNJT04gKyAnLCBPSycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0T25saW5lVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKFZFUlNJT05fVVJMLCB7IGNhY2hlOiAnbm8tY2FjaGUnIH0pLnRoZW4oKHJlcykgPT4gcmVzLnRleHQoKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBncmFkZSgpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gYXdhaXQgZmV0Y2goU0NSSVBUX1VSTCwgeyBjYWNoZTogJ25vLWNhY2hlJyB9KS50aGVuKChyZXMpID0+IHJlcy50ZXh0KCkpO1xuICAgICAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1pZ3JhdGUoKTtcblxuICAgICAgICBzaG93SW5mb01lc3NhZ2UoJ+aPkuS7tuezu+e7n+WNh+e6p+S4re+8jOWNs+WwhuiHquWKqOmHjei9vS4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVUb0xvY2FsKHBsdWdpblNjcmlwdFBvc2l0aW9uLCBzY3JpcHQpO1xuICAgICAgICBsb2coJ1BsdWdpbiBzeXN0ZW0gdXBncmFkZWQsIHJlbG9hZGluZy4uLicpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlbG9hZFdpbmRvdygpLCAzMDAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb21wYXJlV2lkZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgc2VydmVyQXBpLmdldEJhenphcldpZGdldCgpO1xuICAgICAgICBjb25zdCBwYWNrYWdlcyA9IHJlcy5wYWNrYWdlcztcbiAgICAgICAgY29uc3QgcHMgPSBwYWNrYWdlcy5maW5kKChwKSA9PiBwLm5hbWUgPT09ICfmj5Lku7bns7vnu58nKTtcbiAgICAgICAgaWYgKCFwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhdGVzdFZlcnNpb24gPSBwcy52ZXJzaW9uO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2VtVmVyKFZFUlNJT04pLmNvbXBhcmUobGF0ZXN0VmVyc2lvbik7XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICBuZXcgTm90aWZpY2F0aW9uKHsgbWVzc2FnZTogXygnbmV3X3ZlcnNpb25fd2lkZ2V0JyksIHR5cGU6ICdpbmZvJyB9KS5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICcuLi9hcGkvcGx1Z2luJztcbmltcG9ydCBhcGkgZnJvbSAnLi4vYXBpJztcbmltcG9ydCB7XG4gICAgSVBsdWdpbkNvbW1hbmQsXG4gICAgSUNvbW1hbmRNYW5hZ2VyLFxuICAgIElQbHVnaW4sXG4gICAgSVBsdWdpbkZpbGVNYW5hZ2VyLFxuICAgIElQbHVnaW5Mb2FkZXIsXG4gICAgUGx1Z2luTWFuaWZlc3QsXG4gICAgU2V0dGluZ1JlbmRlcixcbiAgICBJU2V0dGluZ01hbmFnZXIsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGludGVybmFsUGx1Z2lucyB9IGZyb20gJy4uL2ludGVybmFsJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgaW5qZWN0LCBpbmplY3RhYmxlIH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IFRZUEVTIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IGNvbnRhaW5lciB9IGZyb20gJ0AvY29udGFpbmVyJztcbmltcG9ydCB7IElTdG9yYWdlTWFuYWdlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGVycm9yIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5sZXQgY29tcG9uZW50czogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBsdWdpbkxvYWRlciBpbXBsZW1lbnRzIElQbHVnaW5Mb2FkZXIge1xuICAgIHBsdWdpbkZpbGVNYW5hZ2VyOiBJUGx1Z2luRmlsZU1hbmFnZXI7XG5cbiAgICBsb2FkZWRQbHVnaW5zOiBNYXA8c3RyaW5nLCBJUGx1Z2luPjtcblxuICAgIGNvbnN0cnVjdG9yKEBpbmplY3QoVFlQRVMuUGx1Z2luRmlsZU1hbmFnZXIpIHBsdWdpbkZpbGVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMucGx1Z2luRmlsZU1hbmFnZXIgPSBwbHVnaW5GaWxlTWFuYWdlcjtcbiAgICAgICAgdGhpcy5sb2FkZWRQbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRFbmFibGVkUGx1Z2lucyhwbHVnaW5zOiBQbHVnaW5NYW5pZmVzdFtdKSB7XG4gICAgICAgIGlmICghcGx1Z2lucyB8fCAhcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKCFwLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZFBsdWdpbihwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxvYWRBbGxJbnRlcm5hbFBsdWdpbnMoKSB7XG4gICAgICAgIGludGVybmFsUGx1Z2lucy5mb3JFYWNoKGFzeW5jIChwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbHVnID0gbmV3IHAucGx1Z2luKCk7XG4gICAgICAgICAgICBpZiAoIShwbHVnIGluc3RhbmNlb2YgUGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgcGx1Z2luICR7cC5uYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nKGBMb2FkIGludGVybmFsIHBsdWdpbjogJHtwLmtleX0oJHtwLm5hbWV9KWApO1xuICAgICAgICAgICAgdGhpcy5hZGRBZGRpdGlvbmFsTWV0aG9kKHBsdWcsIHAua2V5LCBwLm5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgcGx1Zy5vbmxvYWQoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkUGx1Z2lucy5zZXQocC5rZXksIHBsdWcpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkQWxsTG9jYWxQbHVnaW5zKCkge1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gYXdhaXQgdGhpcy5wbHVnaW5GaWxlTWFuYWdlci5nZXRBbGxQbHVnaW5zKCk7XG4gICAgICAgIGlmICghcGx1Z2lucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRQbHVnaW4ocCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBsb2FkUGx1Z2luKHBsdWdpbjogUGx1Z2luTWFuaWZlc3QpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlUmVxdWlyZWRNb2R1bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW4uZW5hYmxlZCB8fCAoIXBsdWdpbi5wbHVnaW4gJiYgIXBsdWdpbi5zY3JpcHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbi5wbHVnaW4pIHtcbiAgICAgICAgICAgIC8vIGludGVybmFsIHBsdWdpblxuICAgICAgICAgICAgY29uc3QgcGx1ZyA9IG5ldyBwbHVnaW4ucGx1Z2luKCk7XG4gICAgICAgICAgICBpZiAoIShwbHVnIGluc3RhbmNlb2YgUGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgcGx1Z2luICR7cGx1Z2luLm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2coYExvYWQgaW50ZXJuYWwgcGx1Z2luOiAke3BsdWdpbi5rZXl9KCR7cGx1Z2luLm5hbWV9KWApO1xuICAgICAgICAgICAgdGhpcy5hZGRBZGRpdGlvbmFsTWV0aG9kKHBsdWcsIHBsdWdpbi5rZXksIHBsdWdpbi5uYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IHBsdWcub25sb2FkKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZFBsdWdpbnMuc2V0KHBsdWdpbi5rZXksIHBsdWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9ydHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0geyBleHBvcnRzIH07XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihzY3JpcHQ6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbCgnKGZ1bmN0aW9uIGFub255bW91cyhyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsnLmNvbmNhdChzY3JpcHQsICdcXG59KVxcbi8vIyBzb3VyY2VVUkw9JykuY29uY2F0KG5hbWUsICdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX19yZXF1aXJlID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbW9kdWxlICR7bmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBwbHVnaW4ua2V5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuKHBsdWdpbi5zY3JpcHQsIHBsdWdpbi5rZXkpKF9fcmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IoJ0Vycm9yIHBsdWdpbjonICsgcGx1Z2luLmtleSArICcgLT4nLCBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGx1Z2luQ29uc3RydWN0b3I7XG4gICAgICAgIGlmICghKHBsdWdpbkNvbnN0cnVjdG9yID0gKG1vZHVsZS5leHBvcnRzIHx8IGV4cG9ydHMpLmRlZmF1bHQgfHwgbW9kdWxlLmV4cG9ydHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHBsdWdpbiAke3BsdWdpbk5hbWV9LiBObyBleHBvcnRzIGRldGVjdGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsdWcgPSBuZXcgcGx1Z2luQ29uc3RydWN0b3IoKTtcbiAgICAgICAgaWYgKCEocGx1ZyBpbnN0YW5jZW9mIFBsdWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgcGx1Z2luICR7cGx1Z2luTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEFkZGl0aW9uYWxNZXRob2QocGx1ZywgcGx1Z2luLmtleSwgcGx1Z2luTmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBwbHVnLm9ubG9hZCgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRQbHVnaW5zLnNldChwbHVnaW4ua2V5LCBwbHVnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IoJ0Vycm9yIHBsdWdpbjonICsgcGx1Z2luLmtleSArICcgLT4nLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHVubG9hZFBsdWdpbihrZXk6IHN0cmluZykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLmxvYWRlZFBsdWdpbnMuZ2V0KGtleSk7XG4gICAgICAgIGlmICghcGx1Z2luKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGx1Z2luLm9udW5sb2FkKCk7XG4gICAgICAgIGNvbnRhaW5lci5nZXQ8SUNvbW1hbmRNYW5hZ2VyPihUWVBFUy5Db21tYW5kTWFuYWdlcikudW5yZWdpc3RlckNvbW1hbmRCeVBsdWdpbihrZXkpO1xuICAgICAgICBjb250YWluZXIuZ2V0PElTZXR0aW5nTWFuYWdlcj4oVFlQRVMuU2V0dGluZ01hbmFnZXIpLnVucmVnaXN0ZXJTZXR0aW5nKGtleSk7XG4gICAgICAgIHRoaXMubG9hZGVkUGx1Z2lucy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyB1bmxvYWRUaGlyZFBhcnR5UGx1Z2lucyhwbHVnaW5zOiBQbHVnaW5NYW5pZmVzdFtdKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBwbHVnaW5zLmZpbHRlcigocCkgPT4gcC5lbmFibGVkKS5tYXAoKHApID0+IHAua2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgIGxvZyhgdW5sb2FkIHRoaXJkIHBhcnR5IHBsdWdpbjogJHtrfWApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51bmxvYWRQbHVnaW4oayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBsb2FkVGhpcmRQYXJ0eUVuYWJsZWRQbHVnaW5zKHBsdWdpbnM6IFBsdWdpbk1hbmlmZXN0W10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEVuYWJsZWRQbHVnaW5zKHBsdWdpbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZW5lcmF0ZVJlcXVpcmVkTW9kdWxlcygpIHtcbiAgICAgICAgY29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgIHNpeXVhbjogYXBpLFxuICAgICAgICAgICAgYXhpb3M6IGF4aW9zLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkQWRkaXRpb25hbE1ldGhvZChwbHVnaW46IFBsdWdpbiwgcGx1Z2luS2V5OiBzdHJpbmcsIHBsdWdpbk5hbWU6IHN0cmluZykge1xuICAgICAgICBwbHVnaW4ucmVnaXN0ZXJDb21tYW5kID0gKGNvbW1hbmQ6IElQbHVnaW5Db21tYW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbSA9IGNvbnRhaW5lci5nZXQ8SUNvbW1hbmRNYW5hZ2VyPihUWVBFUy5Db21tYW5kTWFuYWdlcik7XG4gICAgICAgICAgICBjbS5yZWdpc3RlckNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIC4uLmNvbW1hbmQsXG4gICAgICAgICAgICAgICAgcGx1Z2luOiBwbHVnaW5LZXksXG4gICAgICAgICAgICAgICAgcGx1Z2luTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNtID0gY29udGFpbmVyLmdldDxJU3RvcmFnZU1hbmFnZXI+KFRZUEVTLlN0b3JhZ2VNYW5hZ2VyKTtcbiAgICAgICAgcGx1Z2luLndyaXRlU3RvcmFnZSA9IGFzeW5jIChmaWxlbmFtZTogc3RyaW5nLCBjb250ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzbS5zZXRQbHVnaW5TdG9yYWdlKHBsdWdpbktleSwgZmlsZW5hbWUsIGNvbnRlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBwbHVnaW4ubG9hZFN0b3JhZ2UgPSBhc3luYyAoZmlsZW5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHNtLmdldFBsdWdpblN0b3JhZ2UocGx1Z2luS2V5LCBmaWxlbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHBsdWdpbi5yZWdpc3RlclNldHRpbmdSZW5kZXIgPSAoc2V0dGluZ1JlbmRlcjogU2V0dGluZ1JlbmRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgY20gPSBjb250YWluZXIuZ2V0PElTZXR0aW5nTWFuYWdlcj4oVFlQRVMuU2V0dGluZ01hbmFnZXIpO1xuICAgICAgICAgICAgY20ucmVnaXN0ZXJTZXR0aW5nKHBsdWdpbktleSwgc2V0dGluZ1JlbmRlcik7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRmlsZUNsaWVudCB9IGZyb20gJ0AvYXBpL2ZpbGUtYXBpJztcbmltcG9ydCB7IGluamVjdGFibGUgfSBmcm9tICdpbnZlcnNpZnknO1xuaW1wb3J0IHsgUGx1Z2luTWFuaWZlc3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBlcnJvciwgaXNFeGlzdHMsIGxvZyB9IGZyb20gJy4uL3V0aWwnO1xuXG5leHBvcnQgY29uc3QgTUFOSUZFU1QgPSAnbWFuaWZlc3QuanNvbic7XG5cbmV4cG9ydCBjb25zdCBTQ1JJUFQgPSAnbWFpbi5qcyc7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQbHVnaW5GaWxlTWFuYWdlciB7XG4gICAgYXN5bmMgc2NhblBsdWdpbnMocGx1Z2luRm9sZGVyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEZpbGVDbGllbnQuZ2V0SW5zdGFuY2VBcGkoKS5maWxlQXBpLnJlYWREaXIocGx1Z2luRm9sZGVyKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlcyA9IHJlcztcbiAgICAgICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIGlmIChmLm5hbWUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZi5pc0RpciAmJiAoYXdhaXQgaXNFeGlzdHMoYC9kYXRhL3BsdWdpbnMvJHtmLm5hbWV9L21hbmlmZXN0Lmpzb25gKSkgJiYgKGF3YWl0IGlzRXhpc3RzKGAvZGF0YS9wbHVnaW5zLyR7Zi5uYW1lfS9tYWluLmpzYCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYC9kYXRhL3BsdWdpbnMvJHtmLm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRGaWxlQ29udGVudChmOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBGaWxlQ2xpZW50LmdldEluc3RhbmNlQXBpKCkuZmlsZUFwaS5nZXRGaWxlKGYpO1xuICAgICAgICByZXR1cm4gcmVzIHx8ICcnO1xuICAgIH1cblxuICAgIGFzeW5jIGdldE1hbmlmZXN0KG1hbmlmZXN0OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuZ2V0RmlsZUNvbnRlbnQobWFuaWZlc3QpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yKCdsb2FkaW5nIG1hbmlmZXN0OiAnICsgbWFuaWZlc3QsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRTY3JpcHQoc2NyaXB0OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RmlsZUNvbnRlbnQoc2NyaXB0KTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRBbGxQbHVnaW5zKCk6IFByb21pc2U8UGx1Z2luTWFuaWZlc3RbXT4ge1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gYXdhaXQgdGhpcy5zY2FuUGx1Z2lucygnL2RhdGEvcGx1Z2lucycpO1xuICAgICAgICBpZiAoIXBsdWdpbnMgfHwgIXBsdWdpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2coJ05vIHBsdWdpbiBmb3VuZCBpbiAnICsgJy9kYXRhL3BsdWdpbnMnKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXEgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgIGxvZygnUmVhZGluZyBwbHVnaW4gZnJvbSBmaWxlc3lzdGVtOiAnICsgcCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEZvbGRlck5hbWUocCk7XG4gICAgICAgICAgICBjb25zdCBmID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFttYW5pZmVzdCwgc2NyaXB0XSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmdldE1hbmlmZXN0KGAke3B9L21hbmlmZXN0Lmpzb25gKSwgdGhpcy5nZXRTY3JpcHQoYCR7cH0vbWFpbi5qc2ApXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubWFuaWZlc3QsIHNjcmlwdCwgZW5hYmxlZDogZmFsc2UsIGtleSB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5wdXNoKGYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0OiBQbHVnaW5NYW5pZmVzdFtdID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBbXTtcbiAgICB9XG5cbiAgICBnZXRGb2xkZXJOYW1lKHApIHtcbiAgICAgICAgY29uc3QgZiA9IHAuc3BsaXQoJy8nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChmW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IElFdmVudEJ1cywgTGlzdGVuZXIgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGluamVjdGFibGUgfSBmcm9tICdpbnZlcnNpZnknO1xuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXZlbnRCdXMgaW1wbGVtZW50cyBJRXZlbnRCdXMge1xuICAgIHByaXZhdGUgZXZlbnRMaXN0ZW5lcnM6IHsgW2tleTogc3RyaW5nXTogTGlzdGVuZXJbXSB9O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBkZWxldGUgdGhpcy5ldmVudExpc3RlbmVycztcbiAgICB9XG5cbiAgICBvbihldmVudE5hbWU6IHN0cmluZywgY2FsbGJhY2s6IExpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBvZmYoZXZlbnROYW1lOiBzdHJpbmcsIGNhbGxiYWNrPzogTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXVtpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVtaXQoZXZlbnROYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IGFueSkge1xuICAgICAgICBpZiAodGhpcy5ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0uZm9yRWFjaCgoY2IpID0+IHtcbiAgICAgICAgICAgICAgICBjYiguLi5hcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVFlQRVMgfSBmcm9tICdAL2NvbmZpZyc7XG5pbXBvcnQgeyBDb21tYW5kLCBJQ29tbWFuZE1hbmFnZXIgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IEVycm9yLCBsb2csIFdhcm5pbmcgfSBmcm9tICdAL3V0aWwnO1xuaW1wb3J0IHsgaW5qZWN0LCBpbmplY3RhYmxlIH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IFNob3J0Y3V0IH0gZnJvbSAnLi9zaG9ydGN1dCc7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb21tYW5kTWFuYWdlciBpbXBsZW1lbnRzIElDb21tYW5kTWFuYWdlciB7XG4gICAgcHJpdmF0ZSBzaG9ydGN1dDogU2hvcnRjdXQ7XG4gICAgcHJpdmF0ZSBjb21tYW5kTGlzdDogQ29tbWFuZFtdO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKEBpbmplY3QoVFlQRVMuU2hvcnRjdXQpIHNob3J0Y3V0KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZExpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5zaG9ydGN1dCA9IHNob3J0Y3V0O1xuICAgIH1cblxuICAgIHB1YmxpYyByZWdpc3RlckNvbW1hbmQoY29tbWFuZDogQ29tbWFuZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRMaXN0LnNvbWUoKGNvbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbS5wbHVnaW4gPT09IGNvbW1hbmQucGx1Z2luICYmIGNvbS5jb21tYW5kID09PSBjb21tYW5kLmNvbW1hbmQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0NvbW1hbmQgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCBkbyBub3QgcmVnaXN0ZXIgY29tbWFuZCByZXBlYXRseScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbW1hbmQuc2hvcnRjdXQgJiZcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZExpc3Quc29tZSgoY29tKSA9PiB7XG4gICAgICAgICAgICAgICAgY29tLnNob3J0Y3V0ID09PSBjb21tYW5kLnNob3J0Y3V0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdhcm5pbmcoJ3Nob3J0Y3V0IGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1hbmRMaXN0LnB1c2goY29tbWFuZCk7XG4gICAgICAgIHRoaXMuc2hvcnRjdXQucmVnaXN0ZXJLZXlib2FyZEV2ZW50RnJvbVBsdWdpbihjb21tYW5kKTtcbiAgICAgICAgbG9nKGBSZWdpc3RlciBwbHVnaW46ICR7Y29tbWFuZC5wbHVnaW59IGNvbW1hbmQ6ICR7Y29tbWFuZC5jb21tYW5kfWApO1xuICAgIH1cblxuICAgIHB1YmxpYyB1bnJlZ2lzdGVyQ29tbWFuZEJ5UGx1Z2luKHBsdWdpbjogc3RyaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBsdWdpbiA9PT0gdGhpcy5jb21tYW5kTGlzdFtpXS5wbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb20gPSB0aGlzLmNvbW1hbmRMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxvZyhgVW5yZWdpc3RlciBwbHVnaW46ICR7cGx1Z2lufSBjb21tYW5kOiAke2NvbS5jb21tYW5kfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZExpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjb20uc2hvcnRjdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG9ydGN1dC51bnJlZ2lzdGVyS2V5Ym9hcmRFdmVudChjb20uc2hvcnRjdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyB1bnJlZ2lzdGVyQ29tbWFuZChjb21tYW5kOiBDb21tYW5kKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQuY29tbWFuZCA9PT0gdGhpcy5jb21tYW5kTGlzdFtpXS5jb21tYW5kICYmIGNvbW1hbmQucGx1Z2luID09PSB0aGlzLmNvbW1hbmRMaXN0W2ldLnBsdWdpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZExpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvcnRjdXQucmVnaXN0ZXJLZXlib2FyZEV2ZW50RnJvbVBsdWdpbihjb21tYW5kKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q29tbWFuZHMoKTogQ29tbWFuZFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZExpc3Q7XG4gICAgfVxufVxuIiwiLyoqISBcbiAqIGhvdGtleXMtanMgdjMuMTAuMSBcbiAqIEEgc2ltcGxlIG1pY3JvLWxpYnJhcnkgZm9yIGRlZmluaW5nIGFuZCBkaXNwYXRjaGluZyBrZXlib2FyZCBzaG9ydGN1dHMuIEl0IGhhcyBubyBkZXBlbmRlbmNpZXMuIFxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjIga2Vubnkgd29uZyA8d293b2hvb0BxcS5jb20+IFxuICogaHR0cDovL2pheXdjamxvdmUuZ2l0aHViLmlvL2hvdGtleXMgXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgXG4gKi9cblxudmFyIGlzZmYgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAwIDogZmFsc2U7IC8vIOe7keWumuS6i+S7tlxuXG5mdW5jdGlvbiBhZGRFdmVudChvYmplY3QsIGV2ZW50LCBtZXRob2QsIHVzZUNhcHR1cmUpIHtcbiAgaWYgKG9iamVjdC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG1ldGhvZCwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0LmF0dGFjaEV2ZW50KSB7XG4gICAgb2JqZWN0LmF0dGFjaEV2ZW50KFwib25cIi5jb25jYXQoZXZlbnQpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZXRob2Qod2luZG93LmV2ZW50KTtcbiAgICB9KTtcbiAgfVxufSAvLyDkv67ppbDplK7ovazmjaLmiJDlr7nlupTnmoTplK7noIFcblxuXG5mdW5jdGlvbiBnZXRNb2RzKG1vZGlmaWVyLCBrZXkpIHtcbiAgdmFyIG1vZHMgPSBrZXkuc2xpY2UoMCwga2V5Lmxlbmd0aCAtIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kcy5sZW5ndGg7IGkrKykge1xuICAgIG1vZHNbaV0gPSBtb2RpZmllclttb2RzW2ldLnRvTG93ZXJDYXNlKCldO1xuICB9XG5cbiAgcmV0dXJuIG1vZHM7XG59IC8vIOWkhOeQhuS8oOeahGtleeWtl+espuS4sui9rOaNouaIkOaVsOe7hFxuXG5cbmZ1bmN0aW9uIGdldEtleXMoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykga2V5ID0gJyc7XG4gIGtleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpOyAvLyDljLnphY3ku7vkvZXnqbrnmb3lrZfnrKYs5YyF5ous56m65qC844CB5Yi26KGo56ym44CB5o2i6aG156ym562J562JXG5cbiAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJywnKTsgLy8g5ZCM5pe26K6+572u5aSa5Liq5b+r5o236ZSu77yM5LulJywn5YiG5YmyXG5cbiAgdmFyIGluZGV4ID0ga2V5cy5sYXN0SW5kZXhPZignJyk7IC8vIOW/q+aNt+mUruWPr+iDveWMheWQqycsJ++8jOmcgOeJueauiuWkhOeQhlxuXG4gIGZvciAoOyBpbmRleCA+PSAwOykge1xuICAgIGtleXNbaW5kZXggLSAxXSArPSAnLCc7XG4gICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0ga2V5cy5sYXN0SW5kZXhPZignJyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn0gLy8g5q+U6L6D5L+u6aWw6ZSu55qE5pWw57uEXG5cblxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGExLCBhMikge1xuICB2YXIgYXJyMSA9IGExLmxlbmd0aCA+PSBhMi5sZW5ndGggPyBhMSA6IGEyO1xuICB2YXIgYXJyMiA9IGExLmxlbmd0aCA+PSBhMi5sZW5ndGggPyBhMiA6IGExO1xuICB2YXIgaXNJbmRleCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycjIuaW5kZXhPZihhcnIxW2ldKSA9PT0gLTEpIGlzSW5kZXggPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0luZGV4O1xufVxuXG52YXIgX2tleU1hcCA9IHtcbiAgYmFja3NwYWNlOiA4LFxuICAn4oyrJzogOCxcbiAgdGFiOiA5LFxuICBjbGVhcjogMTIsXG4gIGVudGVyOiAxMyxcbiAgJ+KGqSc6IDEzLFxuICByZXR1cm46IDEzLFxuICBlc2M6IDI3LFxuICBlc2NhcGU6IDI3LFxuICBzcGFjZTogMzIsXG4gIGxlZnQ6IDM3LFxuICB1cDogMzgsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gIGRlbDogNDYsXG4gIGRlbGV0ZTogNDYsXG4gIGluczogNDUsXG4gIGluc2VydDogNDUsXG4gIGhvbWU6IDM2LFxuICBlbmQ6IDM1LFxuICBwYWdldXA6IDMzLFxuICBwYWdlZG93bjogMzQsXG4gIGNhcHNsb2NrOiAyMCxcbiAgbnVtXzA6IDk2LFxuICBudW1fMTogOTcsXG4gIG51bV8yOiA5OCxcbiAgbnVtXzM6IDk5LFxuICBudW1fNDogMTAwLFxuICBudW1fNTogMTAxLFxuICBudW1fNjogMTAyLFxuICBudW1fNzogMTAzLFxuICBudW1fODogMTA0LFxuICBudW1fOTogMTA1LFxuICBudW1fbXVsdGlwbHk6IDEwNixcbiAgbnVtX2FkZDogMTA3LFxuICBudW1fZW50ZXI6IDEwOCxcbiAgbnVtX3N1YnRyYWN0OiAxMDksXG4gIG51bV9kZWNpbWFsOiAxMTAsXG4gIG51bV9kaXZpZGU6IDExMSxcbiAgJ+KHqic6IDIwLFxuICAnLCc6IDE4OCxcbiAgJy4nOiAxOTAsXG4gICcvJzogMTkxLFxuICAnYCc6IDE5MixcbiAgJy0nOiBpc2ZmID8gMTczIDogMTg5LFxuICAnPSc6IGlzZmYgPyA2MSA6IDE4NyxcbiAgJzsnOiBpc2ZmID8gNTkgOiAxODYsXG4gICdcXCcnOiAyMjIsXG4gICdbJzogMjE5LFxuICAnXSc6IDIyMSxcbiAgJ1xcXFwnOiAyMjBcbn07IC8vIE1vZGlmaWVyIEtleXNcblxudmFyIF9tb2RpZmllciA9IHtcbiAgLy8gc2hpZnRLZXlcbiAgJ+KHpyc6IDE2LFxuICBzaGlmdDogMTYsXG4gIC8vIGFsdEtleVxuICAn4oylJzogMTgsXG4gIGFsdDogMTgsXG4gIG9wdGlvbjogMTgsXG4gIC8vIGN0cmxLZXlcbiAgJ+KMgyc6IDE3LFxuICBjdHJsOiAxNyxcbiAgY29udHJvbDogMTcsXG4gIC8vIG1ldGFLZXlcbiAgJ+KMmCc6IDkxLFxuICBjbWQ6IDkxLFxuICBjb21tYW5kOiA5MVxufTtcbnZhciBtb2RpZmllck1hcCA9IHtcbiAgMTY6ICdzaGlmdEtleScsXG4gIDE4OiAnYWx0S2V5JyxcbiAgMTc6ICdjdHJsS2V5JyxcbiAgOTE6ICdtZXRhS2V5JyxcbiAgc2hpZnRLZXk6IDE2LFxuICBjdHJsS2V5OiAxNyxcbiAgYWx0S2V5OiAxOCxcbiAgbWV0YUtleTogOTFcbn07XG52YXIgX21vZHMgPSB7XG4gIDE2OiBmYWxzZSxcbiAgMTg6IGZhbHNlLFxuICAxNzogZmFsc2UsXG4gIDkxOiBmYWxzZVxufTtcbnZhciBfaGFuZGxlcnMgPSB7fTsgLy8gRjF+RjEyIHNwZWNpYWwga2V5XG5cbmZvciAodmFyIGsgPSAxOyBrIDwgMjA7IGsrKykge1xuICBfa2V5TWFwW1wiZlwiLmNvbmNhdChrKV0gPSAxMTEgKyBrO1xufVxuXG52YXIgX2Rvd25LZXlzID0gW107IC8vIOiusOW9leaRgeS4i+eahOe7keWumumUrlxuXG52YXIgd2luTGlzdGVuZEZvY3VzID0gZmFsc2U7IC8vIHdpbmRvd+aYr+WQpuW3sue7j+ebkeWQrOS6hmZvY3Vz5LqL5Lu2XG5cbnZhciBfc2NvcGUgPSAnYWxsJzsgLy8g6buY6K6k54Ot6ZSu6IyD5Zu0XG5cbnZhciBlbGVtZW50SGFzQmluZEV2ZW50ID0gW107IC8vIOW3sue7keWumuS6i+S7tueahOiKgueCueiusOW9lVxuLy8g6L+U5Zue6ZSu56CBXG5cbnZhciBjb2RlID0gZnVuY3Rpb24gY29kZSh4KSB7XG4gIHJldHVybiBfa2V5TWFwW3gudG9Mb3dlckNhc2UoKV0gfHwgX21vZGlmaWVyW3gudG9Mb3dlckNhc2UoKV0gfHwgeC50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG59O1xuXG52YXIgZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5KHgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKF9rZXlNYXApLmZpbmQoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gX2tleU1hcFtrXSA9PT0geDtcbiAgfSk7XG59O1xuXG52YXIgZ2V0TW9kaWZpZXIgPSBmdW5jdGlvbiBnZXRNb2RpZmllcih4KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhfbW9kaWZpZXIpLmZpbmQoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gX21vZGlmaWVyW2tdID09PSB4O1xuICB9KTtcbn07IC8vIOiuvue9ruiOt+WPluW9k+WJjeiMg+WbtO+8iOm7mOiupOS4uifmiYDmnIkn77yJXG5cblxuZnVuY3Rpb24gc2V0U2NvcGUoc2NvcGUpIHtcbiAgX3Njb3BlID0gc2NvcGUgfHwgJ2FsbCc7XG59IC8vIOiOt+WPluW9k+WJjeiMg+WbtFxuXG5cbmZ1bmN0aW9uIGdldFNjb3BlKCkge1xuICByZXR1cm4gX3Njb3BlIHx8ICdhbGwnO1xufSAvLyDojrflj5bmkYHkuIvnu5HlrprplK7nmoTplK7lgLxcblxuXG5mdW5jdGlvbiBnZXRQcmVzc2VkS2V5Q29kZXMoKSB7XG4gIHJldHVybiBfZG93bktleXMuc2xpY2UoMCk7XG59XG5cbmZ1bmN0aW9uIGdldFByZXNzZWRLZXlTdHJpbmcoKSB7XG4gIHJldHVybiBfZG93bktleXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGdldEtleShjKSB8fCBnZXRNb2RpZmllcihjKSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9KTtcbn0gLy8g6KGo5Y2V5o6n5Lu25o6n5Lu25Yik5patIOi/lOWbniBCb29sZWFuXG4vLyBob3RrZXkgaXMgZWZmZWN0aXZlIG9ubHkgd2hlbiBmaWx0ZXIgcmV0dXJuIHRydWVcblxuXG5mdW5jdGlvbiBmaWx0ZXIoZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICB2YXIgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lO1xuICB2YXIgZmxhZyA9IHRydWU7IC8vIGlnbm9yZTogaXNDb250ZW50RWRpdGFibGUgPT09ICd0cnVlJywgPGlucHV0PiBhbmQgPHRleHRhcmVhPiB3aGVuIHJlYWRPbmx5IHN0YXRlIGlzIGZhbHNlLCA8c2VsZWN0PlxuXG4gIGlmICh0YXJnZXQuaXNDb250ZW50RWRpdGFibGUgfHwgKHRhZ05hbWUgPT09ICdJTlBVVCcgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCB0YWdOYW1lID09PSAnU0VMRUNUJykgJiYgIXRhcmdldC5yZWFkT25seSkge1xuICAgIGZsYWcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmbGFnO1xufSAvLyDliKTmlq3mkYHkuIvnmoTplK7mmK/lkKbkuLrmn5DkuKrplK7vvIzov5Tlm550cnVl5oiW6ICFZmFsc2VcblxuXG5mdW5jdGlvbiBpc1ByZXNzZWQoa2V5Q29kZSkge1xuICBpZiAodHlwZW9mIGtleUNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5Q29kZSA9IGNvZGUoa2V5Q29kZSk7IC8vIOi9rOaNouaIkOmUrueggVxuICB9XG5cbiAgcmV0dXJuIF9kb3duS2V5cy5pbmRleE9mKGtleUNvZGUpICE9PSAtMTtcbn0gLy8g5b6q546v5Yig6ZmkaGFuZGxlcnPkuK3nmoTmiYDmnIkgc2NvcGUo6IyD5Zu0KVxuXG5cbmZ1bmN0aW9uIGRlbGV0ZVNjb3BlKHNjb3BlLCBuZXdTY29wZSkge1xuICB2YXIgaGFuZGxlcnM7XG4gIHZhciBpOyAvLyDmsqHmnInmjIflrppzY29wZe+8jOiOt+WPlnNjb3BlXG5cbiAgaWYgKCFzY29wZSkgc2NvcGUgPSBnZXRTY29wZSgpO1xuXG4gIGZvciAodmFyIGtleSBpbiBfaGFuZGxlcnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9oYW5kbGVycywga2V5KSkge1xuICAgICAgaGFuZGxlcnMgPSBfaGFuZGxlcnNba2V5XTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldLnNjb3BlID09PSBzY29wZSkgaGFuZGxlcnMuc3BsaWNlKGksIDEpO2Vsc2UgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyDlpoLmnpxzY29wZeiiq+WIoOmZpO+8jOWwhnNjb3Bl6YeN572u5Li6YWxsXG5cblxuICBpZiAoZ2V0U2NvcGUoKSA9PT0gc2NvcGUpIHNldFNjb3BlKG5ld1Njb3BlIHx8ICdhbGwnKTtcbn0gLy8g5riF6Zmk5L+u6aWw6ZSuXG5cblxuZnVuY3Rpb24gY2xlYXJNb2RpZmllcihldmVudCkge1xuICB2YXIga2V5ID0gZXZlbnQua2V5Q29kZSB8fCBldmVudC53aGljaCB8fCBldmVudC5jaGFyQ29kZTtcblxuICB2YXIgaSA9IF9kb3duS2V5cy5pbmRleE9mKGtleSk7IC8vIOS7juWIl+ihqOS4rea4hemZpOaMieWOi+i/h+eahOmUrlxuXG5cbiAgaWYgKGkgPj0gMCkge1xuICAgIF9kb3duS2V5cy5zcGxpY2UoaSwgMSk7XG4gIH0gLy8g54m55q6K5aSE55CGIGNtbWFuZCDplK7vvIzlnKggY21tYW5kIOe7hOWQiOW/q+aNt+mUriBrZXl1cCDlj6rmiafooYzkuIDmrKHnmoTpl67pophcblxuXG4gIGlmIChldmVudC5rZXkgJiYgZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdtZXRhJykge1xuICAgIF9kb3duS2V5cy5zcGxpY2UoMCwgX2Rvd25LZXlzLmxlbmd0aCk7XG4gIH0gLy8g5L+u6aWw6ZSuIHNoaWZ0S2V5IGFsdEtleSBjdHJsS2V5IChjb21tYW5kfHxtZXRhS2V5KSDmuIXpmaRcblxuXG4gIGlmIChrZXkgPT09IDkzIHx8IGtleSA9PT0gMjI0KSBrZXkgPSA5MTtcblxuICBpZiAoa2V5IGluIF9tb2RzKSB7XG4gICAgX21vZHNba2V5XSA9IGZhbHNlOyAvLyDlsIbkv67ppbDplK7ph43nva7kuLpmYWxzZVxuXG4gICAgZm9yICh2YXIgayBpbiBfbW9kaWZpZXIpIHtcbiAgICAgIGlmIChfbW9kaWZpZXJba10gPT09IGtleSkgaG90a2V5c1trXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bmJpbmQoa2V5c0luZm8pIHtcbiAgLy8gdW5iaW5kKCksIHVuYmluZCBhbGwga2V5c1xuICBpZiAodHlwZW9mIGtleXNJbmZvID09PSAndW5kZWZpbmVkJykge1xuICAgIE9iamVjdC5rZXlzKF9oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZGVsZXRlIF9oYW5kbGVyc1trZXldO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoa2V5c0luZm8pKSB7XG4gICAgLy8gc3VwcG9ydCBsaWtlIDogdW5iaW5kKFt7a2V5OiAnY3RybCthJywgc2NvcGU6ICdzMSd9LCB7a2V5OiAnY3RybC1hJywgc2NvcGU6ICdzMicsIHNwbGl0S2V5OiAnLSd9XSlcbiAgICBrZXlzSW5mby5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBpZiAoaW5mby5rZXkpIGVhY2hVbmJpbmQoaW5mbyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtleXNJbmZvID09PSAnb2JqZWN0Jykge1xuICAgIC8vIHN1cHBvcnQgbGlrZSB1bmJpbmQoe2tleTogJ2N0cmwrYSwgY3RybCtiJywgc2NvcGU6J2FiYyd9KVxuICAgIGlmIChrZXlzSW5mby5rZXkpIGVhY2hVbmJpbmQoa2V5c0luZm8pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBrZXlzSW5mbyA9PT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IG9sZCBtZXRob2RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHNjb3BlID0gYXJnc1swXSxcbiAgICAgICAgbWV0aG9kID0gYXJnc1sxXTtcblxuICAgIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1ldGhvZCA9IHNjb3BlO1xuICAgICAgc2NvcGUgPSAnJztcbiAgICB9XG5cbiAgICBlYWNoVW5iaW5kKHtcbiAgICAgIGtleToga2V5c0luZm8sXG4gICAgICBzY29wZTogc2NvcGUsXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHNwbGl0S2V5OiAnKydcbiAgICB9KTtcbiAgfVxufSAvLyDop6PpmaTnu5Hlrprmn5DkuKrojIPlm7TnmoTlv6vmjbfplK5cblxuXG52YXIgZWFjaFVuYmluZCA9IGZ1bmN0aW9uIGVhY2hVbmJpbmQoX3JlZikge1xuICB2YXIga2V5ID0gX3JlZi5rZXksXG4gICAgICBzY29wZSA9IF9yZWYuc2NvcGUsXG4gICAgICBtZXRob2QgPSBfcmVmLm1ldGhvZCxcbiAgICAgIF9yZWYkc3BsaXRLZXkgPSBfcmVmLnNwbGl0S2V5LFxuICAgICAgc3BsaXRLZXkgPSBfcmVmJHNwbGl0S2V5ID09PSB2b2lkIDAgPyAnKycgOiBfcmVmJHNwbGl0S2V5O1xuICB2YXIgbXVsdGlwbGVLZXlzID0gZ2V0S2V5cyhrZXkpO1xuICBtdWx0aXBsZUtleXMuZm9yRWFjaChmdW5jdGlvbiAob3JpZ2luS2V5KSB7XG4gICAgdmFyIHVuYmluZEtleXMgPSBvcmlnaW5LZXkuc3BsaXQoc3BsaXRLZXkpO1xuICAgIHZhciBsZW4gPSB1bmJpbmRLZXlzLmxlbmd0aDtcbiAgICB2YXIgbGFzdEtleSA9IHVuYmluZEtleXNbbGVuIC0gMV07XG4gICAgdmFyIGtleUNvZGUgPSBsYXN0S2V5ID09PSAnKicgPyAnKicgOiBjb2RlKGxhc3RLZXkpO1xuICAgIGlmICghX2hhbmRsZXJzW2tleUNvZGVdKSByZXR1cm47IC8vIOWIpOaWreaYr+WQpuS8oOWFpeiMg+WbtO+8jOayoeacieWwseiOt+WPluiMg+WbtFxuXG4gICAgaWYgKCFzY29wZSkgc2NvcGUgPSBnZXRTY29wZSgpO1xuICAgIHZhciBtb2RzID0gbGVuID4gMSA/IGdldE1vZHMoX21vZGlmaWVyLCB1bmJpbmRLZXlzKSA6IFtdO1xuICAgIF9oYW5kbGVyc1trZXlDb2RlXSA9IF9oYW5kbGVyc1trZXlDb2RlXS5maWx0ZXIoZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgLy8g6YCa6L+H5Ye95pWw5Yik5pat77yM5piv5ZCm6Kej6Zmk57uR5a6a77yM5Ye95pWw55u4562J55u05o6l6L+U5ZueXG4gICAgICB2YXIgaXNNYXRjaGluZ01ldGhvZCA9IG1ldGhvZCA/IHJlY29yZC5tZXRob2QgPT09IG1ldGhvZCA6IHRydWU7XG4gICAgICByZXR1cm4gIShpc01hdGNoaW5nTWV0aG9kICYmIHJlY29yZC5zY29wZSA9PT0gc2NvcGUgJiYgY29tcGFyZUFycmF5KHJlY29yZC5tb2RzLCBtb2RzKSk7XG4gICAgfSk7XG4gIH0pO1xufTsgLy8g5a+555uR5ZCs5a+55bqU5b+r5o236ZSu55qE5Zue6LCD5Ye95pWw6L+b6KGM5aSE55CGXG5cblxuZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzY29wZSwgZWxlbWVudCkge1xuICBpZiAoaGFuZGxlci5lbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1vZGlmaWVyc01hdGNoOyAvLyDnnIvlroPmmK/lkKblnKjlvZPliY3ojIPlm7RcblxuICBpZiAoaGFuZGxlci5zY29wZSA9PT0gc2NvcGUgfHwgaGFuZGxlci5zY29wZSA9PT0gJ2FsbCcpIHtcbiAgICAvLyDmo4Dmn6XmmK/lkKbljLnphY3kv67ppbDnrKbvvIjlpoLmnpzmnInov5Tlm550cnVl77yJXG4gICAgbW9kaWZpZXJzTWF0Y2ggPSBoYW5kbGVyLm1vZHMubGVuZ3RoID4gMDtcblxuICAgIGZvciAodmFyIHkgaW4gX21vZHMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX21vZHMsIHkpKSB7XG4gICAgICAgIGlmICghX21vZHNbeV0gJiYgaGFuZGxlci5tb2RzLmluZGV4T2YoK3kpID4gLTEgfHwgX21vZHNbeV0gJiYgaGFuZGxlci5tb2RzLmluZGV4T2YoK3kpID09PSAtMSkge1xuICAgICAgICAgIG1vZGlmaWVyc01hdGNoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIOiwg+eUqOWkhOeQhueoi+W6j++8jOWmguaenOaYr+S/rumlsOmUruS4jeWBmuWkhOeQhlxuXG5cbiAgICBpZiAoaGFuZGxlci5tb2RzLmxlbmd0aCA9PT0gMCAmJiAhX21vZHNbMTZdICYmICFfbW9kc1sxOF0gJiYgIV9tb2RzWzE3XSAmJiAhX21vZHNbOTFdIHx8IG1vZGlmaWVyc01hdGNoIHx8IGhhbmRsZXIuc2hvcnRjdXQgPT09ICcqJykge1xuICAgICAgaWYgKGhhbmRsZXIubWV0aG9kKGV2ZW50LCBoYW5kbGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChldmVudC5jYW5jZWxCdWJibGUpIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIOWkhOeQhmtleWRvd27kuovku7ZcblxuXG5mdW5jdGlvbiBkaXNwYXRjaChldmVudCwgZWxlbWVudCkge1xuICB2YXIgYXN0ZXJpc2sgPSBfaGFuZGxlcnNbJyonXTtcbiAgdmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2ggfHwgZXZlbnQuY2hhckNvZGU7IC8vIOihqOWNleaOp+S7tui/h+a7pCDpu5jorqTooajljZXmjqfku7bkuI3op6blj5Hlv6vmjbfplK5cblxuICBpZiAoIWhvdGtleXMuZmlsdGVyLmNhbGwodGhpcywgZXZlbnQpKSByZXR1cm47IC8vIEdlY2tvKEZpcmVmb3gp55qEY29tbWFuZOmUruWAvDIyNO+8jOWcqFdlYmtpdChDaHJvbWUp5Lit5L+d5oyB5LiA6Ie0XG4gIC8vIFdlYmtpdOW3puWPsyBjb21tYW5kIOmUruWAvOS4jeS4gOagt1xuXG4gIGlmIChrZXkgPT09IDkzIHx8IGtleSA9PT0gMjI0KSBrZXkgPSA5MTtcbiAgLyoqXG4gICAqIENvbGxlY3QgYm91bmQga2V5c1xuICAgKiBJZiBhbiBJbnB1dCBNZXRob2QgRWRpdG9yIGlzIHByb2Nlc3Npbmcga2V5IGlucHV0IGFuZCB0aGUgZXZlbnQgaXMga2V5ZG93biwgcmV0dXJuIDIyOS5cbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjUwNDM5MzQvaXMtaXQtb2stdG8taWdub3JlLWtleWRvd24tZXZlbnRzLXdpdGgta2V5Y29kZS0yMjlcbiAgICogaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LWRvbS8yMDEwSnVsU2VwL2F0dC0wMTgyL2tleUNvZGUtc3BlYy5odG1sXG4gICAqL1xuXG4gIGlmIChfZG93bktleXMuaW5kZXhPZihrZXkpID09PSAtMSAmJiBrZXkgIT09IDIyOSkgX2Rvd25LZXlzLnB1c2goa2V5KTtcbiAgLyoqXG4gICAqIEplc3QgdGVzdCBjYXNlcyBhcmUgcmVxdWlyZWQuXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICovXG5cbiAgWydjdHJsS2V5JywgJ2FsdEtleScsICdzaGlmdEtleScsICdtZXRhS2V5J10uZm9yRWFjaChmdW5jdGlvbiAoa2V5TmFtZSkge1xuICAgIHZhciBrZXlOdW0gPSBtb2RpZmllck1hcFtrZXlOYW1lXTtcblxuICAgIGlmIChldmVudFtrZXlOYW1lXSAmJiBfZG93bktleXMuaW5kZXhPZihrZXlOdW0pID09PSAtMSkge1xuICAgICAgX2Rvd25LZXlzLnB1c2goa2V5TnVtKTtcbiAgICB9IGVsc2UgaWYgKCFldmVudFtrZXlOYW1lXSAmJiBfZG93bktleXMuaW5kZXhPZihrZXlOdW0pID4gLTEpIHtcbiAgICAgIF9kb3duS2V5cy5zcGxpY2UoX2Rvd25LZXlzLmluZGV4T2Yoa2V5TnVtKSwgMSk7XG4gICAgfSBlbHNlIGlmIChrZXlOYW1lID09PSAnbWV0YUtleScgJiYgZXZlbnRba2V5TmFtZV0gJiYgX2Rvd25LZXlzLmxlbmd0aCA9PT0gMykge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXggaWYgQ29tbWFuZCBpcyBwcmVzc2VkOlxuICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICovXG4gICAgICBpZiAoIShldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSkpIHtcbiAgICAgICAgX2Rvd25LZXlzID0gX2Rvd25LZXlzLnNsaWNlKF9kb3duS2V5cy5pbmRleE9mKGtleU51bSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIGlmIChrZXkgaW4gX21vZHMpIHtcbiAgICBfbW9kc1trZXldID0gdHJ1ZTsgLy8g5bCG54m55q6K5a2X56ym55qEa2V55rOo5YaM5YiwIGhvdGtleXMg5LiKXG5cbiAgICBmb3IgKHZhciBrIGluIF9tb2RpZmllcikge1xuICAgICAgaWYgKF9tb2RpZmllcltrXSA9PT0ga2V5KSBob3RrZXlzW2tdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWFzdGVyaXNrKSByZXR1cm47XG4gIH0gLy8g5bCGIG1vZGlmaWVyTWFwIOmHjOmdoueahOS/rumlsOmUrue7keWumuWIsCBldmVudCDkuK1cblxuXG4gIGZvciAodmFyIGUgaW4gX21vZHMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9tb2RzLCBlKSkge1xuICAgICAgX21vZHNbZV0gPSBldmVudFttb2RpZmllck1hcFtlXV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vamF5d2NqbG92ZS9ob3RrZXlzL3B1bGwvMTI5XG4gICAqIFRoaXMgc29sdmVzIHRoZSBpc3N1ZSBpbiBGaXJlZm94IG9uIFdpbmRvd3Mgd2hlcmUgaG90a2V5cyBjb3JyZXNwb25kaW5nIHRvIHNwZWNpYWwgY2hhcmFjdGVycyB3b3VsZCBub3QgdHJpZ2dlci5cbiAgICogQW4gZXhhbXBsZSBvZiB0aGlzIGlzIGN0cmwrYWx0K20gb24gYSBTd2VkaXNoIGtleWJvYXJkIHdoaWNoIGlzIHVzZWQgdG8gdHlwZSDOvC5cbiAgICogQnJvd3NlciBzdXBwb3J0OiBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PWtleWJvYXJkZXZlbnQtZ2V0bW9kaWZpZXJzdGF0ZVxuICAgKi9cblxuXG4gIGlmIChldmVudC5nZXRNb2RpZmllclN0YXRlICYmICEoZXZlbnQuYWx0S2V5ICYmICFldmVudC5jdHJsS2V5KSAmJiBldmVudC5nZXRNb2RpZmllclN0YXRlKCdBbHRHcmFwaCcpKSB7XG4gICAgaWYgKF9kb3duS2V5cy5pbmRleE9mKDE3KSA9PT0gLTEpIHtcbiAgICAgIF9kb3duS2V5cy5wdXNoKDE3KTtcbiAgICB9XG5cbiAgICBpZiAoX2Rvd25LZXlzLmluZGV4T2YoMTgpID09PSAtMSkge1xuICAgICAgX2Rvd25LZXlzLnB1c2goMTgpO1xuICAgIH1cblxuICAgIF9tb2RzWzE3XSA9IHRydWU7XG4gICAgX21vZHNbMThdID0gdHJ1ZTtcbiAgfSAvLyDojrflj5bojIPlm7Qg6buY6K6k5Li6IGBhbGxgXG5cblxuICB2YXIgc2NvcGUgPSBnZXRTY29wZSgpOyAvLyDlr7nku7vkvZXlv6vmjbfplK7pg73pnIDopoHlgZrnmoTlpITnkIZcblxuICBpZiAoYXN0ZXJpc2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdGVyaXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXN0ZXJpc2tbaV0uc2NvcGUgPT09IHNjb3BlICYmIChldmVudC50eXBlID09PSAna2V5ZG93bicgJiYgYXN0ZXJpc2tbaV0ua2V5ZG93biB8fCBldmVudC50eXBlID09PSAna2V5dXAnICYmIGFzdGVyaXNrW2ldLmtleXVwKSkge1xuICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQsIGFzdGVyaXNrW2ldLCBzY29wZSwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIGtleSDkuI3lnKggX2hhbmRsZXJzIOS4rei/lOWbnlxuXG5cbiAgaWYgKCEoa2V5IGluIF9oYW5kbGVycykpIHJldHVybjtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2hhbmRsZXJzW2tleV0ubGVuZ3RoOyBfaSsrKSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyAmJiBfaGFuZGxlcnNba2V5XVtfaV0ua2V5ZG93biB8fCBldmVudC50eXBlID09PSAna2V5dXAnICYmIF9oYW5kbGVyc1trZXldW19pXS5rZXl1cCkge1xuICAgICAgaWYgKF9oYW5kbGVyc1trZXldW19pXS5rZXkpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IF9oYW5kbGVyc1trZXldW19pXTtcbiAgICAgICAgdmFyIHNwbGl0S2V5ID0gcmVjb3JkLnNwbGl0S2V5O1xuICAgICAgICB2YXIga2V5U2hvcnRjdXQgPSByZWNvcmQua2V5LnNwbGl0KHNwbGl0S2V5KTtcbiAgICAgICAgdmFyIF9kb3duS2V5c0N1cnJlbnQgPSBbXTsgLy8g6K6w5b2V5b2T5YmN5oyJ6ZSu6ZSu5YC8XG5cbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBrZXlTaG9ydGN1dC5sZW5ndGg7IGErKykge1xuICAgICAgICAgIF9kb3duS2V5c0N1cnJlbnQucHVzaChjb2RlKGtleVNob3J0Y3V0W2FdKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2Rvd25LZXlzQ3VycmVudC5zb3J0KCkuam9pbignJykgPT09IF9kb3duS2V5cy5zb3J0KCkuam9pbignJykpIHtcbiAgICAgICAgICAvLyDmib7liLDlpITnkIblhoXlrrlcbiAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQsIHJlY29yZCwgc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIOWIpOaWrSBlbGVtZW50IOaYr+WQpuW3sue7j+e7keWumuS6i+S7tlxuXG5cbmZ1bmN0aW9uIGlzRWxlbWVudEJpbmQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudEhhc0JpbmRFdmVudC5pbmRleE9mKGVsZW1lbnQpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGhvdGtleXMoa2V5LCBvcHRpb24sIG1ldGhvZCkge1xuICBfZG93bktleXMgPSBbXTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKGtleSk7IC8vIOmcgOimgeWkhOeQhueahOW/q+aNt+mUruWIl+ihqFxuXG4gIHZhciBtb2RzID0gW107XG4gIHZhciBzY29wZSA9ICdhbGwnOyAvLyBzY29wZem7mOiupOS4umFsbO+8jOaJgOacieiMg+WbtOmDveacieaViFxuXG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQ7IC8vIOW/q+aNt+mUruS6i+S7tue7keWumuiKgueCuVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIGtleXVwID0gZmFsc2U7XG4gIHZhciBrZXlkb3duID0gdHJ1ZTtcbiAgdmFyIHNwbGl0S2V5ID0gJysnO1xuICB2YXIgY2FwdHVyZSA9IGZhbHNlOyAvLyDlr7nkuLrorr7lrprojIPlm7TnmoTliKTmlq1cblxuICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1ldGhvZCA9IG9wdGlvbjtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0aW9uKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBpZiAob3B0aW9uLnNjb3BlKSBzY29wZSA9IG9wdGlvbi5zY29wZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKG9wdGlvbi5lbGVtZW50KSBlbGVtZW50ID0gb3B0aW9uLmVsZW1lbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChvcHRpb24ua2V5dXApIGtleXVwID0gb3B0aW9uLmtleXVwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAob3B0aW9uLmtleWRvd24gIT09IHVuZGVmaW5lZCkga2V5ZG93biA9IG9wdGlvbi5rZXlkb3duOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAob3B0aW9uLmNhcHR1cmUgIT09IHVuZGVmaW5lZCkgY2FwdHVyZSA9IG9wdGlvbi5jYXB0dXJlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbi5zcGxpdEtleSA9PT0gJ3N0cmluZycpIHNwbGl0S2V5ID0gb3B0aW9uLnNwbGl0S2V5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHNjb3BlID0gb3B0aW9uOyAvLyDlr7nkuo7mr4/kuKrlv6vmjbfplK7ov5vooYzlpITnkIZcblxuICBmb3IgKDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldLnNwbGl0KHNwbGl0S2V5KTsgLy8g5oyJ6ZSu5YiX6KGoXG5cbiAgICBtb2RzID0gW107IC8vIOWmguaenOaYr+e7hOWQiOW/q+aNt+mUruWPluW+l+e7hOWQiOW/q+aNt+mUrlxuXG4gICAgaWYgKGtleS5sZW5ndGggPiAxKSBtb2RzID0gZ2V0TW9kcyhfbW9kaWZpZXIsIGtleSk7IC8vIOWwhumdnuS/rumlsOmUrui9rOWMluS4uumUrueggVxuXG4gICAga2V5ID0ga2V5W2tleS5sZW5ndGggLSAxXTtcbiAgICBrZXkgPSBrZXkgPT09ICcqJyA/ICcqJyA6IGNvZGUoa2V5KTsgLy8gKuihqOekuuWMuemFjeaJgOacieW/q+aNt+mUrlxuICAgIC8vIOWIpOaWrWtleeaYr+WQpuWcqF9oYW5kbGVyc+S4re+8jOS4jeWcqOWwsei1i+S4gOS4quepuuaVsOe7hFxuXG4gICAgaWYgKCEoa2V5IGluIF9oYW5kbGVycykpIF9oYW5kbGVyc1trZXldID0gW107XG5cbiAgICBfaGFuZGxlcnNba2V5XS5wdXNoKHtcbiAgICAgIGtleXVwOiBrZXl1cCxcbiAgICAgIGtleWRvd246IGtleWRvd24sXG4gICAgICBzY29wZTogc2NvcGUsXG4gICAgICBtb2RzOiBtb2RzLFxuICAgICAgc2hvcnRjdXQ6IGtleXNbaV0sXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIGtleToga2V5c1tpXSxcbiAgICAgIHNwbGl0S2V5OiBzcGxpdEtleSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICB9KTtcbiAgfSAvLyDlnKjlhajlsYBkb2N1bWVudOS4iuiuvue9ruW/q+aNt+mUrlxuXG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhaXNFbGVtZW50QmluZChlbGVtZW50KSAmJiB3aW5kb3cpIHtcbiAgICBlbGVtZW50SGFzQmluZEV2ZW50LnB1c2goZWxlbWVudCk7XG4gICAgYWRkRXZlbnQoZWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZGlzcGF0Y2goZSwgZWxlbWVudCk7XG4gICAgfSwgY2FwdHVyZSk7XG5cbiAgICBpZiAoIXdpbkxpc3RlbmRGb2N1cykge1xuICAgICAgd2luTGlzdGVuZEZvY3VzID0gdHJ1ZTtcbiAgICAgIGFkZEV2ZW50KHdpbmRvdywgJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfZG93bktleXMgPSBbXTtcbiAgICAgIH0sIGNhcHR1cmUpO1xuICAgIH1cblxuICAgIGFkZEV2ZW50KGVsZW1lbnQsICdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaXNwYXRjaChlLCBlbGVtZW50KTtcbiAgICAgIGNsZWFyTW9kaWZpZXIoZSk7XG4gICAgfSwgY2FwdHVyZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlcihzaG9ydGN1dCkge1xuICB2YXIgc2NvcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdhbGwnO1xuICBPYmplY3Qua2V5cyhfaGFuZGxlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBkYXRhTGlzdCA9IF9oYW5kbGVyc1trZXldLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uc2NvcGUgPT09IHNjb3BlICYmIGl0ZW0uc2hvcnRjdXQgPT09IHNob3J0Y3V0O1xuICAgIH0pO1xuXG4gICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5tZXRob2QpIHtcbiAgICAgICAgZGF0YS5tZXRob2QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbnZhciBfYXBpID0ge1xuICBnZXRQcmVzc2VkS2V5U3RyaW5nOiBnZXRQcmVzc2VkS2V5U3RyaW5nLFxuICBzZXRTY29wZTogc2V0U2NvcGUsXG4gIGdldFNjb3BlOiBnZXRTY29wZSxcbiAgZGVsZXRlU2NvcGU6IGRlbGV0ZVNjb3BlLFxuICBnZXRQcmVzc2VkS2V5Q29kZXM6IGdldFByZXNzZWRLZXlDb2RlcyxcbiAgaXNQcmVzc2VkOiBpc1ByZXNzZWQsXG4gIGZpbHRlcjogZmlsdGVyLFxuICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICB1bmJpbmQ6IHVuYmluZCxcbiAga2V5TWFwOiBfa2V5TWFwLFxuICBtb2RpZmllcjogX21vZGlmaWVyLFxuICBtb2RpZmllck1hcDogbW9kaWZpZXJNYXBcbn07XG5cbmZvciAodmFyIGEgaW4gX2FwaSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9hcGksIGEpKSB7XG4gICAgaG90a2V5c1thXSA9IF9hcGlbYV07XG4gIH1cbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBfaG90a2V5cyA9IHdpbmRvdy5ob3RrZXlzO1xuXG4gIGhvdGtleXMubm9Db25mbGljdCA9IGZ1bmN0aW9uIChkZWVwKSB7XG4gICAgaWYgKGRlZXAgJiYgd2luZG93LmhvdGtleXMgPT09IGhvdGtleXMpIHtcbiAgICAgIHdpbmRvdy5ob3RrZXlzID0gX2hvdGtleXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvdGtleXM7XG4gIH07XG5cbiAgd2luZG93LmhvdGtleXMgPSBob3RrZXlzO1xufVxuXG5leHBvcnQgeyBob3RrZXlzIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IFRZUEVTIH0gZnJvbSAnQC9jb25maWcnO1xuaW1wb3J0IHsgQ29tbWFuZCwgSUV2ZW50QnVzLCBJU2hvcnRjdXQgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJ0AvdXRpbCc7XG5pbXBvcnQgaG90a2V5cyBmcm9tICdob3RrZXlzLWpzJztcbmltcG9ydCB7IGluamVjdCwgaW5qZWN0YWJsZSB9IGZyb20gJ2ludmVyc2lmeSc7XG5cbmhvdGtleXMuZmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNob3J0Y3V0IGltcGxlbWVudHMgSVNob3J0Y3V0IHtcbiAgICBwcml2YXRlIGV2ZW50QnVzOiBJRXZlbnRCdXM7XG5cbiAgICBwcml2YXRlIG9wdGlvbiA9IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKEBpbmplY3QoVFlQRVMuRXZlbnRCdXMpIGV2ZW50QnVzOiBJRXZlbnRCdXMpIHtcbiAgICAgICAgbG9nKCdJbml0aWFsaXplIHNob3J0Y3V0IHN1YnN5c3RlbScpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgfVxuXG4gICAgcHVibGljIHJlZ2lzdGVyS2V5Ym9hcmRFdmVudChzaG9ydGN1dDogc3RyaW5nLCBjYWxsYmFjazogKGU6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQpIHtcbiAgICAgICAgaG90a2V5cyhzaG9ydGN1dCwgdGhpcy5vcHRpb24sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbihzaG9ydGN1dC50b1N0cmluZygpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcHVibGljIHVucmVnaXN0ZXJLZXlib2FyZEV2ZW50KHNob3J0Y3V0OiBzdHJpbmcpIHtcbiAgICAgICAgaG90a2V5cy51bmJpbmQoc2hvcnRjdXQpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9mZihzaG9ydGN1dC50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVnaXN0ZXJLZXlib2FyZEV2ZW50RnJvbVBsdWdpbihjb21tYW5kOiBDb21tYW5kKSB7XG4gICAgICAgIGlmIChjb21tYW5kLnNob3J0Y3V0ICYmIGNvbW1hbmQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJLZXlib2FyZEV2ZW50KGNvbW1hbmQuc2hvcnRjdXQsIGNvbW1hbmQuY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHVucmVnaXN0ZXJLZXlib2FyZEV2ZW50RnJvbVBsdWdpbihjb21tYW5kOiBDb21tYW5kKSB7XG4gICAgICAgIGlmIChjb21tYW5kLnNob3J0Y3V0ICYmIGNvbW1hbmQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlcktleWJvYXJkRXZlbnQoY29tbWFuZC5zaG9ydGN1dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBpbmplY3RhYmxlIH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IElTZXR0aW5nTWFuYWdlciwgU2V0dGluZ1JlbmRlciB9IGZyb20gJy4uL3R5cGVzJztcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNldHRpbmdNYW5hZ2VyIGltcGxlbWVudHMgSVNldHRpbmdNYW5hZ2VyIHtcbiAgICBzZXR0aW5nUmVuZGVyczogTWFwPHN0cmluZywgU2V0dGluZ1JlbmRlcj47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ1JlbmRlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJTZXR0aW5nKHBsdWdpbktleTogc3RyaW5nLCBzZXR0aW5nUmVuZGVyOiBTZXR0aW5nUmVuZGVyKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ1JlbmRlcnMuc2V0KHBsdWdpbktleSwgc2V0dGluZ1JlbmRlcik7XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlclNldHRpbmcoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nUmVuZGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBnZXRTZXR0aW5nUmVuZGVycygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTx7IGtleTogc3RyaW5nOyB2YWx1ZTogU2V0dGluZ1JlbmRlciB9PiA9IFtdO1xuICAgICAgICB0aGlzLnNldHRpbmdSZW5kZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IFN0b3JhZ2VNYW5hZ2VyIH0gZnJvbSAnLi9jb3JlL3N0b3JhZ2UtbWFuYWdlcic7XG5pbXBvcnQgeyBQbHVnaW5TeXN0ZW0gfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHsgVFlQRVMgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBTeXN0ZW1NYW5hZ2VyIH0gZnJvbSAnLi9jb3JlL3N5c3RlbS1tYW5hZ2VyJztcbmltcG9ydCB7IFBsdWdpbkxvYWRlciB9IGZyb20gJy4vY29yZS9sb2FkZXInO1xuaW1wb3J0IHsgUGx1Z2luRmlsZU1hbmFnZXIgfSBmcm9tICcuL2NvcmUvcGx1Z2luLWZpbGUtbWFuYWdlcic7XG5pbXBvcnQge1xuICAgIElTdG9yYWdlTWFuYWdlcixcbiAgICBJU3lzdGVtTWFuYWdlcixcbiAgICBJUGx1Z2luU3lzdGVtLFxuICAgIElQbHVnaW5Mb2FkZXIsXG4gICAgSVBsdWdpbkZpbGVNYW5hZ2VyLFxuICAgIElFdmVudEJ1cyxcbiAgICBJU2hvcnRjdXQsXG4gICAgSUNvbW1hbmRNYW5hZ2VyLFxuICAgIElTdG9yZSxcbiAgICBJU2V0dGluZ01hbmFnZXIsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgRXZlbnRCdXMgfSBmcm9tICcuL2NvcmUvZXZlbnQtYnVzJztcbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9jb3JlL2NvbW1hbmQtbWFuYWdlcic7XG5pbXBvcnQgeyBTaG9ydGN1dCB9IGZyb20gJy4vY29yZS9zaG9ydGN1dCc7XG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4vY29yZS9zdG9yZSc7XG5pbXBvcnQgeyBTZXR0aW5nTWFuYWdlciB9IGZyb20gJy4vY29yZS9zZXR0aW5nLW1hbmFnZXInO1xuXG5jb25zdCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKCk7XG5jb250YWluZXIuYmluZDxJU3RvcmFnZU1hbmFnZXI+KFRZUEVTLlN0b3JhZ2VNYW5hZ2VyKS50byhTdG9yYWdlTWFuYWdlcikuaW5TaW5nbGV0b25TY29wZSgpO1xuY29udGFpbmVyLmJpbmQ8SVN5c3RlbU1hbmFnZXI+KFRZUEVTLlN5c3RlbU1hbmFnZXIpLnRvKFN5c3RlbU1hbmFnZXIpLmluU2luZ2xldG9uU2NvcGUoKTtcbmNvbnRhaW5lci5iaW5kPElQbHVnaW5TeXN0ZW0+KFRZUEVTLlBsdWdpblN5c3RlbSkudG8oUGx1Z2luU3lzdGVtKS5pblNpbmdsZXRvblNjb3BlKCk7XG5jb250YWluZXIuYmluZDxJUGx1Z2luTG9hZGVyPihUWVBFUy5QbHVnaW5Mb2FkZXIpLnRvKFBsdWdpbkxvYWRlcikuaW5TaW5nbGV0b25TY29wZSgpO1xuY29udGFpbmVyLmJpbmQ8SVBsdWdpbkZpbGVNYW5hZ2VyPihUWVBFUy5QbHVnaW5GaWxlTWFuYWdlcikudG8oUGx1Z2luRmlsZU1hbmFnZXIpLmluU2luZ2xldG9uU2NvcGUoKTtcbmNvbnRhaW5lci5iaW5kPElFdmVudEJ1cz4oVFlQRVMuRXZlbnRCdXMpLnRvKEV2ZW50QnVzKTtcbmNvbnRhaW5lci5iaW5kPElTaG9ydGN1dD4oVFlQRVMuU2hvcnRjdXQpLnRvKFNob3J0Y3V0KS5pblNpbmdsZXRvblNjb3BlKCk7XG5jb250YWluZXIuYmluZDxJQ29tbWFuZE1hbmFnZXI+KFRZUEVTLkNvbW1hbmRNYW5hZ2VyKS50byhDb21tYW5kTWFuYWdlcikuaW5TaW5nbGV0b25TY29wZSgpO1xuY29udGFpbmVyLmJpbmQ8SVN0b3JlPihUWVBFUy5TdG9yZSkudG8oU3RvcmUpLmluU2luZ2xldG9uU2NvcGUoKTtcbmNvbnRhaW5lci5iaW5kPElTZXR0aW5nTWFuYWdlcj4oVFlQRVMuU2V0dGluZ01hbmFnZXIpLnRvKFNldHRpbmdNYW5hZ2VyKS5pblNpbmdsZXRvblNjb3BlKCk7XG5cbmV4cG9ydCB7IGNvbnRhaW5lciB9O1xuIiwiaW1wb3J0ICdyZWZsZWN0LW1ldGFkYXRhJztcblxuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBjb250YWluZXIgfSBmcm9tICcuL2NvbnRhaW5lcic7XG5pbXBvcnQgeyBUWVBFUyB9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IElQbHVnaW5TeXN0ZW0gfSBmcm9tICcuL3R5cGVzJztcblxuZnVuY3Rpb24gaW5pdFBsdWdpblN5c3RlbSgpIHtcbiAgICBpZiAoIXdpbmRvdy5wbHVnaW5TeXN0ZW0pIHtcbiAgICAgICAgbG9nKCdTaXl1YW4gUGx1Z2luIFN5c3RlbSBsb2FkaW5nLi4uJyk7XG4gICAgICAgIHdpbmRvdy5wbHVnaW5TeXN0ZW1WZXJzaW9uID0gVkVSU0lPTjtcbiAgICAgICAgd2luZG93LnBsdWdpblN5c3RlbSA9IGNvbnRhaW5lci5nZXQ8SVBsdWdpblN5c3RlbT4oVFlQRVMuUGx1Z2luU3lzdGVtKS5pbml0KCk7XG4gICAgICAgIHdpbmRvdy5wbHVnaW5TeXN0ZW1Jb2NDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpbml0UGx1Z2luU3lzdGVtIH07XG5leHBvcnQgZGVmYXVsdCBpbml0UGx1Z2luU3lzdGVtO1xuIl0sIm5hbWVzIjpbIlJlZmxlY3QiLCJmYWN0b3J5IiwiZ2xvYmFsIiwiTWV0YWRhdGEiLCJQIiwiaGFzT3duIiwiX2EiLCJpdGVyYXRvciIsImsiLCJwcm90b3R5cGUiLCJNYXBJdGVyYXRvciIsImVycm9yIiwiTWFwIiwiZ2V0S2V5IiwiaW5zZXJ0IiwiXyIsIlNldCIsIldlYWtNYXAiLCJWRVJTSU9OIiwicmVxdWVzdCIsInVybCIsInRyYW5zYWN0aW9ucyIsInNxbCIsIm5hbWUiLCJpZCIsInRleHQiLCJzZXJ2ZXJBcGkucHVzaEVyck1zZyIsInNlcnZlckFwaS5wdXNoTXNnIiwidCIsImEiLCJlIiwibCIsInAiLCJjIiwiTUFYX0xFTkdUSCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJjb25zdGFudHMiLCJkZWJ1ZyIsIk1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgiLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZSIsIlIiLCJwYXJzZU9wdGlvbnMiLCJjb21wYXJlSWRlbnRpZmllcnMiLCJiIiwiaWRlbnRpZmllcnMiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsInJlcXVpcmUkJDQiLCJTZW1WZXIiLCJ2ZXJzaW9uIiwic2VtdmVyIiwicGFyc2UiLCJ2YWxpZCIsImNsZWFuIiwiaW5jIiwiY29tcGFyZSIsImVxIiwiZGlmZiIsIm1ham9yIiwibWlub3IiLCJwYXRjaCIsInByZXJlbGVhc2UiLCJyY29tcGFyZSIsImNvbXBhcmVMb29zZSIsImNvbXBhcmVCdWlsZCIsInNvcnQiLCJyc29ydCIsImd0IiwibHQiLCJuZXEiLCJndGUiLCJsdGUiLCJyZXF1aXJlJCQ1IiwiY21wIiwiY29lcmNlIiwic2VsZiIsInRyaW0iLCJSYW5nZSIsInJhbmdlIiwiQ29tcGFyYXRvciIsIk0iLCJ6IiwiQU5ZIiwic2F0aXNmaWVzIiwidG9Db21wYXJhdG9ycyIsIm1heFNhdGlzZnlpbmciLCJtaW5TYXRpc2Z5aW5nIiwibWluVmVyc2lvbiIsImNvbXBhcmF0b3IiLCJ2YWxpZFJhbmdlIiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJvdXRzaWRlIiwiZ3RyIiwibHRyIiwiaW50ZXJzZWN0cyIsInN1YnNldCIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE4IiwicmVxdWlyZSQkMTkiLCJyZXF1aXJlJCQyMCIsInJlcXVpcmUkJDIxIiwicmVxdWlyZSQkMjIiLCJyZXF1aXJlJCQyMyIsInJlcXVpcmUkJDI0IiwicmVxdWlyZSQkMjUiLCJyZXF1aXJlJCQyNiIsInJlcXVpcmUkJDI3IiwicmVxdWlyZSQkMjgiLCJyZXF1aXJlJCQyOSIsInJlcXVpcmUkJDMwIiwicmVxdWlyZSQkMzEiLCJyZXF1aXJlJCQzMiIsInJlcXVpcmUkJDMzIiwicmVxdWlyZSQkMzQiLCJyZXF1aXJlJCQzNSIsInJlcXVpcmUkJDM2IiwicmVxdWlyZSQkMzciLCJyZXF1aXJlJCQzOCIsInJlcXVpcmUkJDM5IiwicmVxdWlyZSQkNDAiLCJyZXNvbHZlIiwiZGVzY3JpcHRvcnMiLCJmaWx0ZXIiLCJoYXNPd25Qcm9wZXJ0eSIsIm5vb3AiLCJjb2RlIiwiY29uZmlnIiwiZW5jb2RlIiwiYXBwZW5kIiwidG9TdHJpbmciLCJVUkxTZWFyY2hQYXJhbXMiLCJGb3JtRGF0YSIsIkJsb2IiLCJpc0Zvcm1EYXRhIiwiaXNGaWxlTGlzdCIsInRyYW5zaXRpb25hbCIsImRlZmF1bHRzIiwiQXhpb3NIZWFkZXJzIiwidmFsaWRhdGVTdGF0dXMiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJpc1VSTFNhbWVPcmlnaW4iLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJhZGFwdGVycyIsIm1lcmdlIiwidmFsaWRhdG9ycyIsInZhbGlkYXRvciIsIm9wdHMiLCJJbnRlcmNlcHRvck1hbmFnZXIiLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwiZm9yRWFjaE1ldGhvZFdpdGhEYXRhIiwiZGVmYXVsdENvbmZpZyIsIkF4aW9zIiwiaW5zdGFuY2UiLCJDYW5jZWxUb2tlbiIsIkh0dHBTdGF0dXNDb2RlIiwiTG9nZ2VyRmFjdG9yeSIsIkxvZ0xldmVsRW51bSIsImF4aW9zIiwiRXJyb3IiLCJCaW5kaW5nIiwiTWV0YWRhdGFSZWFkZXIiLCJNRVRBREFUQV9LRVkuUEFSQU1fVFlQRVMiLCJNRVRBREFUQV9LRVkuVEFHR0VEIiwiTUVUQURBVEFfS0VZLlRBR0dFRF9QUk9QIiwiRVJST1JfTVNHUy5TVEFDS19PVkVSRkxPVyIsImNvbnRhaW5lciIsImdldEJpbmRpbmdzIiwiRVJST1JfTVNHUy5DSVJDVUxBUl9ERVBFTkRFTkNZIiwiQ29udGV4dCIsInBsYW4iLCJNRVRBREFUQV9LRVkuTkFNRURfVEFHIiwiUGxhbiIsIkxhenlTZXJ2aWNlSWRlbnRpZmVyIiwiUXVlcnlhYmxlU3RyaW5nIiwiVGFyZ2V0IiwiTUVUQURBVEFfS0VZLk1VTFRJX0lOSkVDVF9UQUciLCJNRVRBREFUQV9LRVkuTk9OX0NVU1RPTV9UQUdfS0VZUyIsIk1FVEFEQVRBX0tFWS5PUFRJT05BTF9UQUciLCJfX3NwcmVhZEFycmF5IiwidGhpcyIsIkVSUk9SX01TR1MuTUlTU0lOR19JTkpFQ1RBQkxFX0FOTk9UQVRJT04iLCJpc09iamVjdCIsImlzRnVuY3Rpb24iLCJpc1VuZGVmaW5lZCIsIkVSUk9SX01TR1MuTUlTU0lOR19JTkpFQ1RfQU5OT1RBVElPTiIsImluamVjdCIsIk1FVEFEQVRBX0tFWS5VTk1BTkFHRURfVEFHIiwiTUVUQURBVEFfS0VZLklOSkVDVF9UQUciLCJNRVRBREFUQV9LRVkuTkFNRV9UQUciLCJSZXF1ZXN0IiwiRVJST1JfTVNHUy5OT1RfUkVHSVNURVJFRCIsIkVSUk9SX01TR1MuQU1CSUdVT1VTX01BVENIIiwiRVJST1JfTVNHUy5BUkdVTUVOVFNfTEVOR1RIX01JU01BVENIIiwiX19hd2FpdGVyIiwiX19nZW5lcmF0b3IiLCJGYWN0b3J5VHlwZSIsIkVSUk9SX01TR1MuSU5WQUxJRF9CSU5ESU5HX1RZUEUiLCJfX2Fzc2lnbiIsIk1FVEFEQVRBX0tFWS5QT1NUX0NPTlNUUlVDVCIsIk1FVEFEQVRBX0tFWS5QUkVfREVTVFJPWSIsIkVSUk9SX01TR1MuQ0lSQ1VMQVJfREVQRU5ERU5DWV9JTl9GQUNUT1JZIiwiQmluZGluZ1doZW5TeW50YXgiLCJCaW5kaW5nT25TeW50YXgiLCJCaW5kaW5nV2hlbk9uU3ludGF4IiwiQmluZGluZ0luU3ludGF4IiwiQmluZGluZ0luV2hlbk9uU3ludGF4IiwiQmluZGluZ1RvU3ludGF4IiwiRVJST1JfTVNHUy5JTlZBTElEX1RPX1NFTEZfVkFMVUUiLCJFUlJPUl9NU0dTLklOVkFMSURfRlVOQ1RJT05fQklORElORyIsIkNvbnRhaW5lclNuYXBzaG90IiwiTG9va3VwIiwiRVJST1JfTVNHUy5OVUxMX0FSR1VNRU5UIiwiRVJST1JfTVNHUy5LRVlfTk9UX0ZPVU5EIiwiTW9kdWxlQWN0aXZhdGlvblN0b3JlIiwiQ29udGFpbmVyIiwiRVJST1JfTVNHUy5DT05UQUlORVJfT1BUSU9OU19NVVNUX0JFX0FOX09CSkVDVCIsIkVSUk9SX01TR1MuQ09OVEFJTkVSX09QVElPTlNfSU5WQUxJRF9ERUZBVUxUX1NDT1BFIiwiRVJST1JfTVNHUy5DT05UQUlORVJfT1BUSU9OU19JTlZBTElEX0FVVE9fQklORF9JTkpFQ1RBQkxFIiwiRVJST1JfTVNHUy5DT05UQUlORVJfT1BUSU9OU19JTlZBTElEX1NLSVBfQkFTRV9DSEVDSyIsIkVSUk9SX01TR1MuTk9fTU9SRV9TTkFQU0hPVFNfQVZBSUxBQkxFIiwiRVJST1JfTVNHUy5PTl9ERUFDVElWQVRJT05fRVJST1IiLCJFUlJPUl9NU0dTLklOVkFMSURfTUlERExFV0FSRV9SRVRVUk4iLCJFUlJPUl9NU0dTLkxBWllfSU5fU1lOQyIsIkVSUk9SX01TR1MuQVNZTkNfVU5CSU5EX1JFUVVJUkVEIiwiRVJST1JfTVNHUy5DQU5OT1RfVU5CSU5EIiwiRVJST1JfTVNHUy5JTlZBTElEX0RFQ09SQVRPUl9PUEVSQVRJT04iLCJFUlJPUl9NU0dTLkRVUExJQ0FURURfTUVUQURBVEEiLCJtIiwiRVJST1JTX01TR1MuRFVQTElDQVRFRF9JTkpFQ1RBQkxFX0RFQ09SQVRPUiIsIk1FVEFEQVRBX0tFWS5ERVNJR05fUEFSQU1fVFlQRVMiLCJlbGVtZW50IiwiZGV0YWNoIiwiY3JlYXRlX2ZyYWdtZW50IiwiY3R4IiwiY3JlYXRlX2lmX2Jsb2NrXzEiLCJjcmVhdGVfaWZfYmxvY2siLCJDb21tYW5kUGFuZWxfX1N2ZWx0ZUNvbXBvbmVudF8iLCJ1bmluc3RhbGwiLCJwbHVnaW4iLCJfX2RlY29yYXRlQ2xhc3MiLCJfX2RlY29yYXRlUGFyYW0iLCJjcmVhdGVfaWZfYmxvY2tfNCIsImNyZWF0ZV9pZl9ibG9ja18zIiwiY3JlYXRlX2lmX2Jsb2NrXzIiLCJkaXNwYXRjaCIsImxvYWRpbmciLCJyZWFkbWUiLCJnb0JhY2siLCJyZW5kZXIiLCJTZXR0aW5nQ29tbW9uIiwiU2V0dGluZ0xpc3QiLCJTZXR0aW5nU3RvcmUiLCJjbGllbnRBcGkuYWRkVG9vbGJhclJpZ2h0IiwiU2V0dGluZ3MiLCJpc0hpZ2hTdXJyb2dhdGUiLCJpc0xvd1N1cnJvZ2F0ZSIsInRydW5jYXRlIiwiZ2V0TGVuZ3RoIiwiYnJvd3NlciIsImFsbCIsInNhbml0aXplIiwiaW50ZXJuYWxQbHVnaW5zIiwic2NyaXB0Iiwic2VydmVyQXBpLmdldEJhenphcldpZGdldCIsInBsdWciLCJwbHVnaW5OYW1lIiwic2hvcnRjdXQiLCJnZXRNb2RpZmllciIsImVhY2hVbmJpbmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQSxJQUFJQTtBQUFBQSxDQUNILFNBQVVBLFVBQVM7QUFHaEIsR0FBQyxTQUFVQyxVQUFTO0FBQ2hCLFFBQUksT0FBTyxPQUFPQyxtQkFBVyxXQUFXQSxpQkFDcEMsT0FBTyxTQUFTLFdBQVcsT0FDdkIsT0FBTyxTQUFTLFdBQVcsT0FDdkIsU0FBUyxjQUFjO0FBQ25DLFFBQUksV0FBVyxhQUFhRixRQUFPO0FBQ25DLFFBQUksT0FBTyxLQUFLLFlBQVksYUFBYTtBQUNyQyxXQUFLLFVBQVVBO0FBQUEsSUFDbEIsT0FDSTtBQUNELGlCQUFXLGFBQWEsS0FBSyxTQUFTLFFBQVE7QUFBQSxJQUNqRDtBQUNELElBQUFDLFNBQVEsUUFBUTtBQUNoQixhQUFTLGFBQWEsUUFBUSxVQUFVO0FBQ3BDLGFBQU8sU0FBVSxLQUFLLE9BQU87QUFDekIsWUFBSSxPQUFPLE9BQU8sR0FBRyxNQUFNLFlBQVk7QUFDbkMsaUJBQU8sZUFBZSxRQUFRLEtBQUssRUFBRSxjQUFjLE1BQU0sVUFBVSxNQUFNLE1BQWMsQ0FBQTtBQUFBLFFBQzFGO0FBQ0QsWUFBSTtBQUNBLG1CQUFTLEtBQUssS0FBSztBQUFBLE1BQ3ZDO0FBQUEsSUFDUztBQUFBLEVBQ0osR0FBRSxTQUFVLFVBQVU7QUFDbkIsUUFBSSxTQUFTLE9BQU8sVUFBVTtBQUU5QixRQUFJLGlCQUFpQixPQUFPLFdBQVc7QUFDdkMsUUFBSSxvQkFBb0Isa0JBQWtCLE9BQU8sT0FBTyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDM0csUUFBSSxpQkFBaUIsa0JBQWtCLE9BQU8sT0FBTyxhQUFhLGNBQWMsT0FBTyxXQUFXO0FBQ2xHLFFBQUksaUJBQWlCLE9BQU8sT0FBTyxXQUFXO0FBQzlDLFFBQUksZ0JBQWdCLEVBQUUsV0FBVyxDQUFFLEVBQUEsYUFBYztBQUNqRCxRQUFJLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQztBQUNwQyxRQUFJLFVBQVU7QUFBQTtBQUFBLE1BRVYsUUFBUSxpQkFDRixXQUFZO0FBQUUsZUFBTyxlQUFlLHVCQUFPLE9BQU8sSUFBSSxDQUFDO0FBQUEsTUFBSSxJQUMzRCxnQkFDSSxXQUFZO0FBQUUsZUFBTyxlQUFlLEVBQUUsV0FBVyxLQUFJLENBQUU7QUFBQSxNQUFJLElBQzNELFdBQVk7QUFBRSxlQUFPLGVBQWUsQ0FBRSxDQUFBO0FBQUEsTUFBSTtBQUFBLE1BQ3BELEtBQUssWUFDQyxTQUFVLEtBQUssS0FBSztBQUFFLGVBQU8sT0FBTyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQUksSUFDckQsU0FBVSxLQUFLLEtBQUs7QUFBRSxlQUFPLE9BQU87QUFBQSxNQUFNO0FBQUEsTUFDaEQsS0FBSyxZQUNDLFNBQVUsS0FBSyxLQUFLO0FBQUUsZUFBTyxPQUFPLEtBQUssS0FBSyxHQUFHLElBQUksSUFBSSxHQUFHLElBQUk7QUFBQSxNQUFZLElBQzVFLFNBQVUsS0FBSyxLQUFLO0FBQUUsZUFBTyxJQUFJLEdBQUc7QUFBQSxNQUFJO0FBQUEsSUFDMUQ7QUFFUSxRQUFJLG9CQUFvQixPQUFPLGVBQWUsUUFBUTtBQUN0RCxRQUFJLGNBQWMsT0FBTyxZQUFZLFlBQVksUUFBUSxPQUFPLFFBQVEsSUFBSSxtQ0FBbUMsTUFBTTtBQUNySCxRQUFJLE9BQU8sQ0FBQyxlQUFlLE9BQU8sUUFBUSxjQUFjLE9BQU8sSUFBSSxVQUFVLFlBQVksYUFBYSxNQUFNLGtCQUFpQjtBQUM3SCxRQUFJLE9BQU8sQ0FBQyxlQUFlLE9BQU8sUUFBUSxjQUFjLE9BQU8sSUFBSSxVQUFVLFlBQVksYUFBYSxNQUFNLGtCQUFpQjtBQUM3SCxRQUFJLFdBQVcsQ0FBQyxlQUFlLE9BQU8sWUFBWSxhQUFhLFVBQVU7QUFHekUsUUFBSUUsWUFBVyxJQUFJO0FBd0NuQixhQUFTLFNBQVMsWUFBWSxRQUFRLGFBQWEsWUFBWTtBQUMzRCxVQUFJLENBQUMsWUFBWSxXQUFXLEdBQUc7QUFDM0IsWUFBSSxDQUFDLFFBQVEsVUFBVTtBQUNuQixnQkFBTSxJQUFJLFVBQVM7QUFDdkIsWUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixnQkFBTSxJQUFJLFVBQVM7QUFDdkIsWUFBSSxDQUFDLFNBQVMsVUFBVSxLQUFLLENBQUMsWUFBWSxVQUFVLEtBQUssQ0FBQyxPQUFPLFVBQVU7QUFDdkUsZ0JBQU0sSUFBSSxVQUFTO0FBQ3ZCLFlBQUksT0FBTyxVQUFVO0FBQ2pCLHVCQUFhO0FBQ2pCLHNCQUFjLGNBQWMsV0FBVztBQUN2QyxlQUFPLGlCQUFpQixZQUFZLFFBQVEsYUFBYSxVQUFVO0FBQUEsTUFDdEUsT0FDSTtBQUNELFlBQUksQ0FBQyxRQUFRLFVBQVU7QUFDbkIsZ0JBQU0sSUFBSSxVQUFTO0FBQ3ZCLFlBQUksQ0FBQyxjQUFjLE1BQU07QUFDckIsZ0JBQU0sSUFBSSxVQUFTO0FBQ3ZCLGVBQU8sb0JBQW9CLFlBQVksTUFBTTtBQUFBLE1BQ2hEO0FBQUEsSUFDSjtBQUNELGFBQVMsWUFBWSxRQUFRO0FBMkM3QixhQUFTLFNBQVMsYUFBYSxlQUFlO0FBQzFDLGVBQVMsVUFBVSxRQUFRLGFBQWE7QUFDcEMsWUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixnQkFBTSxJQUFJLFVBQVM7QUFDdkIsWUFBSSxDQUFDLFlBQVksV0FBVyxLQUFLLENBQUMsY0FBYyxXQUFXO0FBQ3ZELGdCQUFNLElBQUksVUFBUztBQUN2QixrQ0FBMEIsYUFBYSxlQUFlLFFBQVEsV0FBVztBQUFBLE1BQzVFO0FBQ0QsYUFBTztBQUFBLElBQ1Y7QUFDRCxhQUFTLFlBQVksUUFBUTtBQXdDN0IsYUFBUyxlQUFlLGFBQWEsZUFBZSxRQUFRLGFBQWE7QUFDckUsVUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixjQUFNLElBQUksVUFBUztBQUN2QixVQUFJLENBQUMsWUFBWSxXQUFXO0FBQ3hCLHNCQUFjLGNBQWMsV0FBVztBQUMzQyxhQUFPLDBCQUEwQixhQUFhLGVBQWUsUUFBUSxXQUFXO0FBQUEsSUFDbkY7QUFDRCxhQUFTLGtCQUFrQixjQUFjO0FBbUN6QyxhQUFTLFlBQVksYUFBYSxRQUFRLGFBQWE7QUFDbkQsVUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixjQUFNLElBQUksVUFBUztBQUN2QixVQUFJLENBQUMsWUFBWSxXQUFXO0FBQ3hCLHNCQUFjLGNBQWMsV0FBVztBQUMzQyxhQUFPLG9CQUFvQixhQUFhLFFBQVEsV0FBVztBQUFBLElBQzlEO0FBQ0QsYUFBUyxlQUFlLFdBQVc7QUFtQ25DLGFBQVMsZUFBZSxhQUFhLFFBQVEsYUFBYTtBQUN0RCxVQUFJLENBQUMsU0FBUyxNQUFNO0FBQ2hCLGNBQU0sSUFBSSxVQUFTO0FBQ3ZCLFVBQUksQ0FBQyxZQUFZLFdBQVc7QUFDeEIsc0JBQWMsY0FBYyxXQUFXO0FBQzNDLGFBQU8sdUJBQXVCLGFBQWEsUUFBUSxXQUFXO0FBQUEsSUFDakU7QUFDRCxhQUFTLGtCQUFrQixjQUFjO0FBbUN6QyxhQUFTLFlBQVksYUFBYSxRQUFRLGFBQWE7QUFDbkQsVUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixjQUFNLElBQUksVUFBUztBQUN2QixVQUFJLENBQUMsWUFBWSxXQUFXO0FBQ3hCLHNCQUFjLGNBQWMsV0FBVztBQUMzQyxhQUFPLG9CQUFvQixhQUFhLFFBQVEsV0FBVztBQUFBLElBQzlEO0FBQ0QsYUFBUyxlQUFlLFdBQVc7QUFtQ25DLGFBQVMsZUFBZSxhQUFhLFFBQVEsYUFBYTtBQUN0RCxVQUFJLENBQUMsU0FBUyxNQUFNO0FBQ2hCLGNBQU0sSUFBSSxVQUFTO0FBQ3ZCLFVBQUksQ0FBQyxZQUFZLFdBQVc7QUFDeEIsc0JBQWMsY0FBYyxXQUFXO0FBQzNDLGFBQU8sdUJBQXVCLGFBQWEsUUFBUSxXQUFXO0FBQUEsSUFDakU7QUFDRCxhQUFTLGtCQUFrQixjQUFjO0FBa0N6QyxhQUFTLGdCQUFnQixRQUFRLGFBQWE7QUFDMUMsVUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixjQUFNLElBQUksVUFBUztBQUN2QixVQUFJLENBQUMsWUFBWSxXQUFXO0FBQ3hCLHNCQUFjLGNBQWMsV0FBVztBQUMzQyxhQUFPLHFCQUFxQixRQUFRLFdBQVc7QUFBQSxJQUNsRDtBQUNELGFBQVMsbUJBQW1CLGVBQWU7QUFrQzNDLGFBQVMsbUJBQW1CLFFBQVEsYUFBYTtBQUM3QyxVQUFJLENBQUMsU0FBUyxNQUFNO0FBQ2hCLGNBQU0sSUFBSSxVQUFTO0FBQ3ZCLFVBQUksQ0FBQyxZQUFZLFdBQVc7QUFDeEIsc0JBQWMsY0FBYyxXQUFXO0FBQzNDLGFBQU8sd0JBQXdCLFFBQVEsV0FBVztBQUFBLElBQ3JEO0FBQ0QsYUFBUyxzQkFBc0Isa0JBQWtCO0FBbUNqRCxhQUFTLGVBQWUsYUFBYSxRQUFRLGFBQWE7QUFDdEQsVUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixjQUFNLElBQUksVUFBUztBQUN2QixVQUFJLENBQUMsWUFBWSxXQUFXO0FBQ3hCLHNCQUFjLGNBQWMsV0FBVztBQUMzQyxVQUFJLGNBQWM7QUFBQSxRQUF1QjtBQUFBLFFBQVE7QUFBQTtBQUFBLFFBQXdCO0FBQUEsTUFBSztBQUM5RSxVQUFJLFlBQVksV0FBVztBQUN2QixlQUFPO0FBQ1gsVUFBSSxDQUFDLFlBQVksT0FBTyxXQUFXO0FBQy9CLGVBQU87QUFDWCxVQUFJLFlBQVksT0FBTztBQUNuQixlQUFPO0FBQ1gsVUFBSSxpQkFBaUJBLFVBQVMsSUFBSSxNQUFNO0FBQ3hDLHFCQUFlLE9BQU8sV0FBVztBQUNqQyxVQUFJLGVBQWUsT0FBTztBQUN0QixlQUFPO0FBQ1gsTUFBQUEsVUFBUyxPQUFPLE1BQU07QUFDdEIsYUFBTztBQUFBLElBQ1Y7QUFDRCxhQUFTLGtCQUFrQixjQUFjO0FBQ3pDLGFBQVMsb0JBQW9CLFlBQVksUUFBUTtBQUM3QyxlQUFTLElBQUksV0FBVyxTQUFTLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUM3QyxZQUFJLFlBQVksV0FBVyxDQUFDO0FBQzVCLFlBQUksWUFBWSxVQUFVLE1BQU07QUFDaEMsWUFBSSxDQUFDLFlBQVksU0FBUyxLQUFLLENBQUMsT0FBTyxTQUFTLEdBQUc7QUFDL0MsY0FBSSxDQUFDLGNBQWMsU0FBUztBQUN4QixrQkFBTSxJQUFJLFVBQVM7QUFDdkIsbUJBQVM7QUFBQSxRQUNaO0FBQUEsTUFDSjtBQUNELGFBQU87QUFBQSxJQUNWO0FBQ0QsYUFBUyxpQkFBaUIsWUFBWSxRQUFRLGFBQWEsWUFBWTtBQUNuRSxlQUFTLElBQUksV0FBVyxTQUFTLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUM3QyxZQUFJLFlBQVksV0FBVyxDQUFDO0FBQzVCLFlBQUksWUFBWSxVQUFVLFFBQVEsYUFBYSxVQUFVO0FBQ3pELFlBQUksQ0FBQyxZQUFZLFNBQVMsS0FBSyxDQUFDLE9BQU8sU0FBUyxHQUFHO0FBQy9DLGNBQUksQ0FBQyxTQUFTLFNBQVM7QUFDbkIsa0JBQU0sSUFBSSxVQUFTO0FBQ3ZCLHVCQUFhO0FBQUEsUUFDaEI7QUFBQSxNQUNKO0FBQ0QsYUFBTztBQUFBLElBQ1Y7QUFDRCxhQUFTLHVCQUF1QixHQUFHQyxJQUFHLFFBQVE7QUFDMUMsVUFBSSxpQkFBaUJELFVBQVMsSUFBSSxDQUFDO0FBQ25DLFVBQUksWUFBWSxjQUFjLEdBQUc7QUFDN0IsWUFBSSxDQUFDO0FBQ0QsaUJBQU87QUFDWCx5QkFBaUIsSUFBSTtBQUNyQixRQUFBQSxVQUFTLElBQUksR0FBRyxjQUFjO0FBQUEsTUFDakM7QUFDRCxVQUFJLGNBQWMsZUFBZSxJQUFJQyxFQUFDO0FBQ3RDLFVBQUksWUFBWSxXQUFXLEdBQUc7QUFDMUIsWUFBSSxDQUFDO0FBQ0QsaUJBQU87QUFDWCxzQkFBYyxJQUFJO0FBQ2xCLHVCQUFlLElBQUlBLElBQUcsV0FBVztBQUFBLE1BQ3BDO0FBQ0QsYUFBTztBQUFBLElBQ1Y7QUFHRCxhQUFTLG9CQUFvQixhQUFhLEdBQUdBLElBQUc7QUFDNUMsVUFBSUMsVUFBUyx1QkFBdUIsYUFBYSxHQUFHRCxFQUFDO0FBQ3JELFVBQUlDO0FBQ0EsZUFBTztBQUNYLFVBQUksU0FBUyx1QkFBdUIsQ0FBQztBQUNyQyxVQUFJLENBQUMsT0FBTyxNQUFNO0FBQ2QsZUFBTyxvQkFBb0IsYUFBYSxRQUFRRCxFQUFDO0FBQ3JELGFBQU87QUFBQSxJQUNWO0FBR0QsYUFBUyx1QkFBdUIsYUFBYSxHQUFHQSxJQUFHO0FBQy9DLFVBQUksY0FBYztBQUFBLFFBQXVCO0FBQUEsUUFBR0E7QUFBQTtBQUFBLFFBQWM7QUFBQSxNQUFLO0FBQy9ELFVBQUksWUFBWSxXQUFXO0FBQ3ZCLGVBQU87QUFDWCxhQUFPLFVBQVUsWUFBWSxJQUFJLFdBQVcsQ0FBQztBQUFBLElBQ2hEO0FBR0QsYUFBUyxvQkFBb0IsYUFBYSxHQUFHQSxJQUFHO0FBQzVDLFVBQUlDLFVBQVMsdUJBQXVCLGFBQWEsR0FBR0QsRUFBQztBQUNyRCxVQUFJQztBQUNBLGVBQU8sdUJBQXVCLGFBQWEsR0FBR0QsRUFBQztBQUNuRCxVQUFJLFNBQVMsdUJBQXVCLENBQUM7QUFDckMsVUFBSSxDQUFDLE9BQU8sTUFBTTtBQUNkLGVBQU8sb0JBQW9CLGFBQWEsUUFBUUEsRUFBQztBQUNyRCxhQUFPO0FBQUEsSUFDVjtBQUdELGFBQVMsdUJBQXVCLGFBQWEsR0FBR0EsSUFBRztBQUMvQyxVQUFJLGNBQWM7QUFBQSxRQUF1QjtBQUFBLFFBQUdBO0FBQUE7QUFBQSxRQUFjO0FBQUEsTUFBSztBQUMvRCxVQUFJLFlBQVksV0FBVztBQUN2QixlQUFPO0FBQ1gsYUFBTyxZQUFZLElBQUksV0FBVztBQUFBLElBQ3JDO0FBR0QsYUFBUywwQkFBMEIsYUFBYSxlQUFlLEdBQUdBLElBQUc7QUFDakUsVUFBSSxjQUFjO0FBQUEsUUFBdUI7QUFBQSxRQUFHQTtBQUFBO0FBQUEsUUFBYztBQUFBLE1BQUk7QUFDOUQsa0JBQVksSUFBSSxhQUFhLGFBQWE7QUFBQSxJQUM3QztBQUdELGFBQVMscUJBQXFCLEdBQUdBLElBQUc7QUFDaEMsVUFBSSxVQUFVLHdCQUF3QixHQUFHQSxFQUFDO0FBQzFDLFVBQUksU0FBUyx1QkFBdUIsQ0FBQztBQUNyQyxVQUFJLFdBQVc7QUFDWCxlQUFPO0FBQ1gsVUFBSSxhQUFhLHFCQUFxQixRQUFRQSxFQUFDO0FBQy9DLFVBQUksV0FBVyxVQUFVO0FBQ3JCLGVBQU87QUFDWCxVQUFJLFFBQVEsVUFBVTtBQUNsQixlQUFPO0FBQ1gsVUFBSSxNQUFNLElBQUk7QUFDZCxVQUFJLE9BQU8sQ0FBQTtBQUNYLGVBQVMsS0FBSyxHQUFHLFlBQVksU0FBUyxLQUFLLFVBQVUsUUFBUSxNQUFNO0FBQy9ELFlBQUksTUFBTSxVQUFVLEVBQUU7QUFDdEIsWUFBSSxTQUFTLElBQUksSUFBSSxHQUFHO0FBQ3hCLFlBQUksQ0FBQyxRQUFRO0FBQ1QsY0FBSSxJQUFJLEdBQUc7QUFDWCxlQUFLLEtBQUssR0FBRztBQUFBLFFBQ2hCO0FBQUEsTUFDSjtBQUNELGVBQVNFLE1BQUssR0FBRyxlQUFlLFlBQVlBLE1BQUssYUFBYSxRQUFRQSxPQUFNO0FBQ3hFLFlBQUksTUFBTSxhQUFhQSxHQUFFO0FBQ3pCLFlBQUksU0FBUyxJQUFJLElBQUksR0FBRztBQUN4QixZQUFJLENBQUMsUUFBUTtBQUNULGNBQUksSUFBSSxHQUFHO0FBQ1gsZUFBSyxLQUFLLEdBQUc7QUFBQSxRQUNoQjtBQUFBLE1BQ0o7QUFDRCxhQUFPO0FBQUEsSUFDVjtBQUdELGFBQVMsd0JBQXdCLEdBQUdGLElBQUc7QUFDbkMsVUFBSSxPQUFPLENBQUE7QUFDWCxVQUFJLGNBQWM7QUFBQSxRQUF1QjtBQUFBLFFBQUdBO0FBQUE7QUFBQSxRQUFjO0FBQUEsTUFBSztBQUMvRCxVQUFJLFlBQVksV0FBVztBQUN2QixlQUFPO0FBQ1gsVUFBSSxVQUFVLFlBQVk7QUFDMUIsVUFBSUcsWUFBVyxZQUFZLE9BQU87QUFDbEMsVUFBSUMsS0FBSTtBQUNSLGFBQU8sTUFBTTtBQUNULFlBQUksT0FBTyxhQUFhRCxTQUFRO0FBQ2hDLFlBQUksQ0FBQyxNQUFNO0FBQ1AsZUFBSyxTQUFTQztBQUNkLGlCQUFPO0FBQUEsUUFDVjtBQUNELFlBQUksWUFBWSxjQUFjLElBQUk7QUFDbEMsWUFBSTtBQUNBLGVBQUtBLEVBQUMsSUFBSTtBQUFBLFFBQ2IsU0FDTSxHQUFQO0FBQ0ksY0FBSTtBQUNBLDBCQUFjRCxTQUFRO0FBQUEsVUFDekIsVUFDTztBQUNKLGtCQUFNO0FBQUEsVUFDVDtBQUFBLFFBQ0o7QUFDRCxRQUFBQztBQUFBLE1BQ0g7QUFBQSxJQUNKO0FBR0QsYUFBUyxLQUFLLEdBQUc7QUFDYixVQUFJLE1BQU07QUFDTixlQUFPO0FBQ1gsY0FBUSxPQUFPLEdBQUM7QUFBQSxRQUNaLEtBQUs7QUFBYSxpQkFBTztBQUFBLFFBQ3pCLEtBQUs7QUFBVyxpQkFBTztBQUFBLFFBQ3ZCLEtBQUs7QUFBVSxpQkFBTztBQUFBLFFBQ3RCLEtBQUs7QUFBVSxpQkFBTztBQUFBLFFBQ3RCLEtBQUs7QUFBVSxpQkFBTztBQUFBLFFBQ3RCLEtBQUs7QUFBVSxpQkFBTyxNQUFNLE9BQU8sSUFBZTtBQUFBLFFBQ2xEO0FBQVMsaUJBQU87QUFBQSxNQUNuQjtBQUFBLElBQ0o7QUFHRCxhQUFTLFlBQVksR0FBRztBQUNwQixhQUFPLE1BQU07QUFBQSxJQUNoQjtBQUdELGFBQVMsT0FBTyxHQUFHO0FBQ2YsYUFBTyxNQUFNO0FBQUEsSUFDaEI7QUFHRCxhQUFTLFNBQVMsR0FBRztBQUNqQixhQUFPLE9BQU8sTUFBTTtBQUFBLElBQ3ZCO0FBR0QsYUFBUyxTQUFTLEdBQUc7QUFDakIsYUFBTyxPQUFPLE1BQU0sV0FBVyxNQUFNLE9BQU8sT0FBTyxNQUFNO0FBQUEsSUFDNUQ7QUFLRCxhQUFTLFlBQVksT0FBTyxlQUFlO0FBQ3ZDLGNBQVEsS0FBSyxLQUFLLEdBQUM7QUFBQSxRQUNmLEtBQUs7QUFBbUIsaUJBQU87QUFBQSxRQUMvQixLQUFLO0FBQWMsaUJBQU87QUFBQSxRQUMxQixLQUFLO0FBQWlCLGlCQUFPO0FBQUEsUUFDN0IsS0FBSztBQUFnQixpQkFBTztBQUFBLFFBQzVCLEtBQUs7QUFBZ0IsaUJBQU87QUFBQSxRQUM1QixLQUFLO0FBQWdCLGlCQUFPO0FBQUEsTUFDL0I7QUFDRCxVQUFJLE9BQU8sa0JBQWtCLElBQWlCLFdBQVcsa0JBQWtCLElBQWlCLFdBQVc7QUFDdkcsVUFBSSxlQUFlLFVBQVUsT0FBTyxpQkFBaUI7QUFDckQsVUFBSSxpQkFBaUIsUUFBVztBQUM1QixZQUFJLFNBQVMsYUFBYSxLQUFLLE9BQU8sSUFBSTtBQUMxQyxZQUFJLFNBQVMsTUFBTTtBQUNmLGdCQUFNLElBQUksVUFBUztBQUN2QixlQUFPO0FBQUEsTUFDVjtBQUNELGFBQU8sb0JBQW9CLE9BQU8sU0FBUyxZQUFZLFdBQVcsSUFBSTtBQUFBLElBQ3pFO0FBR0QsYUFBUyxvQkFBb0IsR0FBRyxNQUFNO0FBQ2xDLFVBQUksU0FBUyxVQUFVO0FBQ25CLFlBQUksYUFBYSxFQUFFO0FBQ25CLFlBQUksV0FBVyxVQUFVLEdBQUc7QUFDeEIsY0FBSSxTQUFTLFdBQVcsS0FBSyxDQUFDO0FBQzlCLGNBQUksQ0FBQyxTQUFTLE1BQU07QUFDaEIsbUJBQU87QUFBQSxRQUNkO0FBQ0QsWUFBSSxVQUFVLEVBQUU7QUFDaEIsWUFBSSxXQUFXLE9BQU8sR0FBRztBQUNyQixjQUFJLFNBQVMsUUFBUSxLQUFLLENBQUM7QUFDM0IsY0FBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixtQkFBTztBQUFBLFFBQ2Q7QUFBQSxNQUNKLE9BQ0k7QUFDRCxZQUFJLFVBQVUsRUFBRTtBQUNoQixZQUFJLFdBQVcsT0FBTyxHQUFHO0FBQ3JCLGNBQUksU0FBUyxRQUFRLEtBQUssQ0FBQztBQUMzQixjQUFJLENBQUMsU0FBUyxNQUFNO0FBQ2hCLG1CQUFPO0FBQUEsUUFDZDtBQUNELFlBQUksYUFBYSxFQUFFO0FBQ25CLFlBQUksV0FBVyxVQUFVLEdBQUc7QUFDeEIsY0FBSSxTQUFTLFdBQVcsS0FBSyxDQUFDO0FBQzlCLGNBQUksQ0FBQyxTQUFTLE1BQU07QUFDaEIsbUJBQU87QUFBQSxRQUNkO0FBQUEsTUFDSjtBQUNELFlBQU0sSUFBSSxVQUFTO0FBQUEsSUFDdEI7QUFHRCxhQUFTLFVBQVUsVUFBVTtBQUN6QixhQUFPLENBQUMsQ0FBQztBQUFBLElBQ1o7QUFHRCxhQUFTLFNBQVMsVUFBVTtBQUN4QixhQUFPLEtBQUs7QUFBQSxJQUNmO0FBR0QsYUFBUyxjQUFjLFVBQVU7QUFDN0IsVUFBSSxNQUFNO0FBQUEsUUFBWTtBQUFBLFFBQVU7QUFBQTtBQUFBLE1BQUM7QUFDakMsVUFBSSxTQUFTLEdBQUc7QUFDWixlQUFPO0FBQ1gsYUFBTyxTQUFTLEdBQUc7QUFBQSxJQUN0QjtBQUtELGFBQVMsUUFBUSxVQUFVO0FBQ3ZCLGFBQU8sTUFBTSxVQUNQLE1BQU0sUUFBUSxRQUFRLElBQ3RCLG9CQUFvQixTQUNoQixvQkFBb0IsUUFDcEIsT0FBTyxVQUFVLFNBQVMsS0FBSyxRQUFRLE1BQU07QUFBQSxJQUMxRDtBQUdELGFBQVMsV0FBVyxVQUFVO0FBRTFCLGFBQU8sT0FBTyxhQUFhO0FBQUEsSUFDOUI7QUFHRCxhQUFTLGNBQWMsVUFBVTtBQUU3QixhQUFPLE9BQU8sYUFBYTtBQUFBLElBQzlCO0FBR0QsYUFBUyxjQUFjLFVBQVU7QUFDN0IsY0FBUSxLQUFLLFFBQVEsR0FBQztBQUFBLFFBQ2xCLEtBQUs7QUFBZ0IsaUJBQU87QUFBQSxRQUM1QixLQUFLO0FBQWdCLGlCQUFPO0FBQUEsUUFDNUI7QUFBUyxpQkFBTztBQUFBLE1BQ25CO0FBQUEsSUFDSjtBQUtELGFBQVMsVUFBVSxHQUFHSixJQUFHO0FBQ3JCLFVBQUksT0FBTyxFQUFFQSxFQUFDO0FBQ2QsVUFBSSxTQUFTLFVBQWEsU0FBUztBQUMvQixlQUFPO0FBQ1gsVUFBSSxDQUFDLFdBQVcsSUFBSTtBQUNoQixjQUFNLElBQUksVUFBUztBQUN2QixhQUFPO0FBQUEsSUFDVjtBQUdELGFBQVMsWUFBWSxLQUFLO0FBQ3RCLFVBQUksU0FBUyxVQUFVLEtBQUssY0FBYztBQUMxQyxVQUFJLENBQUMsV0FBVyxNQUFNO0FBQ2xCLGNBQU0sSUFBSSxVQUFTO0FBQ3ZCLFVBQUlHLFlBQVcsT0FBTyxLQUFLLEdBQUc7QUFDOUIsVUFBSSxDQUFDLFNBQVNBLFNBQVE7QUFDbEIsY0FBTSxJQUFJLFVBQVM7QUFDdkIsYUFBT0E7QUFBQSxJQUNWO0FBR0QsYUFBUyxjQUFjLFlBQVk7QUFDL0IsYUFBTyxXQUFXO0FBQUEsSUFDckI7QUFHRCxhQUFTLGFBQWFBLFdBQVU7QUFDNUIsVUFBSSxTQUFTQSxVQUFTO0FBQ3RCLGFBQU8sT0FBTyxPQUFPLFFBQVE7QUFBQSxJQUNoQztBQUdELGFBQVMsY0FBY0EsV0FBVTtBQUM3QixVQUFJLElBQUlBLFVBQVMsUUFBUTtBQUN6QixVQUFJO0FBQ0EsVUFBRSxLQUFLQSxTQUFRO0FBQUEsSUFDdEI7QUFLRCxhQUFTLHVCQUF1QixHQUFHO0FBQy9CLFVBQUksUUFBUSxPQUFPLGVBQWUsQ0FBQztBQUNuQyxVQUFJLE9BQU8sTUFBTSxjQUFjLE1BQU07QUFDakMsZUFBTztBQVFYLFVBQUksVUFBVTtBQUNWLGVBQU87QUFFWCxVQUFJRSxhQUFZLEVBQUU7QUFDbEIsVUFBSSxpQkFBaUJBLGNBQWEsT0FBTyxlQUFlQSxVQUFTO0FBQ2pFLFVBQUksa0JBQWtCLFFBQVEsbUJBQW1CLE9BQU87QUFDcEQsZUFBTztBQUVYLFVBQUksY0FBYyxlQUFlO0FBQ2pDLFVBQUksT0FBTyxnQkFBZ0I7QUFDdkIsZUFBTztBQUVYLFVBQUksZ0JBQWdCO0FBQ2hCLGVBQU87QUFFWCxhQUFPO0FBQUEsSUFDVjtBQUVELGFBQVMsb0JBQW9CO0FBQ3pCLFVBQUksZ0JBQWdCLENBQUE7QUFDcEIsVUFBSSxnQkFBZ0IsQ0FBQTtBQUNwQixVQUFJO0FBQUE7QUFBQSxRQUE2QixXQUFZO0FBQ3pDLG1CQUFTQyxhQUFZLE1BQU0sUUFBUSxVQUFVO0FBQ3pDLGlCQUFLLFNBQVM7QUFDZCxpQkFBSyxRQUFRO0FBQ2IsaUJBQUssVUFBVTtBQUNmLGlCQUFLLFlBQVk7QUFBQSxVQUNwQjtBQUNELFVBQUFBLGFBQVksVUFBVSxZQUFZLElBQUksV0FBWTtBQUFFLG1CQUFPO0FBQUE7QUFDM0QsVUFBQUEsYUFBWSxVQUFVLGNBQWMsSUFBSSxXQUFZO0FBQUUsbUJBQU87QUFBQTtBQUM3RCxVQUFBQSxhQUFZLFVBQVUsT0FBTyxXQUFZO0FBQ3JDLGdCQUFJLFFBQVEsS0FBSztBQUNqQixnQkFBSSxTQUFTLEtBQUssUUFBUSxLQUFLLE1BQU0sUUFBUTtBQUN6QyxrQkFBSSxTQUFTLEtBQUssVUFBVSxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUssUUFBUSxLQUFLLENBQUM7QUFDbEUsa0JBQUksUUFBUSxLQUFLLEtBQUssTUFBTSxRQUFRO0FBQ2hDLHFCQUFLLFNBQVM7QUFDZCxxQkFBSyxRQUFRO0FBQ2IscUJBQUssVUFBVTtBQUFBLGNBQ2xCLE9BQ0k7QUFDRCxxQkFBSztBQUFBLGNBQ1I7QUFDRCxxQkFBTyxFQUFFLE9BQU8sUUFBUSxNQUFNLE1BQUs7QUFBQSxZQUN0QztBQUNELG1CQUFPLEVBQUUsT0FBTyxRQUFXLE1BQU0sS0FBSTtBQUFBLFVBQ3pEO0FBQ2dCLFVBQUFBLGFBQVksVUFBVSxRQUFRLFNBQVVDLFFBQU87QUFDM0MsZ0JBQUksS0FBSyxVQUFVLEdBQUc7QUFDbEIsbUJBQUssU0FBUztBQUNkLG1CQUFLLFFBQVE7QUFDYixtQkFBSyxVQUFVO0FBQUEsWUFDbEI7QUFDRCxrQkFBTUE7QUFBQSxVQUMxQjtBQUNnQixVQUFBRCxhQUFZLFVBQVUsU0FBUyxTQUFVLE9BQU87QUFDNUMsZ0JBQUksS0FBSyxVQUFVLEdBQUc7QUFDbEIsbUJBQUssU0FBUztBQUNkLG1CQUFLLFFBQVE7QUFDYixtQkFBSyxVQUFVO0FBQUEsWUFDbEI7QUFDRCxtQkFBTyxFQUFFLE9BQWMsTUFBTSxLQUFJO0FBQUEsVUFDckQ7QUFDZ0IsaUJBQU9BO0FBQUEsUUFDVixFQUFBO0FBQUE7QUFDRDtBQUFBO0FBQUEsUUFBc0IsV0FBWTtBQUM5QixtQkFBU0UsT0FBTTtBQUNYLGlCQUFLLFFBQVE7QUFDYixpQkFBSyxVQUFVO0FBQ2YsaUJBQUssWUFBWTtBQUNqQixpQkFBSyxjQUFjO0FBQUEsVUFDdEI7QUFDRCxpQkFBTyxlQUFlQSxLQUFJLFdBQVcsUUFBUTtBQUFBLFlBQ3pDLEtBQUssV0FBWTtBQUFFLHFCQUFPLEtBQUssTUFBTTtBQUFBLFlBQVM7QUFBQSxZQUM5QyxZQUFZO0FBQUEsWUFDWixjQUFjO0FBQUEsVUFDbEMsQ0FBaUI7QUFDRCxVQUFBQSxLQUFJLFVBQVUsTUFBTSxTQUFVLEtBQUs7QUFBRSxtQkFBTyxLQUFLO0FBQUEsY0FBTTtBQUFBO0FBQUEsY0FBZ0I7QUFBQSxZQUFLLEtBQUs7QUFBQSxVQUFFO0FBQ25GLFVBQUFBLEtBQUksVUFBVSxNQUFNLFNBQVUsS0FBSztBQUMvQixnQkFBSSxRQUFRLEtBQUs7QUFBQSxjQUFNO0FBQUE7QUFBQSxjQUFnQjtBQUFBLFlBQUs7QUFDNUMsbUJBQU8sU0FBUyxJQUFJLEtBQUssUUFBUSxLQUFLLElBQUk7QUFBQSxVQUM5RDtBQUNnQixVQUFBQSxLQUFJLFVBQVUsTUFBTSxTQUFVLEtBQUssT0FBTztBQUN0QyxnQkFBSSxRQUFRLEtBQUs7QUFBQSxjQUFNO0FBQUE7QUFBQSxjQUFnQjtBQUFBLFlBQUk7QUFDM0MsaUJBQUssUUFBUSxLQUFLLElBQUk7QUFDdEIsbUJBQU87QUFBQSxVQUMzQjtBQUNnQixVQUFBQSxLQUFJLFVBQVUsU0FBUyxTQUFVLEtBQUs7QUFDbEMsZ0JBQUksUUFBUSxLQUFLO0FBQUEsY0FBTTtBQUFBO0FBQUEsY0FBZ0I7QUFBQSxZQUFLO0FBQzVDLGdCQUFJLFNBQVMsR0FBRztBQUNaLGtCQUFJLE9BQU8sS0FBSyxNQUFNO0FBQ3RCLHVCQUFTLElBQUksUUFBUSxHQUFHLElBQUksTUFBTSxLQUFLO0FBQ25DLHFCQUFLLE1BQU0sSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUM7QUFDaEMscUJBQUssUUFBUSxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztBQUFBLGNBQ3ZDO0FBQ0QsbUJBQUssTUFBTTtBQUNYLG1CQUFLLFFBQVE7QUFDYixrQkFBSSxRQUFRLEtBQUssV0FBVztBQUN4QixxQkFBSyxZQUFZO0FBQ2pCLHFCQUFLLGNBQWM7QUFBQSxjQUN0QjtBQUNELHFCQUFPO0FBQUEsWUFDVjtBQUNELG1CQUFPO0FBQUEsVUFDM0I7QUFDZ0IsVUFBQUEsS0FBSSxVQUFVLFFBQVEsV0FBWTtBQUM5QixpQkFBSyxNQUFNLFNBQVM7QUFDcEIsaUJBQUssUUFBUSxTQUFTO0FBQ3RCLGlCQUFLLFlBQVk7QUFDakIsaUJBQUssY0FBYztBQUFBLFVBQ3ZDO0FBQ2dCLFVBQUFBLEtBQUksVUFBVSxPQUFPLFdBQVk7QUFBRSxtQkFBTyxJQUFJLFlBQVksS0FBSyxPQUFPLEtBQUssU0FBU0MsT0FBTTtBQUFBLFVBQUU7QUFDNUYsVUFBQUQsS0FBSSxVQUFVLFNBQVMsV0FBWTtBQUFFLG1CQUFPLElBQUksWUFBWSxLQUFLLE9BQU8sS0FBSyxTQUFTLFFBQVE7QUFBQSxVQUFFO0FBQ2hHLFVBQUFBLEtBQUksVUFBVSxVQUFVLFdBQVk7QUFBRSxtQkFBTyxJQUFJLFlBQVksS0FBSyxPQUFPLEtBQUssU0FBUyxRQUFRO0FBQUEsVUFBRTtBQUNqRyxVQUFBQSxLQUFJLFVBQVUsWUFBWSxJQUFJLFdBQVk7QUFBRSxtQkFBTyxLQUFLLFFBQVM7QUFBQTtBQUNqRSxVQUFBQSxLQUFJLFVBQVUsY0FBYyxJQUFJLFdBQVk7QUFBRSxtQkFBTyxLQUFLLFFBQVM7QUFBQTtBQUNuRSxVQUFBQSxLQUFJLFVBQVUsUUFBUSxTQUFVLEtBQUtFLFNBQVE7QUFDekMsZ0JBQUksS0FBSyxjQUFjLEtBQUs7QUFDeEIsbUJBQUssY0FBYyxLQUFLLE1BQU0sUUFBUSxLQUFLLFlBQVksR0FBRztBQUFBLFlBQzdEO0FBQ0QsZ0JBQUksS0FBSyxjQUFjLEtBQUtBLFNBQVE7QUFDaEMsbUJBQUssY0FBYyxLQUFLLE1BQU07QUFDOUIsbUJBQUssTUFBTSxLQUFLLEdBQUc7QUFDbkIsbUJBQUssUUFBUSxLQUFLLE1BQVM7QUFBQSxZQUM5QjtBQUNELG1CQUFPLEtBQUs7QUFBQSxVQUNoQztBQUNnQixpQkFBT0Y7QUFBQSxRQUN2Qjs7QUFDWSxlQUFTQyxRQUFPLEtBQUtFLElBQUc7QUFDcEIsZUFBTztBQUFBLE1BQ1Y7QUFDRCxlQUFTLFNBQVNBLElBQUcsT0FBTztBQUN4QixlQUFPO0FBQUEsTUFDVjtBQUNELGVBQVMsU0FBUyxLQUFLLE9BQU87QUFDMUIsZUFBTyxDQUFDLEtBQUssS0FBSztBQUFBLE1BQ3JCO0FBQUEsSUFDSjtBQUVELGFBQVMsb0JBQW9CO0FBQ3pCO0FBQUE7QUFBQSxRQUFzQixXQUFZO0FBQzlCLG1CQUFTQyxPQUFNO0FBQ1gsaUJBQUssT0FBTyxJQUFJO1VBQ25CO0FBQ0QsaUJBQU8sZUFBZUEsS0FBSSxXQUFXLFFBQVE7QUFBQSxZQUN6QyxLQUFLLFdBQVk7QUFBRSxxQkFBTyxLQUFLLEtBQUs7QUFBQSxZQUFPO0FBQUEsWUFDM0MsWUFBWTtBQUFBLFlBQ1osY0FBYztBQUFBLFVBQ2xDLENBQWlCO0FBQ0QsVUFBQUEsS0FBSSxVQUFVLE1BQU0sU0FBVSxPQUFPO0FBQUUsbUJBQU8sS0FBSyxLQUFLLElBQUksS0FBSztBQUFBLFVBQUU7QUFDbkUsVUFBQUEsS0FBSSxVQUFVLE1BQU0sU0FBVSxPQUFPO0FBQUUsbUJBQU8sS0FBSyxLQUFLLElBQUksT0FBTyxLQUFLLEdBQUc7QUFBQSxVQUFLO0FBQ2hGLFVBQUFBLEtBQUksVUFBVSxTQUFTLFNBQVUsT0FBTztBQUFFLG1CQUFPLEtBQUssS0FBSyxPQUFPLEtBQUs7QUFBQSxVQUFFO0FBQ3pFLFVBQUFBLEtBQUksVUFBVSxRQUFRLFdBQVk7QUFBRSxpQkFBSyxLQUFLLE1BQU87QUFBQTtBQUNyRCxVQUFBQSxLQUFJLFVBQVUsT0FBTyxXQUFZO0FBQUUsbUJBQU8sS0FBSyxLQUFLLEtBQU07QUFBQTtBQUMxRCxVQUFBQSxLQUFJLFVBQVUsU0FBUyxXQUFZO0FBQUUsbUJBQU8sS0FBSyxLQUFLLE9BQVE7QUFBQTtBQUM5RCxVQUFBQSxLQUFJLFVBQVUsVUFBVSxXQUFZO0FBQUUsbUJBQU8sS0FBSyxLQUFLLFFBQVM7QUFBQTtBQUNoRSxVQUFBQSxLQUFJLFVBQVUsWUFBWSxJQUFJLFdBQVk7QUFBRSxtQkFBTyxLQUFLLEtBQU07QUFBQTtBQUM5RCxVQUFBQSxLQUFJLFVBQVUsY0FBYyxJQUFJLFdBQVk7QUFBRSxtQkFBTyxLQUFLLEtBQU07QUFBQTtBQUNoRSxpQkFBT0E7QUFBQSxRQUN2Qjs7SUFDUztBQUVELGFBQVMsd0JBQXdCO0FBQzdCLFVBQUksWUFBWTtBQUNoQixVQUFJLE9BQU8sUUFBUTtBQUNuQixVQUFJLFVBQVU7QUFDZDtBQUFBO0FBQUEsUUFBc0IsV0FBWTtBQUM5QixtQkFBU0MsV0FBVTtBQUNmLGlCQUFLLE9BQU87VUFDZjtBQUNELFVBQUFBLFNBQVEsVUFBVSxNQUFNLFNBQVUsUUFBUTtBQUN0QyxnQkFBSSxRQUFRO0FBQUEsY0FBd0I7QUFBQTtBQUFBLGNBQW1CO0FBQUEsWUFBSztBQUM1RCxtQkFBTyxVQUFVLFNBQVksUUFBUSxJQUFJLE9BQU8sS0FBSyxJQUFJLElBQUk7QUFBQSxVQUNqRjtBQUNnQixVQUFBQSxTQUFRLFVBQVUsTUFBTSxTQUFVLFFBQVE7QUFDdEMsZ0JBQUksUUFBUTtBQUFBLGNBQXdCO0FBQUE7QUFBQSxjQUFtQjtBQUFBLFlBQUs7QUFDNUQsbUJBQU8sVUFBVSxTQUFZLFFBQVEsSUFBSSxPQUFPLEtBQUssSUFBSSxJQUFJO0FBQUEsVUFDakY7QUFDZ0IsVUFBQUEsU0FBUSxVQUFVLE1BQU0sU0FBVSxRQUFRLE9BQU87QUFDN0MsZ0JBQUksUUFBUTtBQUFBLGNBQXdCO0FBQUE7QUFBQSxjQUFtQjtBQUFBLFlBQUk7QUFDM0Qsa0JBQU0sS0FBSyxJQUFJLElBQUk7QUFDbkIsbUJBQU87QUFBQSxVQUMzQjtBQUNnQixVQUFBQSxTQUFRLFVBQVUsU0FBUyxTQUFVLFFBQVE7QUFDekMsZ0JBQUksUUFBUTtBQUFBLGNBQXdCO0FBQUE7QUFBQSxjQUFtQjtBQUFBLFlBQUs7QUFDNUQsbUJBQU8sVUFBVSxTQUFZLE9BQU8sTUFBTSxLQUFLLElBQUksSUFBSTtBQUFBLFVBQzNFO0FBQ2dCLFVBQUFBLFNBQVEsVUFBVSxRQUFRLFdBQVk7QUFFbEMsaUJBQUssT0FBTztVQUNoQztBQUNnQixpQkFBT0E7QUFBQSxRQUN2Qjs7QUFDWSxlQUFTLGtCQUFrQjtBQUN2QixZQUFJO0FBQ0o7QUFDSSxnQkFBTSxnQkFBZ0I7ZUFDbkIsUUFBUSxJQUFJLE1BQU0sR0FBRztBQUM1QixhQUFLLEdBQUcsSUFBSTtBQUNaLGVBQU87QUFBQSxNQUNWO0FBQ0QsZUFBUyx3QkFBd0IsUUFBUSxRQUFRO0FBQzdDLFlBQUksQ0FBQyxPQUFPLEtBQUssUUFBUSxPQUFPLEdBQUc7QUFDL0IsY0FBSSxDQUFDO0FBQ0QsbUJBQU87QUFDWCxpQkFBTyxlQUFlLFFBQVEsU0FBUyxFQUFFLE9BQU8sUUFBUSxPQUFRLEVBQUEsQ0FBRTtBQUFBLFFBQ3JFO0FBQ0QsZUFBTyxPQUFPLE9BQU87QUFBQSxNQUN4QjtBQUNELGVBQVMsZ0JBQWdCLFFBQVEsTUFBTTtBQUNuQyxpQkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUU7QUFDeEIsaUJBQU8sQ0FBQyxJQUFJLEtBQUssT0FBUSxJQUFHLE1BQU87QUFDdkMsZUFBTztBQUFBLE1BQ1Y7QUFDRCxlQUFTLGVBQWUsTUFBTTtBQUMxQixZQUFJLE9BQU8sZUFBZSxZQUFZO0FBQ2xDLGNBQUksT0FBTyxXQUFXO0FBQ2xCLG1CQUFPLE9BQU8sZ0JBQWdCLElBQUksV0FBVyxJQUFJLENBQUM7QUFDdEQsY0FBSSxPQUFPLGFBQWE7QUFDcEIsbUJBQU8sU0FBUyxnQkFBZ0IsSUFBSSxXQUFXLElBQUksQ0FBQztBQUN4RCxpQkFBTyxnQkFBZ0IsSUFBSSxXQUFXLElBQUksR0FBRyxJQUFJO0FBQUEsUUFDcEQ7QUFDRCxlQUFPLGdCQUFnQixJQUFJLE1BQU0sSUFBSSxHQUFHLElBQUk7QUFBQSxNQUMvQztBQUNELGVBQVMsYUFBYTtBQUNsQixZQUFJLE9BQU8sZUFBZSxTQUFTO0FBRW5DLGFBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQU87QUFDM0IsYUFBSyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksTUFBTztBQUMzQixZQUFJLFNBQVM7QUFDYixpQkFBUyxTQUFTLEdBQUcsU0FBUyxXQUFXLEVBQUUsUUFBUTtBQUMvQyxjQUFJLE9BQU8sS0FBSyxNQUFNO0FBQ3RCLGNBQUksV0FBVyxLQUFLLFdBQVcsS0FBSyxXQUFXO0FBQzNDLHNCQUFVO0FBQ2QsY0FBSSxPQUFPO0FBQ1Asc0JBQVU7QUFDZCxvQkFBVSxLQUFLLFNBQVMsRUFBRSxFQUFFLFlBQVc7QUFBQSxRQUMxQztBQUNELGVBQU87QUFBQSxNQUNWO0FBQUEsSUFDSjtBQUVELGFBQVMsZUFBZSxLQUFLO0FBQ3pCLFVBQUksS0FBSztBQUNULGFBQU8sSUFBSTtBQUNYLGFBQU87QUFBQSxJQUNWO0FBQUEsRUFDVCxDQUFLO0FBQ0wsR0FBR2pCLGNBQVlBLFlBQVUsQ0FBQSxFQUFHO0FDeG1DckIsTUFBTWtCLFlBQVU7QUFFaEIsTUFBTSxjQUFjO0FBRXBCLE1BQU0sYUFBYTtBQUVuQixNQUFNLHNCQUFzQjtBQUV0QixNQUFBLFNBQVMsT0FBTyxFQUFFLE9BQU8sT0FBTyxPQUFPLE9BQU8sSUFBSSxNQUFNO0FBRTlELE1BQU0sUUFBUTtBQUFBLEVBQ2pCLGdCQUFnQjtBQUFBLEVBQ2hCLGNBQWM7QUFBQSxFQUNkLGVBQWU7QUFBQSxFQUNmLGNBQWM7QUFBQSxFQUNkLG1CQUFtQjtBQUFBLEVBQ25CLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLGdCQUFnQjtBQUFBLEVBQ2hCLE9BQU87QUFBQSxFQUNQLGdCQUFnQjtBQUNwQjtBQ25Cc0IsZUFBQUMsVUFBUUMsTUFBSyxNQUFNO0FBQ3JDLE1BQUksVUFBVTtBQUNkLFFBQU0sTUFBTUEsTUFBSztBQUFBLElBQ2IsTUFBTSxLQUFLLFVBQVUsSUFBSTtBQUFBLElBQ3pCLFFBQVE7QUFBQSxJQUNSLFNBQVM7QUFBQSxNQUNMLGVBQWUsU0FBUyxPQUFTLEVBQUE7QUFBQSxJQUNyQztBQUFBLEVBQUEsQ0FDSCxFQUFFLEtBQUssU0FBVSxVQUFVO0FBQ3hCLGNBQVUsU0FBUztFQUFLLENBQzNCO0FBQ00sU0FBQTtBQUNYO0FBRUEsZUFBc0IsVUFBVSxVQUFVO0FBQ3RDLE1BQUksSUFBSSxNQUFNO0FBQ2QsU0FBTyxFQUFFLFNBQVMsSUFBSSxFQUFFLE9BQU87QUFDbkM7QUFFQSxlQUFzQixhQUFhLFNBQVNDLGdCQUFlLElBQUk7QUFDM0QsUUFBTUQsT0FBTTtBQUNaLFFBQU0sU0FBUyxJQUFJLElBQUksUUFBUSxHQUFHLEdBQUcsR0FBRztBQUN4QyxRQUFNLE9BQU87QUFBQSxJQUNULEtBQUssT0FBTyxhQUFhLElBQUksS0FBSztBQUFBLElBQ2xDLFNBQVMsT0FBTyxhQUFhLElBQUksSUFBSTtBQUFBLElBQ3JDLGNBQWNDO0FBQUFBLEVBQUE7QUFFbEIsU0FBTyxVQUFVRixVQUFRQyxNQUFLLElBQUksQ0FBQztBQUN2QztBQUVBLGVBQXNCLElBQUlFLE1BQUs7QUFDM0IsTUFBSSxVQUFVO0FBQUEsSUFDVixNQUFNQTtBQUFBQSxFQUFBO0FBRVYsTUFBSUYsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxPQUFPLENBQUM7QUFDMUM7QUFFQSxlQUFzQixZQUFZRSxNQUFLO0FBQy9CLE1BQUEsVUFBVSxFQUFFLE1BQU1BO0FBQ3RCLE1BQUlGLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssT0FBTyxDQUFDO0FBQzFDO0FBRXNCLGVBQUEsVUFBVSxZQUFZRyxPQUFNO0FBQzlDLGVBQWEsV0FBVyxRQUFRLE1BQU0sRUFBRSxFQUFFLFFBQVEsTUFBTSxFQUFFO0FBQzFELE1BQUksWUFBWSxvQ0FBb0M7QUFDaEQsTUFBQSxTQUFTLE1BQU0sSUFBSSxTQUFTO0FBQ2hDLE1BQUksU0FBUztBQUNiLE1BQUksUUFBUTtBQUNKLFFBQUE7QUFDQSxVQUFJLE9BQU8sQ0FBQyxFQUFFQSxLQUFJLEdBQUc7QUFDUixpQkFBQSxPQUFPLENBQUMsRUFBRUEsS0FBSTtBQUFBLE1BQ2hCLFdBQUEsT0FBTyxDQUFDLEVBQUUsU0FBUyxHQUFHO0FBQ3BCLGlCQUFBLE9BQU8sQ0FBQyxFQUFFLFNBQVM7QUFBQSxNQUFBLE9BQ3pCO0FBQ00saUJBQUE7QUFBQSxNQUNiO0FBQUEsYUFDSztBQUNJLGVBQUE7QUFBQSxJQUNiO0FBQUEsRUFDSjtBQUNPLFNBQUE7QUFDWDtBQUVBLGVBQXNCLGFBQWEsWUFBWTtBQUMzQyxNQUFJLE9BQU87QUFBQSxJQUNQLFVBQVU7QUFBQSxFQUFBO0FBRWQsTUFBSUgsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFFdkM7QUFFQSxlQUFzQixjQUFjLFlBQVk7QUFDNUMsTUFBSSxPQUFPO0FBQUEsSUFDUCxVQUFVO0FBQUEsRUFBQTtBQUVkLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBRXNCLGVBQUEsZUFBZSxZQUFZLGlCQUFpQjtBQUM5RCxNQUFJLE9BQU87QUFBQSxJQUNQLFVBQVU7QUFBQSxJQUNWLE1BQU07QUFBQSxFQUFBO0FBRVYsTUFBSUEsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFFdkM7QUFFQSxlQUFzQixlQUFlLGNBQWM7QUFDL0MsTUFBSSxPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsRUFBQTtBQUVWLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBRUEsZUFBc0IsZUFBZSxZQUFZO0FBQ3pDLE1BQUEsT0FBTyxFQUFFLFVBQVU7QUFDdkIsTUFBSUEsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFFdkM7QUFFQSxlQUFzQixnQkFBZ0IsWUFBWTtBQUMxQyxNQUFBLE9BQU8sRUFBRSxVQUFVO0FBQ3ZCLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBRUEsZUFBc0IsZ0JBQWdCLFlBQVk7QUFDMUMsTUFBQSxPQUFPLEVBQUUsVUFBVTtBQUN2QixNQUFJQSxPQUFNO0FBQ1YsU0FBTyxVQUFVRCxVQUFRQyxNQUFLLElBQUksQ0FBQztBQUV2QztBQUVzQixlQUFBLFVBQVUsWUFBWSxNQUFNLE9BQU87QUFDckQsTUFBSSxPQUFPO0FBQUEsSUFDUCxVQUFVO0FBQUEsSUFDVjtBQUFBLElBQ0E7QUFBQSxFQUFBO0FBRUosTUFBSUEsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFFdkM7QUFFc0IsZUFBQSxVQUFVLFlBQVksTUFBTTtBQUM5QyxNQUFJLE9BQU87QUFBQSxJQUNQLFVBQVU7QUFBQSxJQUNWO0FBQUEsRUFBQTtBQUVKLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBRUEsZUFBc0IsUUFBUSxlQUFlLFNBQVMsa0JBQWtCLFlBQVk7QUFDaEYsTUFBSSxPQUFPO0FBQUEsSUFDUCxjQUFjO0FBQUEsSUFDZCxVQUFVO0FBQUEsSUFDVixZQUFZO0FBQUEsSUFDWixRQUFRO0FBQUEsRUFBQTtBQUVaLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBRXNCLGVBQUEsZUFBZSxZQUFZLE1BQU07QUFDbkQsTUFBSSxPQUFPO0FBQUEsSUFDUCxVQUFVO0FBQUEsSUFDVixNQUFNO0FBQUEsRUFBQTtBQUVWLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBRUEsZUFBc0IsYUFBYSxJQUFJO0FBQ25DLE1BQUksT0FBTztBQUFBLElBQ1AsSUFBSTtBQUFBLEVBQUE7QUFFUixNQUFJQSxPQUFNO0FBQ1YsU0FBTyxVQUFVRCxVQUFRQyxNQUFLLElBQUksQ0FBQztBQUN2QztBQUlBLGVBQXNCLGNBQWMsU0FBUztBQUN6QyxNQUFJLE9BQU87QUFBQSxJQUNQLElBQUk7QUFBQSxFQUFBO0FBRVIsTUFBSUEsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFFQSxlQUFzQixhQUFhLFNBQVM7QUFDeEMsTUFBSSxZQUFZLG1DQUFtQztBQUMvQyxNQUFBLE9BQU8sTUFBTSxJQUFJLFNBQVM7QUFDOUIsU0FBTyxLQUFLLENBQUM7QUFDakI7QUFFQSxlQUFzQixpQkFBaUIsU0FBUztBQUM1QyxRQUFNLE9BQU87QUFBQSxJQUNULElBQUk7QUFBQSxFQUFBO0FBRVIsUUFBTUEsT0FBTTtBQUNaLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFFQSxlQUFzQixtQkFBbUIsSUFBSTtBQUN6QyxRQUFNLE9BQU87QUFBQSxJQUNULElBQUk7QUFBQSxFQUFBO0FBRVIsUUFBTUEsT0FBTTtBQUNaLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFFc0IsZUFBQSxjQUFjLFNBQVMsT0FBTztBQUNoRCxNQUFJQSxPQUFNO0FBQ0gsU0FBQTtBQUFBLElBQ0hELFVBQVFDLE1BQUs7QUFBQSxNQUNULElBQUk7QUFBQSxNQUNKO0FBQUEsSUFBQSxDQUNIO0FBQUEsRUFBQTtBQUVUO0FBRUEsZUFBc0IsZ0JBQWdCLE9BQU87QUFDekMsTUFBSSxPQUFPO0FBQUEsSUFDUCxJQUFJO0FBQUEsRUFBQTtBQUVSLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBRUEsZUFBc0IsY0FBYyxPQUFPO0FBQ3ZDLE1BQUksT0FBTztBQUFBLElBQ1AsSUFBSTtBQUFBLEVBQUE7QUFFUixNQUFJQSxPQUFNO0FBQ1YsU0FBTyxVQUFVRCxVQUFRQyxNQUFLLElBQUksQ0FBQztBQUN2QztBQUVBLGVBQXNCLGVBQWUsTUFBTTtBQUN2QyxNQUFJLE9BQU87QUFBQSxJQUNQO0FBQUEsRUFBQTtBQUVKLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBRXZDO0FBVUEsZUFBc0IsWUFBWUksS0FBSTtBQUNsQyxNQUFJLE9BQU87QUFBQSxJQUNQLElBQUFBO0FBQUEsSUFDQSxXQUFXO0FBQUEsSUFDWCxHQUFHO0FBQUEsSUFDSCxJQUFJO0FBQUEsRUFBQTtBQUVSLE1BQUlKLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBRXNCLGVBQUEsaUJBQWlCLFlBQVlFLE1BQUs7QUFDcEQsTUFBSSxPQUFPO0FBQUEsSUFDUCxNQUFNQTtBQUFBQSxJQUNOLFlBQVk7QUFBQSxFQUFBO0FBRWhCLE1BQUlGLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBQ0EsZUFBc0IsT0FBT0ksS0FBSTtBQUM3QixNQUFJLE9BQU87QUFBQSxJQUNQLElBQUFBO0FBQUEsSUFDQSxHQUFHO0FBQUEsSUFDSCxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsRUFBQTtBQUVWLE1BQUlKLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBQ0EsZUFBc0IsY0FBY0ksS0FBSTtBQUNwQyxNQUFJLE9BQU87QUFBQSxJQUNQLElBQUFBO0FBQUEsSUFDQSxHQUFHO0FBQUEsSUFDSCxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsRUFBQTtBQUVWLE1BQUlKLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBQ0EsZUFBc0IsU0FBUztBQUMzQixNQUFJLE9BQU8sQ0FBQTtBQUNYLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBQ0EsZUFBc0IsY0FBY1osSUFBR2dCLEtBQUksTUFBTSxPQUFPO0FBQ3BELE1BQUksT0FBTztBQUFBLElBQ1AsSUFBQUE7QUFBQSxJQUNBLEdBQUFoQjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFBQTtBQUVKLE1BQUlZLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBQ3NCLGVBQUEsU0FBU1osSUFBRyxNQUFNLE9BQU87QUFDM0MsTUFBSSxPQUFPO0FBQUEsSUFDUCxHQUFBQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFBQTtBQUVKLE1BQUlZLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBRUEsZUFBc0IsV0FBV1osSUFBRztBQUNoQyxNQUFJLE9BQU87QUFBQSxJQUNQLEdBQUFBO0FBQUEsRUFBQTtBQUVKLE1BQUlZLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBQ0EsZUFBc0IsWUFBWSxPQUFPO0FBQ3JDLE1BQUksT0FBTztBQUFBLElBQ1A7QUFBQSxFQUFBO0FBRUosTUFBSUEsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFDQSxlQUFzQixlQUFlWixJQUFHO0FBQ3BDLE1BQUksT0FBTztBQUFBLElBQ1AsR0FBQUE7QUFBQSxFQUFBO0FBRUosTUFBSVksT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFFc0IsZUFBQSxnQkFBZ0IsVUFBVSxNQUFNLFVBQVU7QUFDNUQsTUFBSSxPQUFPO0FBQUEsSUFDUDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFBQTtBQUVKLE1BQUlBLE9BQU07QUFDVixTQUFPLFVBQVVELFVBQVFDLE1BQUssSUFBSSxDQUFDO0FBQ3ZDO0FBRXNCLGVBQUEsa0JBQWtCSSxLQUFJLFlBQVksT0FBTztBQUMzRCxNQUFJSixPQUFNO0FBQ1YsTUFBSSxPQUFPO0FBQUEsSUFDUCxJQUFBSTtBQUFBLElBQ0E7QUFBQSxFQUFBO0FBRUosU0FBTyxVQUFVTCxVQUFRQyxNQUFLLElBQUksQ0FBQztBQUN2QztBQUVBLGVBQXNCLE9BQU8sTUFBTTtBQUMvQixNQUFJQSxPQUFNO0FBQ1YsU0FBTyxVQUFVRCxVQUFRQyxNQUFLLElBQUksQ0FBQztBQUN2QztBQUVzQixlQUFBLFlBQVksWUFBWSxVQUFVLE1BQU07QUFDMUQsTUFBSUEsT0FBTTtBQUNILFNBQUE7QUFBQSxJQUNIRDtBQUFBQSxNQUNLQyxPQUFNQTtBQUFBLE1BQ04sT0FBTztBQUFBLFFBQ0o7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFBQTtBQUVSO0FBRXNCLGVBQUEsYUFBYSxVQUFVLFVBQVUsTUFBTTtBQUN6RCxNQUFJQSxPQUFNO0FBQ0gsU0FBQTtBQUFBLElBQ0hEO0FBQUFBLE1BQ0tDLE9BQU1BO0FBQUEsTUFDTixPQUFPO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUFBO0FBRVI7QUFDc0IsZUFBQSxZQUFZLFVBQVUsVUFBVSxNQUFNO0FBQ3hELE1BQUlBLE9BQU07QUFDSCxTQUFBO0FBQUEsSUFDSEQ7QUFBQUEsTUFDS0MsT0FBTUE7QUFBQSxNQUNOLE9BQU87QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLEVBQUE7QUFFUjtBQUVzQixlQUFBLFlBQVlJLEtBQUksVUFBVSxNQUFNO0FBQ2xELE1BQUlKLE9BQU07QUFDSCxTQUFBO0FBQUEsSUFDSEQ7QUFBQUEsTUFDS0MsT0FBTUE7QUFBQSxNQUNOLE9BQU87QUFBQSxRQUNKLElBQUFJO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLEVBQUE7QUFFUjtBQUVBLGVBQXNCLFlBQVlBLEtBQUk7QUFDbEMsTUFBSUosT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxFQUFFLElBQUFJLElBQUEsQ0FBSSxDQUFDO0FBQ3pDO0FBRXNCLGVBQUEsVUFBVUEsS0FBWSxZQUFvQixVQUFrQjtBQUM5RSxNQUFJSixPQUFNO0FBQ0gsU0FBQTtBQUFBLElBQ0hELFVBQVFDLE1BQUssRUFBRSxJQUFBSSxLQUFRLFlBQXdCLFVBQW9CO0FBQUEsRUFBQTtBQUUzRTtBQUVBLGVBQXNCLGNBQWM7QUFDaEMsTUFBSUosT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFFc0IsZUFBQSxRQUFRLE1BQWMsT0FBd0IsUUFBUTtBQUNsRSxRQUFBLFdBQVcsTUFBTSxNQUFNLHFCQUFxQjtBQUFBLElBQzlDLFFBQVE7QUFBQSxJQUNSLFNBQVM7QUFBQSxNQUNMLGVBQWUsU0FBUyxPQUFTLEVBQUE7QUFBQSxJQUNyQztBQUFBLElBQ0EsTUFBTSxLQUFLLFVBQVU7QUFBQSxNQUNqQjtBQUFBLElBQUEsQ0FDSDtBQUFBLEVBQUEsQ0FDSjtBQUNHLE1BQUEsU0FBUyxXQUFXLEtBQUs7QUFDekIsUUFBSSxTQUFTLFFBQVE7QUFDVixhQUFBLE1BQU0sU0FBUztJQUMxQjtBQUNBLFFBQUksU0FBUyxRQUFRO0FBQ1QsY0FBQSxNQUFNLFNBQVMsS0FBQSxHQUFRO0FBQUEsSUFDbkM7QUFBQSxFQUNKO0FBQ08sU0FBQTtBQUNYO0FBRXNCLGVBQUEsUUFBUSxNQUFNLFVBQVUsUUFBUSxPQUFPLFVBQVUsS0FBSyxPQUFPO0FBQy9FLE1BQUksT0FBTyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUM7QUFDMUIsTUFBQSxPQUFPLElBQUksS0FBSyxDQUFDLElBQUksR0FBRyxLQUFLLE1BQU0sR0FBRyxFQUFFLElBQUEsQ0FBSztBQUM3QyxNQUFBLFdBQVcsSUFBSTtBQUNWLFdBQUEsT0FBTyxRQUFRLElBQUk7QUFDbkIsV0FBQSxPQUFPLFFBQVEsSUFBSTtBQUM1QixXQUFTLE9BQU8sU0FBUyxPQUFPLEtBQUssQ0FBQztBQUN0QyxXQUFTLE9BQU8sV0FBVyxPQUFPLE9BQU8sQ0FBQztBQUNwQyxRQUFBLFdBQVcsTUFBTSxNQUFNLHFCQUFxQjtBQUFBLElBQzlDLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLFNBQVM7QUFBQSxNQUNMLGVBQWUsU0FBUyxPQUFTLEVBQUE7QUFBQSxJQUNyQztBQUFBLEVBQUEsQ0FDSDtBQUNELE1BQUksU0FBUyxXQUFXO0FBQVksV0FBQSxNQUFNLFNBQVM7O0FBQ3ZDLFdBQUE7QUFDaEI7QUFFQSxlQUFzQixRQUFRLE1BQWM7QUFDbEMsUUFBQSxXQUFXLE1BQU0sTUFBTSxxQkFBcUI7QUFBQSxJQUM5QyxRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsTUFDTCxlQUFlLFNBQVMsT0FBUyxFQUFBO0FBQUEsSUFDckM7QUFBQSxJQUNBLE1BQU0sS0FBSyxVQUFVO0FBQUEsTUFDakI7QUFBQSxJQUFBLENBQ0g7QUFBQSxFQUFBLENBQ0o7QUFDRyxNQUFBLFNBQVMsV0FBVyxLQUFLO0FBQ2pCLFlBQUEsTUFBTSxTQUFTLEtBQUEsR0FBUTtBQUFBLEVBQ25DO0FBQ08sU0FBQTtBQUNYO0FBRUEsZUFBc0IsV0FBVyxNQUFNO0FBQzdCLFFBQUEsV0FBVyxNQUFNLE1BQU0sd0JBQXdCO0FBQUEsSUFDakQsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLE1BQ0wsZUFBZSxTQUFTLE9BQVMsRUFBQTtBQUFBLElBQ3JDO0FBQUEsSUFDQSxNQUFNLEtBQUssVUFBVTtBQUFBLE1BQ2pCO0FBQUEsSUFBQSxDQUNIO0FBQUEsRUFBQSxDQUNKO0FBQ0QsTUFBSSxTQUFTLFdBQVc7QUFBSztBQUFBO0FBQ2pCLFdBQUE7QUFDaEI7QUFFQSxNQUFNLFlBQVcsWUFBTyxVQUFQLG1CQUFjO0FBRS9CLGVBQXNCLFFBQVEsVUFBVSxNQUFNSyxRQUFPLE1BQU0sVUFBVSxLQUFNO0FBQ3ZFLFFBQU1MLE9BQU07QUFDWixRQUFNLE9BQU87QUFBQSxJQUNULEtBQUssVUFBVSxRQUFRLFFBQVEsS0FBSyxRQUFRLFFBQVFLO0FBQUEsSUFDcEQ7QUFBQSxFQUFBO0FBRUosU0FBTyxVQUFVTixVQUFRQyxNQUFLLElBQUksQ0FBQztBQUN2QztBQUVBLGVBQXNCLFdBQVcsVUFBVSxNQUFNSyxRQUFPLE1BQU0sVUFBVSxLQUFNO0FBQzFFLFFBQU1MLE9BQU07QUFDWixRQUFNLE9BQU87QUFBQSxJQUNULEtBQUssVUFBVSxRQUFRLFFBQVEsS0FBSyxRQUFRLFFBQVFLO0FBQUEsSUFDcEQ7QUFBQSxFQUFBO0FBRUosU0FBTyxVQUFVTixVQUFRQyxNQUFLLElBQUksQ0FBQztBQUN2QztBQUVzQixlQUFBLGNBQWMsS0FBYSxLQUFVO0FBQ3ZELFFBQU1BLE9BQU07QUFDWixRQUFNLE9BQU87QUFBQSxJQUNULEtBQUssUUFBUTtBQUFBLElBQ2I7QUFBQSxJQUNBO0FBQUEsRUFBQTtBQUVKLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFFQSxlQUFzQixrQkFBa0I7QUFDcEMsUUFBTUEsT0FBTTtBQUNaLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7QUFFQSxlQUFzQixZQUFZLE9BQWU7QUFDN0MsTUFBSUEsT0FBTTtBQUNWLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxFQUFDLFVBQVUsTUFBTSxDQUFBLENBQUM7QUFDcEQ7QUFFQSxlQUFzQixrQkFBa0I7QUFDcEMsUUFBTUEsT0FBTTtBQUNaLFNBQU8sVUFBVUQsVUFBUUMsTUFBSyxJQUFJLENBQUM7QUFDdkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xpQk8sTUFBTSxhQUFzQztBQUFBLEVBQy9DLFlBQW9CLFFBQTJCO0FBQTNCLFNBQUEsU0FBQTtBQUFBLEVBQTRCO0FBQUEsRUFFaEQsT0FBTztBQUNDLFFBQUEsS0FBSyxPQUFPLFNBQVMsU0FBUztBQUM5Qk0saUJBQXFCLE1BQU0sS0FBSyxPQUFPLFNBQVMsS0FBSyxPQUFPLE9BQU87QUFBQSxJQUFBLE9BQ2hFO0FBQ0hDLGNBQWtCLE1BQU0sS0FBSyxPQUFPLFNBQVMsS0FBSyxPQUFPLE9BQU87QUFBQSxJQUNwRTtBQUFBLEVBQ0o7QUFDSjtBQ2JBLElBQUksSUFBSSxPQUFPO0FBQ2YsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHQyxPQUFNLEtBQUssSUFBSSxFQUFFLEdBQUcsR0FBRyxFQUFFLFlBQVksTUFBSSxjQUFjLE1BQUksVUFBVSxNQUFJLE9BQU9BLEdBQUMsQ0FBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJQTtBQUM3RyxJQUFJYixNQUFJLENBQUMsR0FBRyxHQUFHYSxRQUFPLEVBQUUsR0FBRyxPQUFPLEtBQUssV0FBVyxJQUFJLEtBQUssR0FBR0EsRUFBQyxHQUFHQTtBQUNsRSxJQUFJLElBQUksT0FBTyxhQUFhLE1BQU0sYUFBYSxPQUFPLFNBQVMsTUFBTSxTQUFTLE9BQU8sU0FBUyxNQUFNLFNBQVMsT0FBTyxPQUFPLE1BQU0sT0FBTyxJQUFJLElBQUksQ0FBRSxHQUFFLElBQUk7QUFBQSxFQUN0SixJQUFJLFVBQVU7QUFDWixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsSUFBSSxRQUFRLEdBQUc7QUFDYixRQUFJO0FBQUEsRUFDTDtBQUNIO0FBQUEsQ0FDQyxTQUFTLEdBQUc7QUFDWCxHQUFDLFNBQVMsR0FBR0EsSUFBRztBQUNkLE1BQUUsVUFBVSxFQUFFLFVBQVVBLEdBQUMsSUFBSyxFQUFFLE1BQU1BO0VBQ3ZDLEdBQUUsR0FBRyxXQUFXO0FBQ2YsUUFBSSxJQUFJLFdBQVc7QUFBQSxJQUN2QixHQUFPQSxLQUFJLGFBQWEsSUFBSSxPQUFPLFdBQVdBLE1BQUssT0FBTyxPQUFPLGNBQWNBLE1BQUssa0JBQWtCLEtBQUssT0FBTyxVQUFVLFNBQVMsR0FBRyxJQUFJO0FBQUEsTUFDdEk7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDTjtBQUNJLGFBQVMsRUFBRUMsSUFBRyxHQUFHO0FBQ2YsVUFBSSxJQUFJQSxHQUFFLENBQUM7QUFDWCxVQUFJLE9BQU8sRUFBRSxRQUFRO0FBQ25CLGVBQU8sRUFBRSxLQUFLQSxFQUFDO0FBQ2pCLFVBQUk7QUFDRixlQUFPLFNBQVMsVUFBVSxLQUFLLEtBQUssR0FBR0EsRUFBQztBQUFBLE1BQ2hELFFBQVE7QUFDQSxlQUFPLFdBQVc7QUFDaEIsaUJBQU8sU0FBUyxVQUFVLE1BQU0sTUFBTSxHQUFHLENBQUNBLElBQUcsU0FBUyxDQUFDO0FBQUEsUUFDakU7QUFBQSxNQUNPO0FBQUEsSUFDRjtBQUNELGFBQVMsSUFBSTtBQUNYLGNBQVEsUUFBUSxRQUFRLElBQUksUUFBUSxRQUFRLElBQUksTUFBTSxTQUFTLFNBQVMsSUFBSSxTQUFTLFVBQVUsTUFBTSxNQUFNLFFBQVEsS0FBSyxDQUFDLFNBQVMsU0FBUyxDQUFDLElBQUksUUFBUSxTQUFTLFFBQVEsTUFBSztBQUFBLElBQy9LO0FBQ0QsYUFBUyxFQUFFQSxJQUFHO0FBQ1osYUFBT0EsT0FBTSxZQUFZQSxLQUFJLFFBQVEsT0FBTyxZQUFZRCxLQUFJLFFBQUtDLE9BQU0sV0FBVyxJQUFJLElBQUksUUFBUUEsRUFBQyxNQUFNLFNBQVMsRUFBRSxTQUFTQSxFQUFDLElBQUksUUFBUSxRQUFRLFNBQVMsRUFBRSxTQUFTLEtBQUssSUFBSTtBQUFBLElBQ2hMO0FBQ0QsYUFBUyxFQUFFQSxJQUFHLEdBQUc7QUFDZixlQUFTLElBQUksR0FBRyxJQUFJLEVBQUUsUUFBUSxLQUFLO0FBQ2pDLFlBQUksSUFBSSxFQUFFLENBQUM7QUFDWCxhQUFLLENBQUMsSUFBSSxJQUFJQSxLQUFJLElBQUksS0FBSyxjQUFjLEdBQUdBLElBQUcsQ0FBQztBQUFBLE1BQ2pEO0FBQ0QsV0FBSyxNQUFNLEtBQUs7QUFBQSxJQUNqQjtBQUNELGFBQVMsRUFBRUEsSUFBRyxHQUFHLEdBQUc7QUFDbEIsYUFBTyxXQUFXO0FBQ2hCLGVBQU8sWUFBWUQsT0FBTSxFQUFFLEtBQUssTUFBTSxHQUFHLENBQUMsR0FBRyxLQUFLQyxFQUFDLEVBQUUsTUFBTSxNQUFNLFNBQVM7QUFBQSxNQUNsRjtBQUFBLElBQ0s7QUFDRCxhQUFTLEVBQUVBLElBQUcsR0FBRyxHQUFHO0FBQ2xCLGFBQU8sRUFBRUEsRUFBQyxLQUFLLEVBQUUsTUFBTSxNQUFNLFNBQVM7QUFBQSxJQUN2QztBQUNELGFBQVMsRUFBRUEsSUFBRyxHQUFHLEdBQUc7QUFDbEIsVUFBSSxJQUFJLE1BQU07QUFDZCxVQUFJLEtBQUs7QUFDVCxVQUFJLElBQUk7QUFDUixhQUFPQSxNQUFLLFdBQVcsS0FBSyxNQUFNQSxLQUFJLE9BQU9BLE1BQUssYUFBYSxJQUFJO0FBQ25FLGVBQVMsRUFBRSxHQUFHO0FBQ1osWUFBSSxLQUFLLEVBQUUsQ0FBQyxLQUFLLFVBQVU7QUFDM0IsWUFBSSxFQUFFLE9BQU8sV0FBV0QsTUFBSyxDQUFDLElBQUk7QUFDaEMsY0FBSTtBQUNGLG1CQUFPLGFBQWEsQ0FBQyxJQUFJO0FBQ3pCO0FBQUEsVUFDWixRQUFZO0FBQUEsVUFDRDtBQUNELGNBQUk7QUFDRixtQkFBTyxTQUFTLFNBQVMsbUJBQW1CLENBQUMsSUFBSSxNQUFNLElBQUk7QUFBQSxVQUN2RSxRQUFZO0FBQUEsVUFDRDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0QsZUFBU3BCLEtBQUk7QUFDWCxZQUFJO0FBQ0osWUFBSSxFQUFFLE9BQU8sV0FBV29CLE1BQUssQ0FBQyxJQUFJO0FBQ2hDLGNBQUk7QUFDRixnQkFBSSxPQUFPLGFBQWEsQ0FBQztBQUFBLFVBQ3JDLFFBQVk7QUFBQSxVQUNEO0FBQ0QsY0FBSSxPQUFPLE1BQU1BO0FBQ2YsZ0JBQUk7QUFDRixrQkFBSSxJQUFJLE9BQU8sU0FBUyxRQUFRLElBQUksRUFBRTtBQUFBLGdCQUNwQyxtQkFBbUIsQ0FBQyxJQUFJO0FBQUEsY0FDeEM7QUFDYyxvQkFBTSxPQUFPLElBQUksV0FBVyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQUEsWUFDNUQsUUFBYztBQUFBLFlBQ0Q7QUFDSCxpQkFBTyxFQUFFLE9BQU8sQ0FBQyxNQUFNLFdBQVcsSUFBSSxTQUFTO0FBQUEsUUFDaEQ7QUFBQSxNQUNGO0FBQ0QsZUFBUyxJQUFJO0FBQ1gsWUFBSSxFQUFFLE9BQU8sV0FBV0EsTUFBSyxDQUFDLElBQUk7QUFDaEMsY0FBSTtBQUNGLG1CQUFPLGFBQWEsV0FBVyxDQUFDO0FBQ2hDO0FBQUEsVUFDWixRQUFZO0FBQUEsVUFDRDtBQUNELGNBQUk7QUFDRixtQkFBTyxTQUFTLFNBQVMsbUJBQW1CLENBQUMsSUFBSTtBQUFBLFVBQzdELFFBQVk7QUFBQSxVQUNEO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDRCxRQUFFLE9BQU9DLElBQUcsRUFBRSxTQUFTO0FBQUEsUUFDckIsT0FBTztBQUFBLFFBQ1AsT0FBTztBQUFBLFFBQ1AsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLFFBQ04sT0FBTztBQUFBLFFBQ1AsUUFBUTtBQUFBLE1BQ2hCLEdBQVMsRUFBRSxnQkFBZ0IsS0FBSyxHQUFHLEVBQUUsV0FBVyxXQUFXO0FBQ25ELGVBQU87QUFBQSxNQUNSLEdBQUUsRUFBRSxXQUFXLFNBQVMsR0FBRyxHQUFHO0FBQzdCLFlBQUksT0FBTyxLQUFLLFlBQVksRUFBRSxPQUFPLEVBQUUsWUFBVyxDQUFFLE1BQU0sV0FBVyxJQUFJLEVBQUUsT0FBTyxFQUFFLFlBQWEsQ0FBQSxJQUFJLE9BQU8sS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLEVBQUUsT0FBTyxRQUFRO0FBQzNKLGNBQUksSUFBSSxHQUFHLE1BQU0sU0FBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssR0FBRyxHQUFHQSxFQUFDLEdBQUcsT0FBTyxZQUFZRCxNQUFLLElBQUksRUFBRSxPQUFPO0FBQ2pGLG1CQUFPO0FBQUEsUUFDVjtBQUNDLGdCQUFNLCtDQUErQztBQUFBLE1BQy9ELEdBQVMsRUFBRSxrQkFBa0IsU0FBUyxHQUFHO0FBQ2pDLFlBQUksR0FBR3BCLFFBQU8sRUFBRSxTQUFTLEdBQUcsS0FBRTtBQUFBLE1BQ3RDLEdBQVMsRUFBRSxhQUFhLFdBQVc7QUFDM0IsVUFBRSxTQUFTLEdBQUcsS0FBRSxHQUFHLEVBQUM7QUFBQSxNQUM1QixHQUFTLEVBQUUsWUFBWSxTQUFTLEdBQUc7QUFDM0IsVUFBRSxTQUFTLEVBQUUsT0FBTyxPQUFPLENBQUM7QUFBQSxNQUNwQyxHQUFTLEVBQUUsYUFBYSxTQUFTLEdBQUc7QUFDNUIsVUFBRSxTQUFTLEVBQUUsT0FBTyxRQUFRLENBQUM7QUFBQSxNQUNyQztBQUNNLFVBQUksSUFBSUE7QUFDUixXQUFLLFNBQVMsSUFBSSxJQUFJLEVBQUUsU0FBUyxHQUFHLEtBQUU7QUFBQSxJQUN2QztBQUNELFFBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFBO0FBQ3JCLE1BQUUsWUFBWSxTQUFTLEdBQUc7QUFDeEIsVUFBSSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxNQUFNO0FBQ3hELGNBQU0sSUFBSSxVQUFVLGdEQUFnRDtBQUN0RSxVQUFJLElBQUksRUFBRSxDQUFDO0FBQ1gsYUFBTyxNQUFNLElBQUksRUFBRSxDQUFDLElBQUksSUFBSTtBQUFBLFFBQzFCO0FBQUEsUUFDQSxFQUFFLFNBQVU7QUFBQSxRQUNaLEVBQUU7QUFBQSxNQUNILElBQUc7QUFBQSxJQUNWO0FBQ0ksUUFBSSxJQUFJLE9BQU8sV0FBV29CLEtBQUksT0FBTyxNQUFNO0FBQzNDLFdBQU8sRUFBRSxhQUFhLFdBQVc7QUFDL0IsYUFBTyxPQUFPLFdBQVdBLE1BQUssT0FBTyxRQUFRLE1BQU0sT0FBTyxNQUFNLElBQUk7QUFBQSxJQUMxRSxHQUFPLEVBQUUsYUFBYSxXQUFXO0FBQzNCLGFBQU87QUFBQSxJQUNSLEdBQUUsRUFBRSxVQUFVLEdBQUc7QUFBQSxFQUN0QixDQUFHO0FBQ0gsR0FBRyxDQUFDO0FBQ0osSUFBSSxJQUFJLENBQUUsR0FBRSxJQUFJO0FBQUEsRUFDZCxJQUFJLFVBQVU7QUFDWixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsSUFBSSxRQUFRLEdBQUc7QUFDYixRQUFJO0FBQUEsRUFDTDtBQUNIO0FBQUEsQ0FDQyxTQUFTLEdBQUc7QUFDWCxHQUFDLFNBQVMsR0FBR0EsSUFBRztBQUNkLE1BQUUsVUFBVSxFQUFFLFVBQVVBLE9BQU0sRUFBRSxTQUFTQSxHQUFFLENBQUM7QUFBQSxFQUNoRCxHQUFLLEdBQUcsU0FBUyxHQUFHO0FBQ2hCLFFBQUlBLEtBQUksU0FBUyxHQUFHO0FBQ2xCLGVBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLEdBQUcsSUFBSSxHQUFHO0FBQzlDLGFBQUssS0FBSyxVQUFVLENBQUM7QUFDbkIsaUJBQU8sVUFBVSxlQUFlLEtBQUssVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUM7QUFDbkYsYUFBTztBQUFBLElBQ1IsR0FBRSxJQUFJO0FBQUEsTUFDTCxVQUFVO0FBQUEsTUFDVixnQkFBZ0IsU0FBUyxHQUFHO0FBQzFCLGVBQU8sRUFBRTtNQUNWO0FBQUEsTUFDRCxlQUFlLFNBQVMsR0FBRztBQUN6QixlQUFPLEtBQUs7QUFBQSxNQUNiO0FBQUEsTUFDRCxvQkFBb0IsU0FBUyxHQUFHO0FBQzlCLGVBQU8sRUFBRSxhQUFjLEVBQUMsUUFBUSwyQkFBMkIsSUFBSTtBQUFBLE1BQ2hFO0FBQUEsTUFDRCxRQUFRO0FBQUEsSUFDVCxHQUFFLEdBQUcsSUFBSSxDQUFFLEdBQUUsSUFBSSxTQUFTLEdBQUc7QUFDNUIsVUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ1gsY0FBTSxJQUFJLFVBQVUsK0JBQStCO0FBQ3JELFVBQUk7QUFBQSxJQUNWLEdBQU8sSUFBSSxTQUFTLEdBQUcsR0FBRztBQUNwQixVQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWCxjQUFNLElBQUksVUFBVSwwQkFBMEI7QUFDaEQsVUFBSSxJQUFJLEVBQUUsZUFBZSxJQUFJLEVBQUUsUUFBUSxJQUFJLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLEtBQUs7QUFDaEUsZUFBU0MsR0FBRSxHQUFHLEdBQUcsR0FBRztBQUNsQixZQUFJLElBQUksRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLEdBQUcsSUFBSSxFQUFFLFNBQVMsUUFBUSxJQUFJLE1BQU0sSUFBSXJCLEtBQUksRUFBRSxTQUFTLFFBQVEsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFLFNBQVMsUUFBUSxJQUFJLE1BQU07QUFDbEosZUFBTyxXQUFXO0FBQ2hCLG1CQUFTLElBQUksSUFBSSxJQUFJLFVBQVUsUUFBUSxJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUc7QUFDakUsY0FBRSxDQUFDLElBQUksVUFBVSxDQUFDO0FBQ3BCLGNBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHO0FBQ2QsZ0JBQUksSUFBSSxFQUFFLG1CQUFtQixJQUFJLEtBQUksQ0FBRSxHQUFHLElBQUksRUFBRSxlQUFlLENBQUMsR0FBRyxJQUFJLEVBQUUsY0FBYyxDQUFDO0FBQ3hGLGNBQUUsU0FBUyxLQUFLLEVBQUUsT0FBTyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEtBQUssRUFBRSxVQUFVLE1BQU0sSUFBSSxFQUFFLFFBQVEsTUFBTSxDQUFDLElBQUlBLE9BQU0sSUFBSSxFQUFFLFFBQVEsTUFBTSxDQUFDLElBQUksTUFBTSxJQUFJLEVBQUUsUUFBUSxNQUFNLENBQUMsS0FBSyxFQUFFLFVBQVUsT0FBTyxFQUFFLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztBQUFBLFVBQzlOO0FBQ0QsWUFBRSxNQUFNLFFBQVEsQ0FBQztBQUFBLFFBQzNCO0FBQUEsTUFDTztBQUNELGFBQU8sRUFBRSxDQUFDLE1BQU0sRUFBRSxnQkFBZ0JxQixLQUFJLElBQUksS0FBSyxDQUFFLEdBQUUsRUFBRSxhQUFhLEVBQUUsU0FBUyxTQUFTLEVBQUUsQ0FBQyxJQUFJRCxHQUFFLENBQUEsR0FBSSxHQUFHLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFRLENBQUUsR0FBRyxLQUFLLEVBQUU7QUFBQSxRQUN6STtBQUFBLE1BQ0QsR0FBRTtBQUFBLElBQ0osR0FBRSxJQUFJO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxPQUFPO0FBQUEsSUFDUixHQUFFO0FBQ0gsV0FBTyxNQUFNLElBQUksRUFBRSxRQUFRLEVBQUUsYUFBYSxXQUFXO0FBQ25ELGFBQU8sRUFBRSxXQUFXLE1BQU0sRUFBRSxTQUFTLElBQUk7QUFBQSxJQUMxQyxJQUFHO0FBQUEsRUFDUixDQUFHO0FBQ0gsR0FBRyxDQUFDO0FBQ0osTUFBTSxFQUFFO0FBQ1I7QUFDQWIsSUFBRSxHQUFHLGlCQUFpQixnQkFBZ0IsR0FBR0EsSUFBRSxHQUFHLGtCQUFrQixpQkFBaUI7QUFDakYsSUFBSSxJQUFxQixrQkFBQyxPQUFPLEVBQUUsa0JBQWtCLFNBQVMsRUFBRSxpQkFBaUIsUUFBUSxFQUFFLGlCQUFpQixRQUFRLEVBQUUsa0JBQWtCLFNBQVMsSUFBSSxLQUFLLENBQUEsQ0FBRTtBQUM1SixTQUFTLElBQUk7QUFDWCxRQUFNLElBQUksTUFBTTtBQUNoQixRQUFNLG9CQUFvQixDQUFDYSxJQUFHLE1BQU07QUFDcEMsUUFBTSxJQUFJLElBQUksTUFBSyxFQUFHLE1BQU0sTUFBTSxDQUFDO0FBQ25DLFNBQU8sTUFBTSxvQkFBb0IsR0FBRztBQUN0QztBQUNBLE1BQU0sRUFBRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT04sT0FBTyxrQkFBa0IsR0FBR0EsSUFBRztBQUM3QixXQUFPLEVBQUUsT0FBTyxLQUFLLENBQUMsRUFBRTtBQUFBLE1BQ3RCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxTQUFVLE1BQUtBO0FBQUEsSUFDakMsRUFBTSxDQUFDLENBQUM7QUFBQSxFQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJRCxPQUFPLFlBQVksR0FBRztBQUNwQixRQUFJLENBQUM7QUFDSDtBQUNGLFVBQU1BLEtBQUksRUFBRTtBQUFBLE1BQ1YsRUFBRTtBQUFBLE1BQ0YsRUFBRTtBQUFBLElBQ1IsR0FBTyxJQUFJLEVBQUU7QUFBQSxNQUNQO0FBQUEsTUFDQUEsR0FBRSxZQUFhO0FBQUEsSUFDckI7QUFDSSxXQUFPLEtBQUssUUFBUTtBQUFBLE1BQ2xCO0FBQUEsSUFDRCxHQUFFO0FBQUEsRUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUQsT0FBTyxhQUFhLEdBQUc7QUFDckIsUUFBSTtBQUNGLGFBQU8sRUFBRSxPQUFPLEVBQUUsY0FBYztBQUFBLEVBQ25DO0FBQ0g7QUFDQSxNQUFNLEVBQUU7QUFBQSxFQUNOLFlBQVksR0FBR0EsSUFBRyxHQUFHO0FBQ25CYixRQUFFLE1BQU0saUJBQWlCLFNBQVM7QUFDbENBLFFBQUUsTUFBTSxhQUFhLENBQUM7QUFRdEJBLFFBQUUsTUFBTSxhQUFhLENBQUNlLE9BQU07QUFDMUIsVUFBSUY7QUFDSixVQUFJRTtBQUNGLFFBQUFGLEtBQUlFO0FBQUEsV0FDRDtBQUNILGNBQU1DLEtBQUksS0FBSyxhQUFZLEdBQUlDLEtBQUksQ0FBRSxHQUFFQyxLQUFJO0FBQzNDLGlCQUFTLElBQUksR0FBRyxJQUFJRixHQUFFLFFBQVEsS0FBSztBQUNqQyxnQkFBTSxJQUFJQSxHQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsWUFBYSxLQUFJO0FBQ3ZDLGNBQUksSUFBSSxLQUFLLFlBQVk7QUFDdkI7QUFDRixnQkFBTSxJQUFJLElBQUksTUFBTSxFQUFFLGNBQWEsSUFBSyxNQUFNLEVBQUU7QUFDaEQsVUFBQUMsR0FBRSxLQUFLLENBQUM7QUFBQSxRQUNUO0FBQ0QsUUFBQUMsR0FBRSxTQUFTLE1BQU1MLEtBQUlJLEdBQUUsS0FBSyxNQUFNO0FBQUEsTUFDbkM7QUFDRCxjQUFRLENBQUNKLE1BQUtBLEdBQUUsS0FBSSxFQUFHLFdBQVcsT0FBT0EsS0FBSSxLQUFLLGdCQUFnQixFQUFFLFVBQVVBLEVBQUM7QUFBQSxJQUNyRixDQUFLO0FBQ0QsU0FBSyxZQUFZO0FBQ2pCLFFBQUk7QUFDSixRQUFJLElBQUksSUFBSSxJQUFJLEVBQUUsWUFBWSxDQUFDLEdBQUcsSUFBSSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsU0FBUyxDQUFDO0FBQ3pFLFVBQU0sSUFBSTtBQUFBLE1BQ1IsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFVO0FBQUEsTUFDekIsT0FBTyxDQUFDLE1BQU0sRUFBRSxTQUFVO0FBQUEsTUFDMUIsUUFBUSxDQUFDLE1BQU0sRUFBRSxTQUFVO0FBQUEsTUFDM0IsS0FBSyxDQUFDLE1BQU0sRUFBRSxTQUFVO0FBQUEsSUFDOUI7QUFDSSxNQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsTUFBTSxHQUFHO0FBQUEsTUFDbkIsT0FBTyxHQUFHLEdBQUcsR0FBRztBQUNkLGNBQU0sSUFBSSxDQUFDLE9BQU9BLE1BQUssRUFBRSxhQUFhLENBQUMsS0FBSyxTQUFTLEdBQUc7QUFDeEQsZ0JBQVEsRUFBRTtBQUFBLFVBQ1IsRUFBRSxLQUFLLEdBQUcsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLFNBQVUsSUFBRyxFQUFFLEtBQUssR0FBRztBQUFBLFFBQzFELEdBQVcsR0FBQztBQUFBLFVBQ0YsS0FBSyxFQUFFO0FBQ0wsY0FBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFlBQWEsRUFBQyxTQUFVLENBQUEsQ0FBQztBQUN6QztBQUFBLFVBQ0YsS0FBSyxFQUFFO0FBQ0wsY0FBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQWEsRUFBQyxTQUFVLENBQUEsQ0FBQztBQUMxQztBQUFBLFVBQ0YsS0FBSyxFQUFFO0FBQ0wsY0FBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFlBQWEsRUFBQyxTQUFVLENBQUEsQ0FBQztBQUMzQztBQUFBLFVBQ0YsS0FBSyxFQUFFO0FBQ0wsY0FBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFlBQWEsRUFBQyxTQUFVLENBQUEsQ0FBQztBQUN4QztBQUFBLFFBQ0g7QUFDRCxlQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFFLFNBQVEsQ0FBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEdBQUc7QUFBQSxNQUN0RTtBQUFBLElBQ1AsQ0FBSztBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNRCxhQUFhLEdBQUc7QUFDZCxTQUFLLFlBQVksS0FBSztBQUFBLEVBQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPRCxlQUFlO0FBQ2IsUUFBSTtBQUNKLFFBQUk7QUFDRixVQUFJLEVBQUM7QUFBQSxJQUNYLFFBQU07QUFDQSxVQUFJLENBQUE7QUFBQSxJQUNMO0FBQ0QsV0FBTztBQUFBLEVBQ1I7QUFDSDtBQUNBLE1BQU0sRUFBRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFRTixZQUFZLEdBQUdBLElBQUcsR0FBRztBQUNuQmIsUUFBRSxNQUFNLFFBQVE7QUFDaEIsU0FBSyxTQUFTLElBQUksRUFBRSxHQUFHYSxJQUFHLENBQUM7QUFBQSxFQUM1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFRRCxVQUFVLEdBQUdBLElBQUc7QUFDZCxXQUFPLEtBQUssT0FBTyxhQUFhQSxFQUFDLEdBQUcsS0FBSyxPQUFPLFVBQVUsQ0FBQztBQUFBLEVBQzVEO0FBQ0g7QUFDQSxNQUFNLFVBQVUsRUFBRTtBQUFBLEVBQ2hCLFlBQVksR0FBR0EsSUFBRyxHQUFHO0FBQ25CLFVBQU0sR0FBR0EsSUFBRyxDQUFDO0FBQUEsRUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0QsVUFBVSxHQUFHQSxJQUFHO0FBQ2QsV0FBTyxNQUFNLFVBQVUsR0FBR0EsRUFBQztBQUFBLEVBQzVCO0FBQ0g7QUFDQSxNQUFNLEVBQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9OLE9BQU8sY0FBYyxHQUFHQSxJQUFHO0FBQ3pCLFdBQU8sRUFBRSxpQkFBaUIsUUFBUSxRQUFRLENBQUMsRUFBRTtBQUFBLE1BQzNDO0FBQUEsTUFDQUE7QUFBQSxJQUNOO0FBQUEsRUFDRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUQsT0FBTyxpQkFBaUIsR0FBR0EsSUFBRyxHQUFHO0FBQy9CLFdBQU8sSUFBSSxFQUFFLEdBQUdBLElBQUcsQ0FBQztBQUFBLEVBQ3JCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJRCxPQUFPLHFCQUFxQixHQUFHQSxJQUFHO0FBQ2hDLFdBQU8sSUFBSSxFQUFFLFFBQVEsR0FBR0EsRUFBQztBQUFBLEVBQzFCO0FBQ0g7QUNwWkEsU0FBUyxhQUFhLFlBQXFCLElBQWE7QUFDN0MsU0FBQSxXQUFXLHNCQUFzQixlQUFlLEVBQUU7QUFDN0Q7QUFFQSxTQUFTLFlBQVksWUFBcUIsSUFBYTtBQUM1QyxTQUFBLFdBQVcsc0JBQXNCLFlBQVksRUFBRTtBQUMxRDtBQUVPLFNBQVMsZUFBZSxJQUFhOztBQUN4QyxRQUFNLFNBQVF0QixNQUFBLFNBQVMsZUFBZSxTQUFTLE1BQWpDLGdCQUFBQSxJQUFvQyx1QkFBdUI7QUFDekUsTUFBSSxDQUFDLE9BQU87QUFDUjtBQUFBLEVBQ0o7QUFDYSxlQUFBLE1BQU0sQ0FBQyxHQUFHLEVBQUU7QUFDN0I7QUFFTyxTQUFTLGdCQUFnQixJQUFhOztBQUN6QyxRQUFNLFNBQVFBLE1BQUEsU0FBUyxlQUFlLFNBQVMsTUFBakMsZ0JBQUFBLElBQW9DLHVCQUF1QjtBQUN6RSxNQUFJLENBQUMsT0FBTztBQUNSO0FBQUEsRUFDSjtBQUNZLGNBQUEsTUFBTSxDQUFDLEdBQUcsRUFBRTtBQUM1QjtBQUVPLE1BQU0sZUFBZSxDQUFDaUIsVUFBaUIsVUFBVUEsS0FBSTs7Ozs7OztBQ1hyRCxNQUFNLEtBQUs7QUFBQSxFQUdkLFlBQVlDLEtBQVk7O0FBQ2QsVUFBQSxRQUFPLE1BQUFsQixNQUFBLE9BQU8sV0FBUCxnQkFBQUEsSUFBZSxVQUFmLG1CQUFzQjtBQUNuQyxRQUFJLENBQUMsTUFBTTtBQUNQLFlBQU0sTUFBTSxpQ0FBaUM7QUFBQSxJQUNqRDtBQUNBLFNBQUssT0FBTztBQUNaLFFBQUksQ0FBQ2tCLEtBQUk7QUFDTCxZQUFNLE1BQU0sOENBQThDO0FBQUEsSUFDOUQ7QUFDQSxTQUFLLE9BQU87QUFDUCxTQUFBLFFBQVEsYUFBYSxhQUFhQSxHQUFFO0FBQUEsRUFDN0M7QUFBQSxFQUVBLFFBQVEsTUFBZ0I7QUFDZixTQUFBLEtBQUssT0FBTyxLQUFLLE9BQU87QUFDdEIsV0FBQTtBQUFBLEVBQ1g7QUFBQSxFQUVBLGVBQWU7QUFDWCxTQUFLLFFBQVEsSUFBSSxTQUFTLEVBQUUsTUFBTSxZQUFhLENBQUEsQ0FBQztBQUN6QyxXQUFBO0FBQUEsRUFDWDtBQUFBLEVBRUEsaUJBQWlCLE9BQW1CO0FBQzNCLFNBQUEsS0FBSyxNQUFNLEVBQUUsR0FBRyxNQUFNLFNBQVMsR0FBRyxNQUFNLFFBQUEsQ0FBUztBQUMvQyxXQUFBO0FBQUEsRUFDWDtBQUFBLEVBRUEsZUFBZSxVQUFvQztBQUMxQyxTQUFBLEtBQUssTUFBTSxFQUFFLEdBQUcsU0FBUyxHQUFHLEdBQUcsU0FBUyxFQUFBLENBQUc7QUFDekMsV0FBQTtBQUFBLEVBQ1g7QUFBQSxFQUVBLFFBQVE7QUFDSixTQUFLLEtBQUs7RUFDZDtBQUNKO0FBS08sTUFBTSxTQUFTO0FBQUEsRUFHbEIsWUFBWSxTQUEwQjtBQUM3QixTQUFBLFVBQVUsU0FBUyxjQUFjLFFBQVE7QUFDOUMsUUFBSSxRQUFRLFVBQVU7QUFDYixXQUFBLFFBQVEsYUFBYSxZQUFZLFVBQVU7QUFBQSxJQUNwRDtBQUNJLFFBQUEsUUFBUSxTQUFTLGFBQWE7QUFDekIsV0FBQSxRQUFRLFVBQVUsSUFBSSxvQkFBb0I7QUFDL0M7QUFBQSxJQUNKO0FBQ0ssU0FBQSxRQUFRLFVBQVUsSUFBSSxlQUFlO0FBQzFDLFFBQUksUUFBUSxTQUFTO0FBQ1osV0FBQSxRQUFRLFVBQVUsSUFBSSx5QkFBeUI7QUFBQSxJQUN4RDtBQUNBLFFBQUksUUFBUSxPQUFPO0FBRWYsV0FBSyxRQUFRLGlCQUFpQixTQUFTLENBQUMsVUFBVTtBQUM5QyxZQUFJLEtBQUssUUFBUSxhQUFhLFVBQVUsR0FBRztBQUN2QztBQUFBLFFBQ0o7QUFDUSxnQkFBQSxNQUFNLEtBQUssT0FBTztBQUMxQixjQUFNLGVBQWU7QUFDckIsY0FBTSx5QkFBeUI7QUFDL0IsY0FBTSxnQkFBZ0I7QUFDZixlQUFBLE9BQU8sTUFBTSxLQUFLLE9BQU87QUFBQSxNQUFBLENBQ25DO0FBQUEsSUFDTDtBQUNJLFFBQUEsT0FBTyxnQ0FBZ0MsUUFBUTtBQUNuRCxRQUFJLFFBQVEsVUFBVTtBQUNsQixhQUFPLFFBQVEsV0FBVztBQUFBLElBQUEsT0FDdkI7QUFDSSxhQUFBLDRCQUNILENBQUMsaUJBQWlCLE9BQU8sT0FBTyxVQUFVLFFBQVEsRUFBRSxTQUFTLFFBQVEsS0FBSyxJQUFJLGVBQWUsY0FDckYsUUFBUSxTQUFTLGNBQWMsaUJBQWlCLHlCQUF5QixRQUFRLFFBQVEsbUJBQW1CO0FBQUEsSUFDNUg7QUFJQSxRQUFJLFFBQVEsUUFBUTtBQUNoQixjQUFRLGtEQUFrRCxRQUFRO0FBQUEsSUFDdEU7QUFDQSxRQUFJLFFBQVEsSUFBSTtBQUNaLFdBQUssUUFBUSxhQUFhLFdBQVcsUUFBUSxFQUFFO0FBQUEsSUFDbkQ7QUFDSSxRQUFBLFFBQVEsU0FBUyxZQUFZO0FBQ3hCLFdBQUEsUUFBUSxVQUFVLElBQUkseUJBQXlCO0FBQUEsSUFDeEQ7QUFDQSxTQUFLLFFBQVEsWUFBWTtBQUN6QixRQUFJLFFBQVEsTUFBTTtBQUVULFdBQUEsUUFBUSxVQUFVLElBQUksdUJBQXVCO0FBQzFDLGNBQUEsS0FBSyxLQUFLLE9BQU87QUFBQSxJQUM3QjtBQUNBLFFBQUksUUFBUSxTQUFTO0FBQ1gsWUFBQSxpQkFBaUIsU0FBUyxjQUFjLEtBQUs7QUFDcEMscUJBQUEsVUFBVSxJQUFJLGtCQUFrQjtBQUN2QyxjQUFBLFFBQVEsUUFBUSxDQUFDLFNBQVM7QUFDOUIsdUJBQWUsT0FBTyxJQUFJLFNBQVMsSUFBSSxFQUFFLE9BQU87QUFBQSxNQUFBLENBQ25EO0FBQ0ksV0FBQSxRQUFRLG1CQUFtQixhQUFhLDJGQUEyRjtBQUNuSSxXQUFBLFFBQVEsT0FBTyxjQUFjO0FBQUEsSUFDdEM7QUFBQSxFQUNKO0FBQ0o7QUFFTyxNQUFNLGNBQWM7QUFBQztBQ3pIckIsTUFBTSxPQUFPO0FBQUEsRUFNaEIsWUFBWSxTQVNUO0FBQ0MsU0FBSyxlQUFlLFFBQVE7QUFDNUIsU0FBSyxLQUFLO0FBQ0gsV0FBQSxPQUFPLFFBQVEsS0FBSyxJQUFJO0FBQy9CLFNBQUssa0JBQWtCLFFBQVE7QUFDMUIsU0FBQSxVQUFVLFNBQVMsY0FBYyxLQUFLO0FBRTNDLFNBQUssUUFBUSxZQUFZO0FBQUEsK0JBQ0YsUUFBUSxjQUFjLHlDQUF5QztBQUFBLGlEQUM3QyxRQUFRLFNBQVM7QUFBQSxzQ0FDNUIsS0FBSyxlQUFlLGNBQWM7QUFBQSxpQ0FDdkMsUUFBUSxRQUFRLEtBQUssOENBQThDLFFBQVEsU0FBUztBQUFBLHVCQUM5RixRQUFRLFVBQVUsV0FBVyxRQUFRO0FBQUE7QUFHcEQsU0FBSyxRQUFRLGNBQWMsbUJBQW1CLEVBQUUsaUJBQWlCLFNBQVMsQ0FBQyxVQUFVO0FBQzdFLFVBQUEsQ0FBQyxLQUFLLGNBQWM7QUFDcEIsYUFBSyxRQUFRO0FBQUEsTUFDakI7QUFDQSxZQUFNLGVBQWU7QUFDckIsWUFBTSxnQkFBZ0I7QUFFZixhQUFBLE9BQU8sTUFBTSxLQUFLLE9BQU87QUFBQSxJQUFBLENBQ25DO0FBQ0csUUFBQSxDQUFDLEtBQUssY0FBYztBQUNwQixXQUFLLFFBQVEsY0FBYyxtQkFBbUIsRUFBRSxpQkFBaUIsU0FBUyxDQUFDLFVBQVU7QUFDakYsYUFBSyxRQUFRO0FBQ2IsY0FBTSxlQUFlO0FBQ3JCLGNBQU0sZ0JBQWdCO0FBQUEsTUFBQSxDQUN6QjtBQUFBLElBQ0w7QUFDUyxhQUFBLEtBQUssT0FBTyxLQUFLLE9BQU87QUFDakMsUUFBSSxRQUFRLGtCQUFrQjtBQUNyQixXQUFBLFFBQVEsVUFBVSxJQUFJLGlCQUFpQjtBQUFBLElBQUEsT0FDekM7QUFDSCxpQkFBVyxNQUFNO0FBQ1IsYUFBQSxRQUFRLFVBQVUsSUFBSSxpQkFBaUI7QUFBQSxNQUFBLENBQy9DO0FBQUEsSUFDTDtBQUVPLFdBQUEsT0FBTyxNQUFNLEtBQUssT0FBTztBQUFBLEVBQ3BDO0FBQUEsRUFFQSxPQUFPLGFBQWE7QUFDaEIsV0FBTyxPQUFPLFFBQVEsUUFBUSxDQUFDLE1BQU0sRUFBRSxTQUFTO0FBQUEsRUFDcEQ7QUFBQSxFQUVPLFVBQVU7QUFDYixTQUFLLFFBQVE7QUFFTixXQUFBLE9BQU8sTUFBTSxLQUFLLE9BQU87QUFDaEMsUUFBSSxLQUFLLGlCQUFpQjtBQUN0QixXQUFLLGdCQUFnQjtBQUFBLElBQ3pCO0FBQ0EsV0FBTyxPQUFPLFFBQVEsS0FBSyxDQUFDLE1BQU0sVUFBVTtBQUNwQyxVQUFBLEtBQUssT0FBTyxLQUFLLElBQUk7QUFDckIsZUFBTyxPQUFPLFFBQVEsT0FBTyxPQUFPLENBQUM7QUFDOUIsZUFBQTtBQUFBLE1BQ1g7QUFBQSxJQUFBLENBQ0g7QUFBQSxFQUNMO0FBQUEsRUFFTyxVQUFVLGNBQXNELFlBQXlCO0FBQzVGLGlCQUFhLE1BQU07QUFDTixpQkFBQSxpQkFBaUIsV0FBVyxDQUFDLFVBQXlCO0FBQy9ELFVBQUksTUFBTSxhQUFhO0FBQ25CLGNBQU0sZUFBZTtBQUNyQjtBQUFBLE1BQ0o7QUFDSSxVQUFBLE1BQU0sUUFBUSxVQUFVO0FBQ3hCLGFBQUssUUFBUTtBQUNiLGNBQU0sZUFBZTtBQUNyQixjQUFNLGdCQUFnQjtBQUN0QjtBQUFBLE1BQ0o7QUFDSSxVQUFBLE1BQU0sUUFBUSxXQUFXLFlBQVk7QUFDMUI7QUFDWCxjQUFNLGVBQWU7QUFBQSxNQUN6QjtBQUFBLElBQUEsQ0FDSDtBQUFBLEVBQ0w7QUFDSjtBQ2xHTyxNQUFNLE9BQTBCO0FBQUEsRUFFbkMsU0FBUztBQUFBLEVBQUM7QUFBQSxFQUNWLFdBQVc7QUFBQSxFQUFDO0FBQUEsRUFDWixnQkFBZ0IsU0FBeUI7QUFBQSxFQUFDO0FBQUEsRUFDMUMsc0JBQXNCLGVBQThCO0FBQUEsRUFBQztBQUFBLEVBQ3JELE1BQU0sWUFBWSxVQUFrQjtBQUN6QixXQUFBO0FBQUEsRUFDWDtBQUFBLEVBQ0EsTUFBTSxhQUFhLFVBQWtCLFNBQWM7QUFBQSxFQUFDO0FBQ3hEO0FDSkEsTUFBZSxNQUFBO0FBQUEsRUFDWDtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDSjs7Ozs7Ozs7OztBQ2hCQSxNQUFNLHNCQUFzQjtBQUU1QixNQUFNVSxlQUFhO0FBQ25CLE1BQU1DLHFCQUFtQixPQUFPO0FBQ0w7QUFHM0IsTUFBTSw0QkFBNEI7QUFFbEMsSUFBQUMsY0FBaUI7QUFBQSxFQUNmO0FBQUEsRUFDRixZQUFFRjtBQUFBQSxFQUNGLGtCQUFFQztBQUFBQSxFQUNBO0FBQ0Y7QUNoQkEsTUFBTUUsVUFDSixPQUFPLFlBQVksWUFDbkIsUUFBUSxPQUNSLFFBQVEsSUFBSSxjQUNaLGNBQWMsS0FBSyxRQUFRLElBQUksVUFBVSxJQUN2QyxJQUFJLFNBQVMsUUFBUSxNQUFNLFVBQVUsR0FBRyxJQUFJLElBQzVDLE1BQU07QUFBRTtBQUVaLElBQUEsVUFBaUJBO0FBQUFBO0FDUmpCLFFBQU0sRUFBRSwyQkFBQUMsMkJBQXlCLElBQUtDO0FBQ3RDLFFBQU1GLFNBQVFHO0FBQ2QsRUFBQUMsV0FBVUMsa0JBQWlCLENBQUU7QUFHN0IsUUFBTUMsTUFBS0YsU0FBQSxLQUFhLENBQUU7QUFDMUIsUUFBTSxNQUFNQSxTQUFBLE1BQWMsQ0FBRTtBQUM1QixRQUFNYixLQUFJYSxTQUFBLElBQVksQ0FBRTtBQUN4QixNQUFJRyxLQUFJO0FBRVIsUUFBTSxjQUFjLENBQUNyQixPQUFNLE9BQU8sYUFBYTtBQUM3QyxVQUFNLFFBQVFxQjtBQUNkLElBQUFQLE9BQU1kLE9BQU0sT0FBTyxLQUFLO0FBQ3hCLElBQUFLLEdBQUVMLEtBQUksSUFBSTtBQUNWLFFBQUksS0FBSyxJQUFJO0FBQ2IsSUFBQW9CLElBQUcsS0FBSyxJQUFJLElBQUksT0FBTyxPQUFPLFdBQVcsTUFBTSxNQUFTO0FBQUEsRUFDekQ7QUFRRCxjQUFZLHFCQUFxQixhQUFhO0FBQzlDLGNBQVksMEJBQTBCLFFBQVE7QUFNOUMsY0FBWSx3QkFBd0IsNEJBQTRCO0FBS2hFLGNBQVksZUFBZSxJQUFJLElBQUlmLEdBQUUsaUJBQWlCLFNBQy9CLElBQUlBLEdBQUUsaUJBQWlCLFNBQ3ZCLElBQUlBLEdBQUUsaUJBQWlCLElBQUk7QUFFbEQsY0FBWSxvQkFBb0IsSUFBSSxJQUFJQSxHQUFFLHNCQUFzQixTQUNwQyxJQUFJQSxHQUFFLHNCQUFzQixTQUM1QixJQUFJQSxHQUFFLHNCQUFzQixJQUFJO0FBSzVELGNBQVksd0JBQXdCLE1BQU0sSUFBSUEsR0FBRSxpQkFBaUIsS0FDN0QsSUFBSUEsR0FBRSxvQkFBb0IsSUFBSTtBQUVsQyxjQUFZLDZCQUE2QixNQUFNLElBQUlBLEdBQUUsc0JBQXNCLEtBQ3ZFLElBQUlBLEdBQUUsb0JBQW9CLElBQUk7QUFNbEMsY0FBWSxjQUFjLFFBQVEsSUFBSUEsR0FBRSxvQkFBb0IsVUFDbkQsSUFBSUEsR0FBRSxvQkFBb0IsT0FBTztBQUUxQyxjQUFZLG1CQUFtQixTQUFTLElBQUlBLEdBQUUseUJBQXlCLFVBQzlELElBQUlBLEdBQUUseUJBQXlCLE9BQU87QUFLL0MsY0FBWSxtQkFBbUIsZUFBZTtBQU05QyxjQUFZLFNBQVMsVUFBVSxJQUFJQSxHQUFFLGVBQWUsVUFDM0MsSUFBSUEsR0FBRSxlQUFlLE9BQU87QUFXckMsY0FBWSxhQUFhLEtBQUssSUFBSUEsR0FBRSxXQUFXLElBQzVDLElBQUlBLEdBQUUsVUFBVSxLQUNqQixJQUFJQSxHQUFFLEtBQUssSUFBSTtBQUVqQixjQUFZLFFBQVEsSUFBSSxJQUFJQSxHQUFFLFNBQVMsSUFBSTtBQUszQyxjQUFZLGNBQWMsV0FBVyxJQUFJQSxHQUFFLGdCQUFnQixJQUN4RCxJQUFJQSxHQUFFLGVBQWUsS0FDdEIsSUFBSUEsR0FBRSxLQUFLLElBQUk7QUFFakIsY0FBWSxTQUFTLElBQUksSUFBSUEsR0FBRSxVQUFVLElBQUk7QUFFN0MsY0FBWSxRQUFRLGNBQWM7QUFLbEMsY0FBWSx5QkFBeUIsR0FBRyxJQUFJQSxHQUFFLHNCQUFzQixXQUFXO0FBQy9FLGNBQVksb0JBQW9CLEdBQUcsSUFBSUEsR0FBRSxpQkFBaUIsV0FBVztBQUVyRSxjQUFZLGVBQWUsWUFBWSxJQUFJQSxHQUFFLGdCQUFnQixZQUNoQyxJQUFJQSxHQUFFLGdCQUFnQixZQUN0QixJQUFJQSxHQUFFLGdCQUFnQixRQUMxQixJQUFJQSxHQUFFLFVBQVUsTUFDcEIsSUFBSUEsR0FBRSxLQUFLLFFBQ1A7QUFFekIsY0FBWSxvQkFBb0IsWUFBWSxJQUFJQSxHQUFFLHFCQUFxQixZQUNyQyxJQUFJQSxHQUFFLHFCQUFxQixZQUMzQixJQUFJQSxHQUFFLHFCQUFxQixRQUMvQixJQUFJQSxHQUFFLGVBQWUsTUFDekIsSUFBSUEsR0FBRSxLQUFLLFFBQ1A7QUFFOUIsY0FBWSxVQUFVLElBQUksSUFBSUEsR0FBRSxJQUFJLFFBQVEsSUFBSUEsR0FBRSxXQUFXLElBQUk7QUFDakUsY0FBWSxlQUFlLElBQUksSUFBSUEsR0FBRSxJQUFJLFFBQVEsSUFBSUEsR0FBRSxnQkFBZ0IsSUFBSTtBQUkzRSxjQUFZLFVBQVUsR0FBRyxzQkFDQ1UsNENBQ0lBLDhDQUNBQSw0Q0FDRjtBQUM1QixjQUFZLGFBQWEsSUFBSVYsR0FBRSxNQUFNLEdBQUcsSUFBSTtBQUk1QyxjQUFZLGFBQWEsU0FBUztBQUVsQyxjQUFZLGFBQWEsU0FBUyxJQUFJQSxHQUFFLFNBQVMsU0FBUyxJQUFJO0FBQzlELEVBQUFhLFNBQUEsbUJBQTJCO0FBRTNCLGNBQVksU0FBUyxJQUFJLElBQUliLEdBQUUsU0FBUyxJQUFJLElBQUlBLEdBQUUsV0FBVyxJQUFJO0FBQ2pFLGNBQVksY0FBYyxJQUFJLElBQUlBLEdBQUUsU0FBUyxJQUFJLElBQUlBLEdBQUUsZ0JBQWdCLElBQUk7QUFJM0UsY0FBWSxhQUFhLFNBQVM7QUFFbEMsY0FBWSxhQUFhLFNBQVMsSUFBSUEsR0FBRSxTQUFTLFNBQVMsSUFBSTtBQUM5RCxFQUFBYSxTQUFBLG1CQUEyQjtBQUUzQixjQUFZLFNBQVMsSUFBSSxJQUFJYixHQUFFLFNBQVMsSUFBSSxJQUFJQSxHQUFFLFdBQVcsSUFBSTtBQUNqRSxjQUFZLGNBQWMsSUFBSSxJQUFJQSxHQUFFLFNBQVMsSUFBSSxJQUFJQSxHQUFFLGdCQUFnQixJQUFJO0FBRzNFLGNBQVksbUJBQW1CLElBQUksSUFBSUEsR0FBRSxJQUFJLFNBQVMsSUFBSUEsR0FBRSxVQUFVLFFBQVE7QUFDOUUsY0FBWSxjQUFjLElBQUksSUFBSUEsR0FBRSxJQUFJLFNBQVMsSUFBSUEsR0FBRSxTQUFTLFFBQVE7QUFJeEUsY0FBWSxrQkFBa0IsU0FBUyxJQUFJQSxHQUFFLElBQUksU0FDekMsSUFBSUEsR0FBRSxVQUFVLEtBQUssSUFBSUEsR0FBRSxXQUFXLE1BQU0sSUFBSTtBQUN4RCxFQUFBYSxTQUFBLHdCQUFnQztBQU1oQyxjQUFZLGVBQWUsU0FBUyxJQUFJYixHQUFFLFdBQVcsZUFFOUIsSUFBSUEsR0FBRSxXQUFXLFNBQ2Q7QUFFMUIsY0FBWSxvQkFBb0IsU0FBUyxJQUFJQSxHQUFFLGdCQUFnQixlQUVuQyxJQUFJQSxHQUFFLGdCQUFnQixTQUNuQjtBQUcvQixjQUFZLFFBQVEsaUJBQWlCO0FBRXJDLGNBQVksUUFBUSwyQkFBMkI7QUFDL0MsY0FBWSxXQUFXLDZCQUE2Qjs7QUNuTHBELE1BQU0sT0FBTyxDQUFDLHFCQUFxQixTQUFTLEtBQUs7QUFDakQsTUFBTWlCLGlCQUFlLGFBQ25CLENBQUMsVUFBVSxDQUFFLElBQ1gsT0FBTyxZQUFZLFdBQVcsRUFBRSxPQUFPLEtBQU0sSUFDN0MsS0FBSyxPQUFPLENBQUFyQyxPQUFLLFFBQVFBLEVBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxHQUFHQSxPQUFNO0FBQzlDLElBQUVBLEVBQUMsSUFBSTtBQUNQLFNBQU87QUFDUixHQUFFLEVBQUU7QUFDUCxJQUFBLGlCQUFpQnFDO0FDVmpCLE1BQU0sVUFBVTtBQUNoQixNQUFNQyx1QkFBcUIsQ0FBQ2pCLElBQUdrQixPQUFNO0FBQ25DLFFBQU0sT0FBTyxRQUFRLEtBQUtsQixFQUFDO0FBQzNCLFFBQU0sT0FBTyxRQUFRLEtBQUtrQixFQUFDO0FBRTNCLE1BQUksUUFBUSxNQUFNO0FBQ2hCLElBQUFsQixLQUFJLENBQUNBO0FBQ0wsSUFBQWtCLEtBQUksQ0FBQ0E7QUFBQSxFQUNOO0FBRUQsU0FBT2xCLE9BQU1rQixLQUFJLElBQ1osUUFBUSxDQUFDLE9BQVEsS0FDakIsUUFBUSxDQUFDLE9BQVEsSUFDbEJsQixLQUFJa0IsS0FBSSxLQUNSO0FBQ047QUFFQSxNQUFNLHNCQUFzQixDQUFDbEIsSUFBR2tCLE9BQU1ELHFCQUFtQkMsSUFBR2xCLEVBQUM7QUFFN0QsSUFBQW1CLGdCQUFpQjtBQUFBLEVBQ2pCLG9CQUFFRjtBQUFBQSxFQUNBO0FBQ0Y7QUN0QkEsTUFBTSxRQUFRUDtBQUNkLE1BQU0sY0FBRUwsY0FBWSxpQkFBZ0IsSUFBS007QUFDekMsTUFBTSxNQUFFRyxNQUFFLEdBQUVmLElBQUMsSUFBS3FCO0FBRWxCLE1BQU1KLGlCQUFlSztBQUNyQixNQUFNLEVBQUUsbUJBQW9CLElBQUdDO0FBQy9CLElBQUEsV0FBQSxNQUFNQyxRQUFPO0FBQUEsRUFDWCxZQUFhQyxVQUFTLFNBQVM7QUFDN0IsY0FBVVIsZUFBYSxPQUFPO0FBRTlCLFFBQUlRLG9CQUFtQkQsU0FBUTtBQUM3QixVQUFJQyxTQUFRLFVBQVUsQ0FBQyxDQUFDLFFBQVEsU0FDNUJBLFNBQVEsc0JBQXNCLENBQUMsQ0FBQyxRQUFRLG1CQUFtQjtBQUM3RCxlQUFPQTtBQUFBLE1BQ2YsT0FBYTtBQUNMLFFBQUFBLFdBQVVBLFNBQVE7QUFBQSxNQUNuQjtBQUFBLElBQ1AsV0FBZSxPQUFPQSxhQUFZLFVBQVU7QUFDdEMsWUFBTSxJQUFJLFVBQVUsb0JBQW9CQSxVQUFTO0FBQUEsSUFDbEQ7QUFFRCxRQUFJQSxTQUFRLFNBQVNuQixjQUFZO0FBQy9CLFlBQU0sSUFBSTtBQUFBLFFBQ1IsMEJBQTBCQTtBQUFBQSxNQUMzQjtBQUFBLElBQ0Y7QUFFRCxVQUFNLFVBQVVtQixVQUFTLE9BQU87QUFDaEMsU0FBSyxVQUFVO0FBQ2YsU0FBSyxRQUFRLENBQUMsQ0FBQyxRQUFRO0FBR3ZCLFNBQUssb0JBQW9CLENBQUMsQ0FBQyxRQUFRO0FBRW5DLFVBQU0sSUFBSUEsU0FBUSxLQUFJLEVBQUcsTUFBTSxRQUFRLFFBQVFWLEtBQUdmLElBQUUsS0FBSyxJQUFJZSxLQUFHZixJQUFFLElBQUksQ0FBQztBQUV2RSxRQUFJLENBQUMsR0FBRztBQUNOLFlBQU0sSUFBSSxVQUFVLG9CQUFvQnlCLFVBQVM7QUFBQSxJQUNsRDtBQUVELFNBQUssTUFBTUE7QUFHWCxTQUFLLFFBQVEsQ0FBQyxFQUFFLENBQUM7QUFDakIsU0FBSyxRQUFRLENBQUMsRUFBRSxDQUFDO0FBQ2pCLFNBQUssUUFBUSxDQUFDLEVBQUUsQ0FBQztBQUVqQixRQUFJLEtBQUssUUFBUSxvQkFBb0IsS0FBSyxRQUFRLEdBQUc7QUFDbkQsWUFBTSxJQUFJLFVBQVUsdUJBQXVCO0FBQUEsSUFDNUM7QUFFRCxRQUFJLEtBQUssUUFBUSxvQkFBb0IsS0FBSyxRQUFRLEdBQUc7QUFDbkQsWUFBTSxJQUFJLFVBQVUsdUJBQXVCO0FBQUEsSUFDNUM7QUFFRCxRQUFJLEtBQUssUUFBUSxvQkFBb0IsS0FBSyxRQUFRLEdBQUc7QUFDbkQsWUFBTSxJQUFJLFVBQVUsdUJBQXVCO0FBQUEsSUFDNUM7QUFHRCxRQUFJLENBQUMsRUFBRSxDQUFDLEdBQUc7QUFDVCxXQUFLLGFBQWEsQ0FBRTtBQUFBLElBQzFCLE9BQVc7QUFDTCxXQUFLLGFBQWEsRUFBRSxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUUsSUFBSSxDQUFDN0IsUUFBTztBQUM1QyxZQUFJLFdBQVcsS0FBS0EsR0FBRSxHQUFHO0FBQ3ZCLGdCQUFNLE1BQU0sQ0FBQ0E7QUFDYixjQUFJLE9BQU8sS0FBSyxNQUFNLGtCQUFrQjtBQUN0QyxtQkFBTztBQUFBLFVBQ1I7QUFBQSxRQUNGO0FBQ0QsZUFBT0E7QUFBQSxNQUNmLENBQU87QUFBQSxJQUNGO0FBRUQsU0FBSyxRQUFRLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sR0FBRyxJQUFJLENBQUU7QUFDeEMsU0FBSyxPQUFRO0FBQUEsRUFDZDtBQUFBLEVBRUQsU0FBVTtBQUNSLFNBQUssVUFBVSxHQUFHLEtBQUssU0FBUyxLQUFLLFNBQVMsS0FBSztBQUNuRCxRQUFJLEtBQUssV0FBVyxRQUFRO0FBQzFCLFdBQUssV0FBVyxJQUFJLEtBQUssV0FBVyxLQUFLLEdBQUc7QUFBQSxJQUM3QztBQUNELFdBQU8sS0FBSztBQUFBLEVBQ2I7QUFBQSxFQUVELFdBQVk7QUFDVixXQUFPLEtBQUs7QUFBQSxFQUNiO0FBQUEsRUFFRCxRQUFTLE9BQU87QUFDZCxVQUFNLGtCQUFrQixLQUFLLFNBQVMsS0FBSyxTQUFTLEtBQUs7QUFDekQsUUFBSSxFQUFFLGlCQUFpQjRCLFVBQVM7QUFDOUIsVUFBSSxPQUFPLFVBQVUsWUFBWSxVQUFVLEtBQUssU0FBUztBQUN2RCxlQUFPO0FBQUEsTUFDUjtBQUNELGNBQVEsSUFBSUEsUUFBTyxPQUFPLEtBQUssT0FBTztBQUFBLElBQ3ZDO0FBRUQsUUFBSSxNQUFNLFlBQVksS0FBSyxTQUFTO0FBQ2xDLGFBQU87QUFBQSxJQUNSO0FBRUQsV0FBTyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLO0FBQUEsRUFDeEQ7QUFBQSxFQUVELFlBQWEsT0FBTztBQUNsQixRQUFJLEVBQUUsaUJBQWlCQSxVQUFTO0FBQzlCLGNBQVEsSUFBSUEsUUFBTyxPQUFPLEtBQUssT0FBTztBQUFBLElBQ3ZDO0FBRUQsV0FDRSxtQkFBbUIsS0FBSyxPQUFPLE1BQU0sS0FBSyxLQUMxQyxtQkFBbUIsS0FBSyxPQUFPLE1BQU0sS0FBSyxLQUMxQyxtQkFBbUIsS0FBSyxPQUFPLE1BQU0sS0FBSztBQUFBLEVBRTdDO0FBQUEsRUFFRCxXQUFZLE9BQU87QUFDakIsUUFBSSxFQUFFLGlCQUFpQkEsVUFBUztBQUM5QixjQUFRLElBQUlBLFFBQU8sT0FBTyxLQUFLLE9BQU87QUFBQSxJQUN2QztBQUdELFFBQUksS0FBSyxXQUFXLFVBQVUsQ0FBQyxNQUFNLFdBQVcsUUFBUTtBQUN0RCxhQUFPO0FBQUEsSUFDYixXQUFlLENBQUMsS0FBSyxXQUFXLFVBQVUsTUFBTSxXQUFXLFFBQVE7QUFDN0QsYUFBTztBQUFBLElBQ2IsV0FBZSxDQUFDLEtBQUssV0FBVyxVQUFVLENBQUMsTUFBTSxXQUFXLFFBQVE7QUFDOUQsYUFBTztBQUFBLElBQ1I7QUFFRCxRQUFJLElBQUk7QUFDUixPQUFHO0FBQ0QsWUFBTXZCLEtBQUksS0FBSyxXQUFXLENBQUM7QUFDM0IsWUFBTWtCLEtBQUksTUFBTSxXQUFXLENBQUM7QUFDNUIsWUFBTSxzQkFBc0IsR0FBR2xCLElBQUdrQixFQUFDO0FBQ25DLFVBQUlsQixPQUFNLFVBQWFrQixPQUFNLFFBQVc7QUFDdEMsZUFBTztBQUFBLE1BQ2YsV0FBaUJBLE9BQU0sUUFBVztBQUMxQixlQUFPO0FBQUEsTUFDZixXQUFpQmxCLE9BQU0sUUFBVztBQUMxQixlQUFPO0FBQUEsTUFDZixXQUFpQkEsT0FBTWtCLElBQUc7QUFDbEI7QUFBQSxNQUNSLE9BQWE7QUFDTCxlQUFPLG1CQUFtQmxCLElBQUdrQixFQUFDO0FBQUEsTUFDL0I7QUFBQSxJQUNGLFNBQVEsRUFBRTtBQUFBLEVBQ1o7QUFBQSxFQUVELGFBQWMsT0FBTztBQUNuQixRQUFJLEVBQUUsaUJBQWlCSyxVQUFTO0FBQzlCLGNBQVEsSUFBSUEsUUFBTyxPQUFPLEtBQUssT0FBTztBQUFBLElBQ3ZDO0FBRUQsUUFBSSxJQUFJO0FBQ1IsT0FBRztBQUNELFlBQU12QixLQUFJLEtBQUssTUFBTSxDQUFDO0FBQ3RCLFlBQU1rQixLQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3ZCLFlBQU0sc0JBQXNCLEdBQUdsQixJQUFHa0IsRUFBQztBQUNuQyxVQUFJbEIsT0FBTSxVQUFha0IsT0FBTSxRQUFXO0FBQ3RDLGVBQU87QUFBQSxNQUNmLFdBQWlCQSxPQUFNLFFBQVc7QUFDMUIsZUFBTztBQUFBLE1BQ2YsV0FBaUJsQixPQUFNLFFBQVc7QUFDMUIsZUFBTztBQUFBLE1BQ2YsV0FBaUJBLE9BQU1rQixJQUFHO0FBQ2xCO0FBQUEsTUFDUixPQUFhO0FBQ0wsZUFBTyxtQkFBbUJsQixJQUFHa0IsRUFBQztBQUFBLE1BQy9CO0FBQUEsSUFDRixTQUFRLEVBQUU7QUFBQSxFQUNaO0FBQUE7QUFBQTtBQUFBLEVBSUQsSUFBSyxTQUFTLFlBQVk7QUFDeEIsWUFBUSxTQUFPO0FBQUEsTUFDYixLQUFLO0FBQ0gsYUFBSyxXQUFXLFNBQVM7QUFDekIsYUFBSyxRQUFRO0FBQ2IsYUFBSyxRQUFRO0FBQ2IsYUFBSztBQUNMLGFBQUssSUFBSSxPQUFPLFVBQVU7QUFDMUI7QUFBQSxNQUNGLEtBQUs7QUFDSCxhQUFLLFdBQVcsU0FBUztBQUN6QixhQUFLLFFBQVE7QUFDYixhQUFLO0FBQ0wsYUFBSyxJQUFJLE9BQU8sVUFBVTtBQUMxQjtBQUFBLE1BQ0YsS0FBSztBQUlILGFBQUssV0FBVyxTQUFTO0FBQ3pCLGFBQUssSUFBSSxTQUFTLFVBQVU7QUFDNUIsYUFBSyxJQUFJLE9BQU8sVUFBVTtBQUMxQjtBQUFBLE1BR0YsS0FBSztBQUNILFlBQUksS0FBSyxXQUFXLFdBQVcsR0FBRztBQUNoQyxlQUFLLElBQUksU0FBUyxVQUFVO0FBQUEsUUFDN0I7QUFDRCxhQUFLLElBQUksT0FBTyxVQUFVO0FBQzFCO0FBQUEsTUFFRixLQUFLO0FBS0gsWUFDRSxLQUFLLFVBQVUsS0FDZixLQUFLLFVBQVUsS0FDZixLQUFLLFdBQVcsV0FBVyxHQUMzQjtBQUNBLGVBQUs7QUFBQSxRQUNOO0FBQ0QsYUFBSyxRQUFRO0FBQ2IsYUFBSyxRQUFRO0FBQ2IsYUFBSyxhQUFhLENBQUU7QUFDcEI7QUFBQSxNQUNGLEtBQUs7QUFLSCxZQUFJLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxXQUFXLEdBQUc7QUFDcEQsZUFBSztBQUFBLFFBQ047QUFDRCxhQUFLLFFBQVE7QUFDYixhQUFLLGFBQWEsQ0FBRTtBQUNwQjtBQUFBLE1BQ0YsS0FBSztBQUtILFlBQUksS0FBSyxXQUFXLFdBQVcsR0FBRztBQUNoQyxlQUFLO0FBQUEsUUFDTjtBQUNELGFBQUssYUFBYSxDQUFFO0FBQ3BCO0FBQUEsTUFHRixLQUFLO0FBQ0gsWUFBSSxLQUFLLFdBQVcsV0FBVyxHQUFHO0FBQ2hDLGVBQUssYUFBYSxDQUFDLENBQUM7QUFBQSxRQUM5QixPQUFlO0FBQ0wsY0FBSSxJQUFJLEtBQUssV0FBVztBQUN4QixpQkFBTyxFQUFFLEtBQUssR0FBRztBQUNmLGdCQUFJLE9BQU8sS0FBSyxXQUFXLENBQUMsTUFBTSxVQUFVO0FBQzFDLG1CQUFLLFdBQVcsQ0FBQztBQUNqQixrQkFBSTtBQUFBLFlBQ0w7QUFBQSxVQUNGO0FBQ0QsY0FBSSxNQUFNLElBQUk7QUFFWixpQkFBSyxXQUFXLEtBQUssQ0FBQztBQUFBLFVBQ3ZCO0FBQUEsUUFDRjtBQUNELFlBQUksWUFBWTtBQUdkLGNBQUksbUJBQW1CLEtBQUssV0FBVyxDQUFDLEdBQUcsVUFBVSxNQUFNLEdBQUc7QUFDNUQsZ0JBQUksTUFBTSxLQUFLLFdBQVcsQ0FBQyxDQUFDLEdBQUc7QUFDN0IsbUJBQUssYUFBYSxDQUFDLFlBQVksQ0FBQztBQUFBLFlBQ2pDO0FBQUEsVUFDYixPQUFpQjtBQUNMLGlCQUFLLGFBQWEsQ0FBQyxZQUFZLENBQUM7QUFBQSxVQUNqQztBQUFBLFFBQ0Y7QUFDRDtBQUFBLE1BRUY7QUFDRSxjQUFNLElBQUksTUFBTSwrQkFBK0IsU0FBUztBQUFBLElBQzNEO0FBQ0QsU0FBSyxPQUFRO0FBQ2IsU0FBSyxNQUFNLEtBQUs7QUFDaEIsV0FBTztBQUFBLEVBQ1I7QUFDSDtBQUVBLElBQUFPLFdBQWlCRjtBQzlSakIsTUFBTSxFQUFFLFdBQVksSUFBR2I7QUFDdkIsTUFBTSxNQUFFSSxNQUFFLEdBQUVmLElBQUMsSUFBS1k7QUFDbEIsTUFBTVksV0FBU0g7QUFFZixNQUFNLGVBQWVDO0FBQ3JCLE1BQU1LLFVBQVEsQ0FBQ0YsVUFBUyxZQUFZO0FBQ2xDLFlBQVUsYUFBYSxPQUFPO0FBRTlCLE1BQUlBLG9CQUFtQkQsVUFBUTtBQUM3QixXQUFPQztBQUFBLEVBQ1I7QUFFRCxNQUFJLE9BQU9BLGFBQVksVUFBVTtBQUMvQixXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUlBLFNBQVEsU0FBUyxZQUFZO0FBQy9CLFdBQU87QUFBQSxFQUNSO0FBRUQsUUFBTSxJQUFJLFFBQVEsUUFBUVYsS0FBR2YsSUFBRSxLQUFLLElBQUllLEtBQUdmLElBQUUsSUFBSTtBQUNqRCxNQUFJLENBQUMsRUFBRSxLQUFLeUIsUUFBTyxHQUFHO0FBQ3BCLFdBQU87QUFBQSxFQUNSO0FBRUQsTUFBSTtBQUNGLFdBQU8sSUFBSUQsU0FBT0MsVUFBUyxPQUFPO0FBQUEsRUFDbkMsU0FBUSxJQUFQO0FBQ0EsV0FBTztBQUFBLEVBQ1I7QUFDSDtBQUVBLElBQUEsVUFBaUJFO0FDaENqQixNQUFNQSxVQUFRaEI7QUFDZCxNQUFNaUIsVUFBUSxDQUFDSCxVQUFTLFlBQVk7QUFDbEMsUUFBTSxJQUFJRSxRQUFNRixVQUFTLE9BQU87QUFDaEMsU0FBTyxJQUFJLEVBQUUsVUFBVTtBQUN6QjtBQUNBLElBQUEsVUFBaUJHO0FDTGpCLE1BQU1ELFVBQVFoQjtBQUNkLE1BQU1rQixVQUFRLENBQUNKLFVBQVMsWUFBWTtBQUNsQyxRQUFNLElBQUlFLFFBQU1GLFNBQVEsS0FBSSxFQUFHLFFBQVEsVUFBVSxFQUFFLEdBQUcsT0FBTztBQUM3RCxTQUFPLElBQUksRUFBRSxVQUFVO0FBQ3pCO0FBQ0EsSUFBQSxVQUFpQkk7QUNMakIsTUFBTUwsV0FBU2I7QUFFZixNQUFNbUIsUUFBTSxDQUFDTCxVQUFTLFNBQVMsU0FBUyxlQUFlO0FBQ3JELE1BQUksT0FBUSxZQUFhLFVBQVU7QUFDakMsaUJBQWE7QUFDYixjQUFVO0FBQUEsRUFDWDtBQUVELE1BQUk7QUFDRixXQUFPLElBQUlEO0FBQUFBLE1BQ1RDLG9CQUFtQkQsV0FBU0MsU0FBUSxVQUFVQTtBQUFBLE1BQzlDO0FBQUEsSUFDRCxFQUFDLElBQUksU0FBUyxVQUFVLEVBQUU7QUFBQSxFQUM1QixTQUFRLElBQVA7QUFDQSxXQUFPO0FBQUEsRUFDUjtBQUNIO0FBQ0EsSUFBQSxRQUFpQks7QUNqQmpCLE1BQU1OLFdBQVNiO0FBQ2YsTUFBTW9CLFlBQVUsQ0FBQzlCLElBQUdrQixJQUFHLFVBQ3JCLElBQUlLLFNBQU92QixJQUFHLEtBQUssRUFBRSxRQUFRLElBQUl1QixTQUFPTCxJQUFHLEtBQUssQ0FBQztBQUVuRCxJQUFBLFlBQWlCWTtBQ0pqQixNQUFNQSxZQUFVcEI7QUFDaEIsTUFBTXFCLE9BQUssQ0FBQy9CLElBQUdrQixJQUFHLFVBQVVZLFVBQVE5QixJQUFHa0IsSUFBRyxLQUFLLE1BQU07QUFDckQsSUFBQSxPQUFpQmE7QUNGakIsTUFBTUwsVUFBUWhCO0FBQ2QsTUFBTXFCLE9BQUtwQjtBQUVYLE1BQU1xQixTQUFPLENBQUMsVUFBVSxhQUFhO0FBQ25DLE1BQUlELEtBQUcsVUFBVSxRQUFRLEdBQUc7QUFDMUIsV0FBTztBQUFBLEVBQ1gsT0FBUztBQUNMLFVBQU0sS0FBS0wsUUFBTSxRQUFRO0FBQ3pCLFVBQU0sS0FBS0EsUUFBTSxRQUFRO0FBQ3pCLFVBQU0sU0FBUyxHQUFHLFdBQVcsVUFBVSxHQUFHLFdBQVc7QUFDckQsVUFBTSxTQUFTLFNBQVMsUUFBUTtBQUNoQyxVQUFNLGdCQUFnQixTQUFTLGVBQWU7QUFDOUMsZUFBVyxPQUFPLElBQUk7QUFDcEIsVUFBSSxRQUFRLFdBQVcsUUFBUSxXQUFXLFFBQVEsU0FBUztBQUN6RCxZQUFJLEdBQUcsR0FBRyxNQUFNLEdBQUcsR0FBRyxHQUFHO0FBQ3ZCLGlCQUFPLFNBQVM7QUFBQSxRQUNqQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0QsV0FBTztBQUFBLEVBQ1I7QUFDSDtBQUNBLElBQUEsU0FBaUJNO0FDdEJqQixNQUFNVCxXQUFTYjtBQUNmLE1BQU11QixVQUFRLENBQUNqQyxJQUFHLFVBQVUsSUFBSXVCLFNBQU92QixJQUFHLEtBQUssRUFBRTtBQUNqRCxJQUFBLFVBQWlCaUM7QUNGakIsTUFBTVYsV0FBU2I7QUFDZixNQUFNd0IsVUFBUSxDQUFDbEMsSUFBRyxVQUFVLElBQUl1QixTQUFPdkIsSUFBRyxLQUFLLEVBQUU7QUFDakQsSUFBQSxVQUFpQmtDO0FDRmpCLE1BQU1YLFdBQVNiO0FBQ2YsTUFBTXlCLFVBQVEsQ0FBQ25DLElBQUcsVUFBVSxJQUFJdUIsU0FBT3ZCLElBQUcsS0FBSyxFQUFFO0FBQ2pELElBQUEsVUFBaUJtQztBQ0ZqQixNQUFNVCxVQUFRaEI7QUFDZCxNQUFNMEIsZUFBYSxDQUFDWixVQUFTLFlBQVk7QUFDdkMsUUFBTSxTQUFTRSxRQUFNRixVQUFTLE9BQU87QUFDckMsU0FBUSxVQUFVLE9BQU8sV0FBVyxTQUFVLE9BQU8sYUFBYTtBQUNwRTtBQUNBLElBQUEsZUFBaUJZO0FDTGpCLE1BQU1OLFlBQVVwQjtBQUNoQixNQUFNMkIsYUFBVyxDQUFDckMsSUFBR2tCLElBQUcsVUFBVVksVUFBUVosSUFBR2xCLElBQUcsS0FBSztBQUNyRCxJQUFBLGFBQWlCcUM7QUNGakIsTUFBTVAsWUFBVXBCO0FBQ2hCLE1BQU00QixpQkFBZSxDQUFDdEMsSUFBR2tCLE9BQU1ZLFVBQVE5QixJQUFHa0IsSUFBRyxJQUFJO0FBQ2pELElBQUEsaUJBQWlCb0I7QUNGakIsTUFBTWYsV0FBU2I7QUFDZixNQUFNNkIsaUJBQWUsQ0FBQ3ZDLElBQUdrQixJQUFHLFVBQVU7QUFDcEMsUUFBTSxXQUFXLElBQUlLLFNBQU92QixJQUFHLEtBQUs7QUFDcEMsUUFBTSxXQUFXLElBQUl1QixTQUFPTCxJQUFHLEtBQUs7QUFDcEMsU0FBTyxTQUFTLFFBQVEsUUFBUSxLQUFLLFNBQVMsYUFBYSxRQUFRO0FBQ3JFO0FBQ0EsSUFBQSxpQkFBaUJxQjtBQ05qQixNQUFNQSxpQkFBZTdCO0FBQ3JCLE1BQU04QixTQUFPLENBQUMsTUFBTSxVQUFVLEtBQUssS0FBSyxDQUFDeEMsSUFBR2tCLE9BQU1xQixlQUFhdkMsSUFBR2tCLElBQUcsS0FBSyxDQUFDO0FBQzNFLElBQUEsU0FBaUJzQjtBQ0ZqQixNQUFNRCxpQkFBZTdCO0FBQ3JCLE1BQU0rQixVQUFRLENBQUMsTUFBTSxVQUFVLEtBQUssS0FBSyxDQUFDekMsSUFBR2tCLE9BQU1xQixlQUFhckIsSUFBR2xCLElBQUcsS0FBSyxDQUFDO0FBQzVFLElBQUEsVUFBaUJ5QztBQ0ZqQixNQUFNWCxZQUFVcEI7QUFDaEIsTUFBTWdDLE9BQUssQ0FBQzFDLElBQUdrQixJQUFHLFVBQVVZLFVBQVE5QixJQUFHa0IsSUFBRyxLQUFLLElBQUk7QUFDbkQsSUFBQSxPQUFpQndCO0FDRmpCLE1BQU1aLFlBQVVwQjtBQUNoQixNQUFNaUMsT0FBSyxDQUFDM0MsSUFBR2tCLElBQUcsVUFBVVksVUFBUTlCLElBQUdrQixJQUFHLEtBQUssSUFBSTtBQUNuRCxJQUFBLE9BQWlCeUI7QUNGakIsTUFBTWIsWUFBVXBCO0FBQ2hCLE1BQU1rQyxRQUFNLENBQUM1QyxJQUFHa0IsSUFBRyxVQUFVWSxVQUFROUIsSUFBR2tCLElBQUcsS0FBSyxNQUFNO0FBQ3RELElBQUEsUUFBaUIwQjtBQ0ZqQixNQUFNZCxZQUFVcEI7QUFDaEIsTUFBTW1DLFFBQU0sQ0FBQzdDLElBQUdrQixJQUFHLFVBQVVZLFVBQVE5QixJQUFHa0IsSUFBRyxLQUFLLEtBQUs7QUFDckQsSUFBQSxRQUFpQjJCO0FDRmpCLE1BQU1mLFlBQVVwQjtBQUNoQixNQUFNb0MsUUFBTSxDQUFDOUMsSUFBR2tCLElBQUcsVUFBVVksVUFBUTlCLElBQUdrQixJQUFHLEtBQUssS0FBSztBQUNyRCxJQUFBLFFBQWlCNEI7QUNGakIsTUFBTWYsT0FBS3JCO0FBQ1gsTUFBTWtDLFFBQU1qQztBQUNaLE1BQU0rQixPQUFLdEI7QUFDWCxNQUFNeUIsUUFBTXhCO0FBQ1osTUFBTXNCLE9BQUtyQjtBQUNYLE1BQU13QixRQUFNQztBQUVaLE1BQU1DLFFBQU0sQ0FBQ2hELElBQUcsSUFBSWtCLElBQUcsVUFBVTtBQUMvQixVQUFRLElBQUU7QUFBQSxJQUNSLEtBQUs7QUFDSCxVQUFJLE9BQU9sQixPQUFNLFVBQVU7QUFDekIsUUFBQUEsS0FBSUEsR0FBRTtBQUFBLE1BQ1A7QUFDRCxVQUFJLE9BQU9rQixPQUFNLFVBQVU7QUFDekIsUUFBQUEsS0FBSUEsR0FBRTtBQUFBLE1BQ1A7QUFDRCxhQUFPbEIsT0FBTWtCO0FBQUEsSUFFZixLQUFLO0FBQ0gsVUFBSSxPQUFPbEIsT0FBTSxVQUFVO0FBQ3pCLFFBQUFBLEtBQUlBLEdBQUU7QUFBQSxNQUNQO0FBQ0QsVUFBSSxPQUFPa0IsT0FBTSxVQUFVO0FBQ3pCLFFBQUFBLEtBQUlBLEdBQUU7QUFBQSxNQUNQO0FBQ0QsYUFBT2xCLE9BQU1rQjtBQUFBLElBRWYsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUNILGFBQU9hLEtBQUcvQixJQUFHa0IsSUFBRyxLQUFLO0FBQUEsSUFFdkIsS0FBSztBQUNILGFBQU8wQixNQUFJNUMsSUFBR2tCLElBQUcsS0FBSztBQUFBLElBRXhCLEtBQUs7QUFDSCxhQUFPd0IsS0FBRzFDLElBQUdrQixJQUFHLEtBQUs7QUFBQSxJQUV2QixLQUFLO0FBQ0gsYUFBTzJCLE1BQUk3QyxJQUFHa0IsSUFBRyxLQUFLO0FBQUEsSUFFeEIsS0FBSztBQUNILGFBQU95QixLQUFHM0MsSUFBR2tCLElBQUcsS0FBSztBQUFBLElBRXZCLEtBQUs7QUFDSCxhQUFPNEIsTUFBSTlDLElBQUdrQixJQUFHLEtBQUs7QUFBQSxJQUV4QjtBQUNFLFlBQU0sSUFBSSxVQUFVLHFCQUFxQixJQUFJO0FBQUEsRUFDaEQ7QUFDSDtBQUNBLElBQUEsUUFBaUI4QjtBQ25EakIsTUFBTXpCLFdBQVNiO0FBQ2YsTUFBTWdCLFVBQVFmO0FBQ2QsTUFBTSxFQUFFLElBQUksRUFBQyxJQUFLUztBQUVsQixNQUFNNkIsV0FBUyxDQUFDekIsVUFBUyxZQUFZO0FBQ25DLE1BQUlBLG9CQUFtQkQsVUFBUTtBQUM3QixXQUFPQztBQUFBLEVBQ1I7QUFFRCxNQUFJLE9BQU9BLGFBQVksVUFBVTtBQUMvQixJQUFBQSxXQUFVLE9BQU9BLFFBQU87QUFBQSxFQUN6QjtBQUVELE1BQUksT0FBT0EsYUFBWSxVQUFVO0FBQy9CLFdBQU87QUFBQSxFQUNSO0FBRUQsWUFBVSxXQUFXLENBQUU7QUFFdkIsTUFBSSxRQUFRO0FBQ1osTUFBSSxDQUFDLFFBQVEsS0FBSztBQUNoQixZQUFRQSxTQUFRLE1BQU0sR0FBRyxFQUFFLE1BQU0sQ0FBQztBQUFBLEVBQ3RDLE9BQVM7QUFTTCxRQUFJO0FBQ0osWUFBUSxPQUFPLEdBQUcsRUFBRSxTQUFTLEVBQUUsS0FBS0EsUUFBTyxPQUN0QyxDQUFDLFNBQVMsTUFBTSxRQUFRLE1BQU0sQ0FBQyxFQUFFLFdBQVdBLFNBQVEsU0FDdkQ7QUFDQSxVQUFJLENBQUMsU0FDQyxLQUFLLFFBQVEsS0FBSyxDQUFDLEVBQUUsV0FBVyxNQUFNLFFBQVEsTUFBTSxDQUFDLEVBQUUsUUFBUTtBQUNuRSxnQkFBUTtBQUFBLE1BQ1Q7QUFDRCxTQUFHLEVBQUUsU0FBUyxFQUFFLFlBQVksS0FBSyxRQUFRLEtBQUssQ0FBQyxFQUFFLFNBQVMsS0FBSyxDQUFDLEVBQUU7QUFBQSxJQUNuRTtBQUVELE9BQUcsRUFBRSxTQUFTLEVBQUUsWUFBWTtBQUFBLEVBQzdCO0FBRUQsTUFBSSxVQUFVLE1BQU07QUFDbEIsV0FBTztBQUFBLEVBQ1I7QUFFRCxTQUFPRSxRQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssTUFBTSxDQUFDLEtBQUssT0FBTyxNQUFNLENBQUMsS0FBSyxPQUFPLE9BQU87QUFDM0U7QUFDQSxJQUFBLFdBQWlCdUI7Ozs7Ozs7QUNsREgsYUFBRyxTQUFVLFNBQVM7QUFDbEMsWUFBUSxVQUFVLE9BQU8sUUFBUSxJQUFJLGFBQWE7QUFDaEQsZUFBUyxTQUFTLEtBQUssTUFBTSxRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQ3pELGNBQU0sT0FBTztBQUFBLE1BQ2Q7QUFBQSxJQUNGO0FBQUEsRUFDSDs7Ozs7Ozs7O0FDTkEsWUFBaUI7QUFFakIsVUFBUSxPQUFPO0FBQ2YsVUFBUSxTQUFTO0FBRWpCLFdBQVMsUUFBUyxNQUFNO0FBQ3RCLFFBQUlDLFFBQU87QUFDWCxRQUFJLEVBQUVBLGlCQUFnQixVQUFVO0FBQzlCLE1BQUFBLFFBQU8sSUFBSSxRQUFTO0FBQUEsSUFDckI7QUFFRCxJQUFBQSxNQUFLLE9BQU87QUFDWixJQUFBQSxNQUFLLE9BQU87QUFDWixJQUFBQSxNQUFLLFNBQVM7QUFFZCxRQUFJLFFBQVEsT0FBTyxLQUFLLFlBQVksWUFBWTtBQUM5QyxXQUFLLFFBQVEsU0FBVSxNQUFNO0FBQzNCLFFBQUFBLE1BQUssS0FBSyxJQUFJO0FBQUEsTUFDcEIsQ0FBSztBQUFBLElBQ0wsV0FBYSxVQUFVLFNBQVMsR0FBRztBQUMvQixlQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUNoRCxRQUFBQSxNQUFLLEtBQUssVUFBVSxDQUFDLENBQUM7QUFBQSxNQUN2QjtBQUFBLElBQ0Y7QUFFRCxXQUFPQTtBQUFBLEVBQ1I7QUFFRCxVQUFRLFVBQVUsYUFBYSxTQUFVLE1BQU07QUFDN0MsUUFBSSxLQUFLLFNBQVMsTUFBTTtBQUN0QixZQUFNLElBQUksTUFBTSxrREFBa0Q7QUFBQSxJQUNuRTtBQUVELFFBQUksT0FBTyxLQUFLO0FBQ2hCLFFBQUksT0FBTyxLQUFLO0FBRWhCLFFBQUksTUFBTTtBQUNSLFdBQUssT0FBTztBQUFBLElBQ2I7QUFFRCxRQUFJLE1BQU07QUFDUixXQUFLLE9BQU87QUFBQSxJQUNiO0FBRUQsUUFBSSxTQUFTLEtBQUssTUFBTTtBQUN0QixXQUFLLE9BQU87QUFBQSxJQUNiO0FBQ0QsUUFBSSxTQUFTLEtBQUssTUFBTTtBQUN0QixXQUFLLE9BQU87QUFBQSxJQUNiO0FBRUQsU0FBSyxLQUFLO0FBQ1YsU0FBSyxPQUFPO0FBQ1osU0FBSyxPQUFPO0FBQ1osU0FBSyxPQUFPO0FBRVosV0FBTztBQUFBLEVBQ1I7QUFFRCxVQUFRLFVBQVUsY0FBYyxTQUFVLE1BQU07QUFDOUMsUUFBSSxTQUFTLEtBQUssTUFBTTtBQUN0QjtBQUFBLElBQ0Q7QUFFRCxRQUFJLEtBQUssTUFBTTtBQUNiLFdBQUssS0FBSyxXQUFXLElBQUk7QUFBQSxJQUMxQjtBQUVELFFBQUksT0FBTyxLQUFLO0FBQ2hCLFNBQUssT0FBTztBQUNaLFNBQUssT0FBTztBQUNaLFFBQUksTUFBTTtBQUNSLFdBQUssT0FBTztBQUFBLElBQ2I7QUFFRCxTQUFLLE9BQU87QUFDWixRQUFJLENBQUMsS0FBSyxNQUFNO0FBQ2QsV0FBSyxPQUFPO0FBQUEsSUFDYjtBQUNELFNBQUs7QUFBQSxFQUNOO0FBRUQsVUFBUSxVQUFVLFdBQVcsU0FBVSxNQUFNO0FBQzNDLFFBQUksU0FBUyxLQUFLLE1BQU07QUFDdEI7QUFBQSxJQUNEO0FBRUQsUUFBSSxLQUFLLE1BQU07QUFDYixXQUFLLEtBQUssV0FBVyxJQUFJO0FBQUEsSUFDMUI7QUFFRCxRQUFJLE9BQU8sS0FBSztBQUNoQixTQUFLLE9BQU87QUFDWixTQUFLLE9BQU87QUFDWixRQUFJLE1BQU07QUFDUixXQUFLLE9BQU87QUFBQSxJQUNiO0FBRUQsU0FBSyxPQUFPO0FBQ1osUUFBSSxDQUFDLEtBQUssTUFBTTtBQUNkLFdBQUssT0FBTztBQUFBLElBQ2I7QUFDRCxTQUFLO0FBQUEsRUFDTjtBQUVELFVBQVEsVUFBVSxPQUFPLFdBQVk7QUFDbkMsYUFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDaEQsV0FBSyxNQUFNLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDeEI7QUFDRCxXQUFPLEtBQUs7QUFBQSxFQUNiO0FBRUQsVUFBUSxVQUFVLFVBQVUsV0FBWTtBQUN0QyxhQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUNoRCxjQUFRLE1BQU0sVUFBVSxDQUFDLENBQUM7QUFBQSxJQUMzQjtBQUNELFdBQU8sS0FBSztBQUFBLEVBQ2I7QUFFRCxVQUFRLFVBQVUsTUFBTSxXQUFZO0FBQ2xDLFFBQUksQ0FBQyxLQUFLLE1BQU07QUFDZCxhQUFPO0FBQUEsSUFDUjtBQUVELFFBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEIsU0FBSyxPQUFPLEtBQUssS0FBSztBQUN0QixRQUFJLEtBQUssTUFBTTtBQUNiLFdBQUssS0FBSyxPQUFPO0FBQUEsSUFDckIsT0FBUztBQUNMLFdBQUssT0FBTztBQUFBLElBQ2I7QUFDRCxTQUFLO0FBQ0wsV0FBTztBQUFBLEVBQ1I7QUFFRCxVQUFRLFVBQVUsUUFBUSxXQUFZO0FBQ3BDLFFBQUksQ0FBQyxLQUFLLE1BQU07QUFDZCxhQUFPO0FBQUEsSUFDUjtBQUVELFFBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEIsU0FBSyxPQUFPLEtBQUssS0FBSztBQUN0QixRQUFJLEtBQUssTUFBTTtBQUNiLFdBQUssS0FBSyxPQUFPO0FBQUEsSUFDckIsT0FBUztBQUNMLFdBQUssT0FBTztBQUFBLElBQ2I7QUFDRCxTQUFLO0FBQ0wsV0FBTztBQUFBLEVBQ1I7QUFFRCxVQUFRLFVBQVUsVUFBVSxTQUFVLElBQUksT0FBTztBQUMvQyxZQUFRLFNBQVM7QUFDakIsYUFBUyxTQUFTLEtBQUssTUFBTSxJQUFJLEdBQUcsV0FBVyxNQUFNLEtBQUs7QUFDeEQsU0FBRyxLQUFLLE9BQU8sT0FBTyxPQUFPLEdBQUcsSUFBSTtBQUNwQyxlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUFBLEVBQ0Y7QUFFRCxVQUFRLFVBQVUsaUJBQWlCLFNBQVUsSUFBSSxPQUFPO0FBQ3RELFlBQVEsU0FBUztBQUNqQixhQUFTLFNBQVMsS0FBSyxNQUFNLElBQUksS0FBSyxTQUFTLEdBQUcsV0FBVyxNQUFNLEtBQUs7QUFDdEUsU0FBRyxLQUFLLE9BQU8sT0FBTyxPQUFPLEdBQUcsSUFBSTtBQUNwQyxlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUFBLEVBQ0Y7QUFFRCxVQUFRLFVBQVUsTUFBTSxTQUFVLEdBQUc7QUFDbkMsYUFBUyxJQUFJLEdBQUcsU0FBUyxLQUFLLE1BQU0sV0FBVyxRQUFRLElBQUksR0FBRyxLQUFLO0FBRWpFLGVBQVMsT0FBTztBQUFBLElBQ2pCO0FBQ0QsUUFBSSxNQUFNLEtBQUssV0FBVyxNQUFNO0FBQzlCLGFBQU8sT0FBTztBQUFBLElBQ2Y7QUFBQSxFQUNGO0FBRUQsVUFBUSxVQUFVLGFBQWEsU0FBVSxHQUFHO0FBQzFDLGFBQVMsSUFBSSxHQUFHLFNBQVMsS0FBSyxNQUFNLFdBQVcsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUVqRSxlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUNELFFBQUksTUFBTSxLQUFLLFdBQVcsTUFBTTtBQUM5QixhQUFPLE9BQU87QUFBQSxJQUNmO0FBQUEsRUFDRjtBQUVELFVBQVEsVUFBVSxNQUFNLFNBQVUsSUFBSSxPQUFPO0FBQzNDLFlBQVEsU0FBUztBQUNqQixRQUFJLE1BQU0sSUFBSSxRQUFTO0FBQ3ZCLGFBQVMsU0FBUyxLQUFLLE1BQU0sV0FBVyxRQUFPO0FBQzdDLFVBQUksS0FBSyxHQUFHLEtBQUssT0FBTyxPQUFPLE9BQU8sSUFBSSxDQUFDO0FBQzNDLGVBQVMsT0FBTztBQUFBLElBQ2pCO0FBQ0QsV0FBTztBQUFBLEVBQ1I7QUFFRCxVQUFRLFVBQVUsYUFBYSxTQUFVLElBQUksT0FBTztBQUNsRCxZQUFRLFNBQVM7QUFDakIsUUFBSSxNQUFNLElBQUksUUFBUztBQUN2QixhQUFTLFNBQVMsS0FBSyxNQUFNLFdBQVcsUUFBTztBQUM3QyxVQUFJLEtBQUssR0FBRyxLQUFLLE9BQU8sT0FBTyxPQUFPLElBQUksQ0FBQztBQUMzQyxlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUNELFdBQU87QUFBQSxFQUNSO0FBRUQsVUFBUSxVQUFVLFNBQVMsU0FBVSxJQUFJLFNBQVM7QUFDaEQsUUFBSTtBQUNKLFFBQUksU0FBUyxLQUFLO0FBQ2xCLFFBQUksVUFBVSxTQUFTLEdBQUc7QUFDeEIsWUFBTTtBQUFBLElBQ1YsV0FBYSxLQUFLLE1BQU07QUFDcEIsZUFBUyxLQUFLLEtBQUs7QUFDbkIsWUFBTSxLQUFLLEtBQUs7QUFBQSxJQUNwQixPQUFTO0FBQ0wsWUFBTSxJQUFJLFVBQVUsNENBQTRDO0FBQUEsSUFDakU7QUFFRCxhQUFTLElBQUksR0FBRyxXQUFXLE1BQU0sS0FBSztBQUNwQyxZQUFNLEdBQUcsS0FBSyxPQUFPLE9BQU8sQ0FBQztBQUM3QixlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUVELFdBQU87QUFBQSxFQUNSO0FBRUQsVUFBUSxVQUFVLGdCQUFnQixTQUFVLElBQUksU0FBUztBQUN2RCxRQUFJO0FBQ0osUUFBSSxTQUFTLEtBQUs7QUFDbEIsUUFBSSxVQUFVLFNBQVMsR0FBRztBQUN4QixZQUFNO0FBQUEsSUFDVixXQUFhLEtBQUssTUFBTTtBQUNwQixlQUFTLEtBQUssS0FBSztBQUNuQixZQUFNLEtBQUssS0FBSztBQUFBLElBQ3BCLE9BQVM7QUFDTCxZQUFNLElBQUksVUFBVSw0Q0FBNEM7QUFBQSxJQUNqRTtBQUVELGFBQVMsSUFBSSxLQUFLLFNBQVMsR0FBRyxXQUFXLE1BQU0sS0FBSztBQUNsRCxZQUFNLEdBQUcsS0FBSyxPQUFPLE9BQU8sQ0FBQztBQUM3QixlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUVELFdBQU87QUFBQSxFQUNSO0FBRUQsVUFBUSxVQUFVLFVBQVUsV0FBWTtBQUN0QyxRQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTTtBQUMvQixhQUFTLElBQUksR0FBRyxTQUFTLEtBQUssTUFBTSxXQUFXLE1BQU0sS0FBSztBQUN4RCxVQUFJLENBQUMsSUFBSSxPQUFPO0FBQ2hCLGVBQVMsT0FBTztBQUFBLElBQ2pCO0FBQ0QsV0FBTztBQUFBLEVBQ1I7QUFFRCxVQUFRLFVBQVUsaUJBQWlCLFdBQVk7QUFDN0MsUUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU07QUFDL0IsYUFBUyxJQUFJLEdBQUcsU0FBUyxLQUFLLE1BQU0sV0FBVyxNQUFNLEtBQUs7QUFDeEQsVUFBSSxDQUFDLElBQUksT0FBTztBQUNoQixlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUNELFdBQU87QUFBQSxFQUNSO0FBRUQsVUFBUSxVQUFVLFFBQVEsU0FBVSxNQUFNLElBQUk7QUFDNUMsU0FBSyxNQUFNLEtBQUs7QUFDaEIsUUFBSSxLQUFLLEdBQUc7QUFDVixZQUFNLEtBQUs7QUFBQSxJQUNaO0FBQ0QsV0FBTyxRQUFRO0FBQ2YsUUFBSSxPQUFPLEdBQUc7QUFDWixjQUFRLEtBQUs7QUFBQSxJQUNkO0FBQ0QsUUFBSSxNQUFNLElBQUksUUFBUztBQUN2QixRQUFJLEtBQUssUUFBUSxLQUFLLEdBQUc7QUFDdkIsYUFBTztBQUFBLElBQ1I7QUFDRCxRQUFJLE9BQU8sR0FBRztBQUNaLGFBQU87QUFBQSxJQUNSO0FBQ0QsUUFBSSxLQUFLLEtBQUssUUFBUTtBQUNwQixXQUFLLEtBQUs7QUFBQSxJQUNYO0FBQ0QsYUFBUyxJQUFJLEdBQUcsU0FBUyxLQUFLLE1BQU0sV0FBVyxRQUFRLElBQUksTUFBTSxLQUFLO0FBQ3BFLGVBQVMsT0FBTztBQUFBLElBQ2pCO0FBQ0QsV0FBTyxXQUFXLFFBQVEsSUFBSSxJQUFJLEtBQUssU0FBUyxPQUFPLE1BQU07QUFDM0QsVUFBSSxLQUFLLE9BQU8sS0FBSztBQUFBLElBQ3RCO0FBQ0QsV0FBTztBQUFBLEVBQ1I7QUFFRCxVQUFRLFVBQVUsZUFBZSxTQUFVLE1BQU0sSUFBSTtBQUNuRCxTQUFLLE1BQU0sS0FBSztBQUNoQixRQUFJLEtBQUssR0FBRztBQUNWLFlBQU0sS0FBSztBQUFBLElBQ1o7QUFDRCxXQUFPLFFBQVE7QUFDZixRQUFJLE9BQU8sR0FBRztBQUNaLGNBQVEsS0FBSztBQUFBLElBQ2Q7QUFDRCxRQUFJLE1BQU0sSUFBSSxRQUFTO0FBQ3ZCLFFBQUksS0FBSyxRQUFRLEtBQUssR0FBRztBQUN2QixhQUFPO0FBQUEsSUFDUjtBQUNELFFBQUksT0FBTyxHQUFHO0FBQ1osYUFBTztBQUFBLElBQ1I7QUFDRCxRQUFJLEtBQUssS0FBSyxRQUFRO0FBQ3BCLFdBQUssS0FBSztBQUFBLElBQ1g7QUFDRCxhQUFTLElBQUksS0FBSyxRQUFRLFNBQVMsS0FBSyxNQUFNLFdBQVcsUUFBUSxJQUFJLElBQUksS0FBSztBQUM1RSxlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUNELFdBQU8sV0FBVyxRQUFRLElBQUksTUFBTSxLQUFLLFNBQVMsT0FBTyxNQUFNO0FBQzdELFVBQUksS0FBSyxPQUFPLEtBQUs7QUFBQSxJQUN0QjtBQUNELFdBQU87QUFBQSxFQUNSO0FBRUQsVUFBUSxVQUFVLFNBQVMsU0FBVSxPQUFPLGdCQUFnQixPQUFPO0FBQ2pFLFFBQUksUUFBUSxLQUFLLFFBQVE7QUFDdkIsY0FBUSxLQUFLLFNBQVM7QUFBQSxJQUN2QjtBQUNELFFBQUksUUFBUSxHQUFHO0FBQ2IsY0FBUSxLQUFLLFNBQVM7QUFBQSxJQUN2QjtBQUVELGFBQVMsSUFBSSxHQUFHLFNBQVMsS0FBSyxNQUFNLFdBQVcsUUFBUSxJQUFJLE9BQU8sS0FBSztBQUNyRSxlQUFTLE9BQU87QUFBQSxJQUNqQjtBQUVELFFBQUksTUFBTSxDQUFFO0FBQ1osYUFBUyxJQUFJLEdBQUcsVUFBVSxJQUFJLGFBQWEsS0FBSztBQUM5QyxVQUFJLEtBQUssT0FBTyxLQUFLO0FBQ3JCLGVBQVMsS0FBSyxXQUFXLE1BQU07QUFBQSxJQUNoQztBQUNELFFBQUksV0FBVyxNQUFNO0FBQ25CLGVBQVMsS0FBSztBQUFBLElBQ2Y7QUFFRCxRQUFJLFdBQVcsS0FBSyxRQUFRLFdBQVcsS0FBSyxNQUFNO0FBQ2hELGVBQVMsT0FBTztBQUFBLElBQ2pCO0FBRUQsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyxlQUFTakUsUUFBTyxNQUFNLFFBQVEsTUFBTSxDQUFDLENBQUM7QUFBQSxJQUN2QztBQUNELFdBQU87QUFBQSxFQUNSO0FBRUQsVUFBUSxVQUFVLFVBQVUsV0FBWTtBQUN0QyxRQUFJLE9BQU8sS0FBSztBQUNoQixRQUFJLE9BQU8sS0FBSztBQUNoQixhQUFTLFNBQVMsTUFBTSxXQUFXLE1BQU0sU0FBUyxPQUFPLE1BQU07QUFDN0QsVUFBSSxJQUFJLE9BQU87QUFDZixhQUFPLE9BQU8sT0FBTztBQUNyQixhQUFPLE9BQU87QUFBQSxJQUNmO0FBQ0QsU0FBSyxPQUFPO0FBQ1osU0FBSyxPQUFPO0FBQ1osV0FBTztBQUFBLEVBQ1I7QUFFRCxXQUFTQSxRQUFRaUUsT0FBTSxNQUFNLE9BQU87QUFDbEMsUUFBSSxXQUFXLFNBQVNBLE1BQUssT0FDM0IsSUFBSSxLQUFLLE9BQU8sTUFBTSxNQUFNQSxLQUFJLElBQ2hDLElBQUksS0FBSyxPQUFPLE1BQU0sS0FBSyxNQUFNQSxLQUFJO0FBRXZDLFFBQUksU0FBUyxTQUFTLE1BQU07QUFDMUIsTUFBQUEsTUFBSyxPQUFPO0FBQUEsSUFDYjtBQUNELFFBQUksU0FBUyxTQUFTLE1BQU07QUFDMUIsTUFBQUEsTUFBSyxPQUFPO0FBQUEsSUFDYjtBQUVELElBQUFBLE1BQUs7QUFFTCxXQUFPO0FBQUEsRUFDUjtBQUVELFdBQVMsS0FBTUEsT0FBTSxNQUFNO0FBQ3pCLElBQUFBLE1BQUssT0FBTyxJQUFJLEtBQUssTUFBTUEsTUFBSyxNQUFNLE1BQU1BLEtBQUk7QUFDaEQsUUFBSSxDQUFDQSxNQUFLLE1BQU07QUFDZCxNQUFBQSxNQUFLLE9BQU9BLE1BQUs7QUFBQSxJQUNsQjtBQUNELElBQUFBLE1BQUs7QUFBQSxFQUNOO0FBRUQsV0FBUyxRQUFTQSxPQUFNLE1BQU07QUFDNUIsSUFBQUEsTUFBSyxPQUFPLElBQUksS0FBSyxNQUFNLE1BQU1BLE1BQUssTUFBTUEsS0FBSTtBQUNoRCxRQUFJLENBQUNBLE1BQUssTUFBTTtBQUNkLE1BQUFBLE1BQUssT0FBT0EsTUFBSztBQUFBLElBQ2xCO0FBQ0QsSUFBQUEsTUFBSztBQUFBLEVBQ047QUFFRCxXQUFTLEtBQU0sT0FBTyxNQUFNLE1BQU0sTUFBTTtBQUN0QyxRQUFJLEVBQUUsZ0JBQWdCLE9BQU87QUFDM0IsYUFBTyxJQUFJLEtBQUssT0FBTyxNQUFNLE1BQU0sSUFBSTtBQUFBLElBQ3hDO0FBRUQsU0FBSyxPQUFPO0FBQ1osU0FBSyxRQUFRO0FBRWIsUUFBSSxNQUFNO0FBQ1IsV0FBSyxPQUFPO0FBQ1osV0FBSyxPQUFPO0FBQUEsSUFDaEIsT0FBUztBQUNMLFdBQUssT0FBTztBQUFBLElBQ2I7QUFFRCxRQUFJLE1BQU07QUFDUixXQUFLLE9BQU87QUFDWixXQUFLLE9BQU87QUFBQSxJQUNoQixPQUFTO0FBQ0wsV0FBSyxPQUFPO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFFRCxNQUFJO0FBRUZ4QyxvQkFBQSxFQUF5QixPQUFPO0FBQUEsV0FDekIsSUFBUDtBQUFBLEVBQVc7Ozs7Ozs7OztBQ3RhYixRQUFNLFVBQVVBLGVBQWtCO0FBRWxDLFFBQU0sTUFBTSxPQUFPLEtBQUs7QUFDeEIsUUFBTSxTQUFTLE9BQU8sUUFBUTtBQUM5QixRQUFNLG9CQUFvQixPQUFPLGtCQUFrQjtBQUNuRCxRQUFNLGNBQWMsT0FBTyxZQUFZO0FBQ3ZDLFFBQU0sVUFBVSxPQUFPLFFBQVE7QUFDL0IsUUFBTSxVQUFVLE9BQU8sU0FBUztBQUNoQyxRQUFNLG9CQUFvQixPQUFPLGdCQUFnQjtBQUNqRCxRQUFNLFdBQVcsT0FBTyxTQUFTO0FBQ2pDLFFBQU0sUUFBUSxPQUFPLE9BQU87QUFDNUIsUUFBTSxvQkFBb0IsT0FBTyxnQkFBZ0I7QUFFakQsUUFBTSxjQUFjLE1BQU07QUFVMUIsUUFBTSxTQUFTO0FBQUEsSUFDYixZQUFhLFNBQVM7QUFDcEIsVUFBSSxPQUFPLFlBQVk7QUFDckIsa0JBQVUsRUFBRSxLQUFLLFFBQVM7QUFFNUIsVUFBSSxDQUFDO0FBQ0gsa0JBQVUsQ0FBRTtBQUVkLFVBQUksUUFBUSxRQUFRLE9BQU8sUUFBUSxRQUFRLFlBQVksUUFBUSxNQUFNO0FBQ25FLGNBQU0sSUFBSSxVQUFVLG1DQUFtQztBQUU3QyxXQUFLLEdBQUcsSUFBSSxRQUFRLE9BQU87QUFFdkMsWUFBTSxLQUFLLFFBQVEsVUFBVTtBQUM3QixXQUFLLGlCQUFpQixJQUFLLE9BQU8sT0FBTyxhQUFjLGNBQWM7QUFDckUsV0FBSyxXQUFXLElBQUksUUFBUSxTQUFTO0FBQ3JDLFVBQUksUUFBUSxVQUFVLE9BQU8sUUFBUSxXQUFXO0FBQzlDLGNBQU0sSUFBSSxVQUFVLHlCQUF5QjtBQUMvQyxXQUFLLE9BQU8sSUFBSSxRQUFRLFVBQVU7QUFDbEMsV0FBSyxPQUFPLElBQUksUUFBUTtBQUN4QixXQUFLLGlCQUFpQixJQUFJLFFBQVEsa0JBQWtCO0FBQ3BELFdBQUssaUJBQWlCLElBQUksUUFBUSxrQkFBa0I7QUFDcEQsV0FBSyxNQUFPO0FBQUEsSUFDYjtBQUFBO0FBQUEsSUFHRCxJQUFJLElBQUssSUFBSTtBQUNYLFVBQUksT0FBTyxPQUFPLFlBQVksS0FBSztBQUNqQyxjQUFNLElBQUksVUFBVSxtQ0FBbUM7QUFFekQsV0FBSyxHQUFHLElBQUksTUFBTTtBQUNsQixNQUFBeUMsTUFBSyxJQUFJO0FBQUEsSUFDVjtBQUFBLElBQ0QsSUFBSSxNQUFPO0FBQ1QsYUFBTyxLQUFLLEdBQUc7QUFBQSxJQUNoQjtBQUFBLElBRUQsSUFBSSxXQUFZLFlBQVk7QUFDMUIsV0FBSyxXQUFXLElBQUksQ0FBQyxDQUFDO0FBQUEsSUFDdkI7QUFBQSxJQUNELElBQUksYUFBYztBQUNoQixhQUFPLEtBQUssV0FBVztBQUFBLElBQ3hCO0FBQUEsSUFFRCxJQUFJLE9BQVEsSUFBSTtBQUNkLFVBQUksT0FBTyxPQUFPO0FBQ2hCLGNBQU0sSUFBSSxVQUFVLHNDQUFzQztBQUU1RCxXQUFLLE9BQU8sSUFBSTtBQUNoQixNQUFBQSxNQUFLLElBQUk7QUFBQSxJQUNWO0FBQUEsSUFDRCxJQUFJLFNBQVU7QUFDWixhQUFPLEtBQUssT0FBTztBQUFBLElBQ3BCO0FBQUE7QUFBQSxJQUdELElBQUksaUJBQWtCLElBQUk7QUFDeEIsVUFBSSxPQUFPLE9BQU87QUFDaEIsYUFBSztBQUVQLFVBQUksT0FBTyxLQUFLLGlCQUFpQixHQUFHO0FBQ2xDLGFBQUssaUJBQWlCLElBQUk7QUFDMUIsYUFBSyxNQUFNLElBQUk7QUFDZixhQUFLLFFBQVEsRUFBRSxRQUFRLFNBQU87QUFDNUIsY0FBSSxTQUFTLEtBQUssaUJBQWlCLEVBQUUsSUFBSSxPQUFPLElBQUksR0FBRztBQUN2RCxlQUFLLE1BQU0sS0FBSyxJQUFJO0FBQUEsUUFDNUIsQ0FBTztBQUFBLE1BQ0Y7QUFDRCxNQUFBQSxNQUFLLElBQUk7QUFBQSxJQUNWO0FBQUEsSUFDRCxJQUFJLG1CQUFvQjtBQUFFLGFBQU8sS0FBSyxpQkFBaUI7QUFBQSxJQUFHO0FBQUEsSUFFMUQsSUFBSSxTQUFVO0FBQUUsYUFBTyxLQUFLLE1BQU07QUFBQSxJQUFHO0FBQUEsSUFDckMsSUFBSSxZQUFhO0FBQUUsYUFBTyxLQUFLLFFBQVEsRUFBRTtBQUFBLElBQVE7QUFBQSxJQUVqRCxTQUFVLElBQUksT0FBTztBQUNuQixjQUFRLFNBQVM7QUFDakIsZUFBUyxTQUFTLEtBQUssUUFBUSxFQUFFLE1BQU0sV0FBVyxRQUFPO0FBQ3ZELGNBQU0sT0FBTyxPQUFPO0FBQ3BCLG9CQUFZLE1BQU0sSUFBSSxRQUFRLEtBQUs7QUFDbkMsaUJBQVM7QUFBQSxNQUNWO0FBQUEsSUFDRjtBQUFBLElBRUQsUUFBUyxJQUFJLE9BQU87QUFDbEIsY0FBUSxTQUFTO0FBQ2pCLGVBQVMsU0FBUyxLQUFLLFFBQVEsRUFBRSxNQUFNLFdBQVcsUUFBTztBQUN2RCxjQUFNLE9BQU8sT0FBTztBQUNwQixvQkFBWSxNQUFNLElBQUksUUFBUSxLQUFLO0FBQ25DLGlCQUFTO0FBQUEsTUFDVjtBQUFBLElBQ0Y7QUFBQSxJQUVELE9BQVE7QUFDTixhQUFPLEtBQUssUUFBUSxFQUFFLFFBQU8sRUFBRyxJQUFJLENBQUF4RSxPQUFLQSxHQUFFLEdBQUc7QUFBQSxJQUMvQztBQUFBLElBRUQsU0FBVTtBQUNSLGFBQU8sS0FBSyxRQUFRLEVBQUUsUUFBTyxFQUFHLElBQUksQ0FBQUEsT0FBS0EsR0FBRSxLQUFLO0FBQUEsSUFDakQ7QUFBQSxJQUVELFFBQVM7QUFDUCxVQUFJLEtBQUssT0FBTyxLQUNaLEtBQUssUUFBUSxLQUNiLEtBQUssUUFBUSxFQUFFLFFBQVE7QUFDekIsYUFBSyxRQUFRLEVBQUUsUUFBUSxTQUFPLEtBQUssT0FBTyxFQUFFLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQztBQUFBLE1BQ2hFO0FBRUQsV0FBSyxLQUFLLElBQUksb0JBQUksSUFBSztBQUN2QixXQUFLLFFBQVEsSUFBSSxJQUFJLFFBQVM7QUFDOUIsV0FBSyxNQUFNLElBQUk7QUFBQSxJQUNoQjtBQUFBLElBRUQsT0FBUTtBQUNOLGFBQU8sS0FBSyxRQUFRLEVBQUUsSUFBSSxTQUN4QixRQUFRLE1BQU0sR0FBRyxJQUFJLFFBQVE7QUFBQSxRQUMzQixHQUFHLElBQUk7QUFBQSxRQUNQLEdBQUcsSUFBSTtBQUFBLFFBQ1AsR0FBRyxJQUFJLE9BQU8sSUFBSSxVQUFVO0FBQUEsTUFDN0IsQ0FBQSxFQUFFLFFBQVMsRUFBQyxPQUFPLE9BQUssQ0FBQztBQUFBLElBQzdCO0FBQUEsSUFFRCxVQUFXO0FBQ1QsYUFBTyxLQUFLLFFBQVE7QUFBQSxJQUNyQjtBQUFBLElBRUQsSUFBSyxLQUFLLE9BQU8sUUFBUTtBQUN2QixlQUFTLFVBQVUsS0FBSyxPQUFPO0FBRS9CLFVBQUksVUFBVSxPQUFPLFdBQVc7QUFDOUIsY0FBTSxJQUFJLFVBQVUseUJBQXlCO0FBRS9DLFlBQU0sTUFBTSxTQUFTLEtBQUssSUFBSyxJQUFHO0FBQ2xDLFlBQU0sTUFBTSxLQUFLLGlCQUFpQixFQUFFLE9BQU8sR0FBRztBQUU5QyxVQUFJLEtBQUssS0FBSyxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ3hCLFlBQUksTUFBTSxLQUFLLEdBQUcsR0FBRztBQUNuQixjQUFJLE1BQU0sS0FBSyxLQUFLLEVBQUUsSUFBSSxHQUFHLENBQUM7QUFDOUIsaUJBQU87QUFBQSxRQUNSO0FBRUQsY0FBTSxPQUFPLEtBQUssS0FBSyxFQUFFLElBQUksR0FBRztBQUNoQyxjQUFNLE9BQU8sS0FBSztBQUlsQixZQUFJLEtBQUssT0FBTyxHQUFHO0FBQ2pCLGNBQUksQ0FBQyxLQUFLLGlCQUFpQjtBQUN6QixpQkFBSyxPQUFPLEVBQUUsS0FBSyxLQUFLLEtBQUs7QUFBQSxRQUNoQztBQUVELGFBQUssTUFBTTtBQUNYLGFBQUssU0FBUztBQUNkLGFBQUssUUFBUTtBQUNiLGFBQUssTUFBTSxLQUFLLE1BQU0sS0FBSztBQUMzQixhQUFLLFNBQVM7QUFDZCxhQUFLLElBQUksR0FBRztBQUNaLFFBQUF3RSxNQUFLLElBQUk7QUFDVCxlQUFPO0FBQUEsTUFDUjtBQUVELFlBQU0sTUFBTSxJQUFJLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNO0FBR2xELFVBQUksSUFBSSxTQUFTLEtBQUssR0FBRyxHQUFHO0FBQzFCLFlBQUksS0FBSyxPQUFPO0FBQ2QsZUFBSyxPQUFPLEVBQUUsS0FBSyxLQUFLO0FBRTFCLGVBQU87QUFBQSxNQUNSO0FBRUQsV0FBSyxNQUFNLEtBQUssSUFBSTtBQUNwQixXQUFLLFFBQVEsRUFBRSxRQUFRLEdBQUc7QUFDMUIsV0FBSyxLQUFLLEVBQUUsSUFBSSxLQUFLLEtBQUssUUFBUSxFQUFFLElBQUk7QUFDeEMsTUFBQUEsTUFBSyxJQUFJO0FBQ1QsYUFBTztBQUFBLElBQ1I7QUFBQSxJQUVELElBQUssS0FBSztBQUNSLFVBQUksQ0FBQyxLQUFLLEtBQUssRUFBRSxJQUFJLEdBQUc7QUFBRyxlQUFPO0FBQ2xDLFlBQU0sTUFBTSxLQUFLLEtBQUssRUFBRSxJQUFJLEdBQUcsRUFBRTtBQUNqQyxhQUFPLENBQUMsUUFBUSxNQUFNLEdBQUc7QUFBQSxJQUMxQjtBQUFBLElBRUQsSUFBSyxLQUFLO0FBQ1IsYUFBTyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQUEsSUFDM0I7QUFBQSxJQUVELEtBQU0sS0FBSztBQUNULGFBQU8sSUFBSSxNQUFNLEtBQUssS0FBSztBQUFBLElBQzVCO0FBQUEsSUFFRCxNQUFPO0FBQ0wsWUFBTSxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQzVCLFVBQUksQ0FBQztBQUNILGVBQU87QUFFVCxVQUFJLE1BQU0sSUFBSTtBQUNkLGFBQU8sS0FBSztBQUFBLElBQ2I7QUFBQSxJQUVELElBQUssS0FBSztBQUNSLFVBQUksTUFBTSxLQUFLLEtBQUssRUFBRSxJQUFJLEdBQUcsQ0FBQztBQUFBLElBQy9CO0FBQUEsSUFFRCxLQUFNLEtBQUs7QUFFVCxXQUFLLE1BQU87QUFFWixZQUFNLE1BQU0sS0FBSyxJQUFLO0FBRXRCLGVBQVMsSUFBSSxJQUFJLFNBQVMsR0FBRyxLQUFLLEdBQUcsS0FBSztBQUN4QyxjQUFNLE1BQU0sSUFBSSxDQUFDO0FBQ2pCLGNBQU0sWUFBWSxJQUFJLEtBQUs7QUFDM0IsWUFBSSxjQUFjO0FBRWhCLGVBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQUEsYUFDbEI7QUFDSCxnQkFBTSxTQUFTLFlBQVk7QUFFM0IsY0FBSSxTQUFTLEdBQUc7QUFDZCxpQkFBSyxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsTUFBTTtBQUFBLFVBQzlCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsSUFFRCxRQUFTO0FBQ1AsV0FBSyxLQUFLLEVBQUUsUUFBUSxDQUFDLE9BQU8sUUFBUSxJQUFJLE1BQU0sS0FBSyxLQUFLLENBQUM7QUFBQSxJQUMxRDtBQUFBLEVBQ0Y7QUFFRCxRQUFNLE1BQU0sQ0FBQ0QsT0FBTSxLQUFLLFVBQVU7QUFDaEMsVUFBTSxPQUFPQSxNQUFLLEtBQUssRUFBRSxJQUFJLEdBQUc7QUFDaEMsUUFBSSxNQUFNO0FBQ1IsWUFBTSxNQUFNLEtBQUs7QUFDakIsVUFBSSxRQUFRQSxPQUFNLEdBQUcsR0FBRztBQUN0QixZQUFJQSxPQUFNLElBQUk7QUFDZCxZQUFJLENBQUNBLE1BQUssV0FBVztBQUNuQixpQkFBTztBQUFBLE1BQ2YsT0FBVztBQUNMLFlBQUksT0FBTztBQUNULGNBQUlBLE1BQUssaUJBQWlCO0FBQ3hCLGlCQUFLLE1BQU0sTUFBTSxLQUFLLElBQUs7QUFDN0IsVUFBQUEsTUFBSyxRQUFRLEVBQUUsWUFBWSxJQUFJO0FBQUEsUUFDaEM7QUFBQSxNQUNGO0FBQ0QsYUFBTyxJQUFJO0FBQUEsSUFDWjtBQUFBLEVBQ0Y7QUFFRCxRQUFNLFVBQVUsQ0FBQ0EsT0FBTSxRQUFRO0FBQzdCLFFBQUksQ0FBQyxPQUFRLENBQUMsSUFBSSxVQUFVLENBQUNBLE1BQUssT0FBTztBQUN2QyxhQUFPO0FBRVQsVUFBTWxCLFFBQU8sS0FBSyxJQUFLLElBQUcsSUFBSTtBQUM5QixXQUFPLElBQUksU0FBU0EsUUFBTyxJQUFJLFNBQzNCa0IsTUFBSyxPQUFPLEtBQU1sQixRQUFPa0IsTUFBSyxPQUFPO0FBQUEsRUFDMUM7QUFFRCxRQUFNQyxRQUFPLENBQUFELFVBQVE7QUFDbkIsUUFBSUEsTUFBSyxNQUFNLElBQUlBLE1BQUssR0FBRyxHQUFHO0FBQzVCLGVBQVMsU0FBU0EsTUFBSyxRQUFRLEVBQUUsTUFDL0JBLE1BQUssTUFBTSxJQUFJQSxNQUFLLEdBQUcsS0FBSyxXQUFXLFFBQU87QUFJOUMsY0FBTSxPQUFPLE9BQU87QUFDcEIsWUFBSUEsT0FBTSxNQUFNO0FBQ2hCLGlCQUFTO0FBQUEsTUFDVjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUQsUUFBTSxNQUFNLENBQUNBLE9BQU0sU0FBUztBQUMxQixRQUFJLE1BQU07QUFDUixZQUFNLE1BQU0sS0FBSztBQUNqQixVQUFJQSxNQUFLLE9BQU87QUFDZCxRQUFBQSxNQUFLLE9BQU8sRUFBRSxJQUFJLEtBQUssSUFBSSxLQUFLO0FBRWxDLE1BQUFBLE1BQUssTUFBTSxLQUFLLElBQUk7QUFDcEIsTUFBQUEsTUFBSyxLQUFLLEVBQUUsT0FBTyxJQUFJLEdBQUc7QUFDMUIsTUFBQUEsTUFBSyxRQUFRLEVBQUUsV0FBVyxJQUFJO0FBQUEsSUFDL0I7QUFBQSxFQUNGO0FBRUQsUUFBTSxNQUFNO0FBQUEsSUFDVixZQUFhLEtBQUssT0FBTyxRQUFRLEtBQUssUUFBUTtBQUM1QyxXQUFLLE1BQU07QUFDWCxXQUFLLFFBQVE7QUFDYixXQUFLLFNBQVM7QUFDZCxXQUFLLE1BQU07QUFDWCxXQUFLLFNBQVMsVUFBVTtBQUFBLElBQ3pCO0FBQUEsRUFDRjtBQUVELFFBQU0sY0FBYyxDQUFDQSxPQUFNLElBQUksTUFBTSxVQUFVO0FBQzdDLFFBQUksTUFBTSxLQUFLO0FBQ2YsUUFBSSxRQUFRQSxPQUFNLEdBQUcsR0FBRztBQUN0QixVQUFJQSxPQUFNLElBQUk7QUFDZCxVQUFJLENBQUNBLE1BQUssV0FBVztBQUNuQixjQUFNO0FBQUEsSUFDVDtBQUNELFFBQUk7QUFDRixTQUFHLEtBQUssT0FBTyxJQUFJLE9BQU8sSUFBSSxLQUFLQSxLQUFJO0FBQUEsRUFDMUM7QUFFRCxhQUFpQjs7Ozs7Ozs7O0FDNVVqQixRQUFNRSxPQUFNO0FBQUEsSUFDVixZQUFhQyxRQUFPLFNBQVM7QUFDM0IsZ0JBQVVyQyxjQUFhLE9BQU87QUFFOUIsVUFBSXFDLGtCQUFpQkQsUUFBTztBQUMxQixZQUNFQyxPQUFNLFVBQVUsQ0FBQyxDQUFDLFFBQVEsU0FDMUJBLE9BQU0sc0JBQXNCLENBQUMsQ0FBQyxRQUFRLG1CQUN0QztBQUNBLGlCQUFPQTtBQUFBLFFBQ2YsT0FBYTtBQUNMLGlCQUFPLElBQUlELE9BQU1DLE9BQU0sS0FBSyxPQUFPO0FBQUEsUUFDcEM7QUFBQSxNQUNGO0FBRUQsVUFBSUEsa0JBQWlCQyxhQUFZO0FBRS9CLGFBQUssTUFBTUQsT0FBTTtBQUNqQixhQUFLLE1BQU0sQ0FBQyxDQUFDQSxNQUFLLENBQUM7QUFDbkIsYUFBSyxPQUFRO0FBQ2IsZUFBTztBQUFBLE1BQ1I7QUFFRCxXQUFLLFVBQVU7QUFDZixXQUFLLFFBQVEsQ0FBQyxDQUFDLFFBQVE7QUFDdkIsV0FBSyxvQkFBb0IsQ0FBQyxDQUFDLFFBQVE7QUFHbkMsV0FBSyxNQUFNQTtBQUNYLFdBQUssTUFBTUEsT0FDUixNQUFNLElBQUksRUFFVixJQUFJLE9BQUssS0FBSyxXQUFXLEVBQUUsS0FBSSxDQUFFLENBQUMsRUFJbEMsT0FBTyxPQUFLLEVBQUUsTUFBTTtBQUV2QixVQUFJLENBQUMsS0FBSyxJQUFJLFFBQVE7QUFDcEIsY0FBTSxJQUFJLFVBQVUseUJBQXlCQSxRQUFPO0FBQUEsTUFDckQ7QUFHRCxVQUFJLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFFdkIsY0FBTSxRQUFRLEtBQUssSUFBSSxDQUFDO0FBQ3hCLGFBQUssTUFBTSxLQUFLLElBQUksT0FBTyxPQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2hELFlBQUksS0FBSyxJQUFJLFdBQVcsR0FBRztBQUN6QixlQUFLLE1BQU0sQ0FBQyxLQUFLO0FBQUEsUUFDbEIsV0FBVSxLQUFLLElBQUksU0FBUyxHQUFHO0FBRTlCLHFCQUFXLEtBQUssS0FBSyxLQUFLO0FBQ3hCLGdCQUFJLEVBQUUsV0FBVyxLQUFLLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRztBQUNqQyxtQkFBSyxNQUFNLENBQUMsQ0FBQztBQUNiO0FBQUEsWUFDRDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVELFdBQUssT0FBUTtBQUFBLElBQ2Q7QUFBQSxJQUVELFNBQVU7QUFDUixXQUFLLFFBQVEsS0FBSyxJQUNmLElBQUksQ0FBQyxVQUFVO0FBQ2QsZUFBTyxNQUFNLEtBQUssR0FBRyxFQUFFLEtBQU07QUFBQSxNQUNyQyxDQUFPLEVBQ0EsS0FBSyxJQUFJLEVBQ1QsS0FBTTtBQUNULGFBQU8sS0FBSztBQUFBLElBQ2I7QUFBQSxJQUVELFdBQVk7QUFDVixhQUFPLEtBQUs7QUFBQSxJQUNiO0FBQUEsSUFFRCxXQUFZQSxRQUFPO0FBQ2pCLE1BQUFBLFNBQVFBLE9BQU0sS0FBTTtBQUlwQixZQUFNLFdBQVcsT0FBTyxLQUFLLEtBQUssT0FBTyxFQUFFLEtBQUssR0FBRztBQUNuRCxZQUFNLFVBQVUsY0FBYyxZQUFZQTtBQUMxQyxZQUFNLFNBQVMsTUFBTSxJQUFJLE9BQU87QUFDaEMsVUFBSSxRQUFRO0FBQ1YsZUFBTztBQUFBLE1BQ1I7QUFFRCxZQUFNLFFBQVEsS0FBSyxRQUFRO0FBRTNCLFlBQU0sS0FBSyxRQUFRdkMsSUFBR2YsR0FBRSxnQkFBZ0IsSUFBSWUsSUFBR2YsR0FBRSxXQUFXO0FBQzVELE1BQUFzRCxTQUFRQSxPQUFNLFFBQVEsSUFBSSxjQUFjLEtBQUssUUFBUSxpQkFBaUIsQ0FBQztBQUN2RSxNQUFBN0MsT0FBTSxrQkFBa0I2QyxNQUFLO0FBRTdCLE1BQUFBLFNBQVFBLE9BQU0sUUFBUXZDLElBQUdmLEdBQUUsY0FBYyxHQUFHLHFCQUFxQjtBQUNqRSxNQUFBUyxPQUFNLG1CQUFtQjZDLE1BQUs7QUFHOUIsTUFBQUEsU0FBUUEsT0FBTSxRQUFRdkMsSUFBR2YsR0FBRSxTQUFTLEdBQUcsZ0JBQWdCO0FBR3ZELE1BQUFzRCxTQUFRQSxPQUFNLFFBQVF2QyxJQUFHZixHQUFFLFNBQVMsR0FBRyxnQkFBZ0I7QUFHdkQsTUFBQXNELFNBQVFBLE9BQU0sTUFBTSxLQUFLLEVBQUUsS0FBSyxHQUFHO0FBS25DLFVBQUksWUFBWUEsT0FDYixNQUFNLEdBQUcsRUFDVCxJQUFJLFVBQVEsZ0JBQWdCLE1BQU0sS0FBSyxPQUFPLENBQUMsRUFDL0MsS0FBSyxHQUFHLEVBQ1IsTUFBTSxLQUFLLEVBRVgsSUFBSSxVQUFRLFlBQVksTUFBTSxLQUFLLE9BQU8sQ0FBQztBQUU5QyxVQUFJLE9BQU87QUFFVCxvQkFBWSxVQUFVLE9BQU8sVUFBUTtBQUNuQyxVQUFBN0MsT0FBTSx3QkFBd0IsTUFBTSxLQUFLLE9BQU87QUFDaEQsaUJBQU8sQ0FBQyxDQUFDLEtBQUssTUFBTU0sSUFBR2YsR0FBRSxlQUFlLENBQUM7QUFBQSxRQUNqRCxDQUFPO0FBQUEsTUFDRjtBQUNELE1BQUFTLE9BQU0sY0FBYyxTQUFTO0FBSzdCLFlBQU0sV0FBVyxvQkFBSSxJQUFLO0FBQzFCLFlBQU0sY0FBYyxVQUFVLElBQUksVUFBUSxJQUFJOEMsWUFBVyxNQUFNLEtBQUssT0FBTyxDQUFDO0FBQzVFLGlCQUFXLFFBQVEsYUFBYTtBQUM5QixZQUFJLFVBQVUsSUFBSSxHQUFHO0FBQ25CLGlCQUFPLENBQUMsSUFBSTtBQUFBLFFBQ2I7QUFDRCxpQkFBUyxJQUFJLEtBQUssT0FBTyxJQUFJO0FBQUEsTUFDOUI7QUFDRCxVQUFJLFNBQVMsT0FBTyxLQUFLLFNBQVMsSUFBSSxFQUFFLEdBQUc7QUFDekMsaUJBQVMsT0FBTyxFQUFFO0FBQUEsTUFDbkI7QUFFRCxZQUFNLFNBQVMsQ0FBQyxHQUFHLFNBQVMsT0FBTSxDQUFFO0FBQ3BDLFlBQU0sSUFBSSxTQUFTLE1BQU07QUFDekIsYUFBTztBQUFBLElBQ1I7QUFBQSxJQUVELFdBQVlELFFBQU8sU0FBUztBQUMxQixVQUFJLEVBQUVBLGtCQUFpQkQsU0FBUTtBQUM3QixjQUFNLElBQUksVUFBVSxxQkFBcUI7QUFBQSxNQUMxQztBQUVELGFBQU8sS0FBSyxJQUFJLEtBQUssQ0FBQyxvQkFBb0I7QUFDeEMsZUFDRSxjQUFjLGlCQUFpQixPQUFPLEtBQ3RDQyxPQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQjtBQUNuQyxpQkFDRSxjQUFjLGtCQUFrQixPQUFPLEtBQ3ZDLGdCQUFnQixNQUFNLENBQUMsbUJBQW1CO0FBQ3hDLG1CQUFPLGlCQUFpQixNQUFNLENBQUMsb0JBQW9CO0FBQ2pELHFCQUFPLGVBQWUsV0FBVyxpQkFBaUIsT0FBTztBQUFBLFlBQ3pFLENBQWU7QUFBQSxVQUNmLENBQWE7QUFBQSxRQUViLENBQVM7QUFBQSxNQUVULENBQUs7QUFBQSxJQUNGO0FBQUE7QUFBQSxJQUdELEtBQU03QixVQUFTO0FBQ2IsVUFBSSxDQUFDQSxVQUFTO0FBQ1osZUFBTztBQUFBLE1BQ1I7QUFFRCxVQUFJLE9BQU9BLGFBQVksVUFBVTtBQUMvQixZQUFJO0FBQ0YsVUFBQUEsV0FBVSxJQUFJRCxRQUFPQyxVQUFTLEtBQUssT0FBTztBQUFBLFFBQzNDLFNBQVEsSUFBUDtBQUNBLGlCQUFPO0FBQUEsUUFDUjtBQUFBLE1BQ0Y7QUFFRCxlQUFTLElBQUksR0FBRyxJQUFJLEtBQUssSUFBSSxRQUFRLEtBQUs7QUFDeEMsWUFBSSxRQUFRLEtBQUssSUFBSSxDQUFDLEdBQUdBLFVBQVMsS0FBSyxPQUFPLEdBQUc7QUFDL0MsaUJBQU87QUFBQSxRQUNSO0FBQUEsTUFDRjtBQUNELGFBQU87QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUNELFVBQWlCNEI7QUFFakIsUUFBTSxNQUFNMUMsZ0JBQW9CO0FBQ2hDLFFBQU0sUUFBUSxJQUFJLElBQUksRUFBRSxLQUFLLElBQUksQ0FBRTtBQUVuQyxRQUFNTSxnQkFBZUw7QUFDckIsUUFBTTJDLGNBQWFsQyxrQkFBdUI7QUFDMUMsUUFBTVosU0FBUWE7QUFDZCxRQUFNRSxVQUFTRDtBQUNmLFFBQU07QUFBQSxJQUNKLElBQUFSO0FBQUEsSUFDQSxHQUFBZjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsSUFBSWdEO0FBRUosUUFBTSxZQUFZLE9BQUssRUFBRSxVQUFVO0FBQ25DLFFBQU0sUUFBUSxPQUFLLEVBQUUsVUFBVTtBQUkvQixRQUFNLGdCQUFnQixDQUFDLGFBQWEsWUFBWTtBQUM5QyxRQUFJLFNBQVM7QUFDYixVQUFNLHVCQUF1QixZQUFZLE1BQU87QUFDaEQsUUFBSSxpQkFBaUIscUJBQXFCLElBQUs7QUFFL0MsV0FBTyxVQUFVLHFCQUFxQixRQUFRO0FBQzVDLGVBQVMscUJBQXFCLE1BQU0sQ0FBQyxvQkFBb0I7QUFDdkQsZUFBTyxlQUFlLFdBQVcsaUJBQWlCLE9BQU87QUFBQSxNQUMvRCxDQUFLO0FBRUQsdUJBQWlCLHFCQUFxQixJQUFLO0FBQUEsSUFDNUM7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQUtELFFBQU0sa0JBQWtCLENBQUMsTUFBTSxZQUFZO0FBQ3pDLElBQUF2QyxPQUFNLFFBQVEsTUFBTSxPQUFPO0FBQzNCLFdBQU8sY0FBYyxNQUFNLE9BQU87QUFDbEMsSUFBQUEsT0FBTSxTQUFTLElBQUk7QUFDbkIsV0FBTyxjQUFjLE1BQU0sT0FBTztBQUNsQyxJQUFBQSxPQUFNLFVBQVUsSUFBSTtBQUNwQixXQUFPLGVBQWUsTUFBTSxPQUFPO0FBQ25DLElBQUFBLE9BQU0sVUFBVSxJQUFJO0FBQ3BCLFdBQU8sYUFBYSxNQUFNLE9BQU87QUFDakMsSUFBQUEsT0FBTSxTQUFTLElBQUk7QUFDbkIsV0FBTztBQUFBLEVBQ1I7QUFFRCxRQUFNLE1BQU0sQ0FBQWIsUUFBTSxDQUFDQSxPQUFNQSxJQUFHLFlBQWEsTUFBSyxPQUFPQSxRQUFPO0FBUzVELFFBQU0sZ0JBQWdCLENBQUMsTUFBTSxZQUMzQixLQUFLLEtBQUksRUFBRyxNQUFNLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTTtBQUNsQyxXQUFPLGFBQWEsR0FBRyxPQUFPO0FBQUEsRUFDbEMsQ0FBRyxFQUFFLEtBQUssR0FBRztBQUViLFFBQU0sZUFBZSxDQUFDLE1BQU0sWUFBWTtBQUN0QyxVQUFNLElBQUksUUFBUSxRQUFRbUIsSUFBR2YsR0FBRSxVQUFVLElBQUllLElBQUdmLEdBQUUsS0FBSztBQUN2RCxXQUFPLEtBQUssUUFBUSxHQUFHLENBQUNiLElBQUdxRSxJQUFHLEdBQUcsR0FBRyxPQUFPO0FBQ3pDLE1BQUEvQyxPQUFNLFNBQVMsTUFBTXRCLElBQUdxRSxJQUFHLEdBQUcsR0FBRyxFQUFFO0FBQ25DLFVBQUk7QUFFSixVQUFJLElBQUlBLEVBQUMsR0FBRztBQUNWLGNBQU07QUFBQSxNQUNaLFdBQWUsSUFBSSxDQUFDLEdBQUc7QUFDakIsY0FBTSxLQUFLQSxXQUFVLENBQUNBLEtBQUk7QUFBQSxNQUNoQyxXQUFlLElBQUksQ0FBQyxHQUFHO0FBRWpCLGNBQU0sS0FBS0EsTUFBSyxRQUFRQSxNQUFLLENBQUMsSUFBSTtBQUFBLE1BQ25DLFdBQVUsSUFBSTtBQUNiLFFBQUEvQyxPQUFNLG1CQUFtQixFQUFFO0FBQzNCLGNBQU0sS0FBSytDLE1BQUssS0FBSyxLQUFLLE9BQ3JCQSxNQUFLLENBQUMsSUFBSTtBQUFBLE1BQ3JCLE9BQVc7QUFFTCxjQUFNLEtBQUtBLE1BQUssS0FBSyxNQUNoQkEsTUFBSyxDQUFDLElBQUk7QUFBQSxNQUNoQjtBQUVELE1BQUEvQyxPQUFNLGdCQUFnQixHQUFHO0FBQ3pCLGFBQU87QUFBQSxJQUNYLENBQUc7QUFBQSxFQUNGO0FBVUQsUUFBTSxnQkFBZ0IsQ0FBQyxNQUFNLFlBQzNCLEtBQUssS0FBSSxFQUFHLE1BQU0sS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNO0FBQ2xDLFdBQU8sYUFBYSxHQUFHLE9BQU87QUFBQSxFQUNsQyxDQUFHLEVBQUUsS0FBSyxHQUFHO0FBRWIsUUFBTSxlQUFlLENBQUMsTUFBTSxZQUFZO0FBQ3RDLElBQUFBLE9BQU0sU0FBUyxNQUFNLE9BQU87QUFDNUIsVUFBTSxJQUFJLFFBQVEsUUFBUU0sSUFBR2YsR0FBRSxVQUFVLElBQUllLElBQUdmLEdBQUUsS0FBSztBQUN2RCxVQUFNeUQsS0FBSSxRQUFRLG9CQUFvQixPQUFPO0FBQzdDLFdBQU8sS0FBSyxRQUFRLEdBQUcsQ0FBQ3RFLElBQUdxRSxJQUFHLEdBQUcsR0FBRyxPQUFPO0FBQ3pDLE1BQUEvQyxPQUFNLFNBQVMsTUFBTXRCLElBQUdxRSxJQUFHLEdBQUcsR0FBRyxFQUFFO0FBQ25DLFVBQUk7QUFFSixVQUFJLElBQUlBLEVBQUMsR0FBRztBQUNWLGNBQU07QUFBQSxNQUNaLFdBQWUsSUFBSSxDQUFDLEdBQUc7QUFDakIsY0FBTSxLQUFLQSxTQUFRQyxPQUFNLENBQUNELEtBQUk7QUFBQSxNQUNwQyxXQUFlLElBQUksQ0FBQyxHQUFHO0FBQ2pCLFlBQUlBLE9BQU0sS0FBSztBQUNiLGdCQUFNLEtBQUtBLE1BQUssTUFBTUMsT0FBTUQsTUFBSyxDQUFDLElBQUk7QUFBQSxRQUM5QyxPQUFhO0FBQ0wsZ0JBQU0sS0FBS0EsTUFBSyxNQUFNQyxPQUFNLENBQUNELEtBQUk7QUFBQSxRQUNsQztBQUFBLE1BQ0YsV0FBVSxJQUFJO0FBQ2IsUUFBQS9DLE9BQU0sbUJBQW1CLEVBQUU7QUFDM0IsWUFBSStDLE9BQU0sS0FBSztBQUNiLGNBQUksTUFBTSxLQUFLO0FBQ2Isa0JBQU0sS0FBS0EsTUFBSyxLQUFLLEtBQUssT0FDckJBLE1BQUssS0FBSyxDQUFDLElBQUk7QUFBQSxVQUM5QixPQUFlO0FBQ0wsa0JBQU0sS0FBS0EsTUFBSyxLQUFLLEtBQUssT0FDckJBLE1BQUssQ0FBQyxJQUFJO0FBQUEsVUFDaEI7QUFBQSxRQUNULE9BQWE7QUFDTCxnQkFBTSxLQUFLQSxNQUFLLEtBQUssS0FBSyxPQUNyQixDQUFDQSxLQUFJO0FBQUEsUUFDWDtBQUFBLE1BQ1AsT0FBVztBQUNMLFFBQUEvQyxPQUFNLE9BQU87QUFDYixZQUFJK0MsT0FBTSxLQUFLO0FBQ2IsY0FBSSxNQUFNLEtBQUs7QUFDYixrQkFBTSxLQUFLQSxNQUFLLEtBQUssSUFDbEJDLE9BQU1ELE1BQUssS0FBSyxDQUFDLElBQUk7QUFBQSxVQUNsQyxPQUFlO0FBQ0wsa0JBQU0sS0FBS0EsTUFBSyxLQUFLLElBQ2xCQyxPQUFNRCxNQUFLLENBQUMsSUFBSTtBQUFBLFVBQ3BCO0FBQUEsUUFDVCxPQUFhO0FBQ0wsZ0JBQU0sS0FBS0EsTUFBSyxLQUFLLE1BQ2hCLENBQUNBLEtBQUk7QUFBQSxRQUNYO0FBQUEsTUFDRjtBQUVELE1BQUEvQyxPQUFNLGdCQUFnQixHQUFHO0FBQ3pCLGFBQU87QUFBQSxJQUNYLENBQUc7QUFBQSxFQUNGO0FBRUQsUUFBTSxpQkFBaUIsQ0FBQyxNQUFNLFlBQVk7QUFDeEMsSUFBQUEsT0FBTSxrQkFBa0IsTUFBTSxPQUFPO0FBQ3JDLFdBQU8sS0FBSyxNQUFNLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTTtBQUNsQyxhQUFPLGNBQWMsR0FBRyxPQUFPO0FBQUEsSUFDbkMsQ0FBRyxFQUFFLEtBQUssR0FBRztBQUFBLEVBQ1o7QUFFRCxRQUFNLGdCQUFnQixDQUFDLE1BQU0sWUFBWTtBQUN2QyxXQUFPLEtBQUssS0FBTTtBQUNsQixVQUFNLElBQUksUUFBUSxRQUFRTSxJQUFHZixHQUFFLFdBQVcsSUFBSWUsSUFBR2YsR0FBRSxNQUFNO0FBQ3pELFdBQU8sS0FBSyxRQUFRLEdBQUcsQ0FBQyxLQUFLLE1BQU13RCxJQUFHLEdBQUcsR0FBRyxPQUFPO0FBQ2pELE1BQUEvQyxPQUFNLFVBQVUsTUFBTSxLQUFLLE1BQU0rQyxJQUFHLEdBQUcsR0FBRyxFQUFFO0FBQzVDLFlBQU0sS0FBSyxJQUFJQSxFQUFDO0FBQ2hCLFlBQU0sS0FBSyxNQUFNLElBQUksQ0FBQztBQUN0QixZQUFNLEtBQUssTUFBTSxJQUFJLENBQUM7QUFDdEIsWUFBTSxPQUFPO0FBRWIsVUFBSSxTQUFTLE9BQU8sTUFBTTtBQUN4QixlQUFPO0FBQUEsTUFDUjtBQUlELFdBQUssUUFBUSxvQkFBb0IsT0FBTztBQUV4QyxVQUFJLElBQUk7QUFDTixZQUFJLFNBQVMsT0FBTyxTQUFTLEtBQUs7QUFFaEMsZ0JBQU07QUFBQSxRQUNkLE9BQWE7QUFFTCxnQkFBTTtBQUFBLFFBQ1A7QUFBQSxNQUNQLFdBQWUsUUFBUSxNQUFNO0FBR3ZCLFlBQUksSUFBSTtBQUNOLGNBQUk7QUFBQSxRQUNMO0FBQ0QsWUFBSTtBQUVKLFlBQUksU0FBUyxLQUFLO0FBR2hCLGlCQUFPO0FBQ1AsY0FBSSxJQUFJO0FBQ04sWUFBQUEsS0FBSSxDQUFDQSxLQUFJO0FBQ1QsZ0JBQUk7QUFDSixnQkFBSTtBQUFBLFVBQ2QsT0FBZTtBQUNMLGdCQUFJLENBQUMsSUFBSTtBQUNULGdCQUFJO0FBQUEsVUFDTDtBQUFBLFFBQ1QsV0FBaUIsU0FBUyxNQUFNO0FBR3hCLGlCQUFPO0FBQ1AsY0FBSSxJQUFJO0FBQ04sWUFBQUEsS0FBSSxDQUFDQSxLQUFJO0FBQUEsVUFDbkIsT0FBZTtBQUNMLGdCQUFJLENBQUMsSUFBSTtBQUFBLFVBQ1Y7QUFBQSxRQUNGO0FBRUQsWUFBSSxTQUFTLEtBQUs7QUFDaEIsZUFBSztBQUFBLFFBQ047QUFFRCxjQUFNLEdBQUcsT0FBT0EsTUFBSyxLQUFLLElBQUk7QUFBQSxNQUMvQixXQUFVLElBQUk7QUFDYixjQUFNLEtBQUtBLFNBQVEsT0FBTyxDQUFDQSxLQUFJO0FBQUEsTUFDaEMsV0FBVSxJQUFJO0FBQ2IsY0FBTSxLQUFLQSxNQUFLLE1BQU0sT0FDakJBLE1BQUssQ0FBQyxJQUFJO0FBQUEsTUFDaEI7QUFFRCxNQUFBL0MsT0FBTSxpQkFBaUIsR0FBRztBQUUxQixhQUFPO0FBQUEsSUFDWCxDQUFHO0FBQUEsRUFDRjtBQUlELFFBQU0sZUFBZSxDQUFDLE1BQU0sWUFBWTtBQUN0QyxJQUFBQSxPQUFNLGdCQUFnQixNQUFNLE9BQU87QUFFbkMsV0FBTyxLQUFLLEtBQUksRUFBRyxRQUFRTSxJQUFHZixHQUFFLElBQUksR0FBRyxFQUFFO0FBQUEsRUFDMUM7QUFFRCxRQUFNLGNBQWMsQ0FBQyxNQUFNLFlBQVk7QUFDckMsSUFBQVMsT0FBTSxlQUFlLE1BQU0sT0FBTztBQUNsQyxXQUFPLEtBQUssS0FBTSxFQUNmLFFBQVFNLElBQUcsUUFBUSxvQkFBb0JmLEdBQUUsVUFBVUEsR0FBRSxJQUFJLEdBQUcsRUFBRTtBQUFBLEVBQ2xFO0FBT0QsUUFBTSxnQkFBZ0IsV0FBUyxDQUFDLElBQzlCLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSyxJQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssT0FBTztBQUM1QixRQUFJLElBQUksRUFBRSxHQUFHO0FBQ1gsYUFBTztBQUFBLElBQ1gsV0FBYSxJQUFJLEVBQUUsR0FBRztBQUNsQixhQUFPLEtBQUssU0FBUyxRQUFRLE9BQU87QUFBQSxJQUN4QyxXQUFhLElBQUksRUFBRSxHQUFHO0FBQ2xCLGFBQU8sS0FBSyxNQUFNLE9BQU8sUUFBUSxPQUFPO0FBQUEsSUFDekMsV0FBVSxLQUFLO0FBQ2QsYUFBTyxLQUFLO0FBQUEsSUFDaEIsT0FBUztBQUNMLGFBQU8sS0FBSyxPQUFPLFFBQVEsT0FBTztBQUFBLElBQ25DO0FBRUQsUUFBSSxJQUFJLEVBQUUsR0FBRztBQUNYLFdBQUs7QUFBQSxJQUNULFdBQWEsSUFBSSxFQUFFLEdBQUc7QUFDbEIsV0FBSyxJQUFJLENBQUMsS0FBSztBQUFBLElBQ25CLFdBQWEsSUFBSSxFQUFFLEdBQUc7QUFDbEIsV0FBSyxJQUFJLE1BQU0sQ0FBQyxLQUFLO0FBQUEsSUFDdEIsV0FBVSxLQUFLO0FBQ2QsV0FBSyxLQUFLLE1BQU0sTUFBTSxNQUFNO0FBQUEsSUFDN0IsV0FBVSxPQUFPO0FBQ2hCLFdBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQyxLQUFLO0FBQUEsSUFDL0IsT0FBUztBQUNMLFdBQUssS0FBSztBQUFBLElBQ1g7QUFFRCxXQUFRLEdBQUcsUUFBUSxLQUFNLEtBQU07QUFBQSxFQUNoQztBQUVELFFBQU0sVUFBVSxDQUFDLEtBQUt5QixVQUFTLFlBQVk7QUFDekMsYUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxVQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBS0EsUUFBTyxHQUFHO0FBQ3pCLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUVELFFBQUlBLFNBQVEsV0FBVyxVQUFVLENBQUMsUUFBUSxtQkFBbUI7QUFNM0QsZUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxRQUFBaEIsT0FBTSxJQUFJLENBQUMsRUFBRSxNQUFNO0FBQ25CLFlBQUksSUFBSSxDQUFDLEVBQUUsV0FBVzhDLFlBQVcsS0FBSztBQUNwQztBQUFBLFFBQ0Q7QUFFRCxZQUFJLElBQUksQ0FBQyxFQUFFLE9BQU8sV0FBVyxTQUFTLEdBQUc7QUFDdkMsZ0JBQU0sVUFBVSxJQUFJLENBQUMsRUFBRTtBQUN2QixjQUFJLFFBQVEsVUFBVTlCLFNBQVEsU0FDMUIsUUFBUSxVQUFVQSxTQUFRLFNBQzFCLFFBQVEsVUFBVUEsU0FBUSxPQUFPO0FBQ25DLG1CQUFPO0FBQUEsVUFDUjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBR0QsYUFBTztBQUFBLElBQ1I7QUFFRCxXQUFPO0FBQUEsRUFDVDs7Ozs7Ozs7O0FDemdCQSxRQUFNaUMsT0FBTSxPQUFPLFlBQVk7QUFFL0IsUUFBTUgsWUFBVztBQUFBLElBQ2YsV0FBVyxNQUFPO0FBQ2hCLGFBQU9HO0FBQUEsSUFDUjtBQUFBLElBRUQsWUFBYSxNQUFNLFNBQVM7QUFDMUIsZ0JBQVV6QyxjQUFhLE9BQU87QUFFOUIsVUFBSSxnQkFBZ0JzQyxhQUFZO0FBQzlCLFlBQUksS0FBSyxVQUFVLENBQUMsQ0FBQyxRQUFRLE9BQU87QUFDbEMsaUJBQU87QUFBQSxRQUNmLE9BQWE7QUFDTCxpQkFBTyxLQUFLO0FBQUEsUUFDYjtBQUFBLE1BQ0Y7QUFFRCxNQUFBOUMsT0FBTSxjQUFjLE1BQU0sT0FBTztBQUNqQyxXQUFLLFVBQVU7QUFDZixXQUFLLFFBQVEsQ0FBQyxDQUFDLFFBQVE7QUFDdkIsV0FBSyxNQUFNLElBQUk7QUFFZixVQUFJLEtBQUssV0FBV2lELE1BQUs7QUFDdkIsYUFBSyxRQUFRO0FBQUEsTUFDbkIsT0FBVztBQUNMLGFBQUssUUFBUSxLQUFLLFdBQVcsS0FBSyxPQUFPO0FBQUEsTUFDMUM7QUFFRCxNQUFBakQsT0FBTSxRQUFRLElBQUk7QUFBQSxJQUNuQjtBQUFBLElBRUQsTUFBTyxNQUFNO0FBQ1gsWUFBTSxJQUFJLEtBQUssUUFBUSxRQUFRTSxJQUFHZixHQUFFLGVBQWUsSUFBSWUsSUFBR2YsR0FBRSxVQUFVO0FBQ3RFLFlBQU0sSUFBSSxLQUFLLE1BQU0sQ0FBQztBQUV0QixVQUFJLENBQUMsR0FBRztBQUNOLGNBQU0sSUFBSSxVQUFVLHVCQUF1QixNQUFNO0FBQUEsTUFDbEQ7QUFFRCxXQUFLLFdBQVcsRUFBRSxDQUFDLE1BQU0sU0FBWSxFQUFFLENBQUMsSUFBSTtBQUM1QyxVQUFJLEtBQUssYUFBYSxLQUFLO0FBQ3pCLGFBQUssV0FBVztBQUFBLE1BQ2pCO0FBR0QsVUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHO0FBQ1QsYUFBSyxTQUFTMEQ7QUFBQSxNQUNwQixPQUFXO0FBQ0wsYUFBSyxTQUFTLElBQUlsQyxRQUFPLEVBQUUsQ0FBQyxHQUFHLEtBQUssUUFBUSxLQUFLO0FBQUEsTUFDbEQ7QUFBQSxJQUNGO0FBQUEsSUFFRCxXQUFZO0FBQ1YsYUFBTyxLQUFLO0FBQUEsSUFDYjtBQUFBLElBRUQsS0FBTUMsVUFBUztBQUNiLE1BQUFoQixPQUFNLG1CQUFtQmdCLFVBQVMsS0FBSyxRQUFRLEtBQUs7QUFFcEQsVUFBSSxLQUFLLFdBQVdpQyxRQUFPakMsYUFBWWlDLE1BQUs7QUFDMUMsZUFBTztBQUFBLE1BQ1I7QUFFRCxVQUFJLE9BQU9qQyxhQUFZLFVBQVU7QUFDL0IsWUFBSTtBQUNGLFVBQUFBLFdBQVUsSUFBSUQsUUFBT0MsVUFBUyxLQUFLLE9BQU87QUFBQSxRQUMzQyxTQUFRLElBQVA7QUFDQSxpQkFBTztBQUFBLFFBQ1I7QUFBQSxNQUNGO0FBRUQsYUFBT3dCLEtBQUl4QixVQUFTLEtBQUssVUFBVSxLQUFLLFFBQVEsS0FBSyxPQUFPO0FBQUEsSUFDN0Q7QUFBQSxJQUVELFdBQVksTUFBTSxTQUFTO0FBQ3pCLFVBQUksRUFBRSxnQkFBZ0I4QixjQUFhO0FBQ2pDLGNBQU0sSUFBSSxVQUFVLDBCQUEwQjtBQUFBLE1BQy9DO0FBRUQsVUFBSSxDQUFDLFdBQVcsT0FBTyxZQUFZLFVBQVU7QUFDM0Msa0JBQVU7QUFBQSxVQUNSLE9BQU8sQ0FBQyxDQUFDO0FBQUEsVUFDVCxtQkFBbUI7QUFBQSxRQUNwQjtBQUFBLE1BQ0Y7QUFFRCxVQUFJLEtBQUssYUFBYSxJQUFJO0FBQ3hCLFlBQUksS0FBSyxVQUFVLElBQUk7QUFDckIsaUJBQU87QUFBQSxRQUNSO0FBQ0QsZUFBTyxJQUFJRixPQUFNLEtBQUssT0FBTyxPQUFPLEVBQUUsS0FBSyxLQUFLLEtBQUs7QUFBQSxNQUMzRCxXQUFlLEtBQUssYUFBYSxJQUFJO0FBQy9CLFlBQUksS0FBSyxVQUFVLElBQUk7QUFDckIsaUJBQU87QUFBQSxRQUNSO0FBQ0QsZUFBTyxJQUFJQSxPQUFNLEtBQUssT0FBTyxPQUFPLEVBQUUsS0FBSyxLQUFLLE1BQU07QUFBQSxNQUN2RDtBQUVELFlBQU0sMkJBQ0gsS0FBSyxhQUFhLFFBQVEsS0FBSyxhQUFhLFNBQzVDLEtBQUssYUFBYSxRQUFRLEtBQUssYUFBYTtBQUMvQyxZQUFNLDJCQUNILEtBQUssYUFBYSxRQUFRLEtBQUssYUFBYSxTQUM1QyxLQUFLLGFBQWEsUUFBUSxLQUFLLGFBQWE7QUFDL0MsWUFBTSxhQUFhLEtBQUssT0FBTyxZQUFZLEtBQUssT0FBTztBQUN2RCxZQUFNLGdDQUNILEtBQUssYUFBYSxRQUFRLEtBQUssYUFBYSxVQUM1QyxLQUFLLGFBQWEsUUFBUSxLQUFLLGFBQWE7QUFDL0MsWUFBTSw2QkFDSkosS0FBSSxLQUFLLFFBQVEsS0FBSyxLQUFLLFFBQVEsT0FBTyxNQUN6QyxLQUFLLGFBQWEsUUFBUSxLQUFLLGFBQWEsU0FDMUMsS0FBSyxhQUFhLFFBQVEsS0FBSyxhQUFhO0FBQ2pELFlBQU0sZ0NBQ0pBLEtBQUksS0FBSyxRQUFRLEtBQUssS0FBSyxRQUFRLE9BQU8sTUFDekMsS0FBSyxhQUFhLFFBQVEsS0FBSyxhQUFhLFNBQzFDLEtBQUssYUFBYSxRQUFRLEtBQUssYUFBYTtBQUVqRCxhQUNFLDJCQUNBLDJCQUNDLGNBQWMsZ0NBQ2YsOEJBQ0E7QUFBQSxJQUVIO0FBQUEsRUFDRjtBQUVELGVBQWlCTTtBQUVqQixRQUFNdEMsZ0JBQWVOO0FBQ3JCLFFBQU0sRUFBRSxJQUFBSSxLQUFJLEdBQUFmLEdBQUMsSUFBS1k7QUFDbEIsUUFBTXFDLE9BQU01QjtBQUNaLFFBQU1aLFNBQVFhO0FBQ2QsUUFBTUUsVUFBU0Q7QUFDZixRQUFNOEIsU0FBUUwsYUFBQTs7O0FDdklkLE1BQU1LLFVBQVExQyxhQUEyQjtBQUN6QyxNQUFNZ0QsY0FBWSxDQUFDbEMsVUFBUzZCLFFBQU8sWUFBWTtBQUM3QyxNQUFJO0FBQ0YsSUFBQUEsU0FBUSxJQUFJRCxRQUFNQyxRQUFPLE9BQU87QUFBQSxFQUNqQyxTQUFRLElBQVA7QUFDQSxXQUFPO0FBQUEsRUFDUjtBQUNELFNBQU9BLE9BQU0sS0FBSzdCLFFBQU87QUFDM0I7QUFDQSxJQUFBLGNBQWlCa0M7QUNUakIsTUFBTU4sVUFBUTFDLGFBQTJCO0FBR3pDLE1BQU1pRCxrQkFBZ0IsQ0FBQ04sUUFBTyxZQUM1QixJQUFJRCxRQUFNQyxRQUFPLE9BQU8sRUFBRSxJQUN2QixJQUFJLFVBQVEsS0FBSyxJQUFJLE9BQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLEVBQUUsS0FBTSxFQUFDLE1BQU0sR0FBRyxDQUFDO0FBRW5FLElBQUEsa0JBQWlCTTtBQ1BqQixNQUFNcEMsV0FBU2I7QUFDZixNQUFNMEMsVUFBUXpDLGFBQTJCO0FBRXpDLE1BQU1pRCxrQkFBZ0IsQ0FBQyxVQUFVUCxRQUFPLFlBQVk7QUFDbEQsTUFBSSxNQUFNO0FBQ1YsTUFBSSxRQUFRO0FBQ1osTUFBSSxXQUFXO0FBQ2YsTUFBSTtBQUNGLGVBQVcsSUFBSUQsUUFBTUMsUUFBTyxPQUFPO0FBQUEsRUFDcEMsU0FBUSxJQUFQO0FBQ0EsV0FBTztBQUFBLEVBQ1I7QUFDRCxXQUFTLFFBQVEsQ0FBQyxNQUFNO0FBQ3RCLFFBQUksU0FBUyxLQUFLLENBQUMsR0FBRztBQUVwQixVQUFJLENBQUMsT0FBTyxNQUFNLFFBQVEsQ0FBQyxNQUFNLElBQUk7QUFFbkMsY0FBTTtBQUNOLGdCQUFRLElBQUk5QixTQUFPLEtBQUssT0FBTztBQUFBLE1BQ2hDO0FBQUEsSUFDRjtBQUFBLEVBQ0wsQ0FBRztBQUNELFNBQU87QUFDVDtBQUNBLElBQUEsa0JBQWlCcUM7QUN4QmpCLE1BQU1yQyxXQUFTYjtBQUNmLE1BQU0wQyxVQUFRekMsYUFBMkI7QUFDekMsTUFBTWtELGtCQUFnQixDQUFDLFVBQVVSLFFBQU8sWUFBWTtBQUNsRCxNQUFJLE1BQU07QUFDVixNQUFJLFFBQVE7QUFDWixNQUFJLFdBQVc7QUFDZixNQUFJO0FBQ0YsZUFBVyxJQUFJRCxRQUFNQyxRQUFPLE9BQU87QUFBQSxFQUNwQyxTQUFRLElBQVA7QUFDQSxXQUFPO0FBQUEsRUFDUjtBQUNELFdBQVMsUUFBUSxDQUFDLE1BQU07QUFDdEIsUUFBSSxTQUFTLEtBQUssQ0FBQyxHQUFHO0FBRXBCLFVBQUksQ0FBQyxPQUFPLE1BQU0sUUFBUSxDQUFDLE1BQU0sR0FBRztBQUVsQyxjQUFNO0FBQ04sZ0JBQVEsSUFBSTlCLFNBQU8sS0FBSyxPQUFPO0FBQUEsTUFDaEM7QUFBQSxJQUNGO0FBQUEsRUFDTCxDQUFHO0FBQ0QsU0FBTztBQUNUO0FBQ0EsSUFBQSxrQkFBaUJzQztBQ3ZCakIsTUFBTXRDLFdBQVNiO0FBQ2YsTUFBTTBDLFVBQVF6QyxhQUEyQjtBQUN6QyxNQUFNK0IsT0FBS3RCO0FBRVgsTUFBTTBDLGVBQWEsQ0FBQ1QsUUFBTyxVQUFVO0FBQ25DLEVBQUFBLFNBQVEsSUFBSUQsUUFBTUMsUUFBTyxLQUFLO0FBRTlCLE1BQUksU0FBUyxJQUFJOUIsU0FBTyxPQUFPO0FBQy9CLE1BQUk4QixPQUFNLEtBQUssTUFBTSxHQUFHO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBRUQsV0FBUyxJQUFJOUIsU0FBTyxTQUFTO0FBQzdCLE1BQUk4QixPQUFNLEtBQUssTUFBTSxHQUFHO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBRUQsV0FBUztBQUNULFdBQVMsSUFBSSxHQUFHLElBQUlBLE9BQU0sSUFBSSxRQUFRLEVBQUUsR0FBRztBQUN6QyxVQUFNLGNBQWNBLE9BQU0sSUFBSSxDQUFDO0FBRS9CLFFBQUksU0FBUztBQUNiLGdCQUFZLFFBQVEsQ0FBQ1UsZ0JBQWU7QUFFbEMsWUFBTSxVQUFVLElBQUl4QyxTQUFPd0MsWUFBVyxPQUFPLE9BQU87QUFDcEQsY0FBUUEsWUFBVyxVQUFRO0FBQUEsUUFDekIsS0FBSztBQUNILGNBQUksUUFBUSxXQUFXLFdBQVcsR0FBRztBQUNuQyxvQkFBUTtBQUFBLFVBQ3BCLE9BQWlCO0FBQ0wsb0JBQVEsV0FBVyxLQUFLLENBQUM7QUFBQSxVQUMxQjtBQUNELGtCQUFRLE1BQU0sUUFBUSxPQUFRO0FBQUEsUUFFaEMsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNILGNBQUksQ0FBQyxVQUFVckIsS0FBRyxTQUFTLE1BQU0sR0FBRztBQUNsQyxxQkFBUztBQUFBLFVBQ1Y7QUFDRDtBQUFBLFFBQ0YsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUVIO0FBQUEsUUFFRjtBQUNFLGdCQUFNLElBQUksTUFBTSx5QkFBeUJxQixZQUFXLFVBQVU7QUFBQSxNQUNqRTtBQUFBLElBQ1AsQ0FBSztBQUNELFFBQUksV0FBVyxDQUFDLFVBQVVyQixLQUFHLFFBQVEsTUFBTSxJQUFJO0FBQzdDLGVBQVM7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUVELE1BQUksVUFBVVcsT0FBTSxLQUFLLE1BQU0sR0FBRztBQUNoQyxXQUFPO0FBQUEsRUFDUjtBQUVELFNBQU87QUFDVDtBQUNBLElBQUEsZUFBaUJTO0FDNURqQixNQUFNVixVQUFRMUMsYUFBMkI7QUFDekMsTUFBTXNELGVBQWEsQ0FBQ1gsUUFBTyxZQUFZO0FBQ3JDLE1BQUk7QUFHRixXQUFPLElBQUlELFFBQU1DLFFBQU8sT0FBTyxFQUFFLFNBQVM7QUFBQSxFQUMzQyxTQUFRLElBQVA7QUFDQSxXQUFPO0FBQUEsRUFDUjtBQUNIO0FBQ0EsSUFBQTFCLFVBQWlCcUM7QUNWakIsTUFBTXpDLFdBQVNiO0FBQ2YsTUFBTTRDLGVBQWEzQyxrQkFBZ0M7QUFDbkQsTUFBTSxFQUFFOEMsS0FBQUEsTUFBSyxJQUFHSDtBQUNoQixNQUFNRixVQUFRaEMsYUFBMkI7QUFDekMsTUFBTXNDLGNBQVlyQztBQUNsQixNQUFNcUIsT0FBS3BCO0FBQ1gsTUFBTXFCLE9BQUtJO0FBQ1gsTUFBTUQsUUFBTW1CO0FBQ1osTUFBTXBCLFFBQU1xQjtBQUVaLE1BQU1DLFlBQVUsQ0FBQzNDLFVBQVM2QixRQUFPLE1BQU0sWUFBWTtBQUNqRCxFQUFBN0IsV0FBVSxJQUFJRCxTQUFPQyxVQUFTLE9BQU87QUFDckMsRUFBQTZCLFNBQVEsSUFBSUQsUUFBTUMsUUFBTyxPQUFPO0FBRWhDLE1BQUksTUFBTSxPQUFPLE1BQU0sTUFBTTtBQUM3QixVQUFRLE1BQUk7QUFBQSxJQUNWLEtBQUs7QUFDSCxhQUFPWDtBQUNQLGNBQVFJO0FBQ1IsYUFBT0g7QUFDUCxhQUFPO0FBQ1AsY0FBUTtBQUNSO0FBQUEsSUFDRixLQUFLO0FBQ0gsYUFBT0E7QUFDUCxjQUFRRTtBQUNSLGFBQU9IO0FBQ1AsYUFBTztBQUNQLGNBQVE7QUFDUjtBQUFBLElBQ0Y7QUFDRSxZQUFNLElBQUksVUFBVSx1Q0FBdUM7QUFBQSxFQUM5RDtBQUdELE1BQUlnQixZQUFVbEMsVUFBUzZCLFFBQU8sT0FBTyxHQUFHO0FBQ3RDLFdBQU87QUFBQSxFQUNSO0FBS0QsV0FBUyxJQUFJLEdBQUcsSUFBSUEsT0FBTSxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQ3pDLFVBQU0sY0FBY0EsT0FBTSxJQUFJLENBQUM7QUFFL0IsUUFBSSxPQUFPO0FBQ1gsUUFBSSxNQUFNO0FBRVYsZ0JBQVksUUFBUSxDQUFDVSxnQkFBZTtBQUNsQyxVQUFJQSxZQUFXLFdBQVdOLE9BQUs7QUFDN0IsUUFBQU0sY0FBYSxJQUFJVCxhQUFXLFNBQVM7QUFBQSxNQUN0QztBQUNELGFBQU8sUUFBUVM7QUFDZixZQUFNLE9BQU9BO0FBQ2IsVUFBSSxLQUFLQSxZQUFXLFFBQVEsS0FBSyxRQUFRLE9BQU8sR0FBRztBQUNqRCxlQUFPQTtBQUFBLE1BQ2YsV0FBaUIsS0FBS0EsWUFBVyxRQUFRLElBQUksUUFBUSxPQUFPLEdBQUc7QUFDdkQsY0FBTUE7QUFBQSxNQUNQO0FBQUEsSUFDUCxDQUFLO0FBSUQsUUFBSSxLQUFLLGFBQWEsUUFBUSxLQUFLLGFBQWEsT0FBTztBQUNyRCxhQUFPO0FBQUEsSUFDUjtBQUlELFNBQUssQ0FBQyxJQUFJLFlBQVksSUFBSSxhQUFhLFNBQ25DLE1BQU12QyxVQUFTLElBQUksTUFBTSxHQUFHO0FBQzlCLGFBQU87QUFBQSxJQUNiLFdBQWUsSUFBSSxhQUFhLFNBQVMsS0FBS0EsVUFBUyxJQUFJLE1BQU0sR0FBRztBQUM5RCxhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFDRCxTQUFPO0FBQ1Q7QUFFQSxJQUFBLFlBQWlCMkM7QUM5RWpCLE1BQU1BLFlBQVV6RDtBQUNoQixNQUFNMEQsUUFBTSxDQUFDNUMsVUFBUzZCLFFBQU8sWUFBWWMsVUFBUTNDLFVBQVM2QixRQUFPLEtBQUssT0FBTztBQUM3RSxJQUFBLFFBQWlCZTtBQ0hqQixNQUFNRCxZQUFVekQ7QUFFaEIsTUFBTTJELFFBQU0sQ0FBQzdDLFVBQVM2QixRQUFPLFlBQVljLFVBQVEzQyxVQUFTNkIsUUFBTyxLQUFLLE9BQU87QUFDN0UsSUFBQSxRQUFpQmdCO0FDSGpCLE1BQU1qQixVQUFRMUMsYUFBMkI7QUFDekMsTUFBTTRELGVBQWEsQ0FBQyxJQUFJLElBQUksWUFBWTtBQUN0QyxPQUFLLElBQUlsQixRQUFNLElBQUksT0FBTztBQUMxQixPQUFLLElBQUlBLFFBQU0sSUFBSSxPQUFPO0FBQzFCLFNBQU8sR0FBRyxXQUFXLEVBQUU7QUFDekI7QUFDQSxJQUFBLGVBQWlCa0I7QUNIakIsTUFBTVosY0FBWWhEO0FBQ2xCLE1BQU1vQixZQUFVbkI7QUFDaEIsSUFBQSxXQUFpQixDQUFDLFVBQVUwQyxRQUFPLFlBQVk7QUFDN0MsUUFBTSxNQUFNLENBQUU7QUFDZCxNQUFJLFFBQVE7QUFDWixNQUFJLE9BQU87QUFDWCxRQUFNLElBQUksU0FBUyxLQUFLLENBQUNyRCxJQUFHa0IsT0FBTVksVUFBUTlCLElBQUdrQixJQUFHLE9BQU8sQ0FBQztBQUN4RCxhQUFXTSxZQUFXLEdBQUc7QUFDdkIsVUFBTSxXQUFXa0MsWUFBVWxDLFVBQVM2QixRQUFPLE9BQU87QUFDbEQsUUFBSSxVQUFVO0FBQ1osYUFBTzdCO0FBQ1AsVUFBSSxDQUFDLE9BQU87QUFDVixnQkFBUUE7QUFBQSxNQUNUO0FBQUEsSUFDUCxPQUFXO0FBQ0wsVUFBSSxNQUFNO0FBQ1IsWUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLENBQUM7QUFBQSxNQUN2QjtBQUNELGFBQU87QUFDUCxjQUFRO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFDRCxNQUFJLE9BQU87QUFDVCxRQUFJLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQztBQUFBLEVBQ3ZCO0FBRUQsUUFBTSxTQUFTLENBQUU7QUFDakIsYUFBVyxDQUFDLEtBQUssR0FBRyxLQUFLLEtBQUs7QUFDNUIsUUFBSSxRQUFRLEtBQUs7QUFDZixhQUFPLEtBQUssR0FBRztBQUFBLElBQ2hCLFdBQVUsQ0FBQyxPQUFPLFFBQVEsRUFBRSxDQUFDLEdBQUc7QUFDL0IsYUFBTyxLQUFLLEdBQUc7QUFBQSxJQUNyQixXQUFlLENBQUMsS0FBSztBQUNmLGFBQU8sS0FBSyxLQUFLLEtBQUs7QUFBQSxJQUN2QixXQUFVLFFBQVEsRUFBRSxDQUFDLEdBQUc7QUFDdkIsYUFBTyxLQUFLLEtBQUssS0FBSztBQUFBLElBQzVCLE9BQVc7QUFDTCxhQUFPLEtBQUssR0FBRyxTQUFTLEtBQUs7QUFBQSxJQUM5QjtBQUFBLEVBQ0Y7QUFDRCxRQUFNLGFBQWEsT0FBTyxLQUFLLE1BQU07QUFDckMsUUFBTSxXQUFXLE9BQU82QixPQUFNLFFBQVEsV0FBV0EsT0FBTSxNQUFNLE9BQU9BLE1BQUs7QUFDekUsU0FBTyxXQUFXLFNBQVMsU0FBUyxTQUFTLGFBQWFBO0FBQzVEO0FDOUNBLE1BQU1ELFVBQVExQyxhQUE4QjtBQUM1QyxNQUFNNEMsZUFBYTNDLGtCQUFtQztBQUN0RCxNQUFNLEVBQUUsSUFBSyxJQUFHMkM7QUFDaEIsTUFBTUksY0FBWXRDO0FBQ2xCLE1BQU1VLFlBQVVUO0FBc0NoQixNQUFNa0QsV0FBUyxDQUFDLEtBQUssS0FBSyxVQUFVLENBQUEsTUFBTztBQUN6QyxNQUFJLFFBQVEsS0FBSztBQUNmLFdBQU87QUFBQSxFQUNSO0FBRUQsUUFBTSxJQUFJbkIsUUFBTSxLQUFLLE9BQU87QUFDNUIsUUFBTSxJQUFJQSxRQUFNLEtBQUssT0FBTztBQUM1QixNQUFJLGFBQWE7QUFFakI7QUFBTyxlQUFXLGFBQWEsSUFBSSxLQUFLO0FBQ3RDLGlCQUFXLGFBQWEsSUFBSSxLQUFLO0FBQy9CLGNBQU0sUUFBUSxhQUFhLFdBQVcsV0FBVyxPQUFPO0FBQ3hELHFCQUFhLGNBQWMsVUFBVTtBQUNyQyxZQUFJLE9BQU87QUFDVCxtQkFBUztBQUFBLFFBQ1Y7QUFBQSxNQUNGO0FBS0QsVUFBSSxZQUFZO0FBQ2QsZUFBTztBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQ0QsU0FBTztBQUNUO0FBRUEsTUFBTSxlQUFlLENBQUMsS0FBSyxLQUFLLFlBQVk7QUFDMUMsTUFBSSxRQUFRLEtBQUs7QUFDZixXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUksSUFBSSxXQUFXLEtBQUssSUFBSSxDQUFDLEVBQUUsV0FBVyxLQUFLO0FBQzdDLFFBQUksSUFBSSxXQUFXLEtBQUssSUFBSSxDQUFDLEVBQUUsV0FBVyxLQUFLO0FBQzdDLGFBQU87QUFBQSxJQUNiLFdBQWUsUUFBUSxtQkFBbUI7QUFDcEMsWUFBTSxDQUFDLElBQUlFLGFBQVcsV0FBVyxDQUFDO0FBQUEsSUFDeEMsT0FBVztBQUNMLFlBQU0sQ0FBQyxJQUFJQSxhQUFXLFNBQVMsQ0FBQztBQUFBLElBQ2pDO0FBQUEsRUFDRjtBQUVELE1BQUksSUFBSSxXQUFXLEtBQUssSUFBSSxDQUFDLEVBQUUsV0FBVyxLQUFLO0FBQzdDLFFBQUksUUFBUSxtQkFBbUI7QUFDN0IsYUFBTztBQUFBLElBQ2IsT0FBVztBQUNMLFlBQU0sQ0FBQyxJQUFJQSxhQUFXLFNBQVMsQ0FBQztBQUFBLElBQ2pDO0FBQUEsRUFDRjtBQUVELFFBQU0sUUFBUSxvQkFBSSxJQUFLO0FBQ3ZCLE1BQUlaLEtBQUlDO0FBQ1IsYUFBVyxLQUFLLEtBQUs7QUFDbkIsUUFBSSxFQUFFLGFBQWEsT0FBTyxFQUFFLGFBQWEsTUFBTTtBQUM3QyxNQUFBRCxNQUFLLFNBQVNBLEtBQUksR0FBRyxPQUFPO0FBQUEsSUFDbEMsV0FBZSxFQUFFLGFBQWEsT0FBTyxFQUFFLGFBQWEsTUFBTTtBQUNwRCxNQUFBQyxNQUFLLFFBQVFBLEtBQUksR0FBRyxPQUFPO0FBQUEsSUFDakMsT0FBVztBQUNMLFlBQU0sSUFBSSxFQUFFLE1BQU07QUFBQSxJQUNuQjtBQUFBLEVBQ0Y7QUFFRCxNQUFJLE1BQU0sT0FBTyxHQUFHO0FBQ2xCLFdBQU87QUFBQSxFQUNSO0FBRUQsTUFBSTtBQUNKLE1BQUlELE9BQU1DLEtBQUk7QUFDWixlQUFXYixVQUFRWSxJQUFHLFFBQVFDLElBQUcsUUFBUSxPQUFPO0FBQ2hELFFBQUksV0FBVyxHQUFHO0FBQ2hCLGFBQU87QUFBQSxJQUNiLFdBQWUsYUFBYSxNQUFNRCxJQUFHLGFBQWEsUUFBUUMsSUFBRyxhQUFhLE9BQU87QUFDM0UsYUFBTztBQUFBLElBQ1I7QUFBQSxFQUNGO0FBR0QsYUFBV1osT0FBTSxPQUFPO0FBQ3RCLFFBQUlXLE9BQU0sQ0FBQ2dCLFlBQVUzQixLQUFJLE9BQU9XLEdBQUUsR0FBRyxPQUFPLEdBQUc7QUFDN0MsYUFBTztBQUFBLElBQ1I7QUFFRCxRQUFJQyxPQUFNLENBQUNlLFlBQVUzQixLQUFJLE9BQU9ZLEdBQUUsR0FBRyxPQUFPLEdBQUc7QUFDN0MsYUFBTztBQUFBLElBQ1I7QUFFRCxlQUFXLEtBQUssS0FBSztBQUNuQixVQUFJLENBQUNlLFlBQVUzQixLQUFJLE9BQU8sQ0FBQyxHQUFHLE9BQU8sR0FBRztBQUN0QyxlQUFPO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUksUUFBUTtBQUNaLE1BQUksVUFBVTtBQUdkLE1BQUksZUFBZVksT0FDakIsQ0FBQyxRQUFRLHFCQUNUQSxJQUFHLE9BQU8sV0FBVyxTQUFTQSxJQUFHLFNBQVM7QUFDNUMsTUFBSSxlQUFlRCxPQUNqQixDQUFDLFFBQVEscUJBQ1RBLElBQUcsT0FBTyxXQUFXLFNBQVNBLElBQUcsU0FBUztBQUU1QyxNQUFJLGdCQUFnQixhQUFhLFdBQVcsV0FBVyxLQUNuREMsSUFBRyxhQUFhLE9BQU8sYUFBYSxXQUFXLENBQUMsTUFBTSxHQUFHO0FBQzNELG1CQUFlO0FBQUEsRUFDaEI7QUFFRCxhQUFXLEtBQUssS0FBSztBQUNuQixlQUFXLFlBQVksRUFBRSxhQUFhLE9BQU8sRUFBRSxhQUFhO0FBQzVELGVBQVcsWUFBWSxFQUFFLGFBQWEsT0FBTyxFQUFFLGFBQWE7QUFDNUQsUUFBSUQsS0FBSTtBQUNOLFVBQUksY0FBYztBQUNoQixZQUFJLEVBQUUsT0FBTyxjQUFjLEVBQUUsT0FBTyxXQUFXLFVBQzNDLEVBQUUsT0FBTyxVQUFVLGFBQWEsU0FDaEMsRUFBRSxPQUFPLFVBQVUsYUFBYSxTQUNoQyxFQUFFLE9BQU8sVUFBVSxhQUFhLE9BQU87QUFDekMseUJBQWU7QUFBQSxRQUNoQjtBQUFBLE1BQ0Y7QUFDRCxVQUFJLEVBQUUsYUFBYSxPQUFPLEVBQUUsYUFBYSxNQUFNO0FBQzdDLGlCQUFTLFNBQVNBLEtBQUksR0FBRyxPQUFPO0FBQ2hDLFlBQUksV0FBVyxLQUFLLFdBQVdBLEtBQUk7QUFDakMsaUJBQU87QUFBQSxRQUNSO0FBQUEsTUFDRixXQUFVQSxJQUFHLGFBQWEsUUFBUSxDQUFDZ0IsWUFBVWhCLElBQUcsUUFBUSxPQUFPLENBQUMsR0FBRyxPQUFPLEdBQUc7QUFDNUUsZUFBTztBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQ0QsUUFBSUMsS0FBSTtBQUNOLFVBQUksY0FBYztBQUNoQixZQUFJLEVBQUUsT0FBTyxjQUFjLEVBQUUsT0FBTyxXQUFXLFVBQzNDLEVBQUUsT0FBTyxVQUFVLGFBQWEsU0FDaEMsRUFBRSxPQUFPLFVBQVUsYUFBYSxTQUNoQyxFQUFFLE9BQU8sVUFBVSxhQUFhLE9BQU87QUFDekMseUJBQWU7QUFBQSxRQUNoQjtBQUFBLE1BQ0Y7QUFDRCxVQUFJLEVBQUUsYUFBYSxPQUFPLEVBQUUsYUFBYSxNQUFNO0FBQzdDLGdCQUFRLFFBQVFBLEtBQUksR0FBRyxPQUFPO0FBQzlCLFlBQUksVUFBVSxLQUFLLFVBQVVBLEtBQUk7QUFDL0IsaUJBQU87QUFBQSxRQUNSO0FBQUEsTUFDRixXQUFVQSxJQUFHLGFBQWEsUUFBUSxDQUFDZSxZQUFVZixJQUFHLFFBQVEsT0FBTyxDQUFDLEdBQUcsT0FBTyxHQUFHO0FBQzVFLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUNELFFBQUksQ0FBQyxFQUFFLGFBQWFBLE9BQU1ELFFBQU8sYUFBYSxHQUFHO0FBQy9DLGFBQU87QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUtELE1BQUlBLE9BQU0sWUFBWSxDQUFDQyxPQUFNLGFBQWEsR0FBRztBQUMzQyxXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUlBLE9BQU0sWUFBWSxDQUFDRCxPQUFNLGFBQWEsR0FBRztBQUMzQyxXQUFPO0FBQUEsRUFDUjtBQUtELE1BQUksZ0JBQWdCLGNBQWM7QUFDaEMsV0FBTztBQUFBLEVBQ1I7QUFFRCxTQUFPO0FBQ1Q7QUFHQSxNQUFNLFdBQVcsQ0FBQzFDLElBQUdrQixJQUFHLFlBQVk7QUFDbEMsTUFBSSxDQUFDbEIsSUFBRztBQUNOLFdBQU9rQjtBQUFBLEVBQ1I7QUFDRCxRQUFNLE9BQU9ZLFVBQVE5QixHQUFFLFFBQVFrQixHQUFFLFFBQVEsT0FBTztBQUNoRCxTQUFPLE9BQU8sSUFBSWxCLEtBQ2QsT0FBTyxJQUFJa0IsS0FDWEEsR0FBRSxhQUFhLE9BQU9sQixHQUFFLGFBQWEsT0FBT2tCLEtBQzVDbEI7QUFDTjtBQUdBLE1BQU0sVUFBVSxDQUFDQSxJQUFHa0IsSUFBRyxZQUFZO0FBQ2pDLE1BQUksQ0FBQ2xCLElBQUc7QUFDTixXQUFPa0I7QUFBQSxFQUNSO0FBQ0QsUUFBTSxPQUFPWSxVQUFROUIsR0FBRSxRQUFRa0IsR0FBRSxRQUFRLE9BQU87QUFDaEQsU0FBTyxPQUFPLElBQUlsQixLQUNkLE9BQU8sSUFBSWtCLEtBQ1hBLEdBQUUsYUFBYSxPQUFPbEIsR0FBRSxhQUFhLE9BQU9rQixLQUM1Q2xCO0FBQ047QUFFQSxJQUFBLFdBQWlCdUU7QUNsUGpCLE1BQU0sYUFBYTdEO0FBQ25CLE1BQU0sWUFBWUM7QUFDbEIsTUFBTSxTQUFTUztBQUNmLE1BQU0sY0FBY0M7QUFDcEIsTUFBTSxRQUFRQztBQUNkLE1BQU0sUUFBUXlCO0FBQ2QsTUFBTSxRQUFRa0I7QUFDZCxNQUFNLE1BQU1DO0FBQ1osTUFBTSxPQUFPTTtBQUNiLE1BQU0sUUFBUUM7QUFDZCxNQUFNLFFBQVFDO0FBQ2QsTUFBTSxRQUFRQztBQUNkLE1BQU0sYUFBYUM7QUFDbkIsTUFBTSxVQUFVQztBQUNoQixNQUFNLFdBQVdDO0FBQ2pCLE1BQU0sZUFBZUM7QUFDckIsTUFBTSxlQUFlQztBQUNyQixNQUFNLE9BQU9DO0FBQ2IsTUFBTSxRQUFRQztBQUNkLE1BQU0sS0FBS0M7QUFDWCxNQUFNLEtBQUtDO0FBQ1gsTUFBTSxLQUFLQztBQUNYLE1BQU0sTUFBTUM7QUFDWixNQUFNLE1BQU1DO0FBQ1osTUFBTSxNQUFNQztBQUNaLE1BQU0sTUFBTUM7QUFDWixNQUFNLFNBQVNDO0FBQ2YsTUFBTSxhQUFhQyxrQkFBK0I7QUFDbEQsTUFBTSxRQUFRQyxhQUEwQjtBQUN4QyxNQUFNLFlBQVlDO0FBQ2xCLE1BQU0sZ0JBQWdCQztBQUN0QixNQUFNLGdCQUFnQkM7QUFDdEIsTUFBTSxnQkFBZ0JDO0FBQ3RCLE1BQU0sYUFBYUM7QUFDbkIsTUFBTSxhQUFhQztBQUNuQixNQUFNLFVBQVVDO0FBQ2hCLE1BQU0sTUFBTUM7QUFDWixNQUFNLE1BQU1DO0FBQ1osTUFBTSxhQUFhQztBQUNuQixNQUFNLGdCQUFnQkM7QUFDdEIsTUFBTSxTQUFTQztBQUNmLElBQUEsU0FBaUI7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQUEsRUFDZixLQUFLLFdBQVc7QUFBQSxFQUNoQixRQUFRLFdBQVc7QUFBQSxFQUNuQixxQkFBcUIsVUFBVTtBQUFBLEVBQy9CLG9CQUFvQixZQUFZO0FBQUEsRUFDaEMscUJBQXFCLFlBQVk7QUFDbkM7QUNsRk8sTUFBTSxXQUFXO0FBQUEsRUFjWixjQUFjO0FBa0JSLFNBQUEsY0FBQTtBQUFBLE1BQ1YsUUFBUSxHQUE2RDtBQUMzRCxjQUFBLEtBQUssT0FBTyxRQUFRLElBQUk7QUFDeEIsY0FBQSxPQUFPLE9BQU8sUUFBUSxNQUFNO0FBQzVCLGNBQUEsbUJBQW1CLEtBQUssS0FBSyxPQUFPLE9BQU8sT0FBTyxPQUFPLFNBQVMsSUFBSTtBQUNyRSxlQUFBLElBQUksUUFBUSxDQUFDQyxhQUFZO0FBQ3pCLGFBQUEsUUFBUSxLQUFLLEtBQUssa0JBQWtCLENBQUMsR0FBRyxDQUFDLEtBQUssVUFBb0I7QUFDakUsZ0JBQUksS0FBSztBQUNMLGNBQUFBLFNBQVEsQ0FBRSxDQUFBO0FBQ1Y7QUFBQSxZQUNKO0FBQ0Esa0JBQU0sU0FBUyxNQUFNLElBQXNDLENBQUMsT0FBZTtBQUFBLGNBQ3ZFLE9BQVEsR0FBRyxTQUFTLEtBQUssS0FBSyxrQkFBa0IsR0FBRyxDQUFDLENBQUMsRUFBWSxZQUFZO0FBQUEsY0FDN0UsTUFBTTtBQUFBLFlBQ1IsRUFBQTtBQUNGLFlBQUFBLFNBQVEsTUFBTTtBQUFBLFVBQUEsQ0FDakI7QUFBQSxRQUFBLENBQ0o7QUFBQSxNQUNMO0FBQUEsTUFDQSxRQUFRLEdBQVcsT0FBd0IsUUFBUTtBQUMvQyxlQUFPLElBQUksUUFBUSxDQUFDQSxVQUFTLFdBQVc7QUFDOUIsZ0JBQUEsS0FBSyxPQUFPLFFBQVEsSUFBSTtBQUN4QixnQkFBQSxPQUFPLE9BQU8sUUFBUSxNQUFNO0FBQzVCLGdCQUFBLG1CQUFtQixLQUFLLEtBQUssT0FBTyxPQUFPLE9BQU8sT0FBTyxTQUFTLElBQUk7QUFDekUsYUFBQSxTQUFTLEtBQUssS0FBSyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxTQUFTO0FBQ3ZELGdCQUFJLEtBQUs7QUFDTCxxQkFBTyxPQUFPLEdBQUc7QUFBQSxZQUNyQjtBQUNNLGtCQUFBN0csUUFBTyxLQUFLLFNBQVMsTUFBTTtBQUNqQyxnQkFBSSxTQUFTLFFBQVE7QUFDYixrQkFBQTtBQUNBLHVCQUFPNkcsU0FBUSxLQUFLLE1BQU03RyxLQUFJLENBQUM7QUFBQSx1QkFDMUI7QUFDTCx1QkFBTyxDQUFDO0FBQ1I7QUFBQSxjQUNKO0FBQUEsWUFDSjtBQUNBLG1CQUFPNkcsU0FBUTdHLEtBQUk7QUFBQSxVQUFBLENBQ3RCO0FBQUEsUUFBQSxDQUNKO0FBQUEsTUFDTDtBQUFBLE1BQ0E7QUFBQSxNQUNBLFdBQVcsR0FBMEI7QUFDakMsZUFBTyxJQUFJLFFBQVEsQ0FBQzZHLFVBQVMsV0FBVztBQUM5QixnQkFBQSxLQUFLLE9BQU8sUUFBUSxJQUFJO0FBQ3hCLGdCQUFBLE9BQU8sT0FBTyxRQUFRLE1BQU07QUFDNUIsZ0JBQUEsbUJBQW1CLEtBQUssS0FBSyxPQUFPLE9BQU8sT0FBTyxPQUFPLFNBQVMsSUFBSTtBQUM1RSxnQkFBTSxJQUFJLEtBQUssS0FBSyxrQkFBa0IsQ0FBQztBQUN2QyxjQUFJLHFCQUFxQixDQUFDO0FBQ3ZCLGFBQUEsR0FBRyxHQUFHLEVBQUUsV0FBVyxNQUFNLE9BQU8sUUFBUSxDQUFDLFFBQVE7QUFDaEQsZ0JBQUksS0FBSztBQUNMLHFCQUFPLE9BQU8sR0FBRztBQUFBLFlBQ3JCO0FBQ0EsWUFBQUEsU0FBUSxJQUFJO0FBQUEsVUFBQSxDQUNmO0FBQUEsUUFBQSxDQUNKO0FBQUEsTUFDTDtBQUFBLElBQUE7QUFHUSxTQUFBLFlBQUE7QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFBc0I7QUFoRmhCLFVBQUEsSUFBSSxLQUFLO0FBQ2YsUUFBSSxPQUFPLFFBQVEsR0FBRyxPQUFPLElBQUksR0FBRztBQUVoQyxXQUFLLFVBQVUsS0FBSztBQUFBLElBQUEsT0FDakI7QUFFSCxXQUFLLFVBQVUsS0FBSztBQUFBLElBQ3hCO0FBQUEsRUFDSjtBQUFBLEVBcEJBLGFBQWE7QUFDRixXQUFBLE9BQU8sT0FBTyxPQUFPLE9BQU87QUFBQSxFQUN2QztBQUFBLEVBb0JBLE9BQU8saUJBQWlCO0FBQ2hCLFFBQUEsQ0FBQyxLQUFLLFlBQVk7QUFDYixXQUFBLGFBQWEsSUFBSTtJQUMxQjtBQUNBLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBbUVKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BHZSxTQUFTLEtBQUssSUFBSSxTQUFTO0FBQ3hDLFNBQU8sU0FBUyxPQUFPO0FBQ3JCLFdBQU8sR0FBRyxNQUFNLFNBQVMsU0FBUztBQUFBLEVBQ3RDO0FBQ0E7QUNBQSxNQUFNLEVBQUMsU0FBUSxJQUFJLE9BQU87QUFDMUIsTUFBTSxFQUFDLGVBQWMsSUFBSTtBQUV6QixNQUFNLFVBQVUsV0FBUyxXQUFTO0FBQzlCLFFBQU0sTUFBTSxTQUFTLEtBQUssS0FBSztBQUMvQixTQUFPLE1BQU0sR0FBRyxNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUksTUFBTSxHQUFHLEVBQUUsRUFBRSxZQUFhO0FBQ3JFLEdBQUcsdUJBQU8sT0FBTyxJQUFJLENBQUM7QUFFdEIsTUFBTSxhQUFhLENBQUMsU0FBUztBQUMzQixTQUFPLEtBQUs7QUFDWixTQUFPLENBQUMsVUFBVSxPQUFPLEtBQUssTUFBTTtBQUN0QztBQUVBLE1BQU0sYUFBYSxVQUFRLFdBQVMsT0FBTyxVQUFVO0FBU3JELE1BQU0sRUFBQyxRQUFPLElBQUk7QUFTbEIsTUFBTSxjQUFjLFdBQVcsV0FBVztBQVMxQyxTQUFTLFNBQVMsS0FBSztBQUNyQixTQUFPLFFBQVEsUUFBUSxDQUFDLFlBQVksR0FBRyxLQUFLLElBQUksZ0JBQWdCLFFBQVEsQ0FBQyxZQUFZLElBQUksV0FBVyxLQUMvRixXQUFXLElBQUksWUFBWSxRQUFRLEtBQUssSUFBSSxZQUFZLFNBQVMsR0FBRztBQUMzRTtBQVNBLE1BQU0sZ0JBQWdCLFdBQVcsYUFBYTtBQVU5QyxTQUFTLGtCQUFrQixLQUFLO0FBQzlCLE1BQUk7QUFDSixNQUFLLE9BQU8sZ0JBQWdCLGVBQWlCLFlBQVksUUFBUztBQUNoRSxhQUFTLFlBQVksT0FBTyxHQUFHO0FBQUEsRUFDbkMsT0FBUztBQUNMLGFBQVUsT0FBUyxJQUFJLFVBQVksY0FBYyxJQUFJLE1BQU07QUFBQSxFQUM1RDtBQUNELFNBQU87QUFDVDtBQVNBLE1BQU0sV0FBVyxXQUFXLFFBQVE7QUFRcEMsTUFBTSxhQUFhLFdBQVcsVUFBVTtBQVN4QyxNQUFNLFdBQVcsV0FBVyxRQUFRO0FBU3BDLE1BQU0sV0FBVyxDQUFDLFVBQVUsVUFBVSxRQUFRLE9BQU8sVUFBVTtBQVEvRCxNQUFNLFlBQVksV0FBUyxVQUFVLFFBQVEsVUFBVTtBQVN2RCxNQUFNLGdCQUFnQixDQUFDLFFBQVE7QUFDN0IsTUFBSSxPQUFPLEdBQUcsTUFBTSxVQUFVO0FBQzVCLFdBQU87QUFBQSxFQUNSO0FBRUQsUUFBTTdILGFBQVksZUFBZSxHQUFHO0FBQ3BDLFVBQVFBLGVBQWMsUUFBUUEsZUFBYyxPQUFPLGFBQWEsT0FBTyxlQUFlQSxVQUFTLE1BQU0sU0FBUyxFQUFFLE9BQU8sZUFBZSxRQUFRLEVBQUUsT0FBTyxZQUFZO0FBQ3JLO0FBU0EsTUFBTSxTQUFTLFdBQVcsTUFBTTtBQVNoQyxNQUFNLFNBQVMsV0FBVyxNQUFNO0FBU2hDLE1BQU0sU0FBUyxXQUFXLE1BQU07QUFTaEMsTUFBTSxhQUFhLFdBQVcsVUFBVTtBQVN4QyxNQUFNLFdBQVcsQ0FBQyxRQUFRLFNBQVMsR0FBRyxLQUFLLFdBQVcsSUFBSSxJQUFJO0FBUzlELE1BQU0sYUFBYSxDQUFDLFVBQVU7QUFDNUIsUUFBTSxVQUFVO0FBQ2hCLFNBQU8sVUFDSixPQUFPLGFBQWEsY0FBYyxpQkFBaUIsWUFDcEQsU0FBUyxLQUFLLEtBQUssTUFBTSxXQUN4QixXQUFXLE1BQU0sUUFBUSxLQUFLLE1BQU0sU0FBVSxNQUFLO0FBRXhEO0FBU0EsTUFBTSxvQkFBb0IsV0FBVyxpQkFBaUI7QUFTdEQsTUFBTSxPQUFPLENBQUMsUUFBUSxJQUFJLE9BQ3hCLElBQUksS0FBSSxJQUFLLElBQUksUUFBUSxzQ0FBc0MsRUFBRTtBQWlCbkUsU0FBUyxRQUFRLEtBQUssSUFBSSxFQUFDLGFBQWEsTUFBSyxJQUFJLElBQUk7QUFFbkQsTUFBSSxRQUFRLFFBQVEsT0FBTyxRQUFRLGFBQWE7QUFDOUM7QUFBQSxFQUNEO0FBRUQsTUFBSTtBQUNKLE1BQUk7QUFHSixNQUFJLE9BQU8sUUFBUSxVQUFVO0FBRTNCLFVBQU0sQ0FBQyxHQUFHO0FBQUEsRUFDWDtBQUVELE1BQUksUUFBUSxHQUFHLEdBQUc7QUFFaEIsU0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDdEMsU0FBRyxLQUFLLE1BQU0sSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHO0FBQUEsSUFDN0I7QUFBQSxFQUNMLE9BQVM7QUFFTCxVQUFNLE9BQU8sYUFBYSxPQUFPLG9CQUFvQixHQUFHLElBQUksT0FBTyxLQUFLLEdBQUc7QUFDM0UsVUFBTSxNQUFNLEtBQUs7QUFDakIsUUFBSTtBQUVKLFNBQUssSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQ3hCLFlBQU0sS0FBSyxDQUFDO0FBQ1osU0FBRyxLQUFLLE1BQU0sSUFBSSxHQUFHLEdBQUcsS0FBSyxHQUFHO0FBQUEsSUFDakM7QUFBQSxFQUNGO0FBQ0g7QUFFQSxTQUFTLFFBQVEsS0FBSyxLQUFLO0FBQ3pCLFFBQU0sSUFBSTtBQUNWLFFBQU0sT0FBTyxPQUFPLEtBQUssR0FBRztBQUM1QixNQUFJLElBQUksS0FBSztBQUNiLE1BQUk7QUFDSixTQUFPLE1BQU0sR0FBRztBQUNkLFdBQU8sS0FBSyxDQUFDO0FBQ2IsUUFBSSxRQUFRLEtBQUssZUFBZTtBQUM5QixhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFDRCxTQUFPO0FBQ1Q7QUFFQSxNQUFNLFdBQVcsTUFBTTtBQUVyQixNQUFJLE9BQU8sZUFBZTtBQUFhLFdBQU87QUFDOUMsU0FBTyxPQUFPLFNBQVMsY0FBYyxPQUFRLE9BQU8sV0FBVyxjQUFjLFNBQVM7QUFDeEY7QUFFQSxNQUFNLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxZQUFZLE9BQU8sS0FBSyxZQUFZO0FBb0IzRSxTQUFTLFFBQW1DO0FBQzFDLFFBQU0sRUFBQyxTQUFRLElBQUksaUJBQWlCLElBQUksS0FBSyxRQUFRO0FBQ3JELFFBQU0sU0FBUyxDQUFBO0FBQ2YsUUFBTSxjQUFjLENBQUMsS0FBSyxRQUFRO0FBQ2hDLFVBQU0sWUFBWSxZQUFZLFFBQVEsUUFBUSxHQUFHLEtBQUs7QUFDdEQsUUFBSSxjQUFjLE9BQU8sU0FBUyxDQUFDLEtBQUssY0FBYyxHQUFHLEdBQUc7QUFDMUQsYUFBTyxTQUFTLElBQUksTUFBTSxPQUFPLFNBQVMsR0FBRyxHQUFHO0FBQUEsSUFDdEQsV0FBZSxjQUFjLEdBQUcsR0FBRztBQUM3QixhQUFPLFNBQVMsSUFBSSxNQUFNLENBQUUsR0FBRSxHQUFHO0FBQUEsSUFDdkMsV0FBZSxRQUFRLEdBQUcsR0FBRztBQUN2QixhQUFPLFNBQVMsSUFBSSxJQUFJLE1BQUs7QUFBQSxJQUNuQyxPQUFXO0FBQ0wsYUFBTyxTQUFTLElBQUk7QUFBQSxJQUNyQjtBQUFBLEVBQ0Y7QUFFRCxXQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUNoRCxjQUFVLENBQUMsS0FBSyxRQUFRLFVBQVUsQ0FBQyxHQUFHLFdBQVc7QUFBQSxFQUNsRDtBQUNELFNBQU87QUFDVDtBQVlBLE1BQU0sU0FBUyxDQUFDb0IsSUFBR2tCLElBQUcsU0FBUyxFQUFDLFdBQVUsSUFBRyxPQUFPO0FBQ2xELFVBQVFBLElBQUcsQ0FBQyxLQUFLLFFBQVE7QUFDdkIsUUFBSSxXQUFXLFdBQVcsR0FBRyxHQUFHO0FBQzlCLE1BQUFsQixHQUFFLEdBQUcsSUFBSSxLQUFLLEtBQUssT0FBTztBQUFBLElBQ2hDLE9BQVc7QUFDTCxNQUFBQSxHQUFFLEdBQUcsSUFBSTtBQUFBLElBQ1Y7QUFBQSxFQUNMLEdBQUssRUFBQyxXQUFVLENBQUM7QUFDZixTQUFPQTtBQUNUO0FBU0EsTUFBTSxXQUFXLENBQUMsWUFBWTtBQUM1QixNQUFJLFFBQVEsV0FBVyxDQUFDLE1BQU0sT0FBUTtBQUNwQyxjQUFVLFFBQVEsTUFBTSxDQUFDO0FBQUEsRUFDMUI7QUFDRCxTQUFPO0FBQ1Q7QUFXQSxNQUFNLFdBQVcsQ0FBQyxhQUFhLGtCQUFrQixPQUFPMEcsaUJBQWdCO0FBQ3RFLGNBQVksWUFBWSxPQUFPLE9BQU8saUJBQWlCLFdBQVdBLFlBQVc7QUFDN0UsY0FBWSxVQUFVLGNBQWM7QUFDcEMsU0FBTyxlQUFlLGFBQWEsU0FBUztBQUFBLElBQzFDLE9BQU8saUJBQWlCO0FBQUEsRUFDNUIsQ0FBRztBQUNELFdBQVMsT0FBTyxPQUFPLFlBQVksV0FBVyxLQUFLO0FBQ3JEO0FBV0EsTUFBTSxlQUFlLENBQUMsV0FBVyxTQUFTQyxTQUFRLGVBQWU7QUFDL0QsTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJO0FBQ0osUUFBTSxTQUFTLENBQUE7QUFFZixZQUFVLFdBQVc7QUFFckIsTUFBSSxhQUFhO0FBQU0sV0FBTztBQUU5QixLQUFHO0FBQ0QsWUFBUSxPQUFPLG9CQUFvQixTQUFTO0FBQzVDLFFBQUksTUFBTTtBQUNWLFdBQU8sTUFBTSxHQUFHO0FBQ2QsYUFBTyxNQUFNLENBQUM7QUFDZCxXQUFLLENBQUMsY0FBYyxXQUFXLE1BQU0sV0FBVyxPQUFPLE1BQU0sQ0FBQyxPQUFPLElBQUksR0FBRztBQUMxRSxnQkFBUSxJQUFJLElBQUksVUFBVSxJQUFJO0FBQzlCLGVBQU8sSUFBSSxJQUFJO0FBQUEsTUFDaEI7QUFBQSxJQUNGO0FBQ0QsZ0JBQVlBLFlBQVcsU0FBUyxlQUFlLFNBQVM7QUFBQSxFQUM1RCxTQUFXLGNBQWMsQ0FBQ0EsV0FBVUEsUUFBTyxXQUFXLE9BQU8sTUFBTSxjQUFjLE9BQU87QUFFdEYsU0FBTztBQUNUO0FBV0EsTUFBTSxXQUFXLENBQUMsS0FBSyxjQUFjLGFBQWE7QUFDaEQsUUFBTSxPQUFPLEdBQUc7QUFDaEIsTUFBSSxhQUFhLFVBQWEsV0FBVyxJQUFJLFFBQVE7QUFDbkQsZUFBVyxJQUFJO0FBQUEsRUFDaEI7QUFDRCxjQUFZLGFBQWE7QUFDekIsUUFBTSxZQUFZLElBQUksUUFBUSxjQUFjLFFBQVE7QUFDcEQsU0FBTyxjQUFjLE1BQU0sY0FBYztBQUMzQztBQVVBLE1BQU0sVUFBVSxDQUFDLFVBQVU7QUFDekIsTUFBSSxDQUFDO0FBQU8sV0FBTztBQUNuQixNQUFJLFFBQVEsS0FBSztBQUFHLFdBQU87QUFDM0IsTUFBSSxJQUFJLE1BQU07QUFDZCxNQUFJLENBQUMsU0FBUyxDQUFDO0FBQUcsV0FBTztBQUN6QixRQUFNLE1BQU0sSUFBSSxNQUFNLENBQUM7QUFDdkIsU0FBTyxNQUFNLEdBQUc7QUFDZCxRQUFJLENBQUMsSUFBSSxNQUFNLENBQUM7QUFBQSxFQUNqQjtBQUNELFNBQU87QUFDVDtBQVdBLE1BQU0sZ0JBQWdCLGdCQUFjO0FBRWxDLFNBQU8sV0FBUztBQUNkLFdBQU8sY0FBYyxpQkFBaUI7QUFBQSxFQUMxQztBQUNBLEdBQUcsT0FBTyxlQUFlLGVBQWUsZUFBZSxVQUFVLENBQUM7QUFVbEUsTUFBTSxlQUFlLENBQUMsS0FBSyxPQUFPO0FBQ2hDLFFBQU0sWUFBWSxPQUFPLElBQUksT0FBTyxRQUFRO0FBRTVDLFFBQU1qSSxZQUFXLFVBQVUsS0FBSyxHQUFHO0FBRW5DLE1BQUk7QUFFSixVQUFRLFNBQVNBLFVBQVMsS0FBSSxNQUFPLENBQUMsT0FBTyxNQUFNO0FBQ2pELFVBQU0sT0FBTyxPQUFPO0FBQ3BCLE9BQUcsS0FBSyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQUEsRUFDOUI7QUFDSDtBQVVBLE1BQU0sV0FBVyxDQUFDLFFBQVEsUUFBUTtBQUNoQyxNQUFJO0FBQ0osUUFBTSxNQUFNLENBQUE7QUFFWixVQUFRLFVBQVUsT0FBTyxLQUFLLEdBQUcsT0FBTyxNQUFNO0FBQzVDLFFBQUksS0FBSyxPQUFPO0FBQUEsRUFDakI7QUFFRCxTQUFPO0FBQ1Q7QUFHQSxNQUFNLGFBQWEsV0FBVyxpQkFBaUI7QUFFL0MsTUFBTSxjQUFjLFNBQU87QUFDekIsU0FBTyxJQUFJLGNBQWM7QUFBQSxJQUFRO0FBQUEsSUFDL0IsU0FBUyxTQUFTLEdBQUcsSUFBSSxJQUFJO0FBQzNCLGFBQU8sR0FBRyxZQUFhLElBQUc7QUFBQSxJQUMzQjtBQUFBLEVBQ0w7QUFDQTtBQUdBLE1BQU0sa0JBQWtCLENBQUMsRUFBQyxnQkFBQWtJLGdCQUFjLE1BQU0sQ0FBQyxLQUFLLFNBQVNBLGdCQUFlLEtBQUssS0FBSyxJQUFJLEdBQUcsT0FBTyxTQUFTO0FBUzdHLE1BQU0sV0FBVyxXQUFXLFFBQVE7QUFFcEMsTUFBTSxvQkFBb0IsQ0FBQyxLQUFLLFlBQVk7QUFDMUMsUUFBTUYsZUFBYyxPQUFPLDBCQUEwQixHQUFHO0FBQ3hELFFBQU0scUJBQXFCLENBQUE7QUFFM0IsVUFBUUEsY0FBYSxDQUFDLFlBQVloSCxVQUFTO0FBQ3pDLFFBQUksUUFBUSxZQUFZQSxPQUFNLEdBQUcsTUFBTSxPQUFPO0FBQzVDLHlCQUFtQkEsS0FBSSxJQUFJO0FBQUEsSUFDNUI7QUFBQSxFQUNMLENBQUc7QUFFRCxTQUFPLGlCQUFpQixLQUFLLGtCQUFrQjtBQUNqRDtBQU9BLE1BQU0sZ0JBQWdCLENBQUMsUUFBUTtBQUM3QixvQkFBa0IsS0FBSyxDQUFDLFlBQVlBLFVBQVM7QUFFM0MsUUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDLGFBQWEsVUFBVSxRQUFRLEVBQUUsUUFBUUEsS0FBSSxNQUFNLElBQUk7QUFDN0UsYUFBTztBQUFBLElBQ1I7QUFFRCxVQUFNLFFBQVEsSUFBSUEsS0FBSTtBQUV0QixRQUFJLENBQUMsV0FBVyxLQUFLO0FBQUc7QUFFeEIsZUFBVyxhQUFhO0FBRXhCLFFBQUksY0FBYyxZQUFZO0FBQzVCLGlCQUFXLFdBQVc7QUFDdEI7QUFBQSxJQUNEO0FBRUQsUUFBSSxDQUFDLFdBQVcsS0FBSztBQUNuQixpQkFBVyxNQUFNLE1BQU07QUFDckIsY0FBTSxNQUFNLHVDQUF3Q0EsUUFBTyxHQUFJO0FBQUEsTUFDdkU7QUFBQSxJQUNLO0FBQUEsRUFDTCxDQUFHO0FBQ0g7QUFFQSxNQUFNLGNBQWMsQ0FBQyxlQUFlLGNBQWM7QUFDaEQsUUFBTSxNQUFNLENBQUE7QUFFWixRQUFNLFNBQVMsQ0FBQyxRQUFRO0FBQ3RCLFFBQUksUUFBUSxXQUFTO0FBQ25CLFVBQUksS0FBSyxJQUFJO0FBQUEsSUFDbkIsQ0FBSztBQUFBLEVBQ0Y7QUFFRCxVQUFRLGFBQWEsSUFBSSxPQUFPLGFBQWEsSUFBSSxPQUFPLE9BQU8sYUFBYSxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRTlGLFNBQU87QUFDVDtBQUVBLE1BQU1tSCxTQUFPLE1BQU07QUFBRTtBQUVyQixNQUFNLGlCQUFpQixDQUFDLE9BQU8saUJBQWlCO0FBQzlDLFVBQVEsQ0FBQztBQUNULFNBQU8sT0FBTyxTQUFTLEtBQUssSUFBSSxRQUFRO0FBQzFDO0FBRUEsTUFBTSxRQUFRO0FBRWQsTUFBTSxRQUFRO0FBRWQsTUFBTSxXQUFXO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxFQUNBLGFBQWEsUUFBUSxNQUFNLFlBQWEsSUFBRztBQUM3QztBQUVBLE1BQU0saUJBQWlCLENBQUMsT0FBTyxJQUFJLFdBQVcsU0FBUyxnQkFBZ0I7QUFDckUsTUFBSSxNQUFNO0FBQ1YsUUFBTSxFQUFDLE9BQU0sSUFBSTtBQUNqQixTQUFPLFFBQVE7QUFDYixXQUFPLFNBQVMsS0FBSyxPQUFNLElBQUssU0FBTyxDQUFDO0FBQUEsRUFDekM7QUFFRCxTQUFPO0FBQ1Q7QUFTQSxTQUFTLG9CQUFvQixPQUFPO0FBQ2xDLFNBQU8sQ0FBQyxFQUFFLFNBQVMsV0FBVyxNQUFNLE1BQU0sS0FBSyxNQUFNLE9BQU8sV0FBVyxNQUFNLGNBQWMsTUFBTSxPQUFPLFFBQVE7QUFDbEg7QUFFQSxNQUFNLGVBQWUsQ0FBQyxRQUFRO0FBQzVCLFFBQU0sUUFBUSxJQUFJLE1BQU0sRUFBRTtBQUUxQixRQUFNLFFBQVEsQ0FBQyxRQUFRLE1BQU07QUFFM0IsUUFBSSxTQUFTLE1BQU0sR0FBRztBQUNwQixVQUFJLE1BQU0sUUFBUSxNQUFNLEtBQUssR0FBRztBQUM5QjtBQUFBLE1BQ0Q7QUFFRCxVQUFHLEVBQUUsWUFBWSxTQUFTO0FBQ3hCLGNBQU0sQ0FBQyxJQUFJO0FBQ1gsY0FBTSxTQUFTLFFBQVEsTUFBTSxJQUFJLENBQUEsSUFBSyxDQUFBO0FBRXRDLGdCQUFRLFFBQVEsQ0FBQyxPQUFPLFFBQVE7QUFDOUIsZ0JBQU0sZUFBZSxNQUFNLE9BQU8sSUFBSSxDQUFDO0FBQ3ZDLFdBQUMsWUFBWSxZQUFZLE1BQU0sT0FBTyxHQUFHLElBQUk7QUFBQSxRQUN2RCxDQUFTO0FBRUQsY0FBTSxDQUFDLElBQUk7QUFFWCxlQUFPO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQUVELFNBQU8sTUFBTSxLQUFLLENBQUM7QUFDckI7QUFFQSxNQUFlLFFBQUE7QUFBQSxFQUNiO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsWUFBWTtBQUFBO0FBQUEsRUFDWjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0YsTUFBRUE7QUFBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBLFFBQVE7QUFBQSxFQUNSO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNGO0FDdnJCQSxTQUFTLFdBQVcsU0FBU0MsT0FBTUMsU0FBUXpILFVBQVMsVUFBVTtBQUM1RCxRQUFNLEtBQUssSUFBSTtBQUVmLE1BQUksTUFBTSxtQkFBbUI7QUFDM0IsVUFBTSxrQkFBa0IsTUFBTSxLQUFLLFdBQVc7QUFBQSxFQUNsRCxPQUFTO0FBQ0wsU0FBSyxRQUFTLElBQUksTUFBSyxFQUFJO0FBQUEsRUFDNUI7QUFFRCxPQUFLLFVBQVU7QUFDZixPQUFLLE9BQU87QUFDWixFQUFBd0gsVUFBUyxLQUFLLE9BQU9BO0FBQ3JCLEVBQUFDLFlBQVcsS0FBSyxTQUFTQTtBQUN6QixFQUFBekgsYUFBWSxLQUFLLFVBQVVBO0FBQzNCLGVBQWEsS0FBSyxXQUFXO0FBQy9CO0FBRUEsTUFBTSxTQUFTLFlBQVksT0FBTztBQUFBLEVBQ2hDLFFBQVEsU0FBUyxTQUFTO0FBQ3hCLFdBQU87QUFBQTtBQUFBLE1BRUwsU0FBUyxLQUFLO0FBQUEsTUFDZCxNQUFNLEtBQUs7QUFBQTtBQUFBLE1BRVgsYUFBYSxLQUFLO0FBQUEsTUFDbEIsUUFBUSxLQUFLO0FBQUE7QUFBQSxNQUViLFVBQVUsS0FBSztBQUFBLE1BQ2YsWUFBWSxLQUFLO0FBQUEsTUFDakIsY0FBYyxLQUFLO0FBQUEsTUFDbkIsT0FBTyxLQUFLO0FBQUE7QUFBQSxNQUVaLFFBQVEsTUFBTSxhQUFhLEtBQUssTUFBTTtBQUFBLE1BQ3RDLE1BQU0sS0FBSztBQUFBLE1BQ1gsUUFBUSxLQUFLLFlBQVksS0FBSyxTQUFTLFNBQVMsS0FBSyxTQUFTLFNBQVM7QUFBQSxJQUM3RTtBQUFBLEVBQ0c7QUFDSCxDQUFDO0FBRUQsTUFBTVYsY0FBWSxXQUFXO0FBQzdCLE1BQU0sY0FBYyxDQUFBO0FBRXBCO0FBQUEsRUFDRTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUE7QUFFRixFQUFFLFFBQVEsQ0FBQWtJLFVBQVE7QUFDaEIsY0FBWUEsS0FBSSxJQUFJLEVBQUMsT0FBT0EsTUFBSTtBQUNsQyxDQUFDO0FBRUQsT0FBTyxpQkFBaUIsWUFBWSxXQUFXO0FBQy9DLE9BQU8sZUFBZWxJLGFBQVcsZ0JBQWdCLEVBQUMsT0FBTyxLQUFJLENBQUM7QUFHOUQsV0FBVyxPQUFPLENBQUNFLFFBQU9nSSxPQUFNQyxTQUFRekgsVUFBUyxVQUFVLGdCQUFnQjtBQUN6RSxRQUFNLGFBQWEsT0FBTyxPQUFPVixXQUFTO0FBRTFDLFFBQU0sYUFBYUUsUUFBTyxZQUFZLFNBQVM2SCxRQUFPLEtBQUs7QUFDekQsV0FBTyxRQUFRLE1BQU07QUFBQSxFQUN0QixHQUFFLFVBQVE7QUFDVCxXQUFPLFNBQVM7QUFBQSxFQUNwQixDQUFHO0FBRUQsYUFBVyxLQUFLLFlBQVk3SCxPQUFNLFNBQVNnSSxPQUFNQyxTQUFRekgsVUFBUyxRQUFRO0FBRTFFLGFBQVcsUUFBUVI7QUFFbkIsYUFBVyxPQUFPQSxPQUFNO0FBRXhCLGlCQUFlLE9BQU8sT0FBTyxZQUFZLFdBQVc7QUFFcEQsU0FBTztBQUNUO0FDaEdBLE1BQUEsY0FBZTtBQ2FmLFNBQVMsWUFBWSxPQUFPO0FBQzFCLFNBQU8sTUFBTSxjQUFjLEtBQUssS0FBSyxNQUFNLFFBQVEsS0FBSztBQUMxRDtBQVNBLFNBQVMsZUFBZSxLQUFLO0FBQzNCLFNBQU8sTUFBTSxTQUFTLEtBQUssSUFBSSxJQUFJLElBQUksTUFBTSxHQUFHLEVBQUUsSUFBSTtBQUN4RDtBQVdBLFNBQVMsVUFBVSxNQUFNLEtBQUssTUFBTTtBQUNsQyxNQUFJLENBQUM7QUFBTSxXQUFPO0FBQ2xCLFNBQU8sS0FBSyxPQUFPLEdBQUcsRUFBRSxJQUFJLFNBQVMsS0FBSyxPQUFPLEdBQUc7QUFFbEQsWUFBUSxlQUFlLEtBQUs7QUFDNUIsV0FBTyxDQUFDLFFBQVEsSUFBSSxNQUFNLFFBQVEsTUFBTTtBQUFBLEVBQ3pDLENBQUEsRUFBRSxLQUFLLE9BQU8sTUFBTSxFQUFFO0FBQ3pCO0FBU0EsU0FBUyxZQUFZLEtBQUs7QUFDeEIsU0FBTyxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxLQUFLLFdBQVc7QUFDcEQ7QUFFQSxNQUFNLGFBQWEsTUFBTSxhQUFhLE9BQU8sQ0FBRSxHQUFFLE1BQU0sU0FBUzZILFFBQU8sTUFBTTtBQUMzRSxTQUFPLFdBQVcsS0FBSyxJQUFJO0FBQzdCLENBQUM7QUF5QkQsU0FBUyxXQUFXLEtBQUssVUFBVSxTQUFTO0FBQzFDLE1BQUksQ0FBQyxNQUFNLFNBQVMsR0FBRyxHQUFHO0FBQ3hCLFVBQU0sSUFBSSxVQUFVLDBCQUEwQjtBQUFBLEVBQy9DO0FBR0QsYUFBVyxZQUFZLElBQXlCO0FBR2hELFlBQVUsTUFBTSxhQUFhLFNBQVM7QUFBQSxJQUNwQyxZQUFZO0FBQUEsSUFDWixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsRUFDVixHQUFFLE9BQU8sU0FBUyxRQUFRLFFBQVEsUUFBUTtBQUV6QyxXQUFPLENBQUMsTUFBTSxZQUFZLE9BQU8sTUFBTSxDQUFDO0FBQUEsRUFDNUMsQ0FBRztBQUVELFFBQU0sYUFBYSxRQUFRO0FBRTNCLFFBQU0sVUFBVSxRQUFRLFdBQVc7QUFDbkMsUUFBTSxPQUFPLFFBQVE7QUFDckIsUUFBTSxVQUFVLFFBQVE7QUFDeEIsUUFBTSxRQUFRLFFBQVEsUUFBUSxPQUFPLFNBQVMsZUFBZTtBQUM3RCxRQUFNLFVBQVUsU0FBUyxNQUFNLG9CQUFvQixRQUFRO0FBRTNELE1BQUksQ0FBQyxNQUFNLFdBQVcsT0FBTyxHQUFHO0FBQzlCLFVBQU0sSUFBSSxVQUFVLDRCQUE0QjtBQUFBLEVBQ2pEO0FBRUQsV0FBUyxhQUFhLE9BQU87QUFDM0IsUUFBSSxVQUFVO0FBQU0sYUFBTztBQUUzQixRQUFJLE1BQU0sT0FBTyxLQUFLLEdBQUc7QUFDdkIsYUFBTyxNQUFNO0lBQ2Q7QUFFRCxRQUFJLENBQUMsV0FBVyxNQUFNLE9BQU8sS0FBSyxHQUFHO0FBQ25DLFlBQU0sSUFBSSxXQUFXLDhDQUE4QztBQUFBLElBQ3BFO0FBRUQsUUFBSSxNQUFNLGNBQWMsS0FBSyxLQUFLLE1BQU0sYUFBYSxLQUFLLEdBQUc7QUFDM0QsYUFBTyxXQUFXLE9BQU8sU0FBUyxhQUFhLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sS0FBSyxLQUFLO0FBQUEsSUFDckY7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQVlELFdBQVMsZUFBZSxPQUFPLEtBQUssTUFBTTtBQUN4QyxRQUFJLE1BQU07QUFFVixRQUFJLFNBQVMsQ0FBQyxRQUFRLE9BQU8sVUFBVSxVQUFVO0FBQy9DLFVBQUksTUFBTSxTQUFTLEtBQUssSUFBSSxHQUFHO0FBRTdCLGNBQU0sYUFBYSxNQUFNLElBQUksTUFBTSxHQUFHLEVBQUU7QUFFeEMsZ0JBQVEsS0FBSyxVQUFVLEtBQUs7QUFBQSxNQUNwQyxXQUNTLE1BQU0sUUFBUSxLQUFLLEtBQUssWUFBWSxLQUFLLE1BQ3hDLE1BQU0sV0FBVyxLQUFLLEtBQUssTUFBTSxTQUFTLEtBQUssSUFBSSxPQUFPLE1BQU0sTUFBTSxRQUFRLEtBQUssSUFDbEY7QUFFSCxjQUFNLGVBQWUsR0FBRztBQUV4QixZQUFJLFFBQVEsU0FBUyxLQUFLLElBQUksT0FBTztBQUNuQyxZQUFFLE1BQU0sWUFBWSxFQUFFLEtBQUssT0FBTyxTQUFTLFNBQVM7QUFBQTtBQUFBLFlBRWxELFlBQVksT0FBTyxVQUFVLENBQUMsR0FBRyxHQUFHLE9BQU8sSUFBSSxJQUFLLFlBQVksT0FBTyxNQUFNLE1BQU07QUFBQSxZQUNuRixhQUFhLEVBQUU7QUFBQSxVQUMzQjtBQUFBLFFBQ0EsQ0FBUztBQUNELGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUVELFFBQUksWUFBWSxLQUFLLEdBQUc7QUFDdEIsYUFBTztBQUFBLElBQ1I7QUFFRCxhQUFTLE9BQU8sVUFBVSxNQUFNLEtBQUssSUFBSSxHQUFHLGFBQWEsS0FBSyxDQUFDO0FBRS9ELFdBQU87QUFBQSxFQUNSO0FBRUQsUUFBTSxRQUFRLENBQUE7QUFFZCxRQUFNLGlCQUFpQixPQUFPLE9BQU8sWUFBWTtBQUFBLElBQy9DO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNKLENBQUc7QUFFRCxXQUFTLE1BQU0sT0FBTyxNQUFNO0FBQzFCLFFBQUksTUFBTSxZQUFZLEtBQUs7QUFBRztBQUU5QixRQUFJLE1BQU0sUUFBUSxLQUFLLE1BQU0sSUFBSTtBQUMvQixZQUFNLE1BQU0sb0NBQW9DLEtBQUssS0FBSyxHQUFHLENBQUM7QUFBQSxJQUMvRDtBQUVELFVBQU0sS0FBSyxLQUFLO0FBRWhCLFVBQU0sUUFBUSxPQUFPLFNBQVMsS0FBSyxJQUFJLEtBQUs7QUFDMUMsWUFBTSxTQUFTLEVBQUUsTUFBTSxZQUFZLEVBQUUsS0FBSyxPQUFPLFNBQVMsUUFBUTtBQUFBLFFBQ2hFO0FBQUEsUUFBVTtBQUFBLFFBQUksTUFBTSxTQUFTLEdBQUcsSUFBSSxJQUFJLEtBQU0sSUFBRztBQUFBLFFBQUs7QUFBQSxRQUFNO0FBQUEsTUFDcEU7QUFFTSxVQUFJLFdBQVcsTUFBTTtBQUNuQixjQUFNLElBQUksT0FBTyxLQUFLLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQUEsTUFDMUM7QUFBQSxJQUNQLENBQUs7QUFFRCxVQUFNLElBQUc7QUFBQSxFQUNWO0FBRUQsTUFBSSxDQUFDLE1BQU0sU0FBUyxHQUFHLEdBQUc7QUFDeEIsVUFBTSxJQUFJLFVBQVUsd0JBQXdCO0FBQUEsRUFDN0M7QUFFRCxRQUFNLEdBQUc7QUFFVCxTQUFPO0FBQ1Q7QUM1TUEsU0FBU0ssU0FBTyxLQUFLO0FBQ25CLFFBQU0sVUFBVTtBQUFBLElBQ2QsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLEVBQ1g7QUFDRSxTQUFPLG1CQUFtQixHQUFHLEVBQUUsUUFBUSxvQkFBb0IsU0FBUyxTQUFTLE9BQU87QUFDbEYsV0FBTyxRQUFRLEtBQUs7QUFBQSxFQUN4QixDQUFHO0FBQ0g7QUFVQSxTQUFTLHFCQUFxQixRQUFRLFNBQVM7QUFDN0MsT0FBSyxTQUFTO0FBRWQsWUFBVSxXQUFXLFFBQVEsTUFBTSxPQUFPO0FBQzVDO0FBRUEsTUFBTSxZQUFZLHFCQUFxQjtBQUV2QyxVQUFVLFNBQVMsU0FBU0MsUUFBT3ZILE9BQU0sT0FBTztBQUM5QyxPQUFLLE9BQU8sS0FBSyxDQUFDQSxPQUFNLEtBQUssQ0FBQztBQUNoQztBQUVBLFVBQVUsV0FBVyxTQUFTd0gsVUFBUyxTQUFTO0FBQzlDLFFBQU0sVUFBVSxVQUFVLFNBQVMsT0FBTztBQUN4QyxXQUFPLFFBQVEsS0FBSyxNQUFNLE9BQU9GLFFBQU07QUFBQSxFQUN4QyxJQUFHQTtBQUVKLFNBQU8sS0FBSyxPQUFPLElBQUksU0FBUyxLQUFLLE1BQU07QUFDekMsV0FBTyxRQUFRLEtBQUssQ0FBQyxDQUFDLElBQUksTUFBTSxRQUFRLEtBQUssQ0FBQyxDQUFDO0FBQUEsRUFDaEQsR0FBRSxFQUFFLEVBQUUsS0FBSyxHQUFHO0FBQ2pCO0FDMUNBLFNBQVMsT0FBTyxLQUFLO0FBQ25CLFNBQU8sbUJBQW1CLEdBQUcsRUFDM0IsUUFBUSxTQUFTLEdBQUcsRUFDcEIsUUFBUSxRQUFRLEdBQUcsRUFDbkIsUUFBUSxTQUFTLEdBQUcsRUFDcEIsUUFBUSxRQUFRLEdBQUcsRUFDbkIsUUFBUSxTQUFTLEdBQUcsRUFDcEIsUUFBUSxTQUFTLEdBQUc7QUFDeEI7QUFXZSxTQUFTLFNBQVN6SCxNQUFLLFFBQVEsU0FBUztBQUVyRCxNQUFJLENBQUMsUUFBUTtBQUNYLFdBQU9BO0FBQUEsRUFDUjtBQUVELFFBQU0sVUFBVSxXQUFXLFFBQVEsVUFBVTtBQUU3QyxRQUFNLGNBQWMsV0FBVyxRQUFRO0FBRXZDLE1BQUk7QUFFSixNQUFJLGFBQWE7QUFDZix1QkFBbUIsWUFBWSxRQUFRLE9BQU87QUFBQSxFQUNsRCxPQUFTO0FBQ0wsdUJBQW1CLE1BQU0sa0JBQWtCLE1BQU0sSUFDL0MsT0FBTyxTQUFVLElBQ2pCLElBQUkscUJBQXFCLFFBQVEsT0FBTyxFQUFFLFNBQVMsT0FBTztBQUFBLEVBQzdEO0FBRUQsTUFBSSxrQkFBa0I7QUFDcEIsVUFBTSxnQkFBZ0JBLEtBQUksUUFBUSxHQUFHO0FBRXJDLFFBQUksa0JBQWtCLElBQUk7QUFDeEIsTUFBQUEsT0FBTUEsS0FBSSxNQUFNLEdBQUcsYUFBYTtBQUFBLElBQ2pDO0FBQ0QsSUFBQUEsU0FBUUEsS0FBSSxRQUFRLEdBQUcsTUFBTSxLQUFLLE1BQU0sT0FBTztBQUFBLEVBQ2hEO0FBRUQsU0FBT0E7QUFDVDtBQzFEQSxNQUFNLG1CQUFtQjtBQUFBLEVBQ3ZCLGNBQWM7QUFDWixTQUFLLFdBQVc7RUFDakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFVRCxJQUFJLFdBQVcsVUFBVSxTQUFTO0FBQ2hDLFNBQUssU0FBUyxLQUFLO0FBQUEsTUFDakI7QUFBQSxNQUNBO0FBQUEsTUFDQSxhQUFhLFVBQVUsUUFBUSxjQUFjO0FBQUEsTUFDN0MsU0FBUyxVQUFVLFFBQVEsVUFBVTtBQUFBLElBQzNDLENBQUs7QUFDRCxXQUFPLEtBQUssU0FBUyxTQUFTO0FBQUEsRUFDL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBU0QsTUFBTUksS0FBSTtBQUNSLFFBQUksS0FBSyxTQUFTQSxHQUFFLEdBQUc7QUFDckIsV0FBSyxTQUFTQSxHQUFFLElBQUk7QUFBQSxJQUNyQjtBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPRCxRQUFRO0FBQ04sUUFBSSxLQUFLLFVBQVU7QUFDakIsV0FBSyxXQUFXO0lBQ2pCO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFZRCxRQUFRLElBQUk7QUFDVixVQUFNLFFBQVEsS0FBSyxVQUFVLFNBQVMsZUFBZSxHQUFHO0FBQ3RELFVBQUksTUFBTSxNQUFNO0FBQ2QsV0FBRyxDQUFDO0FBQUEsTUFDTDtBQUFBLElBQ1AsQ0FBSztBQUFBLEVBQ0Y7QUFDSDtBQUVBLE1BQUEsdUJBQWU7QUNwRWYsTUFBZSx1QkFBQTtBQUFBLEVBQ2IsbUJBQW1CO0FBQUEsRUFDbkIsbUJBQW1CO0FBQUEsRUFDbkIscUJBQXFCO0FBQ3ZCO0FDSEEsTUFBQSxvQkFBZSxPQUFPLG9CQUFvQixjQUFjLGtCQUFrQjtBQ0QxRSxNQUFBLGFBQWUsT0FBTyxhQUFhLGNBQWMsV0FBVztBQ0E1RCxNQUFBLFNBQWUsT0FBTyxTQUFTLGNBQWMsT0FBTztBQ21CcEQsTUFBTSx3QkFBd0IsTUFBTTtBQUNsQyxNQUFJO0FBQ0osTUFBSSxPQUFPLGNBQWMsaUJBQ3RCLFVBQVUsVUFBVSxhQUFhLGlCQUNsQyxZQUFZLGtCQUNaLFlBQVksT0FDWjtBQUNBLFdBQU87QUFBQSxFQUNSO0FBRUQsU0FBTyxPQUFPLFdBQVcsZUFBZSxPQUFPLGFBQWE7QUFDOUQ7QUFXQyxNQUFNLGlDQUFpQyxNQUFNO0FBQzVDLFNBQ0UsT0FBTyxzQkFBc0I7QUFBQSxFQUU3QixnQkFBZ0IscUJBQ2hCLE9BQU8sS0FBSyxrQkFBa0I7QUFFbEM7QUFHQSxNQUFlLFdBQUE7QUFBQSxFQUNiLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxJQUNYLGlCQUFJd0g7QUFBQUEsSUFDSixVQUFJQztBQUFBQSxJQUNKLE1BQUlDO0FBQUFBLEVBQ0Q7QUFBQSxFQUNEO0FBQUEsRUFDQTtBQUFBLEVBQ0EsV0FBVyxDQUFDLFFBQVEsU0FBUyxRQUFRLFFBQVEsT0FBTyxNQUFNO0FBQzVEO0FDekRlLFNBQVMsaUJBQWlCLE1BQU0sU0FBUztBQUN0RCxTQUFPLFdBQVcsTUFBTSxJQUFJLFNBQVMsUUFBUSxnQkFBaUIsR0FBRSxPQUFPLE9BQU87QUFBQSxJQUM1RSxTQUFTLFNBQVMsT0FBTyxLQUFLLE1BQU0sU0FBUztBQUMzQyxVQUFJLFNBQVMsVUFBVSxNQUFNLFNBQVMsS0FBSyxHQUFHO0FBQzVDLGFBQUssT0FBTyxLQUFLLE1BQU0sU0FBUyxRQUFRLENBQUM7QUFDekMsZUFBTztBQUFBLE1BQ1I7QUFFRCxhQUFPLFFBQVEsZUFBZSxNQUFNLE1BQU0sU0FBUztBQUFBLElBQ3BEO0FBQUEsRUFDTCxHQUFLLE9BQU8sQ0FBQztBQUNiO0FDTkEsU0FBUyxjQUFjM0gsT0FBTTtBQUszQixTQUFPLE1BQU0sU0FBUyxpQkFBaUJBLEtBQUksRUFBRSxJQUFJLFdBQVM7QUFDeEQsV0FBTyxNQUFNLENBQUMsTUFBTSxPQUFPLEtBQUssTUFBTSxDQUFDLEtBQUssTUFBTSxDQUFDO0FBQUEsRUFDdkQsQ0FBRztBQUNIO0FBU0EsU0FBUyxjQUFjLEtBQUs7QUFDMUIsUUFBTSxNQUFNLENBQUE7QUFDWixRQUFNLE9BQU8sT0FBTyxLQUFLLEdBQUc7QUFDNUIsTUFBSTtBQUNKLFFBQU0sTUFBTSxLQUFLO0FBQ2pCLE1BQUk7QUFDSixPQUFLLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSztBQUN4QixVQUFNLEtBQUssQ0FBQztBQUNaLFFBQUksR0FBRyxJQUFJLElBQUksR0FBRztBQUFBLEVBQ25CO0FBQ0QsU0FBTztBQUNUO0FBU0EsU0FBUyxlQUFlLFVBQVU7QUFDaEMsV0FBUyxVQUFVLE1BQU0sT0FBTyxRQUFRLE9BQU87QUFDN0MsUUFBSUEsUUFBTyxLQUFLLE9BQU87QUFDdkIsVUFBTSxlQUFlLE9BQU8sU0FBUyxDQUFDQSxLQUFJO0FBQzFDLFVBQU0sU0FBUyxTQUFTLEtBQUs7QUFDN0IsSUFBQUEsUUFBTyxDQUFDQSxTQUFRLE1BQU0sUUFBUSxNQUFNLElBQUksT0FBTyxTQUFTQTtBQUV4RCxRQUFJLFFBQVE7QUFDVixVQUFJLE1BQU0sV0FBVyxRQUFRQSxLQUFJLEdBQUc7QUFDbEMsZUFBT0EsS0FBSSxJQUFJLENBQUMsT0FBT0EsS0FBSSxHQUFHLEtBQUs7QUFBQSxNQUMzQyxPQUFhO0FBQ0wsZUFBT0EsS0FBSSxJQUFJO0FBQUEsTUFDaEI7QUFFRCxhQUFPLENBQUM7QUFBQSxJQUNUO0FBRUQsUUFBSSxDQUFDLE9BQU9BLEtBQUksS0FBSyxDQUFDLE1BQU0sU0FBUyxPQUFPQSxLQUFJLENBQUMsR0FBRztBQUNsRCxhQUFPQSxLQUFJLElBQUk7SUFDaEI7QUFFRCxVQUFNLFNBQVMsVUFBVSxNQUFNLE9BQU8sT0FBT0EsS0FBSSxHQUFHLEtBQUs7QUFFekQsUUFBSSxVQUFVLE1BQU0sUUFBUSxPQUFPQSxLQUFJLENBQUMsR0FBRztBQUN6QyxhQUFPQSxLQUFJLElBQUksY0FBYyxPQUFPQSxLQUFJLENBQUM7QUFBQSxJQUMxQztBQUVELFdBQU8sQ0FBQztBQUFBLEVBQ1Q7QUFFRCxNQUFJLE1BQU0sV0FBVyxRQUFRLEtBQUssTUFBTSxXQUFXLFNBQVMsT0FBTyxHQUFHO0FBQ3BFLFVBQU0sTUFBTSxDQUFBO0FBRVosVUFBTSxhQUFhLFVBQVUsQ0FBQ0EsT0FBTSxVQUFVO0FBQzVDLGdCQUFVLGNBQWNBLEtBQUksR0FBRyxPQUFPLEtBQUssQ0FBQztBQUFBLElBQ2xELENBQUs7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQUVELFNBQU87QUFDVDtBQy9FQSxNQUFNLHVCQUF1QjtBQUFBLEVBQzNCLGdCQUFnQjtBQUNsQjtBQVlBLFNBQVMsZ0JBQWdCLFVBQVUsUUFBUSxTQUFTO0FBQ2xELE1BQUksTUFBTSxTQUFTLFFBQVEsR0FBRztBQUM1QixRQUFJO0FBQ0YsT0FBQyxVQUFVLEtBQUssT0FBTyxRQUFRO0FBQy9CLGFBQU8sTUFBTSxLQUFLLFFBQVE7QUFBQSxJQUMzQixTQUFRLEdBQVA7QUFDQSxVQUFJLEVBQUUsU0FBUyxlQUFlO0FBQzVCLGNBQU07QUFBQSxNQUNQO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFRCxVQUFRLFdBQVcsS0FBSyxXQUFXLFFBQVE7QUFDN0M7QUFFQSxNQUFNLFdBQVc7QUFBQSxFQUVmLGNBQWM7QUFBQSxFQUVkLFNBQVMsQ0FBQyxPQUFPLE1BQU07QUFBQSxFQUV2QixrQkFBa0IsQ0FBQyxTQUFTLGlCQUFpQixNQUFNLFNBQVM7QUFDMUQsVUFBTSxjQUFjLFFBQVEsZUFBYyxLQUFNO0FBQ2hELFVBQU0scUJBQXFCLFlBQVksUUFBUSxrQkFBa0IsSUFBSTtBQUNyRSxVQUFNLGtCQUFrQixNQUFNLFNBQVMsSUFBSTtBQUUzQyxRQUFJLG1CQUFtQixNQUFNLFdBQVcsSUFBSSxHQUFHO0FBQzdDLGFBQU8sSUFBSSxTQUFTLElBQUk7QUFBQSxJQUN6QjtBQUVELFVBQU00SCxjQUFhLE1BQU0sV0FBVyxJQUFJO0FBRXhDLFFBQUlBLGFBQVk7QUFDZCxVQUFJLENBQUMsb0JBQW9CO0FBQ3ZCLGVBQU87QUFBQSxNQUNSO0FBQ0QsYUFBTyxxQkFBcUIsS0FBSyxVQUFVLGVBQWUsSUFBSSxDQUFDLElBQUk7QUFBQSxJQUNwRTtBQUVELFFBQUksTUFBTSxjQUFjLElBQUksS0FDMUIsTUFBTSxTQUFTLElBQUksS0FDbkIsTUFBTSxTQUFTLElBQUksS0FDbkIsTUFBTSxPQUFPLElBQUksS0FDakIsTUFBTSxPQUFPLElBQUksR0FDakI7QUFDQSxhQUFPO0FBQUEsSUFDUjtBQUNELFFBQUksTUFBTSxrQkFBa0IsSUFBSSxHQUFHO0FBQ2pDLGFBQU8sS0FBSztBQUFBLElBQ2I7QUFDRCxRQUFJLE1BQU0sa0JBQWtCLElBQUksR0FBRztBQUNqQyxjQUFRLGVBQWUsbURBQW1ELEtBQUs7QUFDL0UsYUFBTyxLQUFLO0lBQ2I7QUFFRCxRQUFJQztBQUVKLFFBQUksaUJBQWlCO0FBQ25CLFVBQUksWUFBWSxRQUFRLG1DQUFtQyxJQUFJLElBQUk7QUFDakUsZUFBTyxpQkFBaUIsTUFBTSxLQUFLLGNBQWMsRUFBRSxTQUFRO0FBQUEsTUFDNUQ7QUFFRCxXQUFLQSxjQUFhLE1BQU0sV0FBVyxJQUFJLE1BQU0sWUFBWSxRQUFRLHFCQUFxQixJQUFJLElBQUk7QUFDNUYsY0FBTSxZQUFZLEtBQUssT0FBTyxLQUFLLElBQUk7QUFFdkMsZUFBTztBQUFBLFVBQ0xBLGNBQWEsRUFBQyxXQUFXLEtBQUksSUFBSTtBQUFBLFVBQ2pDLGFBQWEsSUFBSSxVQUFXO0FBQUEsVUFDNUIsS0FBSztBQUFBLFFBQ2Y7QUFBQSxNQUNPO0FBQUEsSUFDRjtBQUVELFFBQUksbUJBQW1CLG9CQUFxQjtBQUMxQyxjQUFRLGVBQWUsb0JBQW9CLEtBQUs7QUFDaEQsYUFBTyxnQkFBZ0IsSUFBSTtBQUFBLElBQzVCO0FBRUQsV0FBTztBQUFBLEVBQ1gsQ0FBRztBQUFBLEVBRUQsbUJBQW1CLENBQUMsU0FBUyxrQkFBa0IsTUFBTTtBQUNuRCxVQUFNQyxnQkFBZSxLQUFLLGdCQUFnQixTQUFTO0FBQ25ELFVBQU0sb0JBQW9CQSxpQkFBZ0JBLGNBQWE7QUFDdkQsVUFBTSxnQkFBZ0IsS0FBSyxpQkFBaUI7QUFFNUMsUUFBSSxRQUFRLE1BQU0sU0FBUyxJQUFJLE1BQU8scUJBQXFCLENBQUMsS0FBSyxnQkFBaUIsZ0JBQWdCO0FBQ2hHLFlBQU0sb0JBQW9CQSxpQkFBZ0JBLGNBQWE7QUFDdkQsWUFBTSxvQkFBb0IsQ0FBQyxxQkFBcUI7QUFFaEQsVUFBSTtBQUNGLGVBQU8sS0FBSyxNQUFNLElBQUk7QUFBQSxNQUN2QixTQUFRLEdBQVA7QUFDQSxZQUFJLG1CQUFtQjtBQUNyQixjQUFJLEVBQUUsU0FBUyxlQUFlO0FBQzVCLGtCQUFNLFdBQVcsS0FBSyxHQUFHLFdBQVcsa0JBQWtCLE1BQU0sTUFBTSxLQUFLLFFBQVE7QUFBQSxVQUNoRjtBQUNELGdCQUFNO0FBQUEsUUFDUDtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUQsV0FBTztBQUFBLEVBQ1gsQ0FBRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNRCxTQUFTO0FBQUEsRUFFVCxnQkFBZ0I7QUFBQSxFQUNoQixnQkFBZ0I7QUFBQSxFQUVoQixrQkFBa0I7QUFBQSxFQUNsQixlQUFlO0FBQUEsRUFFZixLQUFLO0FBQUEsSUFDSCxVQUFVLFNBQVMsUUFBUTtBQUFBLElBQzNCLE1BQU0sU0FBUyxRQUFRO0FBQUEsRUFDeEI7QUFBQSxFQUVELGdCQUFnQixTQUFTLGVBQWUsUUFBUTtBQUM5QyxXQUFPLFVBQVUsT0FBTyxTQUFTO0FBQUEsRUFDbEM7QUFBQSxFQUVELFNBQVM7QUFBQSxJQUNQLFFBQVE7QUFBQSxNQUNOLFVBQVU7QUFBQSxJQUNYO0FBQUEsRUFDRjtBQUNIO0FBRUEsTUFBTSxRQUFRLENBQUMsVUFBVSxPQUFPLE1BQU0sR0FBRyxTQUFTLG9CQUFvQixRQUFRO0FBQzVFLFdBQVMsUUFBUSxNQUFNLElBQUk7QUFDN0IsQ0FBQztBQUVELE1BQU0sUUFBUSxDQUFDLFFBQVEsT0FBTyxPQUFPLEdBQUcsU0FBUyxzQkFBc0IsUUFBUTtBQUM3RSxXQUFTLFFBQVEsTUFBTSxJQUFJLE1BQU0sTUFBTSxvQkFBb0I7QUFDN0QsQ0FBQztBQUVELE1BQUEsYUFBZTtBQy9KZixNQUFNLG9CQUFvQixNQUFNLFlBQVk7QUFBQSxFQUMxQztBQUFBLEVBQU87QUFBQSxFQUFpQjtBQUFBLEVBQWtCO0FBQUEsRUFBZ0I7QUFBQSxFQUMxRDtBQUFBLEVBQVc7QUFBQSxFQUFRO0FBQUEsRUFBUTtBQUFBLEVBQXFCO0FBQUEsRUFDaEQ7QUFBQSxFQUFpQjtBQUFBLEVBQVk7QUFBQSxFQUFnQjtBQUFBLEVBQzdDO0FBQUEsRUFBVztBQUFBLEVBQWU7QUFDNUIsQ0FBQztBQWdCRCxNQUFBLGVBQWUsZ0JBQWM7QUFDM0IsUUFBTSxTQUFTLENBQUE7QUFDZixNQUFJO0FBQ0osTUFBSTtBQUNKLE1BQUk7QUFFSixnQkFBYyxXQUFXLE1BQU0sSUFBSSxFQUFFLFFBQVEsU0FBUyxPQUFPLE1BQU07QUFDakUsUUFBSSxLQUFLLFFBQVEsR0FBRztBQUNwQixVQUFNLEtBQUssVUFBVSxHQUFHLENBQUMsRUFBRSxLQUFJLEVBQUc7QUFDbEMsVUFBTSxLQUFLLFVBQVUsSUFBSSxDQUFDLEVBQUU7QUFFNUIsUUFBSSxDQUFDLE9BQVEsT0FBTyxHQUFHLEtBQUssa0JBQWtCLEdBQUcsR0FBSTtBQUNuRDtBQUFBLElBQ0Q7QUFFRCxRQUFJLFFBQVEsY0FBYztBQUN4QixVQUFJLE9BQU8sR0FBRyxHQUFHO0FBQ2YsZUFBTyxHQUFHLEVBQUUsS0FBSyxHQUFHO0FBQUEsTUFDNUIsT0FBYTtBQUNMLGVBQU8sR0FBRyxJQUFJLENBQUMsR0FBRztBQUFBLE1BQ25CO0FBQUEsSUFDUCxPQUFXO0FBQ0wsYUFBTyxHQUFHLElBQUksT0FBTyxHQUFHLElBQUksT0FBTyxHQUFHLElBQUksT0FBTyxNQUFNO0FBQUEsSUFDeEQ7QUFBQSxFQUNMLENBQUc7QUFFRCxTQUFPO0FBQ1Q7QUNqREEsTUFBTSxhQUFhLE9BQU8sV0FBVztBQUVyQyxTQUFTLGdCQUFnQixRQUFRO0FBQy9CLFNBQU8sVUFBVSxPQUFPLE1BQU0sRUFBRSxLQUFJLEVBQUc7QUFDekM7QUFFQSxTQUFTLGVBQWUsT0FBTztBQUM3QixNQUFJLFVBQVUsU0FBUyxTQUFTLE1BQU07QUFDcEMsV0FBTztBQUFBLEVBQ1I7QUFFRCxTQUFPLE1BQU0sUUFBUSxLQUFLLElBQUksTUFBTSxJQUFJLGNBQWMsSUFBSSxPQUFPLEtBQUs7QUFDeEU7QUFFQSxTQUFTLFlBQVksS0FBSztBQUN4QixRQUFNLFNBQVMsdUJBQU8sT0FBTyxJQUFJO0FBQ2pDLFFBQU0sV0FBVztBQUNqQixNQUFJO0FBRUosU0FBUSxRQUFRLFNBQVMsS0FBSyxHQUFHLEdBQUk7QUFDbkMsV0FBTyxNQUFNLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUFBLEVBQzNCO0FBRUQsU0FBTztBQUNUO0FBRUEsU0FBUyxrQkFBa0IsS0FBSztBQUM5QixTQUFPLGdCQUFnQixLQUFLLElBQUksS0FBTSxDQUFBO0FBQ3hDO0FBRUEsU0FBUyxpQkFBaUIsU0FBUyxPQUFPLFFBQVFiLFNBQVEsb0JBQW9CO0FBQzVFLE1BQUksTUFBTSxXQUFXQSxPQUFNLEdBQUc7QUFDNUIsV0FBT0EsUUFBTyxLQUFLLE1BQU0sT0FBTyxNQUFNO0FBQUEsRUFDdkM7QUFFRCxNQUFJLG9CQUFvQjtBQUN0QixZQUFRO0FBQUEsRUFDVDtBQUVELE1BQUksQ0FBQyxNQUFNLFNBQVMsS0FBSztBQUFHO0FBRTVCLE1BQUksTUFBTSxTQUFTQSxPQUFNLEdBQUc7QUFDMUIsV0FBTyxNQUFNLFFBQVFBLE9BQU0sTUFBTTtBQUFBLEVBQ2xDO0FBRUQsTUFBSSxNQUFNLFNBQVNBLE9BQU0sR0FBRztBQUMxQixXQUFPQSxRQUFPLEtBQUssS0FBSztBQUFBLEVBQ3pCO0FBQ0g7QUFFQSxTQUFTLGFBQWEsUUFBUTtBQUM1QixTQUFPLE9BQU8sS0FBTSxFQUNqQixZQUFXLEVBQUcsUUFBUSxtQkFBbUIsQ0FBQyxHQUFHLE1BQU0sUUFBUTtBQUMxRCxXQUFPLEtBQUssWUFBYSxJQUFHO0FBQUEsRUFDbEMsQ0FBSztBQUNMO0FBRUEsU0FBUyxlQUFlLEtBQUssUUFBUTtBQUNuQyxRQUFNLGVBQWUsTUFBTSxZQUFZLE1BQU0sTUFBTTtBQUVuRCxHQUFDLE9BQU8sT0FBTyxLQUFLLEVBQUUsUUFBUSxnQkFBYztBQUMxQyxXQUFPLGVBQWUsS0FBSyxhQUFhLGNBQWM7QUFBQSxNQUNwRCxPQUFPLFNBQVMsTUFBTSxNQUFNLE1BQU07QUFDaEMsZUFBTyxLQUFLLFVBQVUsRUFBRSxLQUFLLE1BQU0sUUFBUSxNQUFNLE1BQU0sSUFBSTtBQUFBLE1BQzVEO0FBQUEsTUFDRCxjQUFjO0FBQUEsSUFDcEIsQ0FBSztBQUFBLEVBQ0wsQ0FBRztBQUNIO0FBRUEsTUFBTSxhQUFhO0FBQUEsRUFDakIsWUFBWSxTQUFTO0FBQ25CLGVBQVcsS0FBSyxJQUFJLE9BQU87QUFBQSxFQUM1QjtBQUFBLEVBRUQsSUFBSSxRQUFRLGdCQUFnQixTQUFTO0FBQ25DLFVBQU16RCxRQUFPO0FBRWIsYUFBUyxVQUFVLFFBQVEsU0FBUyxVQUFVO0FBQzVDLFlBQU0sVUFBVSxnQkFBZ0IsT0FBTztBQUV2QyxVQUFJLENBQUMsU0FBUztBQUNaLGNBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUFBLE1BQ3pEO0FBRUQsWUFBTSxNQUFNLE1BQU0sUUFBUUEsT0FBTSxPQUFPO0FBRXZDLFVBQUcsQ0FBQyxPQUFPQSxNQUFLLEdBQUcsTUFBTSxVQUFhLGFBQWEsUUFBUyxhQUFhLFVBQWFBLE1BQUssR0FBRyxNQUFNLE9BQVE7QUFDMUcsUUFBQUEsTUFBSyxPQUFPLE9BQU8sSUFBSSxlQUFlLE1BQU07QUFBQSxNQUM3QztBQUFBLElBQ0Y7QUFFRCxVQUFNLGFBQWEsQ0FBQyxTQUFTLGFBQzNCLE1BQU0sUUFBUSxTQUFTLENBQUMsUUFBUSxZQUFZLFVBQVUsUUFBUSxTQUFTLFFBQVEsQ0FBQztBQUVsRixRQUFJLE1BQU0sY0FBYyxNQUFNLEtBQUssa0JBQWtCLEtBQUssYUFBYTtBQUNyRSxpQkFBVyxRQUFRLGNBQWM7QUFBQSxJQUNsQyxXQUFTLE1BQU0sU0FBUyxNQUFNLE1BQU0sU0FBUyxPQUFPLFdBQVcsQ0FBQyxrQkFBa0IsTUFBTSxHQUFHO0FBQzFGLGlCQUFXLGFBQWEsTUFBTSxHQUFHLGNBQWM7QUFBQSxJQUNyRCxPQUFXO0FBQ0wsZ0JBQVUsUUFBUSxVQUFVLGdCQUFnQixRQUFRLE9BQU87QUFBQSxJQUM1RDtBQUVELFdBQU87QUFBQSxFQUNSO0FBQUEsRUFFRCxJQUFJLFFBQVEsUUFBUTtBQUNsQixhQUFTLGdCQUFnQixNQUFNO0FBRS9CLFFBQUksUUFBUTtBQUNWLFlBQU0sTUFBTSxNQUFNLFFBQVEsTUFBTSxNQUFNO0FBRXRDLFVBQUksS0FBSztBQUNQLGNBQU0sUUFBUSxLQUFLLEdBQUc7QUFFdEIsWUFBSSxDQUFDLFFBQVE7QUFDWCxpQkFBTztBQUFBLFFBQ1I7QUFFRCxZQUFJLFdBQVcsTUFBTTtBQUNuQixpQkFBTyxZQUFZLEtBQUs7QUFBQSxRQUN6QjtBQUVELFlBQUksTUFBTSxXQUFXLE1BQU0sR0FBRztBQUM1QixpQkFBTyxPQUFPLEtBQUssTUFBTSxPQUFPLEdBQUc7QUFBQSxRQUNwQztBQUVELFlBQUksTUFBTSxTQUFTLE1BQU0sR0FBRztBQUMxQixpQkFBTyxPQUFPLEtBQUssS0FBSztBQUFBLFFBQ3pCO0FBRUQsY0FBTSxJQUFJLFVBQVUsd0NBQXdDO0FBQUEsTUFDN0Q7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRUQsSUFBSSxRQUFRLFNBQVM7QUFDbkIsYUFBUyxnQkFBZ0IsTUFBTTtBQUUvQixRQUFJLFFBQVE7QUFDVixZQUFNLE1BQU0sTUFBTSxRQUFRLE1BQU0sTUFBTTtBQUV0QyxhQUFPLENBQUMsRUFBRSxPQUFPLEtBQUssR0FBRyxNQUFNLFdBQWMsQ0FBQyxXQUFXLGlCQUFpQixNQUFNLEtBQUssR0FBRyxHQUFHLEtBQUssT0FBTztBQUFBLElBQ3hHO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUVELE9BQU8sUUFBUSxTQUFTO0FBQ3RCLFVBQU1BLFFBQU87QUFDYixRQUFJLFVBQVU7QUFFZCxhQUFTLGFBQWEsU0FBUztBQUM3QixnQkFBVSxnQkFBZ0IsT0FBTztBQUVqQyxVQUFJLFNBQVM7QUFDWCxjQUFNLE1BQU0sTUFBTSxRQUFRQSxPQUFNLE9BQU87QUFFdkMsWUFBSSxRQUFRLENBQUMsV0FBVyxpQkFBaUJBLE9BQU1BLE1BQUssR0FBRyxHQUFHLEtBQUssT0FBTyxJQUFJO0FBQ3hFLGlCQUFPQSxNQUFLLEdBQUc7QUFFZixvQkFBVTtBQUFBLFFBQ1g7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVELFFBQUksTUFBTSxRQUFRLE1BQU0sR0FBRztBQUN6QixhQUFPLFFBQVEsWUFBWTtBQUFBLElBQ2pDLE9BQVc7QUFDTCxtQkFBYSxNQUFNO0FBQUEsSUFDcEI7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBRUQsTUFBTSxTQUFTO0FBQ2IsVUFBTSxPQUFPLE9BQU8sS0FBSyxJQUFJO0FBQzdCLFFBQUksSUFBSSxLQUFLO0FBQ2IsUUFBSSxVQUFVO0FBRWQsV0FBTyxLQUFLO0FBQ1YsWUFBTSxNQUFNLEtBQUssQ0FBQztBQUNsQixVQUFHLENBQUMsV0FBVyxpQkFBaUIsTUFBTSxLQUFLLEdBQUcsR0FBRyxLQUFLLFNBQVMsSUFBSSxHQUFHO0FBQ3BFLGVBQU8sS0FBSyxHQUFHO0FBQ2Ysa0JBQVU7QUFBQSxNQUNYO0FBQUEsSUFDRjtBQUVELFdBQU87QUFBQSxFQUNSO0FBQUEsRUFFRCxVQUFVLFFBQVE7QUFDaEIsVUFBTUEsUUFBTztBQUNiLFVBQU0sVUFBVSxDQUFBO0FBRWhCLFVBQU0sUUFBUSxNQUFNLENBQUMsT0FBTyxXQUFXO0FBQ3JDLFlBQU0sTUFBTSxNQUFNLFFBQVEsU0FBUyxNQUFNO0FBRXpDLFVBQUksS0FBSztBQUNQLFFBQUFBLE1BQUssR0FBRyxJQUFJLGVBQWUsS0FBSztBQUNoQyxlQUFPQSxNQUFLLE1BQU07QUFDbEI7QUFBQSxNQUNEO0FBRUQsWUFBTSxhQUFhLFNBQVMsYUFBYSxNQUFNLElBQUksT0FBTyxNQUFNLEVBQUU7QUFFbEUsVUFBSSxlQUFlLFFBQVE7QUFDekIsZUFBT0EsTUFBSyxNQUFNO0FBQUEsTUFDbkI7QUFFRCxNQUFBQSxNQUFLLFVBQVUsSUFBSSxlQUFlLEtBQUs7QUFFdkMsY0FBUSxVQUFVLElBQUk7QUFBQSxJQUM1QixDQUFLO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUVELFVBQVUsU0FBUztBQUNqQixXQUFPLEtBQUssWUFBWSxPQUFPLE1BQU0sR0FBRyxPQUFPO0FBQUEsRUFDaEQ7QUFBQSxFQUVELE9BQU8sV0FBVztBQUNoQixVQUFNLE1BQU0sdUJBQU8sT0FBTyxJQUFJO0FBRTlCLFVBQU0sUUFBUSxNQUFNLENBQUMsT0FBTyxXQUFXO0FBQ3JDLGVBQVMsUUFBUSxVQUFVLFVBQVUsSUFBSSxNQUFNLElBQUksYUFBYSxNQUFNLFFBQVEsS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJLElBQUk7QUFBQSxJQUNoSCxDQUFLO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUVELENBQUMsT0FBTyxRQUFRLElBQUk7QUFDbEIsV0FBTyxPQUFPLFFBQVEsS0FBSyxPQUFRLENBQUEsRUFBRSxPQUFPLFFBQVE7RUFDckQ7QUFBQSxFQUVELFdBQVc7QUFDVCxXQUFPLE9BQU8sUUFBUSxLQUFLLE9BQVEsQ0FBQSxFQUFFLElBQUksQ0FBQyxDQUFDLFFBQVEsS0FBSyxNQUFNLFNBQVMsT0FBTyxLQUFLLEVBQUUsS0FBSyxJQUFJO0FBQUEsRUFDL0Y7QUFBQSxFQUVELEtBQUssT0FBTyxXQUFXLElBQUk7QUFDekIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUVELE9BQU8sS0FBSyxPQUFPO0FBQ2pCLFdBQU8saUJBQWlCLE9BQU8sUUFBUSxJQUFJLEtBQUssS0FBSztBQUFBLEVBQ3REO0FBQUEsRUFFRCxPQUFPLE9BQU8sVUFBVSxTQUFTO0FBQy9CLFVBQU0sV0FBVyxJQUFJLEtBQUssS0FBSztBQUUvQixZQUFRLFFBQVEsQ0FBQyxXQUFXLFNBQVMsSUFBSSxNQUFNLENBQUM7QUFFaEQsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUVELE9BQU8sU0FBUyxRQUFRO0FBQ3RCLFVBQU0sWUFBWSxLQUFLLFVBQVUsSUFBSyxLQUFLLFVBQVUsSUFBSTtBQUFBLE1BQ3ZELFdBQVcsQ0FBRTtBQUFBLElBQ25CO0FBRUksVUFBTSxZQUFZLFVBQVU7QUFDNUIsVUFBTXRFLGFBQVksS0FBSztBQUV2QixhQUFTLGVBQWUsU0FBUztBQUMvQixZQUFNLFVBQVUsZ0JBQWdCLE9BQU87QUFFdkMsVUFBSSxDQUFDLFVBQVUsT0FBTyxHQUFHO0FBQ3ZCLHVCQUFlQSxZQUFXLE9BQU87QUFDakMsa0JBQVUsT0FBTyxJQUFJO0FBQUEsTUFDdEI7QUFBQSxJQUNGO0FBRUQsVUFBTSxRQUFRLE1BQU0sSUFBSSxPQUFPLFFBQVEsY0FBYyxJQUFJLGVBQWUsTUFBTTtBQUU5RSxXQUFPO0FBQUEsRUFDUjtBQUNIO0FBRUEsYUFBYSxTQUFTLENBQUMsZ0JBQWdCLGtCQUFrQixVQUFVLG1CQUFtQixjQUFjLGVBQWUsQ0FBQztBQUVwSCxNQUFNLGNBQWMsYUFBYSxTQUFTO0FBQzFDLE1BQU0sY0FBYyxZQUFZO0FBRWhDLE1BQUEsaUJBQWU7QUNuUkEsU0FBUyxjQUFjLEtBQUssVUFBVTtBQUNuRCxRQUFNbUksVUFBUyxRQUFRVTtBQUN2QixRQUFNLFVBQVUsWUFBWVY7QUFDNUIsUUFBTSxVQUFVVyxlQUFhLEtBQUssUUFBUSxPQUFPO0FBQ2pELE1BQUksT0FBTyxRQUFRO0FBRW5CLFFBQU0sUUFBUSxLQUFLLFNBQVMsVUFBVSxJQUFJO0FBQ3hDLFdBQU8sR0FBRyxLQUFLWCxTQUFRLE1BQU0sUUFBUSxVQUFTLEdBQUksV0FBVyxTQUFTLFNBQVMsTUFBUztBQUFBLEVBQzVGLENBQUc7QUFFRCxVQUFRLFVBQVM7QUFFakIsU0FBTztBQUNUO0FDekJlLFNBQVMsU0FBUyxPQUFPO0FBQ3RDLFNBQU8sQ0FBQyxFQUFFLFNBQVMsTUFBTTtBQUMzQjtBQ1VBLFNBQVMsY0FBYyxTQUFTQSxTQUFRekgsVUFBUztBQUUvQyxhQUFXLEtBQUssTUFBTSxXQUFXLE9BQU8sYUFBYSxTQUFTLFdBQVcsY0FBY3lILFNBQVF6SCxRQUFPO0FBQ3RHLE9BQUssT0FBTztBQUNkO0FBRUEsTUFBTSxTQUFTLGVBQWUsWUFBWTtBQUFBLEVBQ3hDLFlBQVk7QUFDZCxDQUFDO0FDVGMsU0FBUyxPQUFPbUgsVUFBUyxRQUFRLFVBQVU7QUFDeEQsUUFBTWtCLGtCQUFpQixTQUFTLE9BQU87QUFDdkMsTUFBSSxDQUFDLFNBQVMsVUFBVSxDQUFDQSxtQkFBa0JBLGdCQUFlLFNBQVMsTUFBTSxHQUFHO0FBQzFFLElBQUFsQixTQUFRLFFBQVE7QUFBQSxFQUNwQixPQUFTO0FBQ0wsV0FBTyxJQUFJO0FBQUEsTUFDVCxxQ0FBcUMsU0FBUztBQUFBLE1BQzlDLENBQUMsV0FBVyxpQkFBaUIsV0FBVyxnQkFBZ0IsRUFBRSxLQUFLLE1BQU0sU0FBUyxTQUFTLEdBQUcsSUFBSSxDQUFDO0FBQUEsTUFDL0YsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1Q7QUFBQSxJQUNOLENBQUs7QUFBQSxFQUNGO0FBQ0g7QUNyQkEsTUFBZSxVQUFBLFNBQVM7QUFBQTtBQUFBLEVBR3JCLFNBQVMscUJBQXFCO0FBQzdCLFdBQU87QUFBQSxNQUNMLE9BQU8sU0FBUyxNQUFNL0csT0FBTSxPQUFPLFNBQVMsTUFBTSxRQUFRLFFBQVE7QUFDaEUsY0FBTSxTQUFTLENBQUE7QUFDZixlQUFPLEtBQUtBLFFBQU8sTUFBTSxtQkFBbUIsS0FBSyxDQUFDO0FBRWxELFlBQUksTUFBTSxTQUFTLE9BQU8sR0FBRztBQUMzQixpQkFBTyxLQUFLLGFBQWEsSUFBSSxLQUFLLE9BQU8sRUFBRSxZQUFXLENBQUU7QUFBQSxRQUN6RDtBQUVELFlBQUksTUFBTSxTQUFTLElBQUksR0FBRztBQUN4QixpQkFBTyxLQUFLLFVBQVUsSUFBSTtBQUFBLFFBQzNCO0FBRUQsWUFBSSxNQUFNLFNBQVMsTUFBTSxHQUFHO0FBQzFCLGlCQUFPLEtBQUssWUFBWSxNQUFNO0FBQUEsUUFDL0I7QUFFRCxZQUFJLFdBQVcsTUFBTTtBQUNuQixpQkFBTyxLQUFLLFFBQVE7QUFBQSxRQUNyQjtBQUVELGlCQUFTLFNBQVMsT0FBTyxLQUFLLElBQUk7QUFBQSxNQUNuQztBQUFBLE1BRUQsTUFBTSxTQUFTLEtBQUtBLE9BQU07QUFDeEIsY0FBTSxRQUFRLFNBQVMsT0FBTyxNQUFNLElBQUksT0FBTyxlQUFlQSxRQUFPLFdBQVcsQ0FBQztBQUNqRixlQUFRLFFBQVEsbUJBQW1CLE1BQU0sQ0FBQyxDQUFDLElBQUk7QUFBQSxNQUNoRDtBQUFBLE1BRUQsUUFBUSxTQUFTLE9BQU9BLE9BQU07QUFDNUIsYUFBSyxNQUFNQSxPQUFNLElBQUksS0FBSyxJQUFHLElBQUssS0FBUTtBQUFBLE1BQzNDO0FBQUEsSUFDUDtBQUFBLEVBQ0EsRUFBTTtBQUFBO0FBQUE7QUFBQSxFQUdILFNBQVMsd0JBQXdCO0FBQ2hDLFdBQU87QUFBQSxNQUNMLE9BQU8sU0FBUyxRQUFRO0FBQUEsTUFBRTtBQUFBLE1BQzFCLE1BQU0sU0FBUyxPQUFPO0FBQUUsZUFBTztBQUFBLE1BQU87QUFBQSxNQUN0QyxRQUFRLFNBQVMsU0FBUztBQUFBLE1BQUU7QUFBQSxJQUNsQztBQUFBLEVBQ0EsRUFBTTtBQUFBO0FDMUNTLFNBQVMsY0FBY0gsTUFBSztBQUl6QyxTQUFPLDhCQUE4QixLQUFLQSxJQUFHO0FBQy9DO0FDSmUsU0FBUyxZQUFZLFNBQVMsYUFBYTtBQUN4RCxTQUFPLGNBQ0gsUUFBUSxRQUFRLFFBQVEsRUFBRSxJQUFJLE1BQU0sWUFBWSxRQUFRLFFBQVEsRUFBRSxJQUNsRTtBQUNOO0FDQ2UsU0FBUyxjQUFjLFNBQVMsY0FBYztBQUMzRCxNQUFJLFdBQVcsQ0FBQyxjQUFjLFlBQVksR0FBRztBQUMzQyxXQUFPLFlBQVksU0FBUyxZQUFZO0FBQUEsRUFDekM7QUFDRCxTQUFPO0FBQ1Q7QUNmQSxNQUFlLGtCQUFBLFNBQVM7QUFBQTtBQUFBO0FBQUEsRUFJckIsU0FBU3FJLHNCQUFxQjtBQUM3QixVQUFNLE9BQU8sa0JBQWtCLEtBQUssVUFBVSxTQUFTO0FBQ3ZELFVBQU0saUJBQWlCLFNBQVMsY0FBYyxHQUFHO0FBQ2pELFFBQUk7QUFRSixhQUFTLFdBQVdySSxNQUFLO0FBQ3ZCLFVBQUksT0FBT0E7QUFFWCxVQUFJLE1BQU07QUFFUix1QkFBZSxhQUFhLFFBQVEsSUFBSTtBQUN4QyxlQUFPLGVBQWU7QUFBQSxNQUN2QjtBQUVELHFCQUFlLGFBQWEsUUFBUSxJQUFJO0FBR3hDLGFBQU87QUFBQSxRQUNMLE1BQU0sZUFBZTtBQUFBLFFBQ3JCLFVBQVUsZUFBZSxXQUFXLGVBQWUsU0FBUyxRQUFRLE1BQU0sRUFBRSxJQUFJO0FBQUEsUUFDaEYsTUFBTSxlQUFlO0FBQUEsUUFDckIsUUFBUSxlQUFlLFNBQVMsZUFBZSxPQUFPLFFBQVEsT0FBTyxFQUFFLElBQUk7QUFBQSxRQUMzRSxNQUFNLGVBQWUsT0FBTyxlQUFlLEtBQUssUUFBUSxNQUFNLEVBQUUsSUFBSTtBQUFBLFFBQ3BFLFVBQVUsZUFBZTtBQUFBLFFBQ3pCLE1BQU0sZUFBZTtBQUFBLFFBQ3JCLFVBQVcsZUFBZSxTQUFTLE9BQU8sQ0FBQyxNQUFNLE1BQy9DLGVBQWUsV0FDZixNQUFNLGVBQWU7QUFBQSxNQUMvQjtBQUFBLElBQ0s7QUFFRCxnQkFBWSxXQUFXLE9BQU8sU0FBUyxJQUFJO0FBUTNDLFdBQU8sU0FBU3NJLGlCQUFnQixZQUFZO0FBQzFDLFlBQU0sU0FBVSxNQUFNLFNBQVMsVUFBVSxJQUFLLFdBQVcsVUFBVSxJQUFJO0FBQ3ZFLGFBQVEsT0FBTyxhQUFhLFVBQVUsWUFDbEMsT0FBTyxTQUFTLFVBQVU7QUFBQSxJQUNwQztBQUFBLEVBQ0EsRUFBTTtBQUFBO0FBQUE7QUFBQSxFQUdILFNBQVNDLHlCQUF3QjtBQUNoQyxXQUFPLFNBQVNELG1CQUFrQjtBQUNoQyxhQUFPO0FBQUEsSUFDYjtBQUFBLEVBQ0EsRUFBTTtBQUFBO0FDaEVTLFNBQVMsY0FBY3RJLE1BQUs7QUFDekMsUUFBTSxRQUFRLDRCQUE0QixLQUFLQSxJQUFHO0FBQ2xELFNBQU8sU0FBUyxNQUFNLENBQUMsS0FBSztBQUM5QjtBQ0dBLFNBQVMsWUFBWSxjQUFjLEtBQUs7QUFDdEMsaUJBQWUsZ0JBQWdCO0FBQy9CLFFBQU0sUUFBUSxJQUFJLE1BQU0sWUFBWTtBQUNwQyxRQUFNLGFBQWEsSUFBSSxNQUFNLFlBQVk7QUFDekMsTUFBSSxPQUFPO0FBQ1gsTUFBSSxPQUFPO0FBQ1gsTUFBSTtBQUVKLFFBQU0sUUFBUSxTQUFZLE1BQU07QUFFaEMsU0FBTyxTQUFTLEtBQUssYUFBYTtBQUNoQyxVQUFNLE1BQU0sS0FBSztBQUVqQixVQUFNLFlBQVksV0FBVyxJQUFJO0FBRWpDLFFBQUksQ0FBQyxlQUFlO0FBQ2xCLHNCQUFnQjtBQUFBLElBQ2pCO0FBRUQsVUFBTSxJQUFJLElBQUk7QUFDZCxlQUFXLElBQUksSUFBSTtBQUVuQixRQUFJLElBQUk7QUFDUixRQUFJLGFBQWE7QUFFakIsV0FBTyxNQUFNLE1BQU07QUFDakIsb0JBQWMsTUFBTSxHQUFHO0FBQ3ZCLFVBQUksSUFBSTtBQUFBLElBQ1Q7QUFFRCxZQUFRLE9BQU8sS0FBSztBQUVwQixRQUFJLFNBQVMsTUFBTTtBQUNqQixjQUFRLE9BQU8sS0FBSztBQUFBLElBQ3JCO0FBRUQsUUFBSSxNQUFNLGdCQUFnQixLQUFLO0FBQzdCO0FBQUEsSUFDRDtBQUVELFVBQU0sU0FBUyxhQUFhLE1BQU07QUFFbEMsV0FBTyxTQUFTLEtBQUssTUFBTSxhQUFhLE1BQU8sTUFBTSxJQUFJO0FBQUEsRUFDN0Q7QUFDQTtBQ3BDQSxTQUFTLHFCQUFxQixVQUFVLGtCQUFrQjtBQUN4RCxNQUFJLGdCQUFnQjtBQUNwQixRQUFNLGVBQWUsWUFBWSxJQUFJLEdBQUc7QUFFeEMsU0FBTyxPQUFLO0FBQ1YsVUFBTSxTQUFTLEVBQUU7QUFDakIsVUFBTSxRQUFRLEVBQUUsbUJBQW1CLEVBQUUsUUFBUTtBQUM3QyxVQUFNLGdCQUFnQixTQUFTO0FBQy9CLFVBQU0sT0FBTyxhQUFhLGFBQWE7QUFDdkMsVUFBTSxVQUFVLFVBQVU7QUFFMUIsb0JBQWdCO0FBRWhCLFVBQU0sT0FBTztBQUFBLE1BQ1g7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFVLFFBQVMsU0FBUyxRQUFTO0FBQUEsTUFDckMsT0FBTztBQUFBLE1BQ1AsTUFBTSxPQUFPLE9BQU87QUFBQSxNQUNwQixXQUFXLFFBQVEsU0FBUyxXQUFXLFFBQVEsVUFBVSxPQUFPO0FBQUEsTUFDaEUsT0FBTztBQUFBLElBQ2I7QUFFSSxTQUFLLG1CQUFtQixhQUFhLFFBQVEsSUFBSTtBQUVqRCxhQUFTLElBQUk7QUFBQSxFQUNqQjtBQUNBO0FBRUEsTUFBTSx3QkFBd0IsT0FBTyxtQkFBbUI7QUFFeEQsTUFBQSxhQUFlLHlCQUF5QixTQUFVd0gsU0FBUTtBQUN4RCxTQUFPLElBQUksUUFBUSxTQUFTLG1CQUFtQk4sVUFBUyxRQUFRO0FBQzlELFFBQUksY0FBY00sUUFBTztBQUN6QixVQUFNLGlCQUFpQlcsZUFBYSxLQUFLWCxRQUFPLE9BQU8sRUFBRTtBQUN6RCxVQUFNLGVBQWVBLFFBQU87QUFDNUIsUUFBSTtBQUNKLGFBQVMsT0FBTztBQUNkLFVBQUlBLFFBQU8sYUFBYTtBQUN0QixRQUFBQSxRQUFPLFlBQVksWUFBWSxVQUFVO0FBQUEsTUFDMUM7QUFFRCxVQUFJQSxRQUFPLFFBQVE7QUFDakIsUUFBQUEsUUFBTyxPQUFPLG9CQUFvQixTQUFTLFVBQVU7QUFBQSxNQUN0RDtBQUFBLElBQ0Y7QUFFRCxRQUFJLE1BQU0sV0FBVyxXQUFXLE1BQU0sU0FBUyx3QkFBd0IsU0FBUyxnQ0FBZ0M7QUFDOUcscUJBQWUsZUFBZSxLQUFLO0FBQUEsSUFDcEM7QUFFRCxRQUFJekgsV0FBVSxJQUFJO0FBR2xCLFFBQUl5SCxRQUFPLE1BQU07QUFDZixZQUFNLFdBQVdBLFFBQU8sS0FBSyxZQUFZO0FBQ3pDLFlBQU0sV0FBV0EsUUFBTyxLQUFLLFdBQVcsU0FBUyxtQkFBbUJBLFFBQU8sS0FBSyxRQUFRLENBQUMsSUFBSTtBQUM3RixxQkFBZSxJQUFJLGlCQUFpQixXQUFXLEtBQUssV0FBVyxNQUFNLFFBQVEsQ0FBQztBQUFBLElBQy9FO0FBRUQsVUFBTSxXQUFXLGNBQWNBLFFBQU8sU0FBU0EsUUFBTyxHQUFHO0FBRXpELElBQUF6SCxTQUFRLEtBQUt5SCxRQUFPLE9BQU8sWUFBYSxHQUFFLFNBQVMsVUFBVUEsUUFBTyxRQUFRQSxRQUFPLGdCQUFnQixHQUFHLElBQUk7QUFHMUcsSUFBQXpILFNBQVEsVUFBVXlILFFBQU87QUFFekIsYUFBUyxZQUFZO0FBQ25CLFVBQUksQ0FBQ3pILFVBQVM7QUFDWjtBQUFBLE1BQ0Q7QUFFRCxZQUFNLGtCQUFrQm9JLGVBQWE7QUFBQSxRQUNuQywyQkFBMkJwSSxZQUFXQSxTQUFRLHNCQUF1QjtBQUFBLE1BQzdFO0FBQ00sWUFBTSxlQUFlLENBQUMsZ0JBQWdCLGlCQUFpQixVQUFVLGlCQUFpQixTQUNoRkEsU0FBUSxlQUFlQSxTQUFRO0FBQ2pDLFlBQU0sV0FBVztBQUFBLFFBQ2YsTUFBTTtBQUFBLFFBQ04sUUFBUUEsU0FBUTtBQUFBLFFBQ2hCLFlBQVlBLFNBQVE7QUFBQSxRQUNwQixTQUFTO0FBQUEsUUFDVCxRQUFBeUg7QUFBQSxRQUNBLFNBQUF6SDtBQUFBLE1BQ1I7QUFFTSxhQUFPLFNBQVMsU0FBUyxPQUFPO0FBQzlCLFFBQUFtSCxTQUFRLEtBQUs7QUFDYjtNQUNSLEdBQVMsU0FBUyxRQUFRLEtBQUs7QUFDdkIsZUFBTyxHQUFHO0FBQ1Y7TUFDRCxHQUFFLFFBQVE7QUFHWCxNQUFBbkgsV0FBVTtBQUFBLElBQ1g7QUFFRCxRQUFJLGVBQWVBLFVBQVM7QUFFMUIsTUFBQUEsU0FBUSxZQUFZO0FBQUEsSUFDMUIsT0FBVztBQUVMLE1BQUFBLFNBQVEscUJBQXFCLFNBQVMsYUFBYTtBQUNqRCxZQUFJLENBQUNBLFlBQVdBLFNBQVEsZUFBZSxHQUFHO0FBQ3hDO0FBQUEsUUFDRDtBQU1ELFlBQUlBLFNBQVEsV0FBVyxLQUFLLEVBQUVBLFNBQVEsZUFBZUEsU0FBUSxZQUFZLFFBQVEsT0FBTyxNQUFNLElBQUk7QUFDaEc7QUFBQSxRQUNEO0FBR0QsbUJBQVcsU0FBUztBQUFBLE1BQzVCO0FBQUEsSUFDSztBQUdELElBQUFBLFNBQVEsVUFBVSxTQUFTLGNBQWM7QUFDdkMsVUFBSSxDQUFDQSxVQUFTO0FBQ1o7QUFBQSxNQUNEO0FBRUQsYUFBTyxJQUFJLFdBQVcsbUJBQW1CLFdBQVcsY0FBY3lILFNBQVF6SCxRQUFPLENBQUM7QUFHbEYsTUFBQUEsV0FBVTtBQUFBLElBQ2hCO0FBR0ksSUFBQUEsU0FBUSxVQUFVLFNBQVMsY0FBYztBQUd2QyxhQUFPLElBQUksV0FBVyxpQkFBaUIsV0FBVyxhQUFheUgsU0FBUXpILFFBQU8sQ0FBQztBQUcvRSxNQUFBQSxXQUFVO0FBQUEsSUFDaEI7QUFHSSxJQUFBQSxTQUFRLFlBQVksU0FBUyxnQkFBZ0I7QUFDM0MsVUFBSSxzQkFBc0J5SCxRQUFPLFVBQVUsZ0JBQWdCQSxRQUFPLFVBQVUsZ0JBQWdCO0FBQzVGLFlBQU1TLGdCQUFlVCxRQUFPLGdCQUFnQjtBQUM1QyxVQUFJQSxRQUFPLHFCQUFxQjtBQUM5Qiw4QkFBc0JBLFFBQU87QUFBQSxNQUM5QjtBQUNELGFBQU8sSUFBSTtBQUFBLFFBQ1Q7QUFBQSxRQUNBUyxjQUFhLHNCQUFzQixXQUFXLFlBQVksV0FBVztBQUFBLFFBQ3JFVDtBQUFBLFFBQ0F6SDtBQUFBLE1BQU8sQ0FBQztBQUdWLE1BQUFBLFdBQVU7QUFBQSxJQUNoQjtBQUtJLFFBQUksU0FBUyxzQkFBc0I7QUFFakMsWUFBTSxhQUFheUgsUUFBTyxtQkFBbUIsZ0JBQWdCLFFBQVEsTUFDaEVBLFFBQU8sa0JBQWtCLFFBQVEsS0FBS0EsUUFBTyxjQUFjO0FBRWhFLFVBQUksV0FBVztBQUNiLHVCQUFlLElBQUlBLFFBQU8sZ0JBQWdCLFNBQVM7QUFBQSxNQUNwRDtBQUFBLElBQ0Y7QUFHRCxvQkFBZ0IsVUFBYSxlQUFlLGVBQWUsSUFBSTtBQUcvRCxRQUFJLHNCQUFzQnpILFVBQVM7QUFDakMsWUFBTSxRQUFRLGVBQWUsT0FBUSxHQUFFLFNBQVMsaUJBQWlCLEtBQUssS0FBSztBQUN6RSxRQUFBQSxTQUFRLGlCQUFpQixLQUFLLEdBQUc7QUFBQSxNQUN6QyxDQUFPO0FBQUEsSUFDRjtBQUdELFFBQUksQ0FBQyxNQUFNLFlBQVl5SCxRQUFPLGVBQWUsR0FBRztBQUM5QyxNQUFBekgsU0FBUSxrQkFBa0IsQ0FBQyxDQUFDeUgsUUFBTztBQUFBLElBQ3BDO0FBR0QsUUFBSSxnQkFBZ0IsaUJBQWlCLFFBQVE7QUFDM0MsTUFBQXpILFNBQVEsZUFBZXlILFFBQU87QUFBQSxJQUMvQjtBQUdELFFBQUksT0FBT0EsUUFBTyx1QkFBdUIsWUFBWTtBQUNuRCxNQUFBekgsU0FBUSxpQkFBaUIsWUFBWSxxQkFBcUJ5SCxRQUFPLG9CQUFvQixJQUFJLENBQUM7QUFBQSxJQUMzRjtBQUdELFFBQUksT0FBT0EsUUFBTyxxQkFBcUIsY0FBY3pILFNBQVEsUUFBUTtBQUNuRSxNQUFBQSxTQUFRLE9BQU8saUJBQWlCLFlBQVkscUJBQXFCeUgsUUFBTyxnQkFBZ0IsQ0FBQztBQUFBLElBQzFGO0FBRUQsUUFBSUEsUUFBTyxlQUFlQSxRQUFPLFFBQVE7QUFHdkMsbUJBQWEsWUFBVTtBQUNyQixZQUFJLENBQUN6SCxVQUFTO0FBQ1o7QUFBQSxRQUNEO0FBQ0QsZUFBTyxDQUFDLFVBQVUsT0FBTyxPQUFPLElBQUksY0FBYyxNQUFNeUgsU0FBUXpILFFBQU8sSUFBSSxNQUFNO0FBQ2pGLFFBQUFBLFNBQVEsTUFBSztBQUNiLFFBQUFBLFdBQVU7QUFBQSxNQUNsQjtBQUVNLE1BQUF5SCxRQUFPLGVBQWVBLFFBQU8sWUFBWSxVQUFVLFVBQVU7QUFDN0QsVUFBSUEsUUFBTyxRQUFRO0FBQ2pCLFFBQUFBLFFBQU8sT0FBTyxVQUFVLFdBQVksSUFBR0EsUUFBTyxPQUFPLGlCQUFpQixTQUFTLFVBQVU7QUFBQSxNQUMxRjtBQUFBLElBQ0Y7QUFFRCxVQUFNLFdBQVcsY0FBYyxRQUFRO0FBRXZDLFFBQUksWUFBWSxTQUFTLFVBQVUsUUFBUSxRQUFRLE1BQU0sSUFBSTtBQUMzRCxhQUFPLElBQUksV0FBVywwQkFBMEIsV0FBVyxLQUFLLFdBQVcsaUJBQWlCQSxPQUFNLENBQUM7QUFDbkc7QUFBQSxJQUNEO0FBSUQsSUFBQXpILFNBQVEsS0FBSyxlQUFlLElBQUk7QUFBQSxFQUNwQyxDQUFHO0FBQ0g7QUNuUEEsTUFBTSxnQkFBZ0I7QUFBQSxFQUNwQixNQUFNO0FBQUEsRUFDTixLQUFLO0FBQ1A7QUFFQSxNQUFNLFFBQVEsZUFBZSxDQUFDLElBQUksVUFBVTtBQUMxQyxNQUFHLElBQUk7QUFDTCxRQUFJO0FBQ0YsYUFBTyxlQUFlLElBQUksUUFBUSxFQUFDLE1BQUssQ0FBQztBQUFBLElBQzFDLFNBQVEsR0FBUDtBQUFBLElBRUQ7QUFDRCxXQUFPLGVBQWUsSUFBSSxlQUFlLEVBQUMsTUFBSyxDQUFDO0FBQUEsRUFDakQ7QUFDSCxDQUFDO0FBRUQsTUFBZSxXQUFBO0FBQUEsRUFDYixZQUFZLENBQUN5SSxjQUFhO0FBQ3hCLElBQUFBLFlBQVcsTUFBTSxRQUFRQSxTQUFRLElBQUlBLFlBQVcsQ0FBQ0EsU0FBUTtBQUV6RCxVQUFNLEVBQUMsT0FBTSxJQUFJQTtBQUNqQixRQUFJO0FBQ0osUUFBSTtBQUVKLGFBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxLQUFLO0FBQy9CLHNCQUFnQkEsVUFBUyxDQUFDO0FBQzFCLFVBQUksVUFBVSxNQUFNLFNBQVMsYUFBYSxJQUFJLGNBQWMsY0FBYyxhQUFhLElBQUksZUFBZ0I7QUFDekc7QUFBQSxNQUNEO0FBQUEsSUFDRjtBQUVELFFBQUksQ0FBQyxTQUFTO0FBQ1osVUFBSSxZQUFZLE9BQU87QUFDckIsY0FBTSxJQUFJO0FBQUEsVUFDUixXQUFXO0FBQUEsVUFDWDtBQUFBLFFBQ1Y7QUFBQSxNQUNPO0FBRUQsWUFBTSxJQUFJO0FBQUEsUUFDUixNQUFNLFdBQVcsZUFBZSxhQUFhLElBQzNDLFlBQVksaURBQ1osb0JBQW9CO0FBQUEsTUFDOUI7QUFBQSxJQUNLO0FBRUQsUUFBSSxDQUFDLE1BQU0sV0FBVyxPQUFPLEdBQUc7QUFDOUIsWUFBTSxJQUFJLFVBQVUsMkJBQTJCO0FBQUEsSUFDaEQ7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsVUFBVTtBQUNaO0FDMUNBLFNBQVMsNkJBQTZCaEIsU0FBUTtBQUM1QyxNQUFJQSxRQUFPLGFBQWE7QUFDdEIsSUFBQUEsUUFBTyxZQUFZO0VBQ3BCO0FBRUQsTUFBSUEsUUFBTyxVQUFVQSxRQUFPLE9BQU8sU0FBUztBQUMxQyxVQUFNLElBQUksY0FBYyxNQUFNQSxPQUFNO0FBQUEsRUFDckM7QUFDSDtBQVNlLFNBQVMsZ0JBQWdCQSxTQUFRO0FBQzlDLCtCQUE2QkEsT0FBTTtBQUVuQyxFQUFBQSxRQUFPLFVBQVVXLGVBQWEsS0FBS1gsUUFBTyxPQUFPO0FBR2pELEVBQUFBLFFBQU8sT0FBTyxjQUFjO0FBQUEsSUFDMUJBO0FBQUEsSUFDQUEsUUFBTztBQUFBLEVBQ1g7QUFFRSxNQUFJLENBQUMsUUFBUSxPQUFPLE9BQU8sRUFBRSxRQUFRQSxRQUFPLE1BQU0sTUFBTSxJQUFJO0FBQzFELElBQUFBLFFBQU8sUUFBUSxlQUFlLHFDQUFxQyxLQUFLO0FBQUEsRUFDekU7QUFFRCxRQUFNLFVBQVUsU0FBUyxXQUFXQSxRQUFPLFdBQVdVLFdBQVMsT0FBTztBQUV0RSxTQUFPLFFBQVFWLE9BQU0sRUFBRSxLQUFLLFNBQVMsb0JBQW9CLFVBQVU7QUFDakUsaUNBQTZCQSxPQUFNO0FBR25DLGFBQVMsT0FBTyxjQUFjO0FBQUEsTUFDNUJBO0FBQUEsTUFDQUEsUUFBTztBQUFBLE1BQ1A7QUFBQSxJQUNOO0FBRUksYUFBUyxVQUFVVyxlQUFhLEtBQUssU0FBUyxPQUFPO0FBRXJELFdBQU87QUFBQSxFQUNYLEdBQUssU0FBUyxtQkFBbUIsUUFBUTtBQUNyQyxRQUFJLENBQUMsU0FBUyxNQUFNLEdBQUc7QUFDckIsbUNBQTZCWCxPQUFNO0FBR25DLFVBQUksVUFBVSxPQUFPLFVBQVU7QUFDN0IsZUFBTyxTQUFTLE9BQU8sY0FBYztBQUFBLFVBQ25DQTtBQUFBLFVBQ0FBLFFBQU87QUFBQSxVQUNQLE9BQU87QUFBQSxRQUNqQjtBQUNRLGVBQU8sU0FBUyxVQUFVVyxlQUFhLEtBQUssT0FBTyxTQUFTLE9BQU87QUFBQSxNQUNwRTtBQUFBLElBQ0Y7QUFFRCxXQUFPLFFBQVEsT0FBTyxNQUFNO0FBQUEsRUFDaEMsQ0FBRztBQUNIO0FDM0VBLE1BQU0sa0JBQWtCLENBQUMsVUFBVSxpQkFBaUJBLGlCQUFlLE1BQU0sT0FBUSxJQUFHO0FBV3JFLFNBQVMsWUFBWSxTQUFTLFNBQVM7QUFFcEQsWUFBVSxXQUFXO0FBQ3JCLFFBQU1YLFVBQVMsQ0FBQTtBQUVmLFdBQVMsZUFBZSxRQUFRLFFBQVEsVUFBVTtBQUNoRCxRQUFJLE1BQU0sY0FBYyxNQUFNLEtBQUssTUFBTSxjQUFjLE1BQU0sR0FBRztBQUM5RCxhQUFPLE1BQU0sTUFBTSxLQUFLLEVBQUMsU0FBUSxHQUFHLFFBQVEsTUFBTTtBQUFBLElBQ25ELFdBQVUsTUFBTSxjQUFjLE1BQU0sR0FBRztBQUN0QyxhQUFPLE1BQU0sTUFBTSxDQUFFLEdBQUUsTUFBTTtBQUFBLElBQzlCLFdBQVUsTUFBTSxRQUFRLE1BQU0sR0FBRztBQUNoQyxhQUFPLE9BQU87SUFDZjtBQUNELFdBQU87QUFBQSxFQUNSO0FBR0QsV0FBUyxvQkFBb0IvRyxJQUFHa0IsSUFBRyxVQUFVO0FBQzNDLFFBQUksQ0FBQyxNQUFNLFlBQVlBLEVBQUMsR0FBRztBQUN6QixhQUFPLGVBQWVsQixJQUFHa0IsSUFBRyxRQUFRO0FBQUEsSUFDckMsV0FBVSxDQUFDLE1BQU0sWUFBWWxCLEVBQUMsR0FBRztBQUNoQyxhQUFPLGVBQWUsUUFBV0EsSUFBRyxRQUFRO0FBQUEsSUFDN0M7QUFBQSxFQUNGO0FBR0QsV0FBUyxpQkFBaUJBLElBQUdrQixJQUFHO0FBQzlCLFFBQUksQ0FBQyxNQUFNLFlBQVlBLEVBQUMsR0FBRztBQUN6QixhQUFPLGVBQWUsUUFBV0EsRUFBQztBQUFBLElBQ25DO0FBQUEsRUFDRjtBQUdELFdBQVMsaUJBQWlCbEIsSUFBR2tCLElBQUc7QUFDOUIsUUFBSSxDQUFDLE1BQU0sWUFBWUEsRUFBQyxHQUFHO0FBQ3pCLGFBQU8sZUFBZSxRQUFXQSxFQUFDO0FBQUEsSUFDbkMsV0FBVSxDQUFDLE1BQU0sWUFBWWxCLEVBQUMsR0FBRztBQUNoQyxhQUFPLGVBQWUsUUFBV0EsRUFBQztBQUFBLElBQ25DO0FBQUEsRUFDRjtBQUdELFdBQVMsZ0JBQWdCQSxJQUFHa0IsSUFBRyxNQUFNO0FBQ25DLFFBQUksUUFBUSxTQUFTO0FBQ25CLGFBQU8sZUFBZWxCLElBQUdrQixFQUFDO0FBQUEsSUFDaEMsV0FBZSxRQUFRLFNBQVM7QUFDMUIsYUFBTyxlQUFlLFFBQVdsQixFQUFDO0FBQUEsSUFDbkM7QUFBQSxFQUNGO0FBRUQsUUFBTSxXQUFXO0FBQUEsSUFDZixLQUFLO0FBQUEsSUFDTCxRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxrQkFBa0I7QUFBQSxJQUNsQixtQkFBbUI7QUFBQSxJQUNuQixrQkFBa0I7QUFBQSxJQUNsQixTQUFTO0FBQUEsSUFDVCxnQkFBZ0I7QUFBQSxJQUNoQixpQkFBaUI7QUFBQSxJQUNqQixTQUFTO0FBQUEsSUFDVCxjQUFjO0FBQUEsSUFDZCxnQkFBZ0I7QUFBQSxJQUNoQixnQkFBZ0I7QUFBQSxJQUNoQixrQkFBa0I7QUFBQSxJQUNsQixvQkFBb0I7QUFBQSxJQUNwQixZQUFZO0FBQUEsSUFDWixrQkFBa0I7QUFBQSxJQUNsQixlQUFlO0FBQUEsSUFDZixnQkFBZ0I7QUFBQSxJQUNoQixXQUFXO0FBQUEsSUFDWCxXQUFXO0FBQUEsSUFDWCxZQUFZO0FBQUEsSUFDWixhQUFhO0FBQUEsSUFDYixZQUFZO0FBQUEsSUFDWixrQkFBa0I7QUFBQSxJQUNsQixnQkFBZ0I7QUFBQSxJQUNoQixTQUFTLENBQUNBLElBQUdrQixPQUFNLG9CQUFvQixnQkFBZ0JsQixFQUFDLEdBQUcsZ0JBQWdCa0IsRUFBQyxHQUFHLElBQUk7QUFBQSxFQUN2RjtBQUVFLFFBQU0sUUFBUSxPQUFPLEtBQUssT0FBTyxFQUFFLE9BQU8sT0FBTyxLQUFLLE9BQU8sQ0FBQyxHQUFHLFNBQVMsbUJBQW1CLE1BQU07QUFDakcsVUFBTThHLFNBQVEsU0FBUyxJQUFJLEtBQUs7QUFDaEMsVUFBTSxjQUFjQSxPQUFNLFFBQVEsSUFBSSxHQUFHLFFBQVEsSUFBSSxHQUFHLElBQUk7QUFDNUQsSUFBQyxNQUFNLFlBQVksV0FBVyxLQUFLQSxXQUFVLG9CQUFxQmpCLFFBQU8sSUFBSSxJQUFJO0FBQUEsRUFDckYsQ0FBRztBQUVELFNBQU9BO0FBQ1Q7QUN4R08sTUFBTSxVQUFVO0FDS3ZCLE1BQU1rQixlQUFhLENBQUE7QUFHbkIsQ0FBQyxVQUFVLFdBQVcsVUFBVSxZQUFZLFVBQVUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxNQUFNLE1BQU07QUFDbkZBLGVBQVcsSUFBSSxJQUFJLFNBQVNDLFdBQVUsT0FBTztBQUMzQyxXQUFPLE9BQU8sVUFBVSxRQUFRLE9BQU8sSUFBSSxJQUFJLE9BQU8sT0FBTztBQUFBLEVBQ2pFO0FBQ0EsQ0FBQztBQUVELE1BQU0scUJBQXFCLENBQUE7QUFXM0JELGFBQVcsZUFBZSxTQUFTLGFBQWFDLFlBQVcxRyxVQUFTLFNBQVM7QUFDM0UsV0FBUyxjQUFjLEtBQUssTUFBTTtBQUNoQyxXQUFPLGFBQWEsVUFBVSw0QkFBNkIsTUFBTSxNQUFPLFFBQVEsVUFBVSxPQUFPLFVBQVU7QUFBQSxFQUM1RztBQUdELFNBQU8sQ0FBQyxPQUFPLEtBQUsyRyxVQUFTO0FBQzNCLFFBQUlELGVBQWMsT0FBTztBQUN2QixZQUFNLElBQUk7QUFBQSxRQUNSLGNBQWMsS0FBSyx1QkFBdUIxRyxXQUFVLFNBQVNBLFdBQVUsR0FBRztBQUFBLFFBQzFFLFdBQVc7QUFBQSxNQUNuQjtBQUFBLElBQ0s7QUFFRCxRQUFJQSxZQUFXLENBQUMsbUJBQW1CLEdBQUcsR0FBRztBQUN2Qyx5QkFBbUIsR0FBRyxJQUFJO0FBRTFCLGNBQVE7QUFBQSxRQUNOO0FBQUEsVUFDRTtBQUFBLFVBQ0EsaUNBQWlDQSxXQUFVO0FBQUEsUUFDNUM7QUFBQSxNQUNUO0FBQUEsSUFDSztBQUVELFdBQU8wRyxhQUFZQSxXQUFVLE9BQU8sS0FBS0MsS0FBSSxJQUFJO0FBQUEsRUFDckQ7QUFDQTtBQVlBLFNBQVMsY0FBYyxTQUFTLFFBQVEsY0FBYztBQUNwRCxNQUFJLE9BQU8sWUFBWSxVQUFVO0FBQy9CLFVBQU0sSUFBSSxXQUFXLDZCQUE2QixXQUFXLG9CQUFvQjtBQUFBLEVBQ2xGO0FBQ0QsUUFBTSxPQUFPLE9BQU8sS0FBSyxPQUFPO0FBQ2hDLE1BQUksSUFBSSxLQUFLO0FBQ2IsU0FBTyxNQUFNLEdBQUc7QUFDZCxVQUFNLE1BQU0sS0FBSyxDQUFDO0FBQ2xCLFVBQU1ELGFBQVksT0FBTyxHQUFHO0FBQzVCLFFBQUlBLFlBQVc7QUFDYixZQUFNLFFBQVEsUUFBUSxHQUFHO0FBQ3pCLFlBQU0sU0FBUyxVQUFVLFVBQWFBLFdBQVUsT0FBTyxLQUFLLE9BQU87QUFDbkUsVUFBSSxXQUFXLE1BQU07QUFDbkIsY0FBTSxJQUFJLFdBQVcsWUFBWSxNQUFNLGNBQWMsUUFBUSxXQUFXLG9CQUFvQjtBQUFBLE1BQzdGO0FBQ0Q7QUFBQSxJQUNEO0FBQ0QsUUFBSSxpQkFBaUIsTUFBTTtBQUN6QixZQUFNLElBQUksV0FBVyxvQkFBb0IsS0FBSyxXQUFXLGNBQWM7QUFBQSxJQUN4RTtBQUFBLEVBQ0Y7QUFDSDtBQUVBLE1BQWUsWUFBQTtBQUFBLEVBQ2I7QUFBQSxFQUNGLFlBQUVEO0FBQ0Y7QUMvRUEsTUFBTSxhQUFhLFVBQVU7QUFTN0IsTUFBTSxNQUFNO0FBQUEsRUFDVixZQUFZLGdCQUFnQjtBQUMxQixTQUFLLFdBQVc7QUFDaEIsU0FBSyxlQUFlO0FBQUEsTUFDbEIsU0FBUyxJQUFJRyxxQkFBb0I7QUFBQSxNQUNqQyxVQUFVLElBQUlBLHFCQUFvQjtBQUFBLElBQ3hDO0FBQUEsRUFDRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVVELFFBQVEsYUFBYXJCLFNBQVE7QUFHM0IsUUFBSSxPQUFPLGdCQUFnQixVQUFVO0FBQ25DLE1BQUFBLFVBQVNBLFdBQVU7QUFDbkIsTUFBQUEsUUFBTyxNQUFNO0FBQUEsSUFDbkIsT0FBVztBQUNMLE1BQUFBLFVBQVMsZUFBZTtJQUN6QjtBQUVELElBQUFBLFVBQVMsWUFBWSxLQUFLLFVBQVVBLE9BQU07QUFFMUMsVUFBTSxFQUFDLGNBQUFTLGVBQWMsa0JBQWtCLFFBQU8sSUFBSVQ7QUFFbEQsUUFBSVMsa0JBQWlCLFFBQVc7QUFDOUIsZ0JBQVUsY0FBY0EsZUFBYztBQUFBLFFBQ3BDLG1CQUFtQixXQUFXLGFBQWEsV0FBVyxPQUFPO0FBQUEsUUFDN0QsbUJBQW1CLFdBQVcsYUFBYSxXQUFXLE9BQU87QUFBQSxRQUM3RCxxQkFBcUIsV0FBVyxhQUFhLFdBQVcsT0FBTztBQUFBLE1BQ2hFLEdBQUUsS0FBSztBQUFBLElBQ1Q7QUFFRCxRQUFJLHFCQUFxQixRQUFXO0FBQ2xDLGdCQUFVLGNBQWMsa0JBQWtCO0FBQUEsUUFDeEMsUUFBUSxXQUFXO0FBQUEsUUFDbkIsV0FBVyxXQUFXO0FBQUEsTUFDdkIsR0FBRSxJQUFJO0FBQUEsSUFDUjtBQUdELElBQUFULFFBQU8sVUFBVUEsUUFBTyxVQUFVLEtBQUssU0FBUyxVQUFVLE9BQU87QUFFakUsUUFBSTtBQUdKLHFCQUFpQixXQUFXLE1BQU07QUFBQSxNQUNoQyxRQUFRO0FBQUEsTUFDUixRQUFRQSxRQUFPLE1BQU07QUFBQSxJQUMzQjtBQUVJLHNCQUFrQixNQUFNO0FBQUEsTUFDdEIsQ0FBQyxVQUFVLE9BQU8sUUFBUSxRQUFRLE9BQU8sU0FBUyxRQUFRO0FBQUEsTUFDMUQsQ0FBQyxXQUFXO0FBQ1YsZUFBTyxRQUFRLE1BQU07QUFBQSxNQUN0QjtBQUFBLElBQ1A7QUFFSSxJQUFBQSxRQUFPLFVBQVVXLGVBQWEsT0FBTyxnQkFBZ0IsT0FBTztBQUc1RCxVQUFNLDBCQUEwQixDQUFBO0FBQ2hDLFFBQUksaUNBQWlDO0FBQ3JDLFNBQUssYUFBYSxRQUFRLFFBQVEsU0FBUywyQkFBMkIsYUFBYTtBQUNqRixVQUFJLE9BQU8sWUFBWSxZQUFZLGNBQWMsWUFBWSxRQUFRWCxPQUFNLE1BQU0sT0FBTztBQUN0RjtBQUFBLE1BQ0Q7QUFFRCx1Q0FBaUMsa0NBQWtDLFlBQVk7QUFFL0UsOEJBQXdCLFFBQVEsWUFBWSxXQUFXLFlBQVksUUFBUTtBQUFBLElBQ2pGLENBQUs7QUFFRCxVQUFNLDJCQUEyQixDQUFBO0FBQ2pDLFNBQUssYUFBYSxTQUFTLFFBQVEsU0FBUyx5QkFBeUIsYUFBYTtBQUNoRiwrQkFBeUIsS0FBSyxZQUFZLFdBQVcsWUFBWSxRQUFRO0FBQUEsSUFDL0UsQ0FBSztBQUVELFFBQUk7QUFDSixRQUFJLElBQUk7QUFDUixRQUFJO0FBRUosUUFBSSxDQUFDLGdDQUFnQztBQUNuQyxZQUFNLFFBQVEsQ0FBQyxnQkFBZ0IsS0FBSyxJQUFJLEdBQUcsTUFBUztBQUNwRCxZQUFNLFFBQVEsTUFBTSxPQUFPLHVCQUF1QjtBQUNsRCxZQUFNLEtBQUssTUFBTSxPQUFPLHdCQUF3QjtBQUNoRCxZQUFNLE1BQU07QUFFWixnQkFBVSxRQUFRLFFBQVFBLE9BQU07QUFFaEMsYUFBTyxJQUFJLEtBQUs7QUFDZCxrQkFBVSxRQUFRLEtBQUssTUFBTSxHQUFHLEdBQUcsTUFBTSxHQUFHLENBQUM7QUFBQSxNQUM5QztBQUVELGFBQU87QUFBQSxJQUNSO0FBRUQsVUFBTSx3QkFBd0I7QUFFOUIsUUFBSSxZQUFZQTtBQUVoQixRQUFJO0FBRUosV0FBTyxJQUFJLEtBQUs7QUFDZCxZQUFNLGNBQWMsd0JBQXdCLEdBQUc7QUFDL0MsWUFBTSxhQUFhLHdCQUF3QixHQUFHO0FBQzlDLFVBQUk7QUFDRixvQkFBWSxZQUFZLFNBQVM7QUFBQSxNQUNsQyxTQUFRakksUUFBUDtBQUNBLG1CQUFXLEtBQUssTUFBTUEsTUFBSztBQUMzQjtBQUFBLE1BQ0Q7QUFBQSxJQUNGO0FBRUQsUUFBSTtBQUNGLGdCQUFVLGdCQUFnQixLQUFLLE1BQU0sU0FBUztBQUFBLElBQy9DLFNBQVFBLFFBQVA7QUFDQSxhQUFPLFFBQVEsT0FBT0EsTUFBSztBQUFBLElBQzVCO0FBRUQsUUFBSTtBQUNKLFVBQU0seUJBQXlCO0FBRS9CLFdBQU8sSUFBSSxLQUFLO0FBQ2QsZ0JBQVUsUUFBUSxLQUFLLHlCQUF5QixHQUFHLEdBQUcseUJBQXlCLEdBQUcsQ0FBQztBQUFBLElBQ3BGO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUVELE9BQU9pSSxTQUFRO0FBQ2IsSUFBQUEsVUFBUyxZQUFZLEtBQUssVUFBVUEsT0FBTTtBQUMxQyxVQUFNLFdBQVcsY0FBY0EsUUFBTyxTQUFTQSxRQUFPLEdBQUc7QUFDekQsV0FBTyxTQUFTLFVBQVVBLFFBQU8sUUFBUUEsUUFBTyxnQkFBZ0I7QUFBQSxFQUNqRTtBQUNIO0FBR0EsTUFBTSxRQUFRLENBQUMsVUFBVSxPQUFPLFFBQVEsU0FBUyxHQUFHLFNBQVNzQixxQkFBb0IsUUFBUTtBQUV2RixRQUFNLFVBQVUsTUFBTSxJQUFJLFNBQVM5SSxNQUFLd0gsU0FBUTtBQUM5QyxXQUFPLEtBQUssUUFBUSxZQUFZQSxXQUFVLENBQUEsR0FBSTtBQUFBLE1BQzVDO0FBQUEsTUFDQSxLQUFBeEg7QUFBQSxNQUNBLE9BQU93SCxXQUFVLENBQUEsR0FBSTtBQUFBLElBQ3RCLENBQUEsQ0FBQztBQUFBLEVBQ047QUFDQSxDQUFDO0FBRUQsTUFBTSxRQUFRLENBQUMsUUFBUSxPQUFPLE9BQU8sR0FBRyxTQUFTdUIsdUJBQXNCLFFBQVE7QUFHN0UsV0FBUyxtQkFBbUIsUUFBUTtBQUNsQyxXQUFPLFNBQVMsV0FBVy9JLE1BQUssTUFBTXdILFNBQVE7QUFDNUMsYUFBTyxLQUFLLFFBQVEsWUFBWUEsV0FBVSxDQUFBLEdBQUk7QUFBQSxRQUM1QztBQUFBLFFBQ0EsU0FBUyxTQUFTO0FBQUEsVUFDaEIsZ0JBQWdCO0FBQUEsUUFDMUIsSUFBWSxDQUFFO0FBQUEsUUFDTixLQUFBeEg7QUFBQSxRQUNBO0FBQUEsTUFDRCxDQUFBLENBQUM7QUFBQSxJQUNSO0FBQUEsRUFDRztBQUVELFFBQU0sVUFBVSxNQUFNLElBQUksbUJBQWtCO0FBRTVDLFFBQU0sVUFBVSxTQUFTLE1BQU0sSUFBSSxtQkFBbUIsSUFBSTtBQUM1RCxDQUFDO0FBRUQsTUFBQSxVQUFlO0FDekxmLE1BQU0sWUFBWTtBQUFBLEVBQ2hCLFlBQVksVUFBVTtBQUNwQixRQUFJLE9BQU8sYUFBYSxZQUFZO0FBQ2xDLFlBQU0sSUFBSSxVQUFVLDhCQUE4QjtBQUFBLElBQ25EO0FBRUQsUUFBSTtBQUVKLFNBQUssVUFBVSxJQUFJLFFBQVEsU0FBUyxnQkFBZ0JrSCxVQUFTO0FBQzNELHVCQUFpQkE7QUFBQSxJQUN2QixDQUFLO0FBRUQsVUFBTSxRQUFRO0FBR2QsU0FBSyxRQUFRLEtBQUssWUFBVTtBQUMxQixVQUFJLENBQUMsTUFBTTtBQUFZO0FBRXZCLFVBQUksSUFBSSxNQUFNLFdBQVc7QUFFekIsYUFBTyxNQUFNLEdBQUc7QUFDZCxjQUFNLFdBQVcsQ0FBQyxFQUFFLE1BQU07QUFBQSxNQUMzQjtBQUNELFlBQU0sYUFBYTtBQUFBLElBQ3pCLENBQUs7QUFHRCxTQUFLLFFBQVEsT0FBTyxpQkFBZTtBQUNqQyxVQUFJO0FBRUosWUFBTSxVQUFVLElBQUksUUFBUSxDQUFBQSxhQUFXO0FBQ3JDLGNBQU0sVUFBVUEsUUFBTztBQUN2QixtQkFBV0E7QUFBQSxNQUNuQixDQUFPLEVBQUUsS0FBSyxXQUFXO0FBRW5CLGNBQVEsU0FBUyxTQUFTLFNBQVM7QUFDakMsY0FBTSxZQUFZLFFBQVE7QUFBQSxNQUNsQztBQUVNLGFBQU87QUFBQSxJQUNiO0FBRUksYUFBUyxTQUFTLE9BQU8sU0FBU00sU0FBUXpILFVBQVM7QUFDakQsVUFBSSxNQUFNLFFBQVE7QUFFaEI7QUFBQSxNQUNEO0FBRUQsWUFBTSxTQUFTLElBQUksY0FBYyxTQUFTeUgsU0FBUXpILFFBQU87QUFDekQscUJBQWUsTUFBTSxNQUFNO0FBQUEsSUFDakMsQ0FBSztBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtELG1CQUFtQjtBQUNqQixRQUFJLEtBQUssUUFBUTtBQUNmLFlBQU0sS0FBSztBQUFBLElBQ1o7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNRCxVQUFVLFVBQVU7QUFDbEIsUUFBSSxLQUFLLFFBQVE7QUFDZixlQUFTLEtBQUssTUFBTTtBQUNwQjtBQUFBLElBQ0Q7QUFFRCxRQUFJLEtBQUssWUFBWTtBQUNuQixXQUFLLFdBQVcsS0FBSyxRQUFRO0FBQUEsSUFDbkMsT0FBVztBQUNMLFdBQUssYUFBYSxDQUFDLFFBQVE7QUFBQSxJQUM1QjtBQUFBLEVBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1ELFlBQVksVUFBVTtBQUNwQixRQUFJLENBQUMsS0FBSyxZQUFZO0FBQ3BCO0FBQUEsSUFDRDtBQUNELFVBQU0sUUFBUSxLQUFLLFdBQVcsUUFBUSxRQUFRO0FBQzlDLFFBQUksVUFBVSxJQUFJO0FBQ2hCLFdBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQztBQUFBLElBQ2hDO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNRCxPQUFPLFNBQVM7QUFDZCxRQUFJO0FBQ0osVUFBTSxRQUFRLElBQUksWUFBWSxTQUFTLFNBQVMsR0FBRztBQUNqRCxlQUFTO0FBQUEsSUFDZixDQUFLO0FBQ0QsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBO0FBQUEsSUFDTjtBQUFBLEVBQ0c7QUFDSDtBQUVBLE1BQUEsZ0JBQWU7QUNqR0EsU0FBUyxPQUFPLFVBQVU7QUFDdkMsU0FBTyxTQUFTLEtBQUssS0FBSztBQUN4QixXQUFPLFNBQVMsTUFBTSxNQUFNLEdBQUc7QUFBQSxFQUNuQztBQUNBO0FDaEJlLFNBQVMsYUFBYSxTQUFTO0FBQzVDLFNBQU8sTUFBTSxTQUFTLE9BQU8sS0FBTSxRQUFRLGlCQUFpQjtBQUM5RDtBQ2JBLE1BQU0saUJBQWlCO0FBQUEsRUFDckIsVUFBVTtBQUFBLEVBQ1Ysb0JBQW9CO0FBQUEsRUFDcEIsWUFBWTtBQUFBLEVBQ1osWUFBWTtBQUFBLEVBQ1osSUFBSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsNkJBQTZCO0FBQUEsRUFDN0IsV0FBVztBQUFBLEVBQ1gsY0FBYztBQUFBLEVBQ2QsZ0JBQWdCO0FBQUEsRUFDaEIsYUFBYTtBQUFBLEVBQ2IsaUJBQWlCO0FBQUEsRUFDakIsUUFBUTtBQUFBLEVBQ1IsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIsT0FBTztBQUFBLEVBQ1AsVUFBVTtBQUFBLEVBQ1YsYUFBYTtBQUFBLEVBQ2IsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsbUJBQW1CO0FBQUEsRUFDbkIsbUJBQW1CO0FBQUEsRUFDbkIsWUFBWTtBQUFBLEVBQ1osY0FBYztBQUFBLEVBQ2QsaUJBQWlCO0FBQUEsRUFDakIsV0FBVztBQUFBLEVBQ1gsVUFBVTtBQUFBLEVBQ1Ysa0JBQWtCO0FBQUEsRUFDbEIsZUFBZTtBQUFBLEVBQ2YsNkJBQTZCO0FBQUEsRUFDN0IsZ0JBQWdCO0FBQUEsRUFDaEIsVUFBVTtBQUFBLEVBQ1YsTUFBTTtBQUFBLEVBQ04sZ0JBQWdCO0FBQUEsRUFDaEIsb0JBQW9CO0FBQUEsRUFDcEIsaUJBQWlCO0FBQUEsRUFDakIsWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIsbUJBQW1CO0FBQUEsRUFDbkIsV0FBVztBQUFBLEVBQ1gsb0JBQW9CO0FBQUEsRUFDcEIscUJBQXFCO0FBQUEsRUFDckIsUUFBUTtBQUFBLEVBQ1Isa0JBQWtCO0FBQUEsRUFDbEIsVUFBVTtBQUFBLEVBQ1YsaUJBQWlCO0FBQUEsRUFDakIsc0JBQXNCO0FBQUEsRUFDdEIsaUJBQWlCO0FBQUEsRUFDakIsNkJBQTZCO0FBQUEsRUFDN0IsNEJBQTRCO0FBQUEsRUFDNUIscUJBQXFCO0FBQUEsRUFDckIsZ0JBQWdCO0FBQUEsRUFDaEIsWUFBWTtBQUFBLEVBQ1osb0JBQW9CO0FBQUEsRUFDcEIsZ0JBQWdCO0FBQUEsRUFDaEIseUJBQXlCO0FBQUEsRUFDekIsdUJBQXVCO0FBQUEsRUFDdkIscUJBQXFCO0FBQUEsRUFDckIsY0FBYztBQUFBLEVBQ2QsYUFBYTtBQUFBLEVBQ2IsK0JBQStCO0FBQ2pDO0FBRUEsT0FBTyxRQUFRLGNBQWMsRUFBRSxRQUFRLENBQUMsQ0FBQyxLQUFLLEtBQUssTUFBTTtBQUN2RCxpQkFBZSxLQUFLLElBQUk7QUFDMUIsQ0FBQztBQUVELE1BQUEsbUJBQWU7QUM1Q2YsU0FBUyxlQUFlaUosZ0JBQWU7QUFDckMsUUFBTSxVQUFVLElBQUlDLFFBQU1ELGNBQWE7QUFDdkMsUUFBTUUsWUFBVyxLQUFLRCxRQUFNLFVBQVUsU0FBUyxPQUFPO0FBR3RELFFBQU0sT0FBT0MsV0FBVUQsUUFBTSxXQUFXLFNBQVMsRUFBQyxZQUFZLEtBQUksQ0FBQztBQUduRSxRQUFNLE9BQU9DLFdBQVUsU0FBUyxNQUFNLEVBQUMsWUFBWSxLQUFJLENBQUM7QUFHeEQsRUFBQUEsVUFBUyxTQUFTLFNBQVMsT0FBTyxnQkFBZ0I7QUFDaEQsV0FBTyxlQUFlLFlBQVlGLGdCQUFlLGNBQWMsQ0FBQztBQUFBLEVBQ3BFO0FBRUUsU0FBT0U7QUFDVDtBQUdBLE1BQU0sUUFBUSxlQUFlaEIsVUFBUTtBQUdyQyxNQUFNLFFBQVFlO0FBR2QsTUFBTSxnQkFBZ0I7QUFDdEIsTUFBTSxjQUFjRTtBQUNwQixNQUFNLFdBQVc7QUFDakIsTUFBTSxVQUFVO0FBQ2hCLE1BQU0sYUFBYTtBQUduQixNQUFNLGFBQWE7QUFHbkIsTUFBTSxTQUFTLE1BQU07QUFHckIsTUFBTSxNQUFNLFNBQVMsSUFBSSxVQUFVO0FBQ2pDLFNBQU8sUUFBUSxJQUFJLFFBQVE7QUFDN0I7QUFFQSxNQUFNLFNBQVM7QUFHZixNQUFNLGVBQWU7QUFHckIsTUFBTSxjQUFjO0FBRXBCLE1BQU0sZUFBZWhCO0FBRXJCLE1BQU0sYUFBYSxXQUFTLGVBQWUsTUFBTSxXQUFXLEtBQUssSUFBSSxJQUFJLFNBQVMsS0FBSyxJQUFJLEtBQUs7QUFFaEcsTUFBTSxpQkFBaUJpQjtBQUV2QixNQUFNLFVBQVU7QUFHaEIsTUFBZSxVQUFBO0FDN0VmLE1BQU0sVUFBVUMsRUFBYyxpQkFBaUJDLEVBQWEsZ0JBQWdCLGNBQWM7QUFDMUYsTUFBTSxxQkFBcUIsUUFBUSxVQUFVLGVBQWU7QUFFL0MsTUFBQSxNQUFNLElBQUksTUFBTTtBQUNOLHFCQUFBLEtBQUssR0FBRyxDQUFDO0FBQ2hDO0FBRWEsTUFBQSxVQUFVQyxRQUFNLE9BQU87QUFBQSxFQUNoQyxpQkFBaUI7QUFBQSxFQUNqQixTQUFTO0FBQUEsSUFDTCxpQkFBaUI7QUFBQSxJQUNqQixRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsRUFDYjtBQUNKLENBQUM7QUFFWSxNQUFBLFFBQVEsT0FBTy9JLE9BQWM7QUFDL0IsU0FBQSxJQUFJLFFBQVEsQ0FBQzBHLGFBQVk7QUFDNUIsZUFBVyxNQUFNQSxTQUFRLElBQUksR0FBRzFHLEVBQUM7QUFBQSxFQUFBLENBQ3BDO0FBQ0w7QUFFTyxNQUFNLFFBQVEsSUFBSSxNQUFNLG1CQUFtQixNQUFNLEdBQUcsQ0FBQztBQUVyRCxNQUFNLGVBQWUsTUFBTSxPQUFPLFNBQVMsT0FBTztBQW9CNUMsTUFBQSxVQUFVLE9BQ2xCLENBQUMsR0FBRyxFQUFFLFNBQWEsSUFBQSxPQUFPLE9BQU8sT0FBTyxPQUFPO0FBQUEsRUFBUTtBQUFBLEVBQVUsQ0FBQyxPQUM5RCxTQUFTLEdBQUcsRUFBRSxJQUFLLE9BQU8sT0FBTyxnQkFBZ0IsSUFBSSxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSyxNQUFPLFNBQVMsR0FBRyxFQUFFLElBQUksR0FBTSxTQUFTLEVBQUU7QUFDMUg7QUFNSixlQUFzQixTQUFTLEdBQVc7QUFDbEMsTUFBQTtBQUNBLFVBQU0sTUFBTSxNQUFNLFdBQVcsZUFBaUIsRUFBQSxRQUFRLFFBQVEsQ0FBQztBQUMvRCxXQUFPLFFBQVE7QUFBQSxFQUFBLFFBQ2pCO0FBQ1MsV0FBQTtBQUFBLEVBQ1g7QUFDSjtBQUtPLElBQUEsVUFBQSxNQUFNZ0osT0FBTTtBQUFBLEVBQ2YsWUFBb0IsU0FBaUI7QUFBakIsU0FBQSxVQUFBO0FBQUEsRUFBa0I7QUFDMUM7QUFDTyxNQUFNLFFBQVE7QUFBQSxFQUNqQixZQUFvQixTQUFpQjtBQUFqQixTQUFBLFVBQUE7QUFBQSxFQUFrQjtBQUMxQztBQUVPLE1BQU0sa0JBQWtCLENBQUMsU0FBaUIsWUFBcUIsSUFBSSxhQUFhLEVBQUUsTUFBTSxRQUFRLFNBQVMsU0FBUyxFQUFFLEtBQUs7QUFDekgsTUFBTSxtQkFBbUIsQ0FBQyxTQUFpQixZQUFxQixJQUFJLGFBQWEsRUFBRSxNQUFNLFNBQVMsU0FBUyxTQUFTLEVBQUUsS0FBSztBQUUzSCxNQUFNLFlBQVksQ0FBQ3JKLFVBQWlCLFFBQVEsVUFBVUEsS0FBSTtBQUVqRSxNQUFNLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUNKO0FBRWEsTUFBQSxJQUFJLENBQUMsTUFBc0I7QUFDcEMsU0FBTyxNQUFNLE9BQU8sT0FBTyxPQUFPLElBQUksRUFBRSxDQUFDLEtBQUs7QUFDbEQ7QUM1Rk8sSUFBSSxZQUFZO0FBQ2hCLElBQUksV0FBVztBQUNmLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksZUFBZTtBQUNuQixJQUFJLGFBQWE7QUFDakIsSUFBSSxtQkFBbUI7QUFDdkIsSUFBSSxTQUFTO0FBQ2IsSUFBSSxjQUFjO0FBQ2xCLElBQUksY0FBYztBQUNsQixJQUFJLHFCQUFxQjtBQUN6QixJQUFJLGlCQUFpQjtBQUNyQixJQUFJLGNBQWM7QUFDekIsU0FBUyxzQkFBc0I7QUFDM0IsU0FBTztBQUFBLElBQ0g7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ1I7QUFDQTtBQUNPLElBQUksc0JBQXNCLG9CQUFxQjtBQ3RCdEQsSUFBSSxtQkFBbUI7QUFBQSxFQUNuQixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQ2Y7QUFDQSxJQUFJLGtCQUFrQjtBQUFBLEVBQ2xCLGVBQWU7QUFBQSxFQUNmLGFBQWE7QUFBQSxFQUNiLGNBQWM7QUFBQSxFQUNkLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFDZDtBQUNBLElBQUksaUJBQWlCO0FBQUEsRUFDakIsZUFBZTtBQUFBLEVBQ2YscUJBQXFCO0FBQUEsRUFDckIsVUFBVTtBQUNkO0FDbkJBLElBQUksWUFBWTtBQUNoQixTQUFTLEtBQUs7QUFDVixTQUFPO0FBQ1g7QUNEQSxJQUFJLFVBQVcsV0FBWTtBQUN2QixXQUFTc0osU0FBUSxtQkFBbUIsT0FBTztBQUN2QyxTQUFLLEtBQUs7QUFDVixTQUFLLFlBQVk7QUFDakIsU0FBSyxvQkFBb0I7QUFDekIsU0FBSyxRQUFRO0FBQ2IsU0FBSyxPQUFPLGdCQUFnQjtBQUM1QixTQUFLLGFBQWEsU0FBVTFKLFVBQVM7QUFBRSxhQUFPO0FBQUEsSUFBSztBQUNuRCxTQUFLLHFCQUFxQjtBQUMxQixTQUFLLFFBQVE7QUFDYixTQUFLLFVBQVU7QUFDZixTQUFLLFdBQVc7QUFDaEIsU0FBSyxlQUFlO0FBQ3BCLFNBQUssaUJBQWlCO0FBQ3RCLFNBQUssZUFBZTtBQUFBLEVBQ3ZCO0FBQ0QsRUFBQTBKLFNBQVEsVUFBVSxRQUFRLFdBQVk7QUFDbEMsUUFBSSxRQUFRLElBQUlBLFNBQVEsS0FBSyxtQkFBbUIsS0FBSyxLQUFLO0FBQzFELFVBQU0sWUFBYSxNQUFNLFVBQVUsaUJBQWlCLFlBQWEsS0FBSyxZQUFZO0FBQ2xGLFVBQU0scUJBQXFCLEtBQUs7QUFDaEMsVUFBTSxlQUFlLEtBQUs7QUFDMUIsVUFBTSxRQUFRLEtBQUs7QUFDbkIsVUFBTSxPQUFPLEtBQUs7QUFDbEIsVUFBTSxVQUFVLEtBQUs7QUFDckIsVUFBTSxXQUFXLEtBQUs7QUFDdEIsVUFBTSxhQUFhLEtBQUs7QUFDeEIsVUFBTSxlQUFlLEtBQUs7QUFDMUIsVUFBTSxpQkFBaUIsS0FBSztBQUM1QixVQUFNLFFBQVEsS0FBSztBQUNuQixXQUFPO0FBQUEsRUFDZjtBQUNJLFNBQU9BO0FBQ1g7QUNsQ08sSUFBSSxrQ0FBa0M7QUFDdEMsSUFBSSxzQkFBc0I7QUFDMUIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxpQkFBaUI7QUFDckIsSUFBSSxnQ0FBZ0M7QUFDcEMsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSw4QkFBOEIsU0FBVXRKLE9BQU07QUFDckQsU0FBTyxrRUFBa0VBLFFBQU87QUFHcEY7QUFDTyxJQUFJLHNCQUFzQjtBQUUxQixJQUFJLHVCQUF1QjtBQUMzQixJQUFJLDhCQUE4QjtBQUNsQyxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLDJCQUEyQjtBQUMvQixJQUFJLGVBQWUsU0FBVSxLQUFLO0FBQUUsU0FBTyxzQ0FBc0MsTUFBTTs7QUFDdkYsSUFBSSx3QkFBd0I7QUFFNUIsSUFBSSw4QkFBOEI7QUFFbEMsSUFBSSw0QkFBNEIsV0FBWTtBQUMvQyxNQUFJLFNBQVMsQ0FBQTtBQUNiLFdBQVMsS0FBSyxHQUFHLEtBQUssVUFBVSxRQUFRLE1BQU07QUFDMUMsV0FBTyxFQUFFLElBQUksVUFBVSxFQUFFO0FBQUEsRUFDNUI7QUFDRCxTQUFPLCtEQUNGLE9BQU8sQ0FBQyxJQUFJO0FBQ3JCO0FBQ08sSUFBSSxzQ0FBc0M7QUFFMUMsSUFBSSwwQ0FBMEM7QUFFOUMsSUFBSSxpREFBaUQ7QUFFckQsSUFBSSw0Q0FBNEM7QUFJaEQsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSSx1QkFBdUIsU0FBVSxPQUFPLGNBQWM7QUFBRSxTQUFPLG1DQUFtQyxRQUFRLE9BQU87O0FBQ3JILElBQUksb0JBQW9CLFNBQVUsT0FBTyxjQUFjO0FBQUUsU0FBTyxnQ0FBZ0MsUUFBUSxPQUFPOztBQUMvRyxJQUFJLHdCQUF3QixTQUFVLE9BQU8sY0FBYztBQUFFLFNBQU8scUNBQXFDLFFBQVEsT0FBTzs7QUFDeEgsSUFBSSxpQ0FBaUMsU0FBVSxhQUFhLG1CQUFtQjtBQUNsRixTQUFPLGlFQUFpRSxjQUFjLGtEQUNqRix5QkFBeUIsb0JBQW9CO0FBQ3REO0FBQ08sSUFBSSxpQkFBaUI7QUNsRDVCLElBQUksaUJBQWtCLFdBQVk7QUFDOUIsV0FBU3VKLGtCQUFpQjtBQUFBLEVBQ3pCO0FBQ0QsRUFBQUEsZ0JBQWUsVUFBVSx5QkFBeUIsU0FBVSxpQkFBaUI7QUFDekUsUUFBSSw0QkFBNEIsUUFBUSxZQUFZQyxhQUEwQixlQUFlO0FBQzdGLFFBQUksd0JBQXdCLFFBQVEsWUFBWUMsUUFBcUIsZUFBZTtBQUNwRixXQUFPO0FBQUEsTUFDSDtBQUFBLE1BQ0EsdUJBQXVCLHlCQUF5QixDQUFFO0FBQUEsSUFDOUQ7QUFBQSxFQUNBO0FBQ0ksRUFBQUYsZ0JBQWUsVUFBVSx3QkFBd0IsU0FBVSxpQkFBaUI7QUFDeEUsUUFBSSx3QkFBd0IsUUFBUSxZQUFZRyxhQUEwQixlQUFlLEtBQUs7QUFDOUYsV0FBTztBQUFBLEVBQ2Y7QUFDSSxTQUFPSDtBQUNYO0FDakJBLElBQUksZUFBZTtBQUFBLEVBQ2YsMkJBQTJCO0FBQUEsRUFDM0IscUJBQXFCO0FBQUEsRUFDckIseUJBQXlCO0FBQzdCO0FDSE8sU0FBUyx3QkFBd0JuSyxRQUFPO0FBQzNDLFNBQVFBLGtCQUFpQixjQUNyQkEsT0FBTSxZQUFZdUs7QUFDMUI7QUFDTyxJQUFJLGtDQUFrQyxTQUFVLElBQUksZUFBZTtBQUN0RSxNQUFJO0FBQ0EsV0FBTyxHQUFFO0FBQUEsRUFDWixTQUNNdkssUUFBUDtBQUNJLFFBQUksd0JBQXdCQSxNQUFLLEdBQUc7QUFDaEMsTUFBQUEsU0FBUSxjQUFhO0FBQUEsSUFDeEI7QUFDRCxVQUFNQTtBQUFBLEVBQ1Q7QUFDTDtBQ2RBLFNBQVMsNkJBQTZCLG1CQUFtQjtBQUNyRCxNQUFJLE9BQU8sc0JBQXNCLFlBQVk7QUFDekMsUUFBSSxxQkFBcUI7QUFDekIsV0FBTyxtQkFBbUI7QUFBQSxFQUM3QixXQUNRLE9BQU8sc0JBQXNCLFVBQVU7QUFDNUMsV0FBTyxrQkFBa0I7RUFDNUIsT0FDSTtBQUNELFFBQUkscUJBQXFCO0FBQ3pCLFdBQU87QUFBQSxFQUNWO0FBQ0w7QUFDQSxTQUFTLDJDQUEyQ3dLLFlBQVcsbUJBQW1CQyxjQUFhO0FBQzNGLE1BQUkseUJBQXlCO0FBQzdCLE1BQUkscUJBQXFCQSxhQUFZRCxZQUFXLGlCQUFpQjtBQUNqRSxNQUFJLG1CQUFtQixXQUFXLEdBQUc7QUFDakMsNkJBQXlCO0FBQ3pCLHVCQUFtQixRQUFRLFNBQVUsU0FBUztBQUMxQyxVQUFJNUosUUFBTztBQUNYLFVBQUksUUFBUSx1QkFBdUIsTUFBTTtBQUNyQyxRQUFBQSxRQUFPLGdCQUFnQixRQUFRLGtCQUFrQjtBQUFBLE1BQ3BEO0FBQ0QsK0JBQXlCLHlCQUF5QixRQUFRQTtBQUMxRCxVQUFJLFFBQVEsV0FBVyxVQUFVO0FBQzdCLGlDQUF5Qix5QkFBeUIsUUFBUSxRQUFRLFdBQVc7QUFBQSxNQUNoRjtBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ0o7QUFDRCxTQUFPO0FBQ1g7QUFDQSxTQUFTLHVCQUF1QkosVUFBUyxtQkFBbUI7QUFDeEQsTUFBSUEsU0FBUSxrQkFBa0IsTUFBTTtBQUNoQyxXQUFPO0FBQUEsRUFDVixXQUNRQSxTQUFRLGNBQWMsc0JBQXNCLG1CQUFtQjtBQUNwRSxXQUFPO0FBQUEsRUFDVixPQUNJO0FBQ0QsV0FBTyx1QkFBdUJBLFNBQVEsZUFBZSxpQkFBaUI7QUFBQSxFQUN6RTtBQUNMO0FBQ0EsU0FBUyx3QkFBd0JBLFVBQVM7QUFDdEMsV0FBUyxpQkFBaUIsS0FBSyxRQUFRO0FBQ25DLFFBQUksV0FBVyxRQUFRO0FBQUUsZUFBUyxDQUFFO0FBQUEsSUFBRztBQUN2QyxRQUFJLG9CQUFvQiw2QkFBNkIsSUFBSSxpQkFBaUI7QUFDMUUsV0FBTyxLQUFLLGlCQUFpQjtBQUM3QixRQUFJLElBQUksa0JBQWtCLE1BQU07QUFDNUIsYUFBTyxpQkFBaUIsSUFBSSxlQUFlLE1BQU07QUFBQSxJQUNwRDtBQUNELFdBQU87QUFBQSxFQUNWO0FBQ0QsTUFBSSxZQUFZLGlCQUFpQkEsUUFBTztBQUN4QyxTQUFPLFVBQVUsUUFBTyxFQUFHLEtBQUssT0FBTztBQUMzQztBQUNBLFNBQVMsOEJBQThCQSxVQUFTO0FBQzVDLEVBQUFBLFNBQVEsY0FBYyxRQUFRLFNBQVUsY0FBYztBQUNsRCxRQUFJLHVCQUF1QixjQUFjLGFBQWEsaUJBQWlCLEdBQUc7QUFDdEUsVUFBSSxXQUFXLHdCQUF3QixZQUFZO0FBQ25ELFlBQU0sSUFBSSxNQUFNa0ssc0JBQWlDLE1BQU0sUUFBUTtBQUFBLElBQ2xFLE9BQ0k7QUFDRCxvQ0FBOEIsWUFBWTtBQUFBLElBQzdDO0FBQUEsRUFDVCxDQUFLO0FBQ0w7QUFDQSxTQUFTLHNCQUFzQix5QkFBeUIsUUFBUTtBQUM1RCxNQUFJLE9BQU8sU0FBUSxLQUFNLE9BQU8sUUFBTyxHQUFJO0FBQ3ZDLFFBQUksTUFBTTtBQUNWLFFBQUksV0FBVyxPQUFPO0FBQ3RCLFFBQUksWUFBWSxPQUFPO0FBQ3ZCLFFBQUksYUFBYSxNQUFNO0FBQ25CLGFBQU8sU0FBUyxTQUFVLElBQUc7QUFBQSxJQUNoQztBQUNELFFBQUksY0FBYyxNQUFNO0FBQ3BCLGdCQUFVLFFBQVEsU0FBVSxLQUFLO0FBQzdCLGVBQU8sSUFBSSxTQUFVLElBQUc7QUFBQSxNQUN4QyxDQUFhO0FBQUEsSUFDSjtBQUNELFdBQU8sTUFBTSwwQkFBMEIsUUFBUSwwQkFBMEIsUUFBUTtBQUFBLEVBQ3BGLE9BQ0k7QUFDRCxXQUFPLE1BQU07QUFBQSxFQUNoQjtBQUNMO0FBQ0EsU0FBUyxnQkFBZ0IsTUFBTTtBQUMzQixNQUFJLEtBQUssTUFBTTtBQUNYLFdBQU8sS0FBSztBQUFBLEVBQ2YsT0FDSTtBQUNELFFBQUksU0FBUyxLQUFLO0FBQ2xCLFFBQUksUUFBUSxPQUFPLE1BQU0sdUJBQXVCO0FBQ2hELFdBQU8sUUFBUSxNQUFNLENBQUMsSUFBSSx5QkFBeUI7QUFBQSxFQUN0RDtBQUNMO0FBQ0EsU0FBUyxxQkFBcUIsUUFBUTtBQUNsQyxTQUFPLE9BQU8sU0FBVSxFQUFDLE1BQU0sR0FBRyxFQUFFO0FBQ3hDO0FDakdBLElBQUksVUFBVyxXQUFZO0FBQ3ZCLFdBQVNDLFNBQVFILFlBQVc7QUFDeEIsU0FBSyxLQUFLO0FBQ1YsU0FBSyxZQUFZQTtBQUFBLEVBQ3BCO0FBQ0QsRUFBQUcsU0FBUSxVQUFVLFVBQVUsU0FBVUMsT0FBTTtBQUN4QyxTQUFLLE9BQU9BO0FBQUEsRUFDcEI7QUFDSSxFQUFBRCxTQUFRLFVBQVUsb0JBQW9CLFNBQVUsZ0JBQWdCO0FBQzVELFNBQUssaUJBQWlCO0FBQUEsRUFDOUI7QUFDSSxTQUFPQTtBQUNYO0FDWkEsSUFBSSxXQUFZLFdBQVk7QUFDeEIsV0FBU25MLFVBQVMsS0FBSyxPQUFPO0FBQzFCLFNBQUssTUFBTTtBQUNYLFNBQUssUUFBUTtBQUFBLEVBQ2hCO0FBQ0QsRUFBQUEsVUFBUyxVQUFVLFdBQVcsV0FBWTtBQUN0QyxRQUFJLEtBQUssUUFBUXFMLFdBQXdCO0FBQ3JDLGFBQU8sWUFBWSxPQUFPLEtBQUssS0FBSyxFQUFFLFNBQVUsSUFBRztBQUFBLElBQ3RELE9BQ0k7QUFDRCxhQUFPLG1CQUFtQixLQUFLLElBQUksU0FBVSxJQUFHLGNBQWMsT0FBTyxLQUFLLEtBQUssSUFBSTtBQUFBLElBQ3RGO0FBQUEsRUFDVDtBQUNJLFNBQU9yTDtBQUNYO0FDZkEsSUFBSSxPQUFRLFdBQVk7QUFDcEIsV0FBU3NMLE1BQUssZUFBZSxhQUFhO0FBQ3RDLFNBQUssZ0JBQWdCO0FBQ3JCLFNBQUssY0FBYztBQUFBLEVBQ3RCO0FBQ0QsU0FBT0E7QUFDWDtBQ05BLElBQUksdUJBQXdCLFdBQVk7QUFDcEMsV0FBU0Msc0JBQXFCLElBQUk7QUFDOUIsU0FBSyxNQUFNO0FBQUEsRUFDZDtBQUNELEVBQUFBLHNCQUFxQixVQUFVLFNBQVMsV0FBWTtBQUNoRCxXQUFPLEtBQUs7RUFDcEI7QUFDSSxTQUFPQTtBQUNYO0FDUkEsSUFBSSxrQkFBbUIsV0FBWTtBQUMvQixXQUFTQyxpQkFBZ0IsS0FBSztBQUMxQixTQUFLLE1BQU07QUFBQSxFQUNkO0FBQ0QsRUFBQUEsaUJBQWdCLFVBQVUsYUFBYSxTQUFVLGNBQWM7QUFDM0QsV0FBTyxLQUFLLElBQUksUUFBUSxZQUFZLE1BQU07QUFBQSxFQUNsRDtBQUNJLEVBQUFBLGlCQUFnQixVQUFVLFdBQVcsU0FBVSxjQUFjO0FBQ3pELFFBQUksZ0JBQWdCO0FBQ3BCLFFBQUksc0JBQXNCLGFBQWEsTUFBTSxFQUFFLEVBQUUsUUFBUyxFQUFDLEtBQUssRUFBRTtBQUNsRSxvQkFBZ0IsS0FBSyxJQUFJLE1BQU0sRUFBRSxFQUFFLFFBQVMsRUFBQyxLQUFLLEVBQUU7QUFDcEQsV0FBTyxLQUFLLFdBQVcsS0FBSyxFQUFFLEtBQUssY0FBYSxHQUFJLG1CQUFtQjtBQUFBLEVBQy9FO0FBQ0ksRUFBQUEsaUJBQWdCLFVBQVUsV0FBVyxTQUFVLGNBQWM7QUFDekQsV0FBUSxLQUFLLElBQUksUUFBUSxZQUFZLE1BQU07QUFBQSxFQUNuRDtBQUNJLEVBQUFBLGlCQUFnQixVQUFVLFNBQVMsU0FBVSxlQUFlO0FBQ3hELFdBQU8sS0FBSyxRQUFRO0FBQUEsRUFDNUI7QUFDSSxFQUFBQSxpQkFBZ0IsVUFBVSxRQUFRLFdBQVk7QUFDMUMsV0FBTyxLQUFLO0FBQUEsRUFDcEI7QUFDSSxTQUFPQTtBQUNYO0FDbEJBLElBQUksU0FBVSxXQUFZO0FBQ3RCLFdBQVNDLFFBQU8sTUFBTSxZQUFZLG1CQUFtQixlQUFlO0FBQ2hFLFNBQUssS0FBSztBQUNWLFNBQUssT0FBTztBQUNaLFNBQUssb0JBQW9CO0FBQ3pCLFFBQUksZ0JBQWdCLE9BQU8sZUFBZSxXQUFXLHFCQUFxQixVQUFVLElBQUk7QUFDeEYsU0FBSyxPQUFPLElBQUksZ0JBQWdCLGlCQUFpQixFQUFFO0FBQ25ELFNBQUssYUFBYTtBQUNsQixTQUFLLFdBQVcsSUFBSTtBQUNwQixRQUFJLGVBQWU7QUFDbkIsUUFBSSxPQUFPLGtCQUFrQixVQUFVO0FBQ25DLHFCQUFlLElBQUksU0FBU0osV0FBd0IsYUFBYTtBQUFBLElBQ3BFLFdBQ1EseUJBQXlCLFVBQVU7QUFDeEMscUJBQWU7QUFBQSxJQUNsQjtBQUNELFFBQUksaUJBQWlCLE1BQU07QUFDdkIsV0FBSyxTQUFTLEtBQUssWUFBWTtBQUFBLElBQ2xDO0FBQUEsRUFDSjtBQUNELEVBQUFJLFFBQU8sVUFBVSxTQUFTLFNBQVUsS0FBSztBQUNyQyxhQUFTLEtBQUssR0FBR3RMLE1BQUssS0FBSyxVQUFVLEtBQUtBLElBQUcsUUFBUSxNQUFNO0FBQ3ZELFVBQUksSUFBSUEsSUFBRyxFQUFFO0FBQ2IsVUFBSSxFQUFFLFFBQVEsS0FBSztBQUNmLGVBQU87QUFBQSxNQUNWO0FBQUEsSUFDSjtBQUNELFdBQU87QUFBQSxFQUNmO0FBQ0ksRUFBQXNMLFFBQU8sVUFBVSxVQUFVLFdBQVk7QUFDbkMsV0FBTyxLQUFLLE9BQU9DLGdCQUE2QjtBQUFBLEVBQ3hEO0FBQ0ksRUFBQUQsUUFBTyxVQUFVLGVBQWUsU0FBVXJLLE9BQU07QUFDNUMsV0FBTyxLQUFLLFdBQVdzSyxnQkFBNkIsRUFBRXRLLEtBQUk7QUFBQSxFQUNsRTtBQUNJLEVBQUFxSyxRQUFPLFVBQVUsVUFBVSxXQUFZO0FBQ25DLFdBQU8sS0FBSyxPQUFPSixTQUFzQjtBQUFBLEVBQ2pEO0FBQ0ksRUFBQUksUUFBTyxVQUFVLFdBQVcsV0FBWTtBQUNwQyxXQUFPLEtBQUssU0FBUyxLQUFLLFNBQVUsVUFBVTtBQUFFLGFBQU9FLG9CQUFpQyxNQUFNLFNBQVUsS0FBSztBQUFFLGVBQU8sU0FBUyxRQUFRO0FBQUEsTUFBTSxDQUFBO0FBQUEsSUFBRSxDQUFFO0FBQUEsRUFDeko7QUFDSSxFQUFBRixRQUFPLFVBQVUsYUFBYSxXQUFZO0FBQ3RDLFdBQU8sS0FBSyxXQUFXRyxZQUF5QixFQUFFLElBQUk7QUFBQSxFQUM5RDtBQUNJLEVBQUFILFFBQU8sVUFBVSxjQUFjLFdBQVk7QUFDdkMsUUFBSSxLQUFLLFdBQVc7QUFDaEIsYUFBTyxLQUFLLFNBQVMsT0FBTyxTQUFVLEdBQUc7QUFBRSxlQUFPLEVBQUUsUUFBUUo7QUFBQUEsT0FBeUIsRUFBRSxDQUFDO0FBQUEsSUFDM0Y7QUFDRCxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFJLFFBQU8sVUFBVSxnQkFBZ0IsV0FBWTtBQUN6QyxRQUFJLEtBQUssWUFBWTtBQUNqQixhQUFPLEtBQUssU0FBUyxPQUFPLFNBQVUsVUFBVTtBQUFFLGVBQU9FLG9CQUFpQyxNQUFNLFNBQVUsS0FBSztBQUFFLGlCQUFPLFNBQVMsUUFBUTtBQUFBLFFBQU0sQ0FBQTtBQUFBLE1BQUUsQ0FBRTtBQUFBLElBQ3RKLE9BQ0k7QUFDRCxhQUFPO0FBQUEsSUFDVjtBQUFBLEVBQ1Q7QUFDSSxFQUFBRixRQUFPLFVBQVUsa0JBQWtCLFNBQVVySyxPQUFNO0FBQy9DLFdBQU8sS0FBSyxXQUFXaUssU0FBc0IsRUFBRWpLLEtBQUk7QUFBQSxFQUMzRDtBQUNJLEVBQUFxSyxRQUFPLFVBQVUsYUFBYSxTQUFVLEtBQUs7QUFDekMsUUFBSSxRQUFRO0FBQ1osV0FBTyxTQUFVLE9BQU87QUFDcEIsZUFBUyxLQUFLLEdBQUd0TCxNQUFLLE1BQU0sVUFBVSxLQUFLQSxJQUFHLFFBQVEsTUFBTTtBQUN4RCxZQUFJLElBQUlBLElBQUcsRUFBRTtBQUNiLFlBQUksRUFBRSxRQUFRLE9BQU8sRUFBRSxVQUFVLE9BQU87QUFDcEMsaUJBQU87QUFBQSxRQUNWO0FBQUEsTUFDSjtBQUNELGFBQU87QUFBQSxJQUNuQjtBQUFBLEVBQ0E7QUFDSSxTQUFPc0w7QUFDWDtBQy9FQSxJQUFJSSxrQkFBaUJDLGNBQVFBLFdBQUssaUJBQWtCLFNBQVUsSUFBSSxNQUFNLE1BQU07QUFDMUUsTUFBSSxRQUFRLFVBQVUsV0FBVztBQUFHLGFBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLElBQUksSUFBSSxHQUFHLEtBQUs7QUFDakYsVUFBSSxNQUFNLEVBQUUsS0FBSyxPQUFPO0FBQ3BCLFlBQUksQ0FBQztBQUFJLGVBQUssTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLEdBQUcsQ0FBQztBQUNuRCxXQUFHLENBQUMsSUFBSSxLQUFLLENBQUM7QUFBQSxNQUNqQjtBQUFBLElBQ0o7QUFDRCxTQUFPLEdBQUcsT0FBTyxNQUFNLE1BQU0sVUFBVSxNQUFNLEtBQUssSUFBSSxDQUFDO0FBQzNEO0FBT0EsU0FBUyxnQkFBZ0IsZ0JBQWdCLE1BQU07QUFDM0MsTUFBSSxrQkFBa0IsZ0JBQWdCLElBQUk7QUFDMUMsU0FBTyxXQUFXLGdCQUFnQixpQkFBaUIsTUFBTSxLQUFLO0FBQ2xFO0FBQ0EsU0FBUyxXQUFXLGdCQUFnQixpQkFBaUIsTUFBTSxhQUFhO0FBQ3BFLE1BQUksV0FBVyxlQUFlLHVCQUF1QixJQUFJO0FBQ3pELE1BQUkscUJBQXFCLFNBQVM7QUFDbEMsTUFBSSx1QkFBdUIsUUFBVztBQUNsQyxRQUFJLE1BQU1DLGdDQUEyQyxNQUFNLGtCQUFrQjtBQUM3RSxVQUFNLElBQUksTUFBTSxHQUFHO0FBQUEsRUFDdEI7QUFDRCxNQUFJLDBCQUEwQixTQUFTO0FBQ3ZDLE1BQUksT0FBTyxPQUFPLEtBQUssdUJBQXVCO0FBQzlDLE1BQUksbUNBQW9DLEtBQUssV0FBVyxLQUFLLEtBQUssU0FBUztBQUMzRSxNQUFJLHdCQUF3QixLQUFLLFNBQVMsS0FBSztBQUMvQyxNQUFJLGFBQWMsb0NBQW9DLHdCQUF5QixLQUFLLFNBQVMsS0FBSztBQUNsRyxNQUFJLHFCQUFxQiw0QkFBNEIsYUFBYSxpQkFBaUIsb0JBQW9CLHlCQUF5QixVQUFVO0FBQzFJLE1BQUksa0JBQWtCLHVCQUF1QixnQkFBZ0IsTUFBTSxlQUFlO0FBQ2xGLE1BQUksVUFBVUYsZ0JBQWNBLGdCQUFjLENBQUUsR0FBRSxvQkFBb0IsSUFBSSxHQUFHLGlCQUFpQixJQUFJO0FBQzlGLFNBQU87QUFDWDtBQUNBLFNBQVMsMkJBQTJCLE9BQU8sYUFBYSxpQkFBaUIsb0JBQW9CLHlCQUF5QjtBQUNsSCxNQUFJLGlCQUFpQix3QkFBd0IsTUFBTSxTQUFVLENBQUEsS0FBSyxDQUFBO0FBQ2xFLE1BQUksV0FBVyxxQkFBcUIsY0FBYztBQUNsRCxNQUFJLFlBQVksU0FBUyxjQUFjO0FBQ3ZDLE1BQUksb0JBQW9CLG1CQUFtQixLQUFLO0FBQ2hELE1BQUksbUJBQW9CLFNBQVMsVUFBVSxTQUFTO0FBQ3BELHNCQUFxQixtQkFBcUIsbUJBQW9CO0FBQzlELE1BQUksNkJBQTZCLHNCQUFzQjtBQUNuRCx3QkFBb0Isa0JBQWtCO0VBQ3pDO0FBQ0QsTUFBSSxXQUFXO0FBQ1gsUUFBSUcsWUFBVyxzQkFBc0I7QUFDckMsUUFBSUMsY0FBYSxzQkFBc0I7QUFDdkMsUUFBSUMsZUFBYyxzQkFBc0I7QUFDeEMsUUFBSSxnQkFBaUJGLGFBQVlDLGVBQWNDO0FBQy9DLFFBQUksQ0FBQyxlQUFlLGVBQWU7QUFDL0IsVUFBSSxNQUFNQyw0QkFBdUMsZUFBZSxRQUFRLGVBQWUsa0JBQWtCO0FBQ3pHLFlBQU0sSUFBSSxNQUFNLEdBQUc7QUFBQSxJQUN0QjtBQUNELFFBQUksU0FBUyxJQUFJLE9BQU8sZUFBZSxxQkFBcUIsU0FBUyxZQUFZLGlCQUFpQjtBQUNsRyxXQUFPLFdBQVc7QUFDbEIsV0FBTztBQUFBLEVBQ1Y7QUFDRCxTQUFPO0FBQ1g7QUFDQSxTQUFTLDRCQUE0QixhQUFhLGlCQUFpQixvQkFBb0IseUJBQXlCLFlBQVk7QUFDeEgsTUFBSSxVQUFVLENBQUE7QUFDZCxXQUFTLElBQUksR0FBRyxJQUFJLFlBQVksS0FBSztBQUNqQyxRQUFJLFFBQVE7QUFDWixRQUFJLFNBQVMsMkJBQTJCLE9BQU8sYUFBYSxpQkFBaUIsb0JBQW9CLHVCQUF1QjtBQUN4SCxRQUFJLFdBQVcsTUFBTTtBQUNqQixjQUFRLEtBQUssTUFBTTtBQUFBLElBQ3RCO0FBQUEsRUFDSjtBQUNELFNBQU87QUFDWDtBQUNBLFNBQVMsaUNBQWlDQyxTQUFRLGFBQWEsY0FBYyxXQUFXO0FBQ3BGLE1BQUksb0JBQXFCQSxXQUFVO0FBQ25DLE1BQUksc0JBQXNCLFFBQVc7QUFDakMsUUFBSSxNQUFNTCxnQ0FBMkMsbUJBQW1CLE9BQU8sWUFBWSxJQUFJLGVBQWUsWUFBWTtBQUMxSCxVQUFNLElBQUksTUFBTSxHQUFHO0FBQUEsRUFDdEI7QUFDRCxTQUFPO0FBQ1g7QUFDQSxTQUFTLHVCQUF1QixnQkFBZ0IsaUJBQWlCLGlCQUFpQjtBQUM5RSxNQUFJLHFCQUFxQixlQUFlLHNCQUFzQixlQUFlO0FBQzdFLE1BQUksVUFBVSxDQUFBO0FBQ2QsTUFBSSxhQUFhLE9BQU8sc0JBQXNCLGtCQUFrQjtBQUNoRSxNQUFJLGFBQWEsT0FBTyxLQUFLLGtCQUFrQjtBQUMvQyxNQUFJLE9BQU8sV0FBVyxPQUFPLFVBQVU7QUFDdkMsV0FBUyxLQUFLLEdBQUcsU0FBUyxNQUFNLEtBQUssT0FBTyxRQUFRLE1BQU07QUFDdEQsUUFBSSxNQUFNLE9BQU8sRUFBRTtBQUNuQixRQUFJLGlCQUFpQixtQkFBbUIsR0FBRztBQUMzQyxRQUFJLFdBQVcscUJBQXFCLGNBQWM7QUFDbEQsUUFBSSxhQUFhLFNBQVMsY0FBYztBQUN4QyxRQUFJLG9CQUFvQixpQ0FBaUMsU0FBUyxRQUFRLFNBQVMsYUFBYSxLQUFLLGVBQWU7QUFDcEgsUUFBSSxTQUFTLElBQUksT0FBTyxlQUFlLGVBQWUsWUFBWSxpQkFBaUI7QUFDbkYsV0FBTyxXQUFXO0FBQ2xCLFlBQVEsS0FBSyxNQUFNO0FBQUEsRUFDdEI7QUFDRCxNQUFJLGtCQUFrQixPQUFPLGVBQWUsZ0JBQWdCLFNBQVMsRUFBRTtBQUN2RSxNQUFJLG9CQUFvQixRQUFRO0FBQzVCLFFBQUksY0FBYyx1QkFBdUIsZ0JBQWdCLGlCQUFpQixlQUFlO0FBQ3pGLGNBQVVGLGdCQUFjQSxnQkFBYyxDQUFFLEdBQUUsU0FBUyxJQUFJLEdBQUcsYUFBYSxJQUFJO0FBQUEsRUFDOUU7QUFDRCxTQUFPO0FBQ1g7QUFDQSxTQUFTLDRCQUE0QixnQkFBZ0IsTUFBTTtBQUN2RCxNQUFJLGtCQUFrQixPQUFPLGVBQWUsS0FBSyxTQUFTLEVBQUU7QUFDNUQsTUFBSSxvQkFBb0IsUUFBUTtBQUM1QixRQUFJLHNCQUFzQixnQkFBZ0IsZUFBZTtBQUN6RCxRQUFJLFVBQVUsV0FBVyxnQkFBZ0IscUJBQXFCLGlCQUFpQixJQUFJO0FBQ25GLFFBQUksV0FBVyxRQUFRLElBQUksU0FBVXBLLElBQUc7QUFBRSxhQUFPQSxHQUFFLFNBQVMsT0FBTyxTQUFVLEdBQUc7QUFBRSxlQUFPLEVBQUUsUUFBUTRLO0FBQUFBLE1BQTZCLENBQUE7QUFBQSxJQUFFLENBQUU7QUFDcEksUUFBSSxpQkFBaUIsQ0FBQSxFQUFHLE9BQU8sTUFBTSxJQUFJLFFBQVEsRUFBRTtBQUNuRCxRQUFJLGtCQUFrQixRQUFRLFNBQVM7QUFDdkMsUUFBSSxrQkFBa0IsR0FBRztBQUNyQixhQUFPO0FBQUEsSUFDVixPQUNJO0FBQ0QsYUFBTyw0QkFBNEIsZ0JBQWdCLGVBQWU7QUFBQSxJQUNyRTtBQUFBLEVBQ0osT0FDSTtBQUNELFdBQU87QUFBQSxFQUNWO0FBQ0w7QUFDQSxTQUFTLHFCQUFxQixnQkFBZ0I7QUFDMUMsTUFBSSxvQkFBb0IsQ0FBQTtBQUN4QixpQkFBZSxRQUFRLFNBQVUsR0FBRztBQUNoQyxzQkFBa0IsRUFBRSxJQUFJLFNBQVEsQ0FBRSxJQUFJLEVBQUU7QUFBQSxFQUNoRCxDQUFLO0FBQ0QsU0FBTztBQUFBLElBQ0gsUUFBUSxrQkFBa0JDLFVBQXVCO0FBQUEsSUFDakQsYUFBYSxrQkFBa0JaLGdCQUE2QjtBQUFBLElBQzVELFlBQVksa0JBQWtCYSxRQUFxQjtBQUFBLElBQ25ELFdBQVcsa0JBQWtCRixhQUEwQjtBQUFBLEVBQy9EO0FBQ0E7QUNwSUEsSUFBSSxVQUFXLFdBQVk7QUFDdkIsV0FBU0csU0FBUSxtQkFBbUIsZUFBZSxlQUFlLFVBQVUsUUFBUTtBQUNoRixTQUFLLEtBQUs7QUFDVixTQUFLLG9CQUFvQjtBQUN6QixTQUFLLGdCQUFnQjtBQUNyQixTQUFLLGdCQUFnQjtBQUNyQixTQUFLLFNBQVM7QUFDZCxTQUFLLGdCQUFnQjtBQUNyQixTQUFLLFdBQVksTUFBTSxRQUFRLFFBQVEsSUFBSSxXQUFXLENBQUMsUUFBUTtBQUMvRCxTQUFLLGVBQWUsa0JBQWtCLE9BQ2hDLG9CQUFJLElBQUssSUFDVDtBQUFBLEVBQ1Q7QUFDRCxFQUFBQSxTQUFRLFVBQVUsa0JBQWtCLFNBQVUsbUJBQW1CLFVBQVUsUUFBUTtBQUMvRSxRQUFJLFFBQVEsSUFBSUEsU0FBUSxtQkFBbUIsS0FBSyxlQUFlLE1BQU0sVUFBVSxNQUFNO0FBQ3JGLFNBQUssY0FBYyxLQUFLLEtBQUs7QUFDN0IsV0FBTztBQUFBLEVBQ2Y7QUFDSSxTQUFPQTtBQUNYO0FDUkEsU0FBUyxxQkFBcUIsT0FBTztBQUNqQyxTQUFPLE1BQU07QUFDakI7QUFDQSxTQUFTLGNBQWMsZUFBZSxZQUFZLG1CQUFtQnBMLE9BQU0sS0FBSyxPQUFPO0FBQ25GLE1BQUksY0FBYyxnQkFBZ0JzSyxtQkFBZ0NZO0FBQ2xFLE1BQUksaUJBQWlCLElBQUksU0FBUyxhQUFhLGlCQUFpQjtBQUNoRSxNQUFJLFNBQVMsSUFBSSxPQUFPLFlBQVlsTCxPQUFNLG1CQUFtQixjQUFjO0FBQzNFLE1BQUksUUFBUSxRQUFXO0FBQ25CLFFBQUksY0FBYyxJQUFJLFNBQVMsS0FBSyxLQUFLO0FBQ3pDLFdBQU8sU0FBUyxLQUFLLFdBQVc7QUFBQSxFQUNuQztBQUNELFNBQU87QUFDWDtBQUNBLFNBQVMsbUJBQW1CLGdCQUFnQixrQkFBa0IsU0FBUyxlQUFlLFFBQVE7QUFDMUYsTUFBSSxXQUFXLFlBQVksUUFBUSxXQUFXLE9BQU8saUJBQWlCO0FBQ3RFLE1BQUksaUJBQWlCLENBQUE7QUFDckIsTUFBSSxTQUFTLFdBQVcsYUFBYSx1QkFDakMsUUFBUSxVQUFVLFFBQVEsc0JBQzFCLE9BQU8sT0FBTyxzQkFBc0IsY0FDcEMsZUFBZSx1QkFBdUIsT0FBTyxpQkFBaUIsRUFBRSwyQkFBMkI7QUFDM0YsWUFBUSxVQUFVLEtBQUssT0FBTyxpQkFBaUIsRUFBRTtBQUNqRCxlQUFXLFlBQVksUUFBUSxXQUFXLE9BQU8saUJBQWlCO0FBQUEsRUFDckU7QUFDRCxNQUFJLENBQUMsa0JBQWtCO0FBQ25CLHFCQUFpQixTQUFTLE9BQU8sU0FBVSxTQUFTO0FBQ2hELFVBQUlKLFdBQVUsSUFBSSxRQUFRLFFBQVEsbUJBQW1CLFNBQVMsZUFBZSxTQUFTLE1BQU07QUFDNUYsYUFBTyxRQUFRLFdBQVdBLFFBQU87QUFBQSxJQUM3QyxDQUFTO0FBQUEsRUFDSixPQUNJO0FBQ0QscUJBQWlCO0FBQUEsRUFDcEI7QUFDRCw4QkFBNEIsT0FBTyxtQkFBbUIsZ0JBQWdCLFFBQVEsUUFBUSxTQUFTO0FBQy9GLFNBQU87QUFDWDtBQUNBLFNBQVMsNEJBQTRCLG1CQUFtQixVQUFVLFFBQVFnSyxZQUFXO0FBQ2pGLFVBQVEsU0FBUyxRQUFNO0FBQUEsSUFDbkIsS0FBSyxhQUFhO0FBQ2QsVUFBSSxPQUFPLGNBQWM7QUFDckIsZUFBTztBQUFBLE1BQ1YsT0FDSTtBQUNELFlBQUksMEJBQTBCLDZCQUE2QixpQkFBaUI7QUFDNUUsWUFBSSxNQUFNeUI7QUFDVixlQUFPLHNCQUFzQix5QkFBeUIsTUFBTTtBQUM1RCxlQUFPLDJDQUEyQ3pCLFlBQVcseUJBQXlCLFdBQVc7QUFDakcsY0FBTSxJQUFJLE1BQU0sR0FBRztBQUFBLE1BQ3RCO0FBQUEsSUFDTCxLQUFLLGFBQWE7QUFDZCxhQUFPO0FBQUEsSUFDWCxLQUFLLGFBQWE7QUFBQSxJQUNsQjtBQUNJLFVBQUksQ0FBQyxPQUFPLFdBQVc7QUFDbkIsWUFBSSwwQkFBMEIsNkJBQTZCLGlCQUFpQjtBQUM1RSxZQUFJLE1BQU0wQixrQkFBNkIsTUFBTTtBQUM3QyxlQUFPLDJDQUEyQzFCLFlBQVcseUJBQXlCLFdBQVc7QUFDakcsY0FBTSxJQUFJLE1BQU0sR0FBRztBQUFBLE1BQ3RCLE9BQ0k7QUFDRCxlQUFPO0FBQUEsTUFDVjtBQUFBLEVBQ1I7QUFDTDtBQUNBLFNBQVMsbUJBQW1CLGdCQUFnQixrQkFBa0IsbUJBQW1CLFNBQVMsZUFBZSxRQUFRO0FBQzdHLE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSSxrQkFBa0IsTUFBTTtBQUN4QixxQkFBaUIsbUJBQW1CLGdCQUFnQixrQkFBa0IsU0FBUyxNQUFNLE1BQU07QUFDM0YsbUJBQWUsSUFBSSxRQUFRLG1CQUFtQixTQUFTLE1BQU0sZ0JBQWdCLE1BQU07QUFDbkYsUUFBSSxVQUFVLElBQUksS0FBSyxTQUFTLFlBQVk7QUFDNUMsWUFBUSxRQUFRLE9BQU87QUFBQSxFQUMxQixPQUNJO0FBQ0QscUJBQWlCLG1CQUFtQixnQkFBZ0Isa0JBQWtCLFNBQVMsZUFBZSxNQUFNO0FBQ3BHLG1CQUFlLGNBQWMsZ0JBQWdCLE9BQU8sbUJBQW1CLGdCQUFnQixNQUFNO0FBQUEsRUFDaEc7QUFDRCxpQkFBZSxRQUFRLFNBQVUsU0FBUztBQUN0QyxRQUFJLGtCQUFrQjtBQUN0QixRQUFJLE9BQU8sV0FBVztBQUNsQix3QkFBa0IsYUFBYSxnQkFBZ0IsUUFBUSxtQkFBbUIsU0FBUyxNQUFNO0FBQUEsSUFDNUYsT0FDSTtBQUNELFVBQUksUUFBUSxPQUFPO0FBQ2Y7QUFBQSxNQUNIO0FBQ0Qsd0JBQWtCO0FBQUEsSUFDckI7QUFDRCxRQUFJLFFBQVEsU0FBUyxnQkFBZ0IsWUFBWSxRQUFRLHVCQUF1QixNQUFNO0FBQ2xGLFVBQUksZUFBZSxnQkFBZ0IsZ0JBQWdCLFFBQVEsa0JBQWtCO0FBQzdFLFVBQUksQ0FBQyxRQUFRLFVBQVUsUUFBUSxxQkFBcUI7QUFDaEQsWUFBSSwyQkFBMkIsNEJBQTRCLGdCQUFnQixRQUFRLGtCQUFrQjtBQUNyRyxZQUFJLGFBQWEsU0FBUywwQkFBMEI7QUFDaEQsY0FBSXhLLFNBQVFtTSwwQkFBcUMsZ0JBQWdCLFFBQVEsa0JBQWtCLENBQUM7QUFDNUYsZ0JBQU0sSUFBSSxNQUFNbk0sTUFBSztBQUFBLFFBQ3hCO0FBQUEsTUFDSjtBQUNELG1CQUFhLFFBQVEsU0FBVSxZQUFZO0FBQ3ZDLDJCQUFtQixnQkFBZ0IsT0FBTyxXQUFXLG1CQUFtQixTQUFTLGlCQUFpQixVQUFVO0FBQUEsTUFDNUgsQ0FBYTtBQUFBLElBQ0o7QUFBQSxFQUNULENBQUs7QUFDTDtBQUNBLFNBQVMsWUFBWXdLLFlBQVcsbUJBQW1CO0FBQy9DLE1BQUksV0FBVyxDQUFBO0FBQ2YsTUFBSSxvQkFBb0IscUJBQXFCQSxVQUFTO0FBQ3RELE1BQUksa0JBQWtCLE9BQU8saUJBQWlCLEdBQUc7QUFDN0MsZUFBVyxrQkFBa0IsSUFBSSxpQkFBaUI7QUFBQSxFQUNyRCxXQUNRQSxXQUFVLFdBQVcsTUFBTTtBQUNoQyxlQUFXLFlBQVlBLFdBQVUsUUFBUSxpQkFBaUI7QUFBQSxFQUM3RDtBQUNELFNBQU87QUFDWDtBQUNBLFNBQVMsS0FBSyxnQkFBZ0JBLFlBQVcsZUFBZSxZQUFZLG1CQUFtQixLQUFLLE9BQU8sa0JBQWtCO0FBQ2pILE1BQUkscUJBQXFCLFFBQVE7QUFBRSx1QkFBbUI7QUFBQSxFQUFRO0FBQzlELE1BQUksVUFBVSxJQUFJLFFBQVFBLFVBQVM7QUFDbkMsTUFBSSxTQUFTLGNBQWMsZUFBZSxZQUFZLG1CQUFtQixJQUFJLEtBQUssS0FBSztBQUN2RixNQUFJO0FBQ0EsdUJBQW1CLGdCQUFnQixrQkFBa0IsbUJBQW1CLFNBQVMsTUFBTSxNQUFNO0FBQzdGLFdBQU87QUFBQSxFQUNWLFNBQ014SyxRQUFQO0FBQ0ksUUFBSSx3QkFBd0JBLE1BQUssR0FBRztBQUNoQyxvQ0FBOEIsUUFBUSxLQUFLLFdBQVc7QUFBQSxJQUN6RDtBQUNELFVBQU1BO0FBQUEsRUFDVDtBQUNMO0FBQ0EsU0FBUyxrQkFBa0J3SyxZQUFXLG1CQUFtQixLQUFLLE9BQU87QUFDakUsTUFBSSxTQUFTLElBQUksT0FBTyxlQUFlLFVBQVUsSUFBSSxtQkFBbUIsSUFBSSxTQUFTLEtBQUssS0FBSyxDQUFDO0FBQ2hHLE1BQUksVUFBVSxJQUFJLFFBQVFBLFVBQVM7QUFDbkMsTUFBSWhLLFdBQVUsSUFBSSxRQUFRLG1CQUFtQixTQUFTLE1BQU0sQ0FBQSxHQUFJLE1BQU07QUFDdEUsU0FBT0E7QUFDWDtBQ2pKQSxTQUFTLFVBQVUsUUFBUTtBQUN2QixNQUFJLHFCQUFzQixPQUFPLFdBQVcsWUFBWSxXQUFXLFFBQVMsT0FBTyxXQUFXO0FBQzlGLFNBQU8sc0JBQXNCLE9BQU8sT0FBTyxTQUFTO0FBQ3hEO0FBQ0EsU0FBUywyQkFBMkIsUUFBUTtBQUN4QyxNQUFJLFVBQVUsTUFBTSxHQUFHO0FBQ25CLFdBQU87QUFBQSxFQUNWO0FBQ0QsU0FBTyxNQUFNLFFBQVEsTUFBTSxLQUFLLE9BQU8sS0FBSyxTQUFTO0FBQ3pEO0FDVEEsSUFBSTRMLGNBQWFkLGNBQVFBLFdBQUssYUFBYyxTQUFVLFNBQVMsWUFBWTdMLElBQUcsV0FBVztBQUNyRixXQUFTLE1BQU0sT0FBTztBQUFFLFdBQU8saUJBQWlCQSxLQUFJLFFBQVEsSUFBSUEsR0FBRSxTQUFVa0ksVUFBUztBQUFFLE1BQUFBLFNBQVEsS0FBSztBQUFBLElBQUUsQ0FBRTtBQUFBLEVBQUk7QUFDNUcsU0FBTyxLQUFLbEksT0FBTUEsS0FBSSxVQUFVLFNBQVVrSSxVQUFTLFFBQVE7QUFDdkQsYUFBUyxVQUFVLE9BQU87QUFBRSxVQUFJO0FBQUUsYUFBSyxVQUFVLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFBRSxTQUFVLEdBQVA7QUFBWSxlQUFPLENBQUM7QUFBQTtJQUFNO0FBQzNGLGFBQVMsU0FBUyxPQUFPO0FBQUUsVUFBSTtBQUFFLGFBQUssVUFBVSxPQUFPLEVBQUUsS0FBSyxDQUFDO0FBQUEsTUFBSSxTQUFRLEdBQVA7QUFBWSxlQUFPLENBQUM7QUFBQTtJQUFNO0FBQzlGLGFBQVMsS0FBSyxRQUFRO0FBQUUsYUFBTyxPQUFPQSxTQUFRLE9BQU8sS0FBSyxJQUFJLE1BQU0sT0FBTyxLQUFLLEVBQUUsS0FBSyxXQUFXLFFBQVE7QUFBQSxJQUFJO0FBQzlHLFVBQU0sWUFBWSxVQUFVLE1BQU0sU0FBUyxjQUFjLENBQUUsQ0FBQSxHQUFHLEtBQUksQ0FBRTtBQUFBLEVBQzVFLENBQUs7QUFDTDtBQUNBLElBQUkwRSxnQkFBZWYsY0FBUUEsV0FBSyxlQUFnQixTQUFVLFNBQVMsTUFBTTtBQUNyRSxNQUFJbEwsS0FBSSxFQUFFLE9BQU8sR0FBRyxNQUFNLFdBQVc7QUFBRSxRQUFJYSxHQUFFLENBQUMsSUFBSTtBQUFHLFlBQU1BLEdBQUUsQ0FBQztBQUFHLFdBQU9BLEdBQUUsQ0FBQztBQUFBLEVBQUksR0FBRSxNQUFNLENBQUUsR0FBRSxLQUFLLENBQUEsRUFBSSxHQUFFLEdBQUcsR0FBR0EsSUFBRztBQUMvRyxTQUFPLElBQUksRUFBRSxNQUFNLEtBQUssQ0FBQyxHQUFHLFNBQVMsS0FBSyxDQUFDLEdBQUcsVUFBVSxLQUFLLENBQUMsRUFBRyxHQUFFLE9BQU8sV0FBVyxlQUFlLEVBQUUsT0FBTyxRQUFRLElBQUksV0FBVztBQUFFLFdBQU87QUFBQSxFQUFPLElBQUc7QUFDdkosV0FBUyxLQUFLLEdBQUc7QUFBRSxXQUFPLFNBQVUsR0FBRztBQUFFLGFBQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQUEsSUFBSTtBQUFBLEVBQUc7QUFDbEUsV0FBUyxLQUFLLElBQUk7QUFDZCxRQUFJO0FBQUcsWUFBTSxJQUFJLFVBQVUsaUNBQWlDO0FBQzVELFdBQU9iO0FBQUcsVUFBSTtBQUNWLFlBQUksSUFBSSxHQUFHLE1BQU1hLEtBQUksR0FBRyxDQUFDLElBQUksSUFBSSxFQUFFLFFBQVEsSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFFLE9BQU8sT0FBT0EsS0FBSSxFQUFFLFFBQVEsTUFBTUEsR0FBRSxLQUFLLENBQUMsR0FBRyxLQUFLLEVBQUUsU0FBUyxFQUFFQSxLQUFJQSxHQUFFLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHO0FBQU0saUJBQU9BO0FBQzNKLFlBQUksSUFBSSxHQUFHQTtBQUFHLGVBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHQSxHQUFFLEtBQUs7QUFDdEMsZ0JBQVEsR0FBRyxDQUFDLEdBQUM7QUFBQSxVQUNULEtBQUs7QUFBQSxVQUFHLEtBQUs7QUFBRyxZQUFBQSxLQUFJO0FBQUk7QUFBQSxVQUN4QixLQUFLO0FBQUcsWUFBQWIsR0FBRTtBQUFTLG1CQUFPLEVBQUUsT0FBTyxHQUFHLENBQUMsR0FBRyxNQUFNLE1BQUs7QUFBQSxVQUNyRCxLQUFLO0FBQUcsWUFBQUEsR0FBRTtBQUFTLGdCQUFJLEdBQUcsQ0FBQztBQUFHLGlCQUFLLENBQUMsQ0FBQztBQUFHO0FBQUEsVUFDeEMsS0FBSztBQUFHLGlCQUFLQSxHQUFFLElBQUk7QUFBTyxZQUFBQSxHQUFFLEtBQUssSUFBRztBQUFJO0FBQUEsVUFDeEM7QUFDSSxnQkFBSSxFQUFFYSxLQUFJYixHQUFFLE1BQU1hLEtBQUlBLEdBQUUsU0FBUyxLQUFLQSxHQUFFQSxHQUFFLFNBQVMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRyxDQUFDLE1BQU0sSUFBSTtBQUFFLGNBQUFiLEtBQUk7QUFBRztBQUFBLFlBQVc7QUFDNUcsZ0JBQUksR0FBRyxDQUFDLE1BQU0sTUFBTSxDQUFDYSxNQUFNLEdBQUcsQ0FBQyxJQUFJQSxHQUFFLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSUEsR0FBRSxDQUFDLElBQUs7QUFBRSxjQUFBYixHQUFFLFFBQVEsR0FBRyxDQUFDO0FBQUc7QUFBQSxZQUFRO0FBQ3RGLGdCQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUtBLEdBQUUsUUFBUWEsR0FBRSxDQUFDLEdBQUc7QUFBRSxjQUFBYixHQUFFLFFBQVFhLEdBQUUsQ0FBQztBQUFHLGNBQUFBLEtBQUk7QUFBSTtBQUFBLFlBQVE7QUFDckUsZ0JBQUlBLE1BQUtiLEdBQUUsUUFBUWEsR0FBRSxDQUFDLEdBQUc7QUFBRSxjQUFBYixHQUFFLFFBQVFhLEdBQUUsQ0FBQztBQUFHLGNBQUFiLEdBQUUsSUFBSSxLQUFLLEVBQUU7QUFBRztBQUFBLFlBQVE7QUFDbkUsZ0JBQUlhLEdBQUUsQ0FBQztBQUFHLGNBQUFiLEdBQUUsSUFBSSxJQUFHO0FBQ25CLFlBQUFBLEdBQUUsS0FBSyxJQUFLO0FBQUU7QUFBQSxRQUNyQjtBQUNELGFBQUssS0FBSyxLQUFLLFNBQVNBLEVBQUM7QUFBQSxNQUM1QixTQUFRLEdBQVA7QUFBWSxhQUFLLENBQUMsR0FBRyxDQUFDO0FBQUcsWUFBSTtBQUFBLE1BQUUsVUFBVztBQUFFLFlBQUlhLEtBQUk7QUFBQSxNQUFJO0FBQzFELFFBQUksR0FBRyxDQUFDLElBQUk7QUFBRyxZQUFNLEdBQUcsQ0FBQztBQUFHLFdBQU8sRUFBRSxPQUFPLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLFFBQVEsTUFBTTtFQUM3RTtBQUNMO0FBR08sSUFBSSxrQkFBa0IsU0FBVSxjQUFjLFNBQVM7QUFDMUQsTUFBSyxRQUFRLFVBQVUsaUJBQWlCLGFBQWMsUUFBUSxXQUFXO0FBQ3JFLFdBQU8sUUFBUTtBQUFBLEVBQ2xCO0FBQ0QsTUFBSSxRQUFRLFVBQVUsaUJBQWlCLFdBQ25DLGFBQWEsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUM5QixXQUFPLGFBQWEsSUFBSSxRQUFRLEVBQUU7QUFBQSxFQUNyQztBQUNELFNBQU87QUFDWDtBQUNPLElBQUksY0FBYyxTQUFVLGNBQWMsU0FBUyxRQUFRO0FBQzlELE1BQUksUUFBUSxVQUFVLGlCQUFpQixXQUFXO0FBQzlDLDBCQUFzQixTQUFTLE1BQU07QUFBQSxFQUN4QztBQUNELE1BQUksUUFBUSxVQUFVLGlCQUFpQixTQUFTO0FBQzVDLHdCQUFvQixjQUFjLFNBQVMsTUFBTTtBQUFBLEVBQ3BEO0FBQ0w7QUFDQSxJQUFJLHNCQUFzQixTQUFVLGNBQWMsU0FBUyxRQUFRO0FBQy9ELE1BQUksQ0FBQyxhQUFhLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDL0IsaUJBQWEsSUFBSSxRQUFRLElBQUksTUFBTTtBQUFBLEVBQ3RDO0FBQ0w7QUFDQSxJQUFJLHdCQUF3QixTQUFVLFNBQVMsUUFBUTtBQUNuRCxVQUFRLFFBQVE7QUFDaEIsVUFBUSxZQUFZO0FBQ3BCLE1BQUksVUFBVSxNQUFNLEdBQUc7QUFDbkIsU0FBSyxpQ0FBaUMsU0FBUyxNQUFNO0FBQUEsRUFDeEQ7QUFDTDtBQUNBLElBQUksbUNBQW1DLFNBQVUsU0FBUyxhQUFhO0FBQUUsU0FBT21MLFlBQVUsUUFBUSxRQUFRLFFBQVEsV0FBWTtBQUMxSCxRQUFJLFFBQVE7QUFDWixXQUFPQyxjQUFZLE1BQU0sU0FBVTFNLEtBQUk7QUFDbkMsY0FBUUEsSUFBRyxPQUFLO0FBQUEsUUFDWixLQUFLO0FBQ0QsVUFBQUEsSUFBRyxLQUFLLEtBQUssQ0FBQyxHQUFHLEdBQUMsRUFBSSxDQUFDLENBQUM7QUFDeEIsaUJBQU8sQ0FBQyxHQUFHLFdBQVc7QUFBQSxRQUMxQixLQUFLO0FBQ0QsbUJBQVNBLElBQUc7QUFDWixrQkFBUSxRQUFRO0FBQ2hCLGlCQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsUUFDaEIsS0FBSztBQUNELGlCQUFPQSxJQUFHO0FBQ1Ysa0JBQVEsUUFBUTtBQUNoQixrQkFBUSxZQUFZO0FBQ3BCLGdCQUFNO0FBQUEsUUFDVixLQUFLO0FBQUcsaUJBQU8sQ0FBQyxDQUFDO0FBQUEsTUFDcEI7QUFBQSxJQUNULENBQUs7QUFBQSxFQUNMLENBQUM7QUFBSTtBQ3ZGRSxJQUFJO0FBQUEsQ0FDVixTQUFVMk0sY0FBYTtBQUNwQixFQUFBQSxhQUFZLGNBQWMsSUFBSTtBQUM5QixFQUFBQSxhQUFZLFNBQVMsSUFBSTtBQUN6QixFQUFBQSxhQUFZLFVBQVUsSUFBSTtBQUM5QixHQUFHLGdCQUFnQixjQUFjLENBQUEsRUFBRztBQ1U3QixJQUFJLG1CQUFtQixTQUFVLFNBQVM7QUFDN0MsTUFBSSxhQUFhO0FBQ2pCLFVBQVEsUUFBUSxNQUFJO0FBQUEsSUFDaEIsS0FBSyxnQkFBZ0I7QUFBQSxJQUNyQixLQUFLLGdCQUFnQjtBQUNqQixtQkFBYSxRQUFRO0FBQ3JCO0FBQUEsSUFDSixLQUFLLGdCQUFnQjtBQUFBLElBQ3JCLEtBQUssZ0JBQWdCO0FBQ2pCLG1CQUFhLFFBQVE7QUFDckI7QUFBQSxJQUNKLEtBQUssZ0JBQWdCO0FBQ2pCLG1CQUFhLFFBQVE7QUFDckI7QUFBQSxJQUNKLEtBQUssZ0JBQWdCO0FBQ2pCLG1CQUFhLFFBQVE7QUFDckI7QUFBQSxJQUNKLEtBQUssZ0JBQWdCO0FBQ2pCLG1CQUFhLFFBQVE7QUFDckI7QUFBQSxFQUNQO0FBQ0QsTUFBSSxlQUFlLE1BQU07QUFDckIsUUFBSSw0QkFBNEIsNkJBQTZCLFFBQVEsaUJBQWlCO0FBQ3RGLFVBQU0sSUFBSSxNQUFNQyx1QkFBa0MsTUFBTSx5QkFBeUI7QUFBQSxFQUNwRjtBQUNMO0FBQ08sSUFBSSxvQkFBb0IsU0FBVSxTQUFTO0FBQzlDLFVBQVEsUUFBUSxNQUFJO0FBQUEsSUFDaEIsS0FBSyxnQkFBZ0I7QUFDakIsYUFBTyxFQUFFLFNBQVMsUUFBUSxTQUFTLGFBQWEsWUFBWTtJQUNoRSxLQUFLLGdCQUFnQjtBQUNqQixhQUFPLEVBQUUsU0FBUyxRQUFRLFVBQVUsYUFBYSxZQUFZO0lBQ2pFLEtBQUssZ0JBQWdCO0FBQ2pCLGFBQU8sRUFBRSxTQUFTLFFBQVEsY0FBYyxhQUFhLFlBQVk7SUFDckU7QUFDSSxZQUFNLElBQUksTUFBTSw2QkFBNkIsUUFBUSxJQUFJO0FBQUEsRUFDaEU7QUFDTDtBQ3BEQSxJQUFJQyxhQUFZbEIsY0FBUUEsV0FBSyxZQUFhLFdBQVk7QUFDbERrQixlQUFXLE9BQU8sVUFBVSxTQUFTdkwsSUFBRztBQUNwQyxhQUFTLEdBQUcsSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLElBQUksR0FBRyxLQUFLO0FBQ2pELFVBQUksVUFBVSxDQUFDO0FBQ2YsZUFBUyxLQUFLO0FBQUcsWUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLEdBQUcsQ0FBQztBQUMxRCxVQUFBQSxHQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFBQSxJQUNqQjtBQUNELFdBQU9BO0FBQUEsRUFDZjtBQUNJLFNBQU91TCxXQUFTLE1BQU0sTUFBTSxTQUFTO0FBQ3pDO0FBQ0EsSUFBSUosY0FBYWQsY0FBUUEsV0FBSyxhQUFjLFNBQVUsU0FBUyxZQUFZN0wsSUFBRyxXQUFXO0FBQ3JGLFdBQVMsTUFBTSxPQUFPO0FBQUUsV0FBTyxpQkFBaUJBLEtBQUksUUFBUSxJQUFJQSxHQUFFLFNBQVVrSSxVQUFTO0FBQUUsTUFBQUEsU0FBUSxLQUFLO0FBQUEsSUFBRSxDQUFFO0FBQUEsRUFBSTtBQUM1RyxTQUFPLEtBQUtsSSxPQUFNQSxLQUFJLFVBQVUsU0FBVWtJLFVBQVMsUUFBUTtBQUN2RCxhQUFTLFVBQVUsT0FBTztBQUFFLFVBQUk7QUFBRSxhQUFLLFVBQVUsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUFFLFNBQVUsR0FBUDtBQUFZLGVBQU8sQ0FBQztBQUFBO0lBQU07QUFDM0YsYUFBUyxTQUFTLE9BQU87QUFBRSxVQUFJO0FBQUUsYUFBSyxVQUFVLE9BQU8sRUFBRSxLQUFLLENBQUM7QUFBQSxNQUFJLFNBQVEsR0FBUDtBQUFZLGVBQU8sQ0FBQztBQUFBO0lBQU07QUFDOUYsYUFBUyxLQUFLLFFBQVE7QUFBRSxhQUFPLE9BQU9BLFNBQVEsT0FBTyxLQUFLLElBQUksTUFBTSxPQUFPLEtBQUssRUFBRSxLQUFLLFdBQVcsUUFBUTtBQUFBLElBQUk7QUFDOUcsVUFBTSxZQUFZLFVBQVUsTUFBTSxTQUFTLGNBQWMsQ0FBRSxDQUFBLEdBQUcsS0FBSSxDQUFFO0FBQUEsRUFDNUUsQ0FBSztBQUNMO0FBQ0EsSUFBSTBFLGdCQUFlZixjQUFRQSxXQUFLLGVBQWdCLFNBQVUsU0FBUyxNQUFNO0FBQ3JFLE1BQUlsTCxLQUFJLEVBQUUsT0FBTyxHQUFHLE1BQU0sV0FBVztBQUFFLFFBQUlhLEdBQUUsQ0FBQyxJQUFJO0FBQUcsWUFBTUEsR0FBRSxDQUFDO0FBQUcsV0FBT0EsR0FBRSxDQUFDO0FBQUEsRUFBSSxHQUFFLE1BQU0sQ0FBRSxHQUFFLEtBQUssQ0FBQSxFQUFJLEdBQUUsR0FBRyxHQUFHQSxJQUFHO0FBQy9HLFNBQU8sSUFBSSxFQUFFLE1BQU0sS0FBSyxDQUFDLEdBQUcsU0FBUyxLQUFLLENBQUMsR0FBRyxVQUFVLEtBQUssQ0FBQyxFQUFHLEdBQUUsT0FBTyxXQUFXLGVBQWUsRUFBRSxPQUFPLFFBQVEsSUFBSSxXQUFXO0FBQUUsV0FBTztBQUFBLEVBQU8sSUFBRztBQUN2SixXQUFTLEtBQUssR0FBRztBQUFFLFdBQU8sU0FBVSxHQUFHO0FBQUUsYUFBTyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFBQSxJQUFJO0FBQUEsRUFBRztBQUNsRSxXQUFTLEtBQUssSUFBSTtBQUNkLFFBQUk7QUFBRyxZQUFNLElBQUksVUFBVSxpQ0FBaUM7QUFDNUQsV0FBT2I7QUFBRyxVQUFJO0FBQ1YsWUFBSSxJQUFJLEdBQUcsTUFBTWEsS0FBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUUsUUFBUSxJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxPQUFPQSxLQUFJLEVBQUUsUUFBUSxNQUFNQSxHQUFFLEtBQUssQ0FBQyxHQUFHLEtBQUssRUFBRSxTQUFTLEVBQUVBLEtBQUlBLEdBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUc7QUFBTSxpQkFBT0E7QUFDM0osWUFBSSxJQUFJLEdBQUdBO0FBQUcsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUdBLEdBQUUsS0FBSztBQUN0QyxnQkFBUSxHQUFHLENBQUMsR0FBQztBQUFBLFVBQ1QsS0FBSztBQUFBLFVBQUcsS0FBSztBQUFHLFlBQUFBLEtBQUk7QUFBSTtBQUFBLFVBQ3hCLEtBQUs7QUFBRyxZQUFBYixHQUFFO0FBQVMsbUJBQU8sRUFBRSxPQUFPLEdBQUcsQ0FBQyxHQUFHLE1BQU0sTUFBSztBQUFBLFVBQ3JELEtBQUs7QUFBRyxZQUFBQSxHQUFFO0FBQVMsZ0JBQUksR0FBRyxDQUFDO0FBQUcsaUJBQUssQ0FBQyxDQUFDO0FBQUc7QUFBQSxVQUN4QyxLQUFLO0FBQUcsaUJBQUtBLEdBQUUsSUFBSTtBQUFPLFlBQUFBLEdBQUUsS0FBSyxJQUFHO0FBQUk7QUFBQSxVQUN4QztBQUNJLGdCQUFJLEVBQUVhLEtBQUliLEdBQUUsTUFBTWEsS0FBSUEsR0FBRSxTQUFTLEtBQUtBLEdBQUVBLEdBQUUsU0FBUyxDQUFDLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxHQUFHLENBQUMsTUFBTSxJQUFJO0FBQUUsY0FBQWIsS0FBSTtBQUFHO0FBQUEsWUFBVztBQUM1RyxnQkFBSSxHQUFHLENBQUMsTUFBTSxNQUFNLENBQUNhLE1BQU0sR0FBRyxDQUFDLElBQUlBLEdBQUUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJQSxHQUFFLENBQUMsSUFBSztBQUFFLGNBQUFiLEdBQUUsUUFBUSxHQUFHLENBQUM7QUFBRztBQUFBLFlBQVE7QUFDdEYsZ0JBQUksR0FBRyxDQUFDLE1BQU0sS0FBS0EsR0FBRSxRQUFRYSxHQUFFLENBQUMsR0FBRztBQUFFLGNBQUFiLEdBQUUsUUFBUWEsR0FBRSxDQUFDO0FBQUcsY0FBQUEsS0FBSTtBQUFJO0FBQUEsWUFBUTtBQUNyRSxnQkFBSUEsTUFBS2IsR0FBRSxRQUFRYSxHQUFFLENBQUMsR0FBRztBQUFFLGNBQUFiLEdBQUUsUUFBUWEsR0FBRSxDQUFDO0FBQUcsY0FBQWIsR0FBRSxJQUFJLEtBQUssRUFBRTtBQUFHO0FBQUEsWUFBUTtBQUNuRSxnQkFBSWEsR0FBRSxDQUFDO0FBQUcsY0FBQWIsR0FBRSxJQUFJLElBQUc7QUFDbkIsWUFBQUEsR0FBRSxLQUFLLElBQUs7QUFBRTtBQUFBLFFBQ3JCO0FBQ0QsYUFBSyxLQUFLLEtBQUssU0FBU0EsRUFBQztBQUFBLE1BQzVCLFNBQVEsR0FBUDtBQUFZLGFBQUssQ0FBQyxHQUFHLENBQUM7QUFBRyxZQUFJO0FBQUEsTUFBRSxVQUFXO0FBQUUsWUFBSWEsS0FBSTtBQUFBLE1BQUk7QUFDMUQsUUFBSSxHQUFHLENBQUMsSUFBSTtBQUFHLFlBQU0sR0FBRyxDQUFDO0FBQUcsV0FBTyxFQUFFLE9BQU8sR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksUUFBUSxNQUFNO0VBQzdFO0FBQ0w7QUFDQSxJQUFJb0ssa0JBQWlCQyxjQUFRQSxXQUFLLGlCQUFrQixTQUFVLElBQUksTUFBTSxNQUFNO0FBQzFFLE1BQUksUUFBUSxVQUFVLFdBQVc7QUFBRyxhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksR0FBRyxLQUFLO0FBQ2pGLFVBQUksTUFBTSxFQUFFLEtBQUssT0FBTztBQUNwQixZQUFJLENBQUM7QUFBSSxlQUFLLE1BQU0sVUFBVSxNQUFNLEtBQUssTUFBTSxHQUFHLENBQUM7QUFDbkQsV0FBRyxDQUFDLElBQUksS0FBSyxDQUFDO0FBQUEsTUFDakI7QUFBQSxJQUNKO0FBQ0QsU0FBTyxHQUFHLE9BQU8sTUFBTSxNQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksQ0FBQztBQUMzRDtBQUtBLFNBQVMsaUJBQWlCLGVBQWUsZ0JBQWdCO0FBQ3JELFNBQU8sY0FBYyxPQUFPLFNBQVUsa0JBQWtCLGNBQWM7QUFDbEUsUUFBSSxZQUFZLGVBQWUsWUFBWTtBQUMzQyxRQUFJLGFBQWEsYUFBYSxPQUFPO0FBQ3JDLFFBQUksZUFBZSxlQUFlLHFCQUFxQjtBQUNuRCx1QkFBaUIsc0JBQXNCLEtBQUssU0FBUztBQUFBLElBQ3hELE9BQ0k7QUFDRCx1QkFBaUIsaUJBQWlCLEtBQUssWUFBWTtBQUNuRCx1QkFBaUIsbUJBQW1CLEtBQUssU0FBUztBQUFBLElBQ3JEO0FBQ0QsUUFBSSxDQUFDLGlCQUFpQixTQUFTO0FBQzNCLHVCQUFpQixVQUFVLDJCQUEyQixTQUFTO0FBQUEsSUFDbEU7QUFDRCxXQUFPO0FBQUEsRUFDZixHQUFPLEVBQUUsdUJBQXVCLENBQUUsR0FBRSxvQkFBb0IsQ0FBQSxHQUFJLGtCQUFrQixJQUFJLFNBQVMsTUFBSyxDQUFFO0FBQ2xHO0FBQ0EsU0FBUyxnQkFBZ0IsUUFBUSxlQUFlLGdCQUFnQjtBQUM1RCxNQUFJO0FBQ0osTUFBSSxjQUFjLFNBQVMsR0FBRztBQUMxQixRQUFJLFdBQVcsaUJBQWlCLGVBQWUsY0FBYztBQUM3RCxRQUFJLGtDQUFrQ2tCLFdBQVNBLFdBQVMsQ0FBRSxHQUFFLFFBQVEsR0FBRyxFQUFFLE9BQWMsQ0FBRTtBQUN6RixRQUFJLFNBQVMsU0FBUztBQUNsQixlQUFTLGtDQUFrQywrQkFBK0I7QUFBQSxJQUM3RSxPQUNJO0FBQ0QsZUFBUyw2QkFBNkIsK0JBQStCO0FBQUEsSUFDeEU7QUFBQSxFQUNKLE9BQ0k7QUFDRCxhQUFTLElBQUk7RUFDaEI7QUFDRCxTQUFPO0FBQ1g7QUFDQSxTQUFTLDZCQUE2QixNQUFNO0FBQ3hDLE1BQUk3TTtBQUNKLE1BQUlnSyxZQUFXLE1BQU1oSyxNQUFLLEtBQUssUUFBUSxLQUFLLE1BQU1BLEtBQUkwTCxnQkFBYyxDQUFDLE1BQU0sR0FBRyxLQUFLLHVCQUF1QixLQUFLLENBQUM7QUFDaEgsT0FBSyxpQkFBaUIsUUFBUSxTQUFVLEdBQUcsT0FBTztBQUM5QyxRQUFJLFdBQVcsRUFBRSxPQUFPO0FBQ3hCLFFBQUksWUFBWSxLQUFLLG1CQUFtQixLQUFLO0FBQzdDLElBQUExQixVQUFTLFFBQVEsSUFBSTtBQUFBLEVBQzdCLENBQUs7QUFDRCxTQUFPQTtBQUNYO0FBQ0EsU0FBUyxrQ0FBa0MsTUFBTTtBQUM3QyxTQUFPeUMsWUFBVSxNQUFNLFFBQVEsUUFBUSxXQUFZO0FBQy9DLFFBQUksdUJBQXVCO0FBQzNCLFdBQU9DLGNBQVksTUFBTSxTQUFVMU0sS0FBSTtBQUNuQyxjQUFRQSxJQUFHLE9BQUs7QUFBQSxRQUNaLEtBQUs7QUFBRyxpQkFBTyxDQUFDLEdBQUcsdUJBQXVCLEtBQUsscUJBQXFCLENBQUM7QUFBQSxRQUNyRSxLQUFLO0FBQ0Qsa0NBQXdCQSxJQUFHO0FBQzNCLGlCQUFPLENBQUMsR0FBRyx1QkFBdUIsS0FBSyxrQkFBa0IsQ0FBQztBQUFBLFFBQzlELEtBQUs7QUFDRCwrQkFBcUJBLElBQUc7QUFDeEIsaUJBQU8sQ0FBQyxHQUFHLDZCQUE2QjZNLFdBQVNBLFdBQVMsQ0FBQSxHQUFJLElBQUksR0FBRyxFQUFFLHVCQUE4QyxtQkFBd0MsQ0FBQSxDQUFDLENBQUM7QUFBQSxNQUN0SztBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ1QsQ0FBSztBQUNMO0FBQ0EsU0FBUyx1QkFBdUIsMkJBQTJCO0FBQ3ZELFNBQU9KLFlBQVUsTUFBTSxRQUFRLFFBQVEsV0FBWTtBQUMvQyxRQUFJLFlBQVksSUFBSSw2QkFBNkI7QUFDakQsV0FBT0MsY0FBWSxNQUFNLFNBQVUxTSxLQUFJO0FBQ25DLG1CQUFhLENBQUE7QUFDYixXQUFLLEtBQUssR0FBRyw4QkFBOEIsMkJBQTJCLEtBQUssNEJBQTRCLFFBQVEsTUFBTTtBQUNqSCxvQkFBWSw0QkFBNEIsRUFBRTtBQUMxQyxZQUFJLE1BQU0sUUFBUSxTQUFTLEdBQUc7QUFDMUIscUJBQVcsS0FBSyxRQUFRLElBQUksU0FBUyxDQUFDO0FBQUEsUUFDekMsT0FDSTtBQUNELHFCQUFXLEtBQUssU0FBUztBQUFBLFFBQzVCO0FBQUEsTUFDSjtBQUNELGFBQU8sQ0FBQyxHQUFHLFFBQVEsSUFBSSxVQUFVLENBQUM7QUFBQSxJQUM5QyxDQUFTO0FBQUEsRUFDVCxDQUFLO0FBQ0w7QUFDQSxTQUFTLCtCQUErQixRQUFRLFFBQVE7QUFDcEQsTUFBSSxzQkFBc0IsZUFBZSxRQUFRLE1BQU07QUFDdkQsTUFBSSxVQUFVLG1CQUFtQixHQUFHO0FBQ2hDLFdBQU8sb0JBQW9CLEtBQUssV0FBWTtBQUFFLGFBQU87QUFBQSxJQUFTLENBQUE7QUFBQSxFQUNqRSxPQUNJO0FBQ0QsV0FBTztBQUFBLEVBQ1Y7QUFDTDtBQUNBLFNBQVMsZUFBZSxRQUFRZ0ssV0FBVTtBQUN0QyxNQUFJaEssS0FBSTtBQUNSLE1BQUksUUFBUSxZQUFZOE0sZ0JBQTZCLE1BQU0sR0FBRztBQUMxRCxRQUFJLE9BQU8sUUFBUSxZQUFZQSxnQkFBNkIsTUFBTTtBQUNsRSxRQUFJO0FBQ0EsY0FBUSxNQUFNOU0sTUFBS2dLLFdBQVUsS0FBSyxLQUFLLE9BQU8sUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLEtBQUtoSyxHQUFFO0FBQUEsSUFDNUYsU0FDTSxHQUFQO0FBQ0ksWUFBTSxJQUFJLE1BQU0scUJBQXFCLE9BQU8sTUFBTSxFQUFFLE9BQU8sQ0FBQztBQUFBLElBQy9EO0FBQUEsRUFDSjtBQUNMO0FBQ0EsU0FBUyw0QkFBNEIsU0FBUyxRQUFRO0FBQ2xELE1BQUksUUFBUSxVQUFVLGlCQUFpQixXQUFXO0FBQzlDLGlDQUE2QixTQUFTLE1BQU07QUFBQSxFQUMvQztBQUNMO0FBQ0EsU0FBUyw2QkFBNkIsU0FBUyxRQUFRO0FBQ25ELE1BQUksb0JBQW9CLHNDQUFzQyxRQUFRLFVBQVUsaUJBQWlCLFVBQzdGLFlBQ0EsZUFBZTtBQUNuQixNQUFJLE9BQU8sUUFBUSxtQkFBbUIsWUFBWTtBQUM5QyxVQUFNLElBQUksTUFBTSxzQkFBc0IsT0FBTyxNQUFNLGlCQUFpQixDQUFDO0FBQUEsRUFDeEU7QUFDRCxNQUFJLFFBQVEsWUFBWStNLGFBQTBCLE1BQU0sR0FBRztBQUN2RCxVQUFNLElBQUksTUFBTSxrQkFBa0IsT0FBTyxNQUFNLGlCQUFpQixDQUFDO0FBQUEsRUFDcEU7QUFDTDtBQUNBLFNBQVMsZ0JBQWdCLFNBQVMsUUFBUSxlQUFlLGdCQUFnQjtBQUNyRSw4QkFBNEIsU0FBUyxNQUFNO0FBQzNDLE1BQUksU0FBUyxnQkFBZ0IsUUFBUSxlQUFlLGNBQWM7QUFDbEUsTUFBSSxVQUFVLE1BQU0sR0FBRztBQUNuQixXQUFPLE9BQU8sS0FBSyxTQUFVLGdCQUFnQjtBQUFFLGFBQU8sK0JBQStCLFFBQVEsY0FBYztBQUFBLElBQUUsQ0FBRTtBQUFBLEVBQ2xILE9BQ0k7QUFDRCxXQUFPLCtCQUErQixRQUFRLE1BQU07QUFBQSxFQUN2RDtBQUNMO0FDeExBLElBQUlOLGNBQWFkLGNBQVFBLFdBQUssYUFBYyxTQUFVLFNBQVMsWUFBWTdMLElBQUcsV0FBVztBQUNyRixXQUFTLE1BQU0sT0FBTztBQUFFLFdBQU8saUJBQWlCQSxLQUFJLFFBQVEsSUFBSUEsR0FBRSxTQUFVa0ksVUFBUztBQUFFLE1BQUFBLFNBQVEsS0FBSztBQUFBLElBQUUsQ0FBRTtBQUFBLEVBQUk7QUFDNUcsU0FBTyxLQUFLbEksT0FBTUEsS0FBSSxVQUFVLFNBQVVrSSxVQUFTLFFBQVE7QUFDdkQsYUFBUyxVQUFVLE9BQU87QUFBRSxVQUFJO0FBQUUsYUFBSyxVQUFVLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFBRSxTQUFVLEdBQVA7QUFBWSxlQUFPLENBQUM7QUFBQTtJQUFNO0FBQzNGLGFBQVMsU0FBUyxPQUFPO0FBQUUsVUFBSTtBQUFFLGFBQUssVUFBVSxPQUFPLEVBQUUsS0FBSyxDQUFDO0FBQUEsTUFBSSxTQUFRLEdBQVA7QUFBWSxlQUFPLENBQUM7QUFBQTtJQUFNO0FBQzlGLGFBQVMsS0FBSyxRQUFRO0FBQUUsYUFBTyxPQUFPQSxTQUFRLE9BQU8sS0FBSyxJQUFJLE1BQU0sT0FBTyxLQUFLLEVBQUUsS0FBSyxXQUFXLFFBQVE7QUFBQSxJQUFJO0FBQzlHLFVBQU0sWUFBWSxVQUFVLE1BQU0sU0FBUyxjQUFjLENBQUUsQ0FBQSxHQUFHLEtBQUksQ0FBRTtBQUFBLEVBQzVFLENBQUs7QUFDTDtBQUNBLElBQUkwRSxnQkFBZWYsY0FBUUEsV0FBSyxlQUFnQixTQUFVLFNBQVMsTUFBTTtBQUNyRSxNQUFJbEwsS0FBSSxFQUFFLE9BQU8sR0FBRyxNQUFNLFdBQVc7QUFBRSxRQUFJYSxHQUFFLENBQUMsSUFBSTtBQUFHLFlBQU1BLEdBQUUsQ0FBQztBQUFHLFdBQU9BLEdBQUUsQ0FBQztBQUFBLEVBQUksR0FBRSxNQUFNLENBQUUsR0FBRSxLQUFLLENBQUEsRUFBSSxHQUFFLEdBQUcsR0FBR0EsSUFBRztBQUMvRyxTQUFPLElBQUksRUFBRSxNQUFNLEtBQUssQ0FBQyxHQUFHLFNBQVMsS0FBSyxDQUFDLEdBQUcsVUFBVSxLQUFLLENBQUMsRUFBRyxHQUFFLE9BQU8sV0FBVyxlQUFlLEVBQUUsT0FBTyxRQUFRLElBQUksV0FBVztBQUFFLFdBQU87QUFBQSxFQUFPLElBQUc7QUFDdkosV0FBUyxLQUFLLEdBQUc7QUFBRSxXQUFPLFNBQVUsR0FBRztBQUFFLGFBQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQUEsSUFBSTtBQUFBLEVBQUc7QUFDbEUsV0FBUyxLQUFLLElBQUk7QUFDZCxRQUFJO0FBQUcsWUFBTSxJQUFJLFVBQVUsaUNBQWlDO0FBQzVELFdBQU9iO0FBQUcsVUFBSTtBQUNWLFlBQUksSUFBSSxHQUFHLE1BQU1hLEtBQUksR0FBRyxDQUFDLElBQUksSUFBSSxFQUFFLFFBQVEsSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFFLE9BQU8sT0FBT0EsS0FBSSxFQUFFLFFBQVEsTUFBTUEsR0FBRSxLQUFLLENBQUMsR0FBRyxLQUFLLEVBQUUsU0FBUyxFQUFFQSxLQUFJQSxHQUFFLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHO0FBQU0saUJBQU9BO0FBQzNKLFlBQUksSUFBSSxHQUFHQTtBQUFHLGVBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHQSxHQUFFLEtBQUs7QUFDdEMsZ0JBQVEsR0FBRyxDQUFDLEdBQUM7QUFBQSxVQUNULEtBQUs7QUFBQSxVQUFHLEtBQUs7QUFBRyxZQUFBQSxLQUFJO0FBQUk7QUFBQSxVQUN4QixLQUFLO0FBQUcsWUFBQWIsR0FBRTtBQUFTLG1CQUFPLEVBQUUsT0FBTyxHQUFHLENBQUMsR0FBRyxNQUFNLE1BQUs7QUFBQSxVQUNyRCxLQUFLO0FBQUcsWUFBQUEsR0FBRTtBQUFTLGdCQUFJLEdBQUcsQ0FBQztBQUFHLGlCQUFLLENBQUMsQ0FBQztBQUFHO0FBQUEsVUFDeEMsS0FBSztBQUFHLGlCQUFLQSxHQUFFLElBQUk7QUFBTyxZQUFBQSxHQUFFLEtBQUssSUFBRztBQUFJO0FBQUEsVUFDeEM7QUFDSSxnQkFBSSxFQUFFYSxLQUFJYixHQUFFLE1BQU1hLEtBQUlBLEdBQUUsU0FBUyxLQUFLQSxHQUFFQSxHQUFFLFNBQVMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRyxDQUFDLE1BQU0sSUFBSTtBQUFFLGNBQUFiLEtBQUk7QUFBRztBQUFBLFlBQVc7QUFDNUcsZ0JBQUksR0FBRyxDQUFDLE1BQU0sTUFBTSxDQUFDYSxNQUFNLEdBQUcsQ0FBQyxJQUFJQSxHQUFFLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSUEsR0FBRSxDQUFDLElBQUs7QUFBRSxjQUFBYixHQUFFLFFBQVEsR0FBRyxDQUFDO0FBQUc7QUFBQSxZQUFRO0FBQ3RGLGdCQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUtBLEdBQUUsUUFBUWEsR0FBRSxDQUFDLEdBQUc7QUFBRSxjQUFBYixHQUFFLFFBQVFhLEdBQUUsQ0FBQztBQUFHLGNBQUFBLEtBQUk7QUFBSTtBQUFBLFlBQVE7QUFDckUsZ0JBQUlBLE1BQUtiLEdBQUUsUUFBUWEsR0FBRSxDQUFDLEdBQUc7QUFBRSxjQUFBYixHQUFFLFFBQVFhLEdBQUUsQ0FBQztBQUFHLGNBQUFiLEdBQUUsSUFBSSxLQUFLLEVBQUU7QUFBRztBQUFBLFlBQVE7QUFDbkUsZ0JBQUlhLEdBQUUsQ0FBQztBQUFHLGNBQUFiLEdBQUUsSUFBSSxJQUFHO0FBQ25CLFlBQUFBLEdBQUUsS0FBSyxJQUFLO0FBQUU7QUFBQSxRQUNyQjtBQUNELGFBQUssS0FBSyxLQUFLLFNBQVNBLEVBQUM7QUFBQSxNQUM1QixTQUFRLEdBQVA7QUFBWSxhQUFLLENBQUMsR0FBRyxDQUFDO0FBQUcsWUFBSTtBQUFBLE1BQUUsVUFBVztBQUFFLFlBQUlhLEtBQUk7QUFBQSxNQUFJO0FBQzFELFFBQUksR0FBRyxDQUFDLElBQUk7QUFBRyxZQUFNLEdBQUcsQ0FBQztBQUFHLFdBQU8sRUFBRSxPQUFPLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLFFBQVEsTUFBTTtFQUM3RTtBQUNMO0FBU0EsSUFBSSxrQkFBa0IsU0FBVSxjQUFjO0FBQzFDLFNBQU8sU0FBVVQsVUFBUztBQUN0QixJQUFBQSxTQUFRLGNBQWMsa0JBQWtCQSxRQUFPO0FBQy9DLFFBQUksV0FBV0EsU0FBUTtBQUN2QixRQUFJLGdCQUFnQkEsU0FBUTtBQUM1QixRQUFJLGtCQUFrQkEsU0FBUSxVQUFVQSxTQUFRLE9BQU87QUFDdkQsUUFBSSwyQkFBMkIsQ0FBQ0EsU0FBUSxpQkFDcEMsQ0FBQ0EsU0FBUSxjQUFjLFVBQ3ZCLENBQUNBLFNBQVEsVUFDVCxDQUFDQSxTQUFRLGNBQWMsT0FBTyxhQUFhQSxTQUFRLE9BQU8saUJBQWlCO0FBQy9FLFFBQUksbUJBQW1CLDBCQUEwQjtBQUM3QyxhQUFPLGNBQWMsSUFBSSxTQUFVLGNBQWM7QUFDN0MsWUFBSSxLQUFLLGdCQUFnQixZQUFZO0FBQ3JDLGVBQU8sR0FBRyxZQUFZO0FBQUEsTUFDdEMsQ0FBYTtBQUFBLElBQ0osT0FDSTtBQUNELFVBQUlBLFNBQVEsT0FBTyxXQUFZLEtBQUksU0FBUyxXQUFXLEdBQUc7QUFDdEQsZUFBTztBQUFBLE1BQ1Y7QUFDRCxVQUFJLFVBQVUsU0FBUyxDQUFDO0FBQ3hCLGFBQU8sZ0JBQWdCLGNBQWNBLFVBQVMsT0FBTztBQUFBLElBQ3hEO0FBQUEsRUFDVDtBQUNBO0FBQ0EsSUFBSSw2QkFBNkIsU0FBVSxTQUFTLFNBQVM7QUFDekQsTUFBSSxpQkFBaUIsa0JBQWtCLE9BQU87QUFDOUMsU0FBTyxnQ0FBZ0MsV0FBWTtBQUFFLFdBQU8sZUFBZSxRQUFRLEtBQUssT0FBTyxFQUFFLE9BQU87QUFBQSxFQUFFLEdBQUksV0FBWTtBQUFFLFdBQU8sSUFBSSxNQUFNbU0sK0JBQTBDLGVBQWUsYUFBYSxRQUFRLGVBQWUsa0JBQWtCLFNBQVEsQ0FBRSxDQUFDO0FBQUEsRUFBSSxDQUFBO0FBQy9RO0FBQ0EsSUFBSSwwQkFBMEIsU0FBVSxjQUFjbk0sVUFBUyxTQUFTO0FBQ3BFLE1BQUk7QUFDSixNQUFJLGdCQUFnQkEsU0FBUTtBQUM1QixtQkFBaUIsT0FBTztBQUN4QixVQUFRLFFBQVEsTUFBSTtBQUFBLElBQ2hCLEtBQUssZ0JBQWdCO0FBQUEsSUFDckIsS0FBSyxnQkFBZ0I7QUFDakIsZUFBUyxRQUFRO0FBQ2pCO0FBQUEsSUFDSixLQUFLLGdCQUFnQjtBQUNqQixlQUFTLFFBQVE7QUFDakI7QUFBQSxJQUNKLEtBQUssZ0JBQWdCO0FBQ2pCLGVBQVMsZ0JBQWdCLFNBQVMsUUFBUSxvQkFBb0IsZUFBZSxnQkFBZ0IsWUFBWSxDQUFDO0FBQzFHO0FBQUEsSUFDSjtBQUNJLGVBQVMsMkJBQTJCLFNBQVNBLFNBQVEsYUFBYTtBQUFBLEVBQ3pFO0FBQ0QsU0FBTztBQUNYO0FBQ0EsSUFBSSxrQkFBa0IsU0FBVSxjQUFjLFNBQVMsb0JBQW9CO0FBQ3ZFLE1BQUksU0FBUyxnQkFBZ0IsY0FBYyxPQUFPO0FBQ2xELE1BQUksV0FBVyxNQUFNO0FBQ2pCLFdBQU87QUFBQSxFQUNWO0FBQ0QsV0FBUyxtQkFBa0I7QUFDM0IsY0FBWSxjQUFjLFNBQVMsTUFBTTtBQUN6QyxTQUFPO0FBQ1g7QUFDQSxJQUFJLGtCQUFrQixTQUFVLGNBQWNBLFVBQVMsU0FBUztBQUM1RCxTQUFPLGdCQUFnQixjQUFjLFNBQVMsV0FBWTtBQUN0RCxRQUFJLFNBQVMsd0JBQXdCLGNBQWNBLFVBQVMsT0FBTztBQUNuRSxRQUFJLFVBQVUsTUFBTSxHQUFHO0FBQ25CLGVBQVMsT0FBTyxLQUFLLFNBQVUsVUFBVTtBQUFFLGVBQU8sY0FBY0EsVUFBUyxTQUFTLFFBQVE7QUFBQSxNQUFJLENBQUE7QUFBQSxJQUNqRyxPQUNJO0FBQ0QsZUFBUyxjQUFjQSxVQUFTLFNBQVMsTUFBTTtBQUFBLElBQ2xEO0FBQ0QsV0FBTztBQUFBLEVBQ2YsQ0FBSztBQUNMO0FBQ0EsU0FBUyxjQUFjQSxVQUFTLFNBQVMsVUFBVTtBQUMvQyxNQUFJLFNBQVMsbUJBQW1CQSxTQUFRLGVBQWUsU0FBUyxRQUFRO0FBQ3hFLE1BQUkscUJBQXFCLHVCQUF1QkEsU0FBUSxjQUFjLFNBQVM7QUFDL0UsTUFBSWdLO0FBQ0osTUFBSSwyQkFBMkIsbUJBQW1CO0FBQ2xELEtBQUc7QUFDQyxJQUFBQSxhQUFZLHlCQUF5QjtBQUNyQyxRQUFJLFlBQVloSyxTQUFRO0FBQ3hCLFFBQUksb0JBQW9CQSxTQUFRO0FBQ2hDLFFBQUksc0JBQXNCLG1DQUFtQ2dLLFlBQVcsaUJBQWlCO0FBQ3pGLFFBQUksVUFBVSxNQUFNLEdBQUc7QUFDbkIsZUFBUyx3QkFBd0IscUJBQXFCLFdBQVcsTUFBTTtBQUFBLElBQzFFLE9BQ0k7QUFDRCxlQUFTLG1CQUFtQixxQkFBcUIsV0FBVyxNQUFNO0FBQUEsSUFDckU7QUFDRCwrQkFBMkIsbUJBQW1CO0VBQ3RELFNBQWEseUJBQXlCLFNBQVMsUUFBUSxDQUFDLHFCQUFxQkEsVUFBUyxFQUFFLE9BQU9oSyxTQUFRLGlCQUFpQjtBQUNwSCxTQUFPO0FBQ1g7QUFDQSxJQUFJLHFCQUFxQixTQUFVLFNBQVMsU0FBUyxnQkFBZ0I7QUFDakUsTUFBSTtBQUNKLE1BQUksT0FBTyxRQUFRLGlCQUFpQixZQUFZO0FBQzVDLGFBQVMsUUFBUSxhQUFhLFNBQVMsY0FBYztBQUFBLEVBQ3hELE9BQ0k7QUFDRCxhQUFTO0FBQUEsRUFDWjtBQUNELFNBQU87QUFDWDtBQUNBLElBQUkscUJBQXFCLFNBQVUscUJBQXFCLFNBQVMsUUFBUTtBQUNyRSxNQUFJLGFBQWEsb0JBQW9CO0FBQ3JDLFNBQU8sQ0FBQyxXQUFXLE1BQU07QUFDckIsYUFBUyxXQUFXLE1BQU0sU0FBUyxNQUFNO0FBQ3pDLFFBQUksVUFBVSxNQUFNLEdBQUc7QUFDbkIsYUFBTyx3QkFBd0IscUJBQXFCLFNBQVMsTUFBTTtBQUFBLElBQ3RFO0FBQ0QsaUJBQWEsb0JBQW9CO0VBQ3BDO0FBQ0QsU0FBTztBQUNYO0FBQ0EsSUFBSSwwQkFBMEIsU0FBVSxxQkFBcUIsU0FBUyxlQUFlO0FBQUUsU0FBTzRMLFlBQVUsUUFBUSxRQUFRLFFBQVEsV0FBWTtBQUN4SSxRQUFJLFFBQVE7QUFDWixXQUFPQyxjQUFZLE1BQU0sU0FBVTFNLEtBQUk7QUFDbkMsY0FBUUEsSUFBRyxPQUFLO0FBQUEsUUFDWixLQUFLO0FBQUcsaUJBQU8sQ0FBQyxHQUFHLGFBQWE7QUFBQSxRQUNoQyxLQUFLO0FBQ0QsbUJBQVNBLElBQUc7QUFDWix1QkFBYSxvQkFBb0I7QUFDakMsVUFBQUEsSUFBRyxRQUFRO0FBQUEsUUFDZixLQUFLO0FBQ0QsY0FBSSxDQUFDLENBQUMsV0FBVztBQUFNLG1CQUFPLENBQUMsR0FBRyxDQUFDO0FBQ25DLGlCQUFPLENBQUMsR0FBRyxXQUFXLE1BQU0sU0FBUyxNQUFNLENBQUM7QUFBQSxRQUNoRCxLQUFLO0FBQ0QsbUJBQVNBLElBQUc7QUFDWix1QkFBYSxvQkFBb0I7QUFDakMsaUJBQU8sQ0FBQyxHQUFHLENBQUM7QUFBQSxRQUNoQixLQUFLO0FBQUcsaUJBQU8sQ0FBQyxHQUFHLE1BQU07QUFBQSxNQUM1QjtBQUFBLElBQ1QsQ0FBSztBQUFBLEVBQ0wsQ0FBQztBQUFFO0FBQ0gsSUFBSSxxQ0FBcUMsU0FBVTZLLFlBQVcsbUJBQW1CO0FBQzdFLE1BQUksY0FBY0EsV0FBVTtBQUM1QixTQUFPLFlBQVksT0FBTyxpQkFBaUIsSUFBSSxZQUFZLElBQUksaUJBQWlCLEVBQUUsT0FBTSxJQUFLLENBQUUsRUFBQyxPQUFNO0FBQzFHO0FBQ0EsSUFBSSx5QkFBeUIsU0FBVUEsWUFBVztBQUM5QyxNQUFJLGtCQUFrQixDQUFDQSxVQUFTO0FBQ2hDLE1BQUksU0FBU0EsV0FBVTtBQUN2QixTQUFPLFdBQVcsTUFBTTtBQUNwQixvQkFBZ0IsS0FBSyxNQUFNO0FBQzNCLGFBQVMsT0FBTztBQUFBLEVBQ25CO0FBQ0QsTUFBSSxtQkFBbUIsV0FBWTtBQUMvQixRQUFJLGdCQUFnQixnQkFBZ0I7QUFDcEMsUUFBSSxrQkFBa0IsUUFBVztBQUM3QixhQUFPLEVBQUUsTUFBTSxPQUFPLE9BQU8sY0FBYTtBQUFBLElBQzdDLE9BQ0k7QUFDRCxhQUFPLEVBQUUsTUFBTSxNQUFNLE9BQU8sT0FBUztBQUFBLElBQ3hDO0FBQUEsRUFDVDtBQUNJLE1BQUkscUJBQXFCO0FBQUEsSUFDckIsTUFBTTtBQUFBLEVBQ2Q7QUFDSSxTQUFPO0FBQ1g7QUFDQSxTQUFTLFFBQVEsU0FBUztBQUN0QixNQUFJLEtBQUssZ0JBQWdCLFFBQVEsS0FBSyxZQUFZLFlBQVk7QUFDOUQsU0FBTyxHQUFHLFFBQVEsS0FBSyxXQUFXO0FBQ3RDO0FDek1BLElBQUkscUJBQXFCLFNBQVVoSyxVQUFTLFlBQVk7QUFDcEQsTUFBSSxTQUFTQSxTQUFRO0FBQ3JCLE1BQUksV0FBVyxNQUFNO0FBQ2pCLFdBQU8sV0FBVyxNQUFNLElBQUksT0FBTyxtQkFBbUIsUUFBUSxVQUFVO0FBQUEsRUFDM0UsT0FDSTtBQUNELFdBQU87QUFBQSxFQUNWO0FBQ0w7QUFDQSxJQUFJLG1CQUFtQixTQUFVLEtBQUs7QUFBRSxTQUFPLFNBQVUsT0FBTztBQUM1RCxRQUFJLGFBQWEsU0FBVUEsVUFBUztBQUNoQyxhQUFPQSxhQUFZLFFBQVFBLFNBQVEsV0FBVyxRQUFRQSxTQUFRLE9BQU8sV0FBVyxHQUFHLEVBQUUsS0FBSztBQUFBLElBQ2xHO0FBQ0ksZUFBVyxXQUFXLElBQUksU0FBUyxLQUFLLEtBQUs7QUFDN0MsV0FBTztBQUFBLEVBQ1g7O0FBQ0EsSUFBSSxrQkFBa0IsaUJBQWlCcUssU0FBc0I7QUFDN0QsSUFBSSxpQkFBaUIsU0FBVSxNQUFNO0FBQUUsU0FBTyxTQUFVckssVUFBUztBQUM3RCxRQUFJLFVBQVU7QUFDZCxRQUFJQSxhQUFZLE1BQU07QUFDbEIsZ0JBQVVBLFNBQVEsU0FBUyxDQUFDO0FBQzVCLFVBQUksT0FBTyxTQUFTLFVBQVU7QUFDMUIsWUFBSSxvQkFBb0IsUUFBUTtBQUNoQyxlQUFPLHNCQUFzQjtBQUFBLE1BQ2hDLE9BQ0k7QUFDRCxZQUFJLGNBQWNBLFNBQVEsU0FBUyxDQUFDLEVBQUU7QUFDdEMsZUFBTyxTQUFTO0FBQUEsTUFDbkI7QUFBQSxJQUNKO0FBQ0QsV0FBTztBQUFBLEVBQ1g7QUFBSTtBQy9CSixJQUFJLG9CQUFxQixXQUFZO0FBQ2pDLFdBQVNvTSxtQkFBa0IsU0FBUztBQUNoQyxTQUFLLFdBQVc7QUFBQSxFQUNuQjtBQUNELEVBQUFBLG1CQUFrQixVQUFVLE9BQU8sU0FBVSxZQUFZO0FBQ3JELFNBQUssU0FBUyxhQUFhO0FBQzNCLFdBQU8sSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDaEQ7QUFDSSxFQUFBQSxtQkFBa0IsVUFBVSxrQkFBa0IsU0FBVWhNLE9BQU07QUFDMUQsU0FBSyxTQUFTLGFBQWEsZ0JBQWdCQSxLQUFJO0FBQy9DLFdBQU8sSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDaEQ7QUFDSSxFQUFBZ00sbUJBQWtCLFVBQVUsc0JBQXNCLFdBQVk7QUFDMUQsU0FBSyxTQUFTLGFBQWEsU0FBVXBNLFVBQVM7QUFDMUMsVUFBSUEsYUFBWSxNQUFNO0FBQ2xCLGVBQU87QUFBQSxNQUNWO0FBQ0QsVUFBSSxrQkFBbUJBLFNBQVEsV0FBVyxRQUNyQyxDQUFDQSxTQUFRLE9BQU8sYUFDaEIsQ0FBQ0EsU0FBUSxPQUFPLFNBQVE7QUFDN0IsYUFBTztBQUFBLElBQ25CO0FBQ1EsV0FBTyxJQUFJLGdCQUFnQixLQUFLLFFBQVE7QUFBQSxFQUNoRDtBQUNJLEVBQUFvTSxtQkFBa0IsVUFBVSxtQkFBbUIsU0FBVSxLQUFLLE9BQU87QUFDakUsU0FBSyxTQUFTLGFBQWEsaUJBQWlCLEdBQUcsRUFBRSxLQUFLO0FBQ3RELFdBQU8sSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDaEQ7QUFDSSxFQUFBQSxtQkFBa0IsVUFBVSxtQkFBbUIsU0FBVSxRQUFRO0FBQzdELFNBQUssU0FBUyxhQUFhLFNBQVVwTSxVQUFTO0FBQzFDLGFBQU9BLGFBQVksUUFBUSxlQUFlLE1BQU0sRUFBRUEsU0FBUSxhQUFhO0FBQUEsSUFDbkY7QUFDUSxXQUFPLElBQUksZ0JBQWdCLEtBQUssUUFBUTtBQUFBLEVBQ2hEO0FBQ0ksRUFBQW9NLG1CQUFrQixVQUFVLGtCQUFrQixTQUFVaE0sT0FBTTtBQUMxRCxTQUFLLFNBQVMsYUFBYSxTQUFVSixVQUFTO0FBQzFDLGFBQU9BLGFBQVksUUFBUSxnQkFBZ0JJLEtBQUksRUFBRUosU0FBUSxhQUFhO0FBQUEsSUFDbEY7QUFDUSxXQUFPLElBQUksZ0JBQWdCLEtBQUssUUFBUTtBQUFBLEVBQ2hEO0FBQ0ksRUFBQW9NLG1CQUFrQixVQUFVLG1CQUFtQixTQUFVLEtBQUssT0FBTztBQUNqRSxTQUFLLFNBQVMsYUFBYSxTQUFVcE0sVUFBUztBQUMxQyxhQUFPQSxhQUFZLFFBQVEsaUJBQWlCLEdBQUcsRUFBRSxLQUFLLEVBQUVBLFNBQVEsYUFBYTtBQUFBLElBQ3pGO0FBQ1EsV0FBTyxJQUFJLGdCQUFnQixLQUFLLFFBQVE7QUFBQSxFQUNoRDtBQUNJLEVBQUFvTSxtQkFBa0IsVUFBVSxvQkFBb0IsU0FBVSxVQUFVO0FBQ2hFLFNBQUssU0FBUyxhQUFhLFNBQVVwTSxVQUFTO0FBQzFDLGFBQU9BLGFBQVksUUFBUSxtQkFBbUJBLFVBQVMsZUFBZSxRQUFRLENBQUM7QUFBQSxJQUMzRjtBQUNRLFdBQU8sSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDaEQ7QUFDSSxFQUFBb00sbUJBQWtCLFVBQVUsbUJBQW1CLFNBQVUsVUFBVTtBQUMvRCxTQUFLLFNBQVMsYUFBYSxTQUFVcE0sVUFBUztBQUMxQyxhQUFPQSxhQUFZLFFBQVEsQ0FBQyxtQkFBbUJBLFVBQVMsZUFBZSxRQUFRLENBQUM7QUFBQSxJQUM1RjtBQUNRLFdBQU8sSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDaEQ7QUFDSSxFQUFBb00sbUJBQWtCLFVBQVUsdUJBQXVCLFNBQVVoTSxPQUFNO0FBQy9ELFNBQUssU0FBUyxhQUFhLFNBQVVKLFVBQVM7QUFDMUMsYUFBT0EsYUFBWSxRQUFRLG1CQUFtQkEsVUFBUyxnQkFBZ0JJLEtBQUksQ0FBQztBQUFBLElBQ3hGO0FBQ1EsV0FBTyxJQUFJLGdCQUFnQixLQUFLLFFBQVE7QUFBQSxFQUNoRDtBQUNJLEVBQUFnTSxtQkFBa0IsVUFBVSxzQkFBc0IsU0FBVWhNLE9BQU07QUFDOUQsU0FBSyxTQUFTLGFBQWEsU0FBVUosVUFBUztBQUMxQyxhQUFPQSxhQUFZLFFBQVEsQ0FBQyxtQkFBbUJBLFVBQVMsZ0JBQWdCSSxLQUFJLENBQUM7QUFBQSxJQUN6RjtBQUNRLFdBQU8sSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDaEQ7QUFDSSxFQUFBZ00sbUJBQWtCLFVBQVUsd0JBQXdCLFNBQVUsS0FBSyxPQUFPO0FBQ3RFLFNBQUssU0FBUyxhQUFhLFNBQVVwTSxVQUFTO0FBQzFDLGFBQU9BLGFBQVksUUFBUSxtQkFBbUJBLFVBQVMsaUJBQWlCLEdBQUcsRUFBRSxLQUFLLENBQUM7QUFBQSxJQUMvRjtBQUNRLFdBQU8sSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDaEQ7QUFDSSxFQUFBb00sbUJBQWtCLFVBQVUsdUJBQXVCLFNBQVUsS0FBSyxPQUFPO0FBQ3JFLFNBQUssU0FBUyxhQUFhLFNBQVVwTSxVQUFTO0FBQzFDLGFBQU9BLGFBQVksUUFBUSxDQUFDLG1CQUFtQkEsVUFBUyxpQkFBaUIsR0FBRyxFQUFFLEtBQUssQ0FBQztBQUFBLElBQ2hHO0FBQ1EsV0FBTyxJQUFJLGdCQUFnQixLQUFLLFFBQVE7QUFBQSxFQUNoRDtBQUNJLEVBQUFvTSxtQkFBa0IsVUFBVSx5QkFBeUIsU0FBVSxZQUFZO0FBQ3ZFLFNBQUssU0FBUyxhQUFhLFNBQVVwTSxVQUFTO0FBQzFDLGFBQU9BLGFBQVksUUFBUSxtQkFBbUJBLFVBQVMsVUFBVTtBQUFBLElBQzdFO0FBQ1EsV0FBTyxJQUFJLGdCQUFnQixLQUFLLFFBQVE7QUFBQSxFQUNoRDtBQUNJLEVBQUFvTSxtQkFBa0IsVUFBVSx3QkFBd0IsU0FBVSxZQUFZO0FBQ3RFLFNBQUssU0FBUyxhQUFhLFNBQVVwTSxVQUFTO0FBQzFDLGFBQU9BLGFBQVksUUFBUSxDQUFDLG1CQUFtQkEsVUFBUyxVQUFVO0FBQUEsSUFDOUU7QUFDUSxXQUFPLElBQUksZ0JBQWdCLEtBQUssUUFBUTtBQUFBLEVBQ2hEO0FBQ0ksU0FBT29NO0FBQ1g7QUNoR0EsSUFBSSxrQkFBbUIsV0FBWTtBQUMvQixXQUFTQyxpQkFBZ0IsU0FBUztBQUM5QixTQUFLLFdBQVc7QUFBQSxFQUNuQjtBQUNELEVBQUFBLGlCQUFnQixVQUFVLGVBQWUsU0FBVSxTQUFTO0FBQ3hELFNBQUssU0FBUyxlQUFlO0FBQzdCLFdBQU8sSUFBSSxrQkFBa0IsS0FBSyxRQUFRO0FBQUEsRUFDbEQ7QUFDSSxFQUFBQSxpQkFBZ0IsVUFBVSxpQkFBaUIsU0FBVSxTQUFTO0FBQzFELFNBQUssU0FBUyxpQkFBaUI7QUFDL0IsV0FBTyxJQUFJLGtCQUFrQixLQUFLLFFBQVE7QUFBQSxFQUNsRDtBQUNJLFNBQU9BO0FBQ1g7QUNaQSxJQUFJLHNCQUF1QixXQUFZO0FBQ25DLFdBQVNDLHFCQUFvQixTQUFTO0FBQ2xDLFNBQUssV0FBVztBQUNoQixTQUFLLHFCQUFxQixJQUFJLGtCQUFrQixLQUFLLFFBQVE7QUFDN0QsU0FBSyxtQkFBbUIsSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQUEsRUFDNUQ7QUFDRCxFQUFBQSxxQkFBb0IsVUFBVSxPQUFPLFNBQVUsWUFBWTtBQUN2RCxXQUFPLEtBQUssbUJBQW1CLEtBQUssVUFBVTtBQUFBLEVBQ3REO0FBQ0ksRUFBQUEscUJBQW9CLFVBQVUsa0JBQWtCLFNBQVVsTSxPQUFNO0FBQzVELFdBQU8sS0FBSyxtQkFBbUIsZ0JBQWdCQSxLQUFJO0FBQUEsRUFDM0Q7QUFDSSxFQUFBa00scUJBQW9CLFVBQVUsc0JBQXNCLFdBQVk7QUFDNUQsV0FBTyxLQUFLLG1CQUFtQjtFQUN2QztBQUNJLEVBQUFBLHFCQUFvQixVQUFVLG1CQUFtQixTQUFVLEtBQUssT0FBTztBQUNuRSxXQUFPLEtBQUssbUJBQW1CLGlCQUFpQixLQUFLLEtBQUs7QUFBQSxFQUNsRTtBQUNJLEVBQUFBLHFCQUFvQixVQUFVLG1CQUFtQixTQUFVLFFBQVE7QUFDL0QsV0FBTyxLQUFLLG1CQUFtQixpQkFBaUIsTUFBTTtBQUFBLEVBQzlEO0FBQ0ksRUFBQUEscUJBQW9CLFVBQVUsa0JBQWtCLFNBQVVsTSxPQUFNO0FBQzVELFdBQU8sS0FBSyxtQkFBbUIsZ0JBQWdCQSxLQUFJO0FBQUEsRUFDM0Q7QUFDSSxFQUFBa00scUJBQW9CLFVBQVUsbUJBQW1CLFNBQVUsS0FBSyxPQUFPO0FBQ25FLFdBQU8sS0FBSyxtQkFBbUIsaUJBQWlCLEtBQUssS0FBSztBQUFBLEVBQ2xFO0FBQ0ksRUFBQUEscUJBQW9CLFVBQVUsb0JBQW9CLFNBQVUsVUFBVTtBQUNsRSxXQUFPLEtBQUssbUJBQW1CLGtCQUFrQixRQUFRO0FBQUEsRUFDakU7QUFDSSxFQUFBQSxxQkFBb0IsVUFBVSxtQkFBbUIsU0FBVSxVQUFVO0FBQ2pFLFdBQU8sS0FBSyxtQkFBbUIsaUJBQWlCLFFBQVE7QUFBQSxFQUNoRTtBQUNJLEVBQUFBLHFCQUFvQixVQUFVLHVCQUF1QixTQUFVbE0sT0FBTTtBQUNqRSxXQUFPLEtBQUssbUJBQW1CLHFCQUFxQkEsS0FBSTtBQUFBLEVBQ2hFO0FBQ0ksRUFBQWtNLHFCQUFvQixVQUFVLHdCQUF3QixTQUFVLEtBQUssT0FBTztBQUN4RSxXQUFPLEtBQUssbUJBQW1CLHNCQUFzQixLQUFLLEtBQUs7QUFBQSxFQUN2RTtBQUNJLEVBQUFBLHFCQUFvQixVQUFVLHNCQUFzQixTQUFVbE0sT0FBTTtBQUNoRSxXQUFPLEtBQUssbUJBQW1CLG9CQUFvQkEsS0FBSTtBQUFBLEVBQy9EO0FBQ0ksRUFBQWtNLHFCQUFvQixVQUFVLHVCQUF1QixTQUFVLEtBQUssT0FBTztBQUN2RSxXQUFPLEtBQUssbUJBQW1CLHFCQUFxQixLQUFLLEtBQUs7QUFBQSxFQUN0RTtBQUNJLEVBQUFBLHFCQUFvQixVQUFVLHlCQUF5QixTQUFVLFlBQVk7QUFDekUsV0FBTyxLQUFLLG1CQUFtQix1QkFBdUIsVUFBVTtBQUFBLEVBQ3hFO0FBQ0ksRUFBQUEscUJBQW9CLFVBQVUsd0JBQXdCLFNBQVUsWUFBWTtBQUN4RSxXQUFPLEtBQUssbUJBQW1CLHNCQUFzQixVQUFVO0FBQUEsRUFDdkU7QUFDSSxFQUFBQSxxQkFBb0IsVUFBVSxlQUFlLFNBQVUsU0FBUztBQUM1RCxXQUFPLEtBQUssaUJBQWlCLGFBQWEsT0FBTztBQUFBLEVBQ3pEO0FBQ0ksRUFBQUEscUJBQW9CLFVBQVUsaUJBQWlCLFNBQVUsU0FBUztBQUM5RCxXQUFPLEtBQUssaUJBQWlCLGVBQWUsT0FBTztBQUFBLEVBQzNEO0FBQ0ksU0FBT0E7QUFDWDtBQzFEQSxJQUFJLGtCQUFtQixXQUFZO0FBQy9CLFdBQVNDLGlCQUFnQixTQUFTO0FBQzlCLFNBQUssV0FBVztBQUFBLEVBQ25CO0FBQ0QsRUFBQUEsaUJBQWdCLFVBQVUsaUJBQWlCLFdBQVk7QUFDbkQsU0FBSyxTQUFTLFFBQVEsaUJBQWlCO0FBQ3ZDLFdBQU8sSUFBSSxvQkFBb0IsS0FBSyxRQUFRO0FBQUEsRUFDcEQ7QUFDSSxFQUFBQSxpQkFBZ0IsVUFBVSxtQkFBbUIsV0FBWTtBQUNyRCxTQUFLLFNBQVMsUUFBUSxpQkFBaUI7QUFDdkMsV0FBTyxJQUFJLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNwRDtBQUNJLEVBQUFBLGlCQUFnQixVQUFVLG1CQUFtQixXQUFZO0FBQ3JELFNBQUssU0FBUyxRQUFRLGlCQUFpQjtBQUN2QyxXQUFPLElBQUksb0JBQW9CLEtBQUssUUFBUTtBQUFBLEVBQ3BEO0FBQ0ksU0FBT0E7QUFDWDtBQ2hCQSxJQUFJLHdCQUF5QixXQUFZO0FBQ3JDLFdBQVNDLHVCQUFzQixTQUFTO0FBQ3BDLFNBQUssV0FBVztBQUNoQixTQUFLLHFCQUFxQixJQUFJLGtCQUFrQixLQUFLLFFBQVE7QUFDN0QsU0FBSyxtQkFBbUIsSUFBSSxnQkFBZ0IsS0FBSyxRQUFRO0FBQ3pELFNBQUssbUJBQW1CLElBQUksZ0JBQWdCLE9BQU87QUFBQSxFQUN0RDtBQUNELEVBQUFBLHVCQUFzQixVQUFVLGlCQUFpQixXQUFZO0FBQ3pELFdBQU8sS0FBSyxpQkFBaUI7RUFDckM7QUFDSSxFQUFBQSx1QkFBc0IsVUFBVSxtQkFBbUIsV0FBWTtBQUMzRCxXQUFPLEtBQUssaUJBQWlCO0VBQ3JDO0FBQ0ksRUFBQUEsdUJBQXNCLFVBQVUsbUJBQW1CLFdBQVk7QUFDM0QsV0FBTyxLQUFLLGlCQUFpQjtFQUNyQztBQUNJLEVBQUFBLHVCQUFzQixVQUFVLE9BQU8sU0FBVSxZQUFZO0FBQ3pELFdBQU8sS0FBSyxtQkFBbUIsS0FBSyxVQUFVO0FBQUEsRUFDdEQ7QUFDSSxFQUFBQSx1QkFBc0IsVUFBVSxrQkFBa0IsU0FBVXBNLE9BQU07QUFDOUQsV0FBTyxLQUFLLG1CQUFtQixnQkFBZ0JBLEtBQUk7QUFBQSxFQUMzRDtBQUNJLEVBQUFvTSx1QkFBc0IsVUFBVSxzQkFBc0IsV0FBWTtBQUM5RCxXQUFPLEtBQUssbUJBQW1CO0VBQ3ZDO0FBQ0ksRUFBQUEsdUJBQXNCLFVBQVUsbUJBQW1CLFNBQVUsS0FBSyxPQUFPO0FBQ3JFLFdBQU8sS0FBSyxtQkFBbUIsaUJBQWlCLEtBQUssS0FBSztBQUFBLEVBQ2xFO0FBQ0ksRUFBQUEsdUJBQXNCLFVBQVUsbUJBQW1CLFNBQVUsUUFBUTtBQUNqRSxXQUFPLEtBQUssbUJBQW1CLGlCQUFpQixNQUFNO0FBQUEsRUFDOUQ7QUFDSSxFQUFBQSx1QkFBc0IsVUFBVSxrQkFBa0IsU0FBVXBNLE9BQU07QUFDOUQsV0FBTyxLQUFLLG1CQUFtQixnQkFBZ0JBLEtBQUk7QUFBQSxFQUMzRDtBQUNJLEVBQUFvTSx1QkFBc0IsVUFBVSxtQkFBbUIsU0FBVSxLQUFLLE9BQU87QUFDckUsV0FBTyxLQUFLLG1CQUFtQixpQkFBaUIsS0FBSyxLQUFLO0FBQUEsRUFDbEU7QUFDSSxFQUFBQSx1QkFBc0IsVUFBVSxvQkFBb0IsU0FBVSxVQUFVO0FBQ3BFLFdBQU8sS0FBSyxtQkFBbUIsa0JBQWtCLFFBQVE7QUFBQSxFQUNqRTtBQUNJLEVBQUFBLHVCQUFzQixVQUFVLG1CQUFtQixTQUFVLFVBQVU7QUFDbkUsV0FBTyxLQUFLLG1CQUFtQixpQkFBaUIsUUFBUTtBQUFBLEVBQ2hFO0FBQ0ksRUFBQUEsdUJBQXNCLFVBQVUsdUJBQXVCLFNBQVVwTSxPQUFNO0FBQ25FLFdBQU8sS0FBSyxtQkFBbUIscUJBQXFCQSxLQUFJO0FBQUEsRUFDaEU7QUFDSSxFQUFBb00sdUJBQXNCLFVBQVUsd0JBQXdCLFNBQVUsS0FBSyxPQUFPO0FBQzFFLFdBQU8sS0FBSyxtQkFBbUIsc0JBQXNCLEtBQUssS0FBSztBQUFBLEVBQ3ZFO0FBQ0ksRUFBQUEsdUJBQXNCLFVBQVUsc0JBQXNCLFNBQVVwTSxPQUFNO0FBQ2xFLFdBQU8sS0FBSyxtQkFBbUIsb0JBQW9CQSxLQUFJO0FBQUEsRUFDL0Q7QUFDSSxFQUFBb00sdUJBQXNCLFVBQVUsdUJBQXVCLFNBQVUsS0FBSyxPQUFPO0FBQ3pFLFdBQU8sS0FBSyxtQkFBbUIscUJBQXFCLEtBQUssS0FBSztBQUFBLEVBQ3RFO0FBQ0ksRUFBQUEsdUJBQXNCLFVBQVUseUJBQXlCLFNBQVUsWUFBWTtBQUMzRSxXQUFPLEtBQUssbUJBQW1CLHVCQUF1QixVQUFVO0FBQUEsRUFDeEU7QUFDSSxFQUFBQSx1QkFBc0IsVUFBVSx3QkFBd0IsU0FBVSxZQUFZO0FBQzFFLFdBQU8sS0FBSyxtQkFBbUIsc0JBQXNCLFVBQVU7QUFBQSxFQUN2RTtBQUNJLEVBQUFBLHVCQUFzQixVQUFVLGVBQWUsU0FBVSxTQUFTO0FBQzlELFdBQU8sS0FBSyxpQkFBaUIsYUFBYSxPQUFPO0FBQUEsRUFDekQ7QUFDSSxFQUFBQSx1QkFBc0IsVUFBVSxpQkFBaUIsU0FBVSxTQUFTO0FBQ2hFLFdBQU8sS0FBSyxpQkFBaUIsZUFBZSxPQUFPO0FBQUEsRUFDM0Q7QUFDSSxTQUFPQTtBQUNYO0FDbkVBLElBQUksa0JBQW1CLFdBQVk7QUFDL0IsV0FBU0MsaUJBQWdCLFNBQVM7QUFDOUIsU0FBSyxXQUFXO0FBQUEsRUFDbkI7QUFDRCxFQUFBQSxpQkFBZ0IsVUFBVSxLQUFLLFNBQVUsYUFBYTtBQUNsRCxTQUFLLFNBQVMsT0FBTyxnQkFBZ0I7QUFDckMsU0FBSyxTQUFTLHFCQUFxQjtBQUNuQyxXQUFPLElBQUksc0JBQXNCLEtBQUssUUFBUTtBQUFBLEVBQ3REO0FBQ0ksRUFBQUEsaUJBQWdCLFVBQVUsU0FBUyxXQUFZO0FBQzNDLFFBQUksT0FBTyxLQUFLLFNBQVMsc0JBQXNCLFlBQVk7QUFDdkQsWUFBTSxJQUFJLE1BQU0sS0FBS0MscUJBQWdDO0FBQUEsSUFDeEQ7QUFDRCxRQUFJOUksUUFBTyxLQUFLLFNBQVM7QUFDekIsV0FBTyxLQUFLLEdBQUdBLEtBQUk7QUFBQSxFQUMzQjtBQUNJLEVBQUE2SSxpQkFBZ0IsVUFBVSxrQkFBa0IsU0FBVSxPQUFPO0FBQ3pELFNBQUssU0FBUyxPQUFPLGdCQUFnQjtBQUNyQyxTQUFLLFNBQVMsUUFBUTtBQUN0QixTQUFLLFNBQVMsZUFBZTtBQUM3QixTQUFLLFNBQVMscUJBQXFCO0FBQ25DLFNBQUssU0FBUyxRQUFRLGlCQUFpQjtBQUN2QyxXQUFPLElBQUksb0JBQW9CLEtBQUssUUFBUTtBQUFBLEVBQ3BEO0FBQ0ksRUFBQUEsaUJBQWdCLFVBQVUsaUJBQWlCLFNBQVUsTUFBTTtBQUN2RCxTQUFLLFNBQVMsT0FBTyxnQkFBZ0I7QUFDckMsU0FBSyxTQUFTLFFBQVE7QUFDdEIsU0FBSyxTQUFTLGVBQWU7QUFDN0IsU0FBSyxTQUFTLHFCQUFxQjtBQUNuQyxXQUFPLElBQUksc0JBQXNCLEtBQUssUUFBUTtBQUFBLEVBQ3REO0FBQ0ksRUFBQUEsaUJBQWdCLFVBQVUsZ0JBQWdCLFNBQVUsYUFBYTtBQUM3RCxTQUFLLFNBQVMsT0FBTyxnQkFBZ0I7QUFDckMsU0FBSyxTQUFTLHFCQUFxQjtBQUNuQyxTQUFLLFNBQVMsUUFBUSxpQkFBaUI7QUFDdkMsV0FBTyxJQUFJLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNwRDtBQUNJLEVBQUFBLGlCQUFnQixVQUFVLFlBQVksU0FBVTNOLFVBQVM7QUFDckQsU0FBSyxTQUFTLE9BQU8sZ0JBQWdCO0FBQ3JDLFNBQUssU0FBUyxVQUFVQTtBQUN4QixTQUFLLFNBQVMsUUFBUSxpQkFBaUI7QUFDdkMsV0FBTyxJQUFJLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNwRDtBQUNJLEVBQUEyTixpQkFBZ0IsVUFBVSxhQUFhLFNBQVUsTUFBTTtBQUNuRCxRQUFJLE9BQU8sU0FBUyxZQUFZO0FBQzVCLFlBQU0sSUFBSSxNQUFNRSx3QkFBbUM7QUFBQSxJQUN0RDtBQUNELFFBQUksc0JBQXNCLEtBQUssZ0JBQWdCLElBQUk7QUFDbkQsU0FBSyxTQUFTLE9BQU8sZ0JBQWdCO0FBQ3JDLFNBQUssU0FBUyxRQUFRLGlCQUFpQjtBQUN2QyxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFGLGlCQUFnQixVQUFVLGdCQUFnQixTQUFVLG1CQUFtQjtBQUNuRSxTQUFLLFNBQVMsT0FBTyxnQkFBZ0I7QUFDckMsU0FBSyxTQUFTLFVBQVUsU0FBVSxTQUFTO0FBQ3ZDLFVBQUksY0FBYyxXQUFZO0FBQUUsZUFBTyxRQUFRLFVBQVUsSUFBSSxpQkFBaUI7QUFBQTtBQUM5RSxhQUFPO0FBQUEsSUFDbkI7QUFDUSxTQUFLLFNBQVMsUUFBUSxpQkFBaUI7QUFDdkMsV0FBTyxJQUFJLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNwRDtBQUNJLEVBQUFBLGlCQUFnQixVQUFVLHFCQUFxQixTQUFVLG1CQUFtQjtBQUN4RSxTQUFLLFNBQVMsT0FBTyxnQkFBZ0I7QUFDckMsU0FBSyxTQUFTLFVBQVUsU0FBVSxTQUFTO0FBQ3ZDLGFBQU8sU0FBVSxPQUFPO0FBQUUsZUFBTyxRQUFRLFVBQVUsU0FBUyxtQkFBbUIsS0FBSztBQUFBO0lBQ2hHO0FBQ1EsV0FBTyxJQUFJLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNwRDtBQUNJLEVBQUFBLGlCQUFnQixVQUFVLGFBQWEsU0FBVSxVQUFVO0FBQ3ZELFNBQUssU0FBUyxPQUFPLGdCQUFnQjtBQUNyQyxTQUFLLFNBQVMsV0FBVztBQUN6QixTQUFLLFNBQVMsUUFBUSxpQkFBaUI7QUFDdkMsV0FBTyxJQUFJLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNwRDtBQUNJLEVBQUFBLGlCQUFnQixVQUFVLFlBQVksU0FBVSxTQUFTO0FBQ3JELFNBQUssZUFBZSxTQUFVLFNBQVM7QUFBRSxhQUFPLFFBQVEsVUFBVSxJQUFJLE9BQU87QUFBQSxJQUFFLENBQUU7QUFBQSxFQUN6RjtBQUNJLFNBQU9BO0FBQ1g7QUNsRkEsSUFBSSxvQkFBcUIsV0FBWTtBQUNqQyxXQUFTRyxxQkFBb0I7QUFBQSxFQUM1QjtBQUNELEVBQUFBLG1CQUFrQixLQUFLLFNBQVUsVUFBVSxZQUFZLGFBQWEsZUFBZSx1QkFBdUI7QUFDdEcsUUFBSSxXQUFXLElBQUlBO0FBQ25CLGFBQVMsV0FBVztBQUNwQixhQUFTLGFBQWE7QUFDdEIsYUFBUyxnQkFBZ0I7QUFDekIsYUFBUyxjQUFjO0FBQ3ZCLGFBQVMsd0JBQXdCO0FBQ2pDLFdBQU87QUFBQSxFQUNmO0FBQ0ksU0FBT0E7QUFDWDtBQ2JBLFNBQVMsV0FBVyxLQUFLO0FBQ3JCLFNBQVEsT0FBTyxRQUFRLFlBQ2YsUUFBUSxRQUNSLFdBQVcsT0FDWixPQUFPLElBQUksVUFBVTtBQUNoQztBQ0hBLElBQUksU0FBVSxXQUFZO0FBQ3RCLFdBQVNDLFVBQVM7QUFDZCxTQUFLLE9BQU8sb0JBQUk7RUFDbkI7QUFDRCxFQUFBQSxRQUFPLFVBQVUsU0FBUyxXQUFZO0FBQ2xDLFdBQU8sS0FBSztBQUFBLEVBQ3BCO0FBQ0ksRUFBQUEsUUFBTyxVQUFVLE1BQU0sU0FBVSxtQkFBbUIsT0FBTztBQUN2RCxRQUFJLHNCQUFzQixRQUFRLHNCQUFzQixRQUFXO0FBQy9ELFlBQU0sSUFBSSxNQUFNQyxhQUF3QjtBQUFBLElBQzNDO0FBQ0QsUUFBSSxVQUFVLFFBQVEsVUFBVSxRQUFXO0FBQ3ZDLFlBQU0sSUFBSSxNQUFNQSxhQUF3QjtBQUFBLElBQzNDO0FBQ0QsUUFBSSxRQUFRLEtBQUssS0FBSyxJQUFJLGlCQUFpQjtBQUMzQyxRQUFJLFVBQVUsUUFBVztBQUNyQixZQUFNLEtBQUssS0FBSztBQUFBLElBQ25CLE9BQ0k7QUFDRCxXQUFLLEtBQUssSUFBSSxtQkFBbUIsQ0FBQyxLQUFLLENBQUM7QUFBQSxJQUMzQztBQUFBLEVBQ1Q7QUFDSSxFQUFBRCxRQUFPLFVBQVUsTUFBTSxTQUFVLG1CQUFtQjtBQUNoRCxRQUFJLHNCQUFzQixRQUFRLHNCQUFzQixRQUFXO0FBQy9ELFlBQU0sSUFBSSxNQUFNQyxhQUF3QjtBQUFBLElBQzNDO0FBQ0QsUUFBSSxRQUFRLEtBQUssS0FBSyxJQUFJLGlCQUFpQjtBQUMzQyxRQUFJLFVBQVUsUUFBVztBQUNyQixhQUFPO0FBQUEsSUFDVixPQUNJO0FBQ0QsWUFBTSxJQUFJLE1BQU1DLGFBQXdCO0FBQUEsSUFDM0M7QUFBQSxFQUNUO0FBQ0ksRUFBQUYsUUFBTyxVQUFVLFNBQVMsU0FBVSxtQkFBbUI7QUFDbkQsUUFBSSxzQkFBc0IsUUFBUSxzQkFBc0IsUUFBVztBQUMvRCxZQUFNLElBQUksTUFBTUMsYUFBd0I7QUFBQSxJQUMzQztBQUNELFFBQUksQ0FBQyxLQUFLLEtBQUssT0FBTyxpQkFBaUIsR0FBRztBQUN0QyxZQUFNLElBQUksTUFBTUMsYUFBd0I7QUFBQSxJQUMzQztBQUFBLEVBQ1Q7QUFDSSxFQUFBRixRQUFPLFVBQVUscUJBQXFCLFNBQVUsUUFBUTtBQUNwRCxRQUFJLFFBQVE7QUFDWixTQUFLLFNBQVMsU0FBVSxtQkFBbUIsT0FBTztBQUM5QyxVQUFJLG9CQUFvQixPQUFPLE9BQU8saUJBQWlCLElBQUksT0FBTyxJQUFJLGlCQUFpQixJQUFJO0FBQzNGLFVBQUksc0JBQXNCLFFBQVc7QUFDakMsWUFBSSxpQkFBaUIsTUFBTSxPQUFPLFNBQVUsYUFBYTtBQUNyRCxpQkFBTyxDQUFDLGtCQUFrQixLQUFLLFNBQVUsa0JBQWtCO0FBQUUsbUJBQU8sZ0JBQWdCO0FBQUEsVUFBaUIsQ0FBRTtBQUFBLFFBQzNILENBQWlCO0FBQ0QsY0FBTSxVQUFVLG1CQUFtQixjQUFjO0FBQUEsTUFDcEQ7QUFBQSxJQUNiLENBQVM7QUFBQSxFQUNUO0FBQ0ksRUFBQUEsUUFBTyxVQUFVLG9CQUFvQixTQUFVLFdBQVc7QUFDdEQsUUFBSSxRQUFRO0FBQ1osUUFBSSxXQUFXLENBQUE7QUFDZixTQUFLLEtBQUssUUFBUSxTQUFVLFNBQVMsS0FBSztBQUN0QyxVQUFJLGlCQUFpQixDQUFBO0FBQ3JCLGVBQVMsS0FBSyxHQUFHLFlBQVksU0FBUyxLQUFLLFVBQVUsUUFBUSxNQUFNO0FBQy9ELFlBQUksUUFBUSxVQUFVLEVBQUU7QUFDeEIsWUFBSSxTQUFTLFVBQVUsS0FBSztBQUM1QixZQUFJLFFBQVE7QUFDUixtQkFBUyxLQUFLLEtBQUs7QUFBQSxRQUN0QixPQUNJO0FBQ0QseUJBQWUsS0FBSyxLQUFLO0FBQUEsUUFDNUI7QUFBQSxNQUNKO0FBQ0QsWUFBTSxVQUFVLEtBQUssY0FBYztBQUFBLElBQy9DLENBQVM7QUFDRCxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFBLFFBQU8sVUFBVSxTQUFTLFNBQVUsbUJBQW1CO0FBQ25ELFFBQUksc0JBQXNCLFFBQVEsc0JBQXNCLFFBQVc7QUFDL0QsWUFBTSxJQUFJLE1BQU1DLGFBQXdCO0FBQUEsSUFDM0M7QUFDRCxXQUFPLEtBQUssS0FBSyxJQUFJLGlCQUFpQjtBQUFBLEVBQzlDO0FBQ0ksRUFBQUQsUUFBTyxVQUFVLFFBQVEsV0FBWTtBQUNqQyxRQUFJLE9BQU8sSUFBSUE7QUFDZixTQUFLLEtBQUssUUFBUSxTQUFVLE9BQU8sS0FBSztBQUNwQyxZQUFNLFFBQVEsU0FBVWpMLElBQUc7QUFBRSxlQUFPLEtBQUssSUFBSSxLQUFLLFdBQVdBLEVBQUMsSUFBSUEsR0FBRSxNQUFPLElBQUdBLEVBQUM7QUFBQSxNQUFFLENBQUU7QUFBQSxJQUMvRixDQUFTO0FBQ0QsV0FBTztBQUFBLEVBQ2Y7QUFDSSxFQUFBaUwsUUFBTyxVQUFVLFdBQVcsU0FBVSxNQUFNO0FBQ3hDLFNBQUssS0FBSyxRQUFRLFNBQVUsT0FBTyxLQUFLO0FBQ3BDLFdBQUssS0FBSyxLQUFLO0FBQUEsSUFDM0IsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxFQUFBQSxRQUFPLFVBQVUsWUFBWSxTQUFVLG1CQUFtQixPQUFPO0FBQzdELFFBQUksTUFBTSxTQUFTLEdBQUc7QUFDbEIsV0FBSyxLQUFLLElBQUksbUJBQW1CLEtBQUs7QUFBQSxJQUN6QyxPQUNJO0FBQ0QsV0FBSyxLQUFLLE9BQU8saUJBQWlCO0FBQUEsSUFDckM7QUFBQSxFQUNUO0FBQ0ksU0FBT0E7QUFDWDtBQ3JHQSxJQUFJLHdCQUF5QixXQUFZO0FBQ3JDLFdBQVNHLHlCQUF3QjtBQUM3QixTQUFLLE9BQU8sb0JBQUk7RUFDbkI7QUFDRCxFQUFBQSx1QkFBc0IsVUFBVSxTQUFTLFNBQVUsVUFBVTtBQUN6RCxRQUFJLEtBQUssS0FBSyxJQUFJLFFBQVEsR0FBRztBQUN6QixVQUFJLFdBQVcsS0FBSyxLQUFLLElBQUksUUFBUTtBQUNyQyxXQUFLLEtBQUssT0FBTyxRQUFRO0FBQ3pCLGFBQU87QUFBQSxJQUNWO0FBQ0QsV0FBTyxLQUFLO0VBQ3BCO0FBQ0ksRUFBQUEsdUJBQXNCLFVBQVUsa0JBQWtCLFNBQVUsVUFBVSxtQkFBbUIsZ0JBQWdCO0FBQ3JHLFNBQUssNkJBQTZCLFFBQVEsRUFDckMsZ0JBQWdCLElBQUksbUJBQW1CLGNBQWM7QUFBQSxFQUNsRTtBQUNJLEVBQUFBLHVCQUFzQixVQUFVLGdCQUFnQixTQUFVLFVBQVUsbUJBQW1CLGNBQWM7QUFDakcsU0FBSyw2QkFBNkIsUUFBUSxFQUNyQyxjQUFjLElBQUksbUJBQW1CLFlBQVk7QUFBQSxFQUM5RDtBQUNJLEVBQUFBLHVCQUFzQixVQUFVLFFBQVEsV0FBWTtBQUNoRCxRQUFJLFFBQVEsSUFBSUE7QUFDaEIsU0FBSyxLQUFLLFFBQVEsU0FBVSxlQUFlLFVBQVU7QUFDakQsWUFBTSxLQUFLLElBQUksVUFBVTtBQUFBLFFBQ3JCLGVBQWUsY0FBYyxjQUFjLE1BQU87QUFBQSxRQUNsRCxpQkFBaUIsY0FBYyxnQkFBZ0IsTUFBTztBQUFBLE1BQ3RFLENBQWE7QUFBQSxJQUNiLENBQVM7QUFDRCxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFBLHVCQUFzQixVQUFVLCtCQUErQixTQUFVLFVBQVU7QUFDL0UsUUFBSSwyQkFBMkIsS0FBSyxLQUFLLElBQUksUUFBUTtBQUNyRCxRQUFJLDZCQUE2QixRQUFXO0FBQ3hDLGlDQUEyQixLQUFLO0FBQ2hDLFdBQUssS0FBSyxJQUFJLFVBQVUsd0JBQXdCO0FBQUEsSUFDbkQ7QUFDRCxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFBLHVCQUFzQixVQUFVLHlCQUF5QixXQUFZO0FBQ2pFLFFBQUksZ0JBQWdCO0FBQUEsTUFDaEIsZUFBZSxJQUFJLE9BQVE7QUFBQSxNQUMzQixpQkFBaUIsSUFBSSxPQUFRO0FBQUEsSUFDekM7QUFDUSxXQUFPO0FBQUEsRUFDZjtBQUNJLFNBQU9BO0FBQ1g7QUMvQ0EsSUFBSSxXQUFZbEMsY0FBUUEsV0FBSyxZQUFhLFdBQVk7QUFDbEQsYUFBVyxPQUFPLFVBQVUsU0FBU3JLLElBQUc7QUFDcEMsYUFBUyxHQUFHLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUNqRCxVQUFJLFVBQVUsQ0FBQztBQUNmLGVBQVMsS0FBSztBQUFHLFlBQUksT0FBTyxVQUFVLGVBQWUsS0FBSyxHQUFHLENBQUM7QUFDMUQsVUFBQUEsR0FBRSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQUEsSUFDakI7QUFDRCxXQUFPQTtBQUFBLEVBQ2Y7QUFDSSxTQUFPLFNBQVMsTUFBTSxNQUFNLFNBQVM7QUFDekM7QUFDQSxJQUFJLFlBQWFxSyxjQUFRQSxXQUFLLGFBQWMsU0FBVSxTQUFTLFlBQVk3TCxJQUFHLFdBQVc7QUFDckYsV0FBUyxNQUFNLE9BQU87QUFBRSxXQUFPLGlCQUFpQkEsS0FBSSxRQUFRLElBQUlBLEdBQUUsU0FBVWtJLFVBQVM7QUFBRSxNQUFBQSxTQUFRLEtBQUs7QUFBQSxJQUFFLENBQUU7QUFBQSxFQUFJO0FBQzVHLFNBQU8sS0FBS2xJLE9BQU1BLEtBQUksVUFBVSxTQUFVa0ksVUFBUyxRQUFRO0FBQ3ZELGFBQVMsVUFBVSxPQUFPO0FBQUUsVUFBSTtBQUFFLGFBQUssVUFBVSxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQUUsU0FBVSxHQUFQO0FBQVksZUFBTyxDQUFDO0FBQUE7SUFBTTtBQUMzRixhQUFTLFNBQVMsT0FBTztBQUFFLFVBQUk7QUFBRSxhQUFLLFVBQVUsT0FBTyxFQUFFLEtBQUssQ0FBQztBQUFBLE1BQUksU0FBUSxHQUFQO0FBQVksZUFBTyxDQUFDO0FBQUE7SUFBTTtBQUM5RixhQUFTLEtBQUssUUFBUTtBQUFFLGFBQU8sT0FBT0EsU0FBUSxPQUFPLEtBQUssSUFBSSxNQUFNLE9BQU8sS0FBSyxFQUFFLEtBQUssV0FBVyxRQUFRO0FBQUEsSUFBSTtBQUM5RyxVQUFNLFlBQVksVUFBVSxNQUFNLFNBQVMsY0FBYyxDQUFFLENBQUEsR0FBRyxLQUFJLENBQUU7QUFBQSxFQUM1RSxDQUFLO0FBQ0w7QUFDQSxJQUFJLGNBQWUyRCxjQUFRQSxXQUFLLGVBQWdCLFNBQVUsU0FBUyxNQUFNO0FBQ3JFLE1BQUlsTCxLQUFJLEVBQUUsT0FBTyxHQUFHLE1BQU0sV0FBVztBQUFFLFFBQUlhLEdBQUUsQ0FBQyxJQUFJO0FBQUcsWUFBTUEsR0FBRSxDQUFDO0FBQUcsV0FBT0EsR0FBRSxDQUFDO0FBQUEsRUFBSSxHQUFFLE1BQU0sQ0FBRSxHQUFFLEtBQUssQ0FBQSxFQUFJLEdBQUUsR0FBRyxHQUFHQSxJQUFHO0FBQy9HLFNBQU8sSUFBSSxFQUFFLE1BQU0sS0FBSyxDQUFDLEdBQUcsU0FBUyxLQUFLLENBQUMsR0FBRyxVQUFVLEtBQUssQ0FBQyxFQUFHLEdBQUUsT0FBTyxXQUFXLGVBQWUsRUFBRSxPQUFPLFFBQVEsSUFBSSxXQUFXO0FBQUUsV0FBTztBQUFBLEVBQU8sSUFBRztBQUN2SixXQUFTLEtBQUssR0FBRztBQUFFLFdBQU8sU0FBVSxHQUFHO0FBQUUsYUFBTyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFBQSxJQUFJO0FBQUEsRUFBRztBQUNsRSxXQUFTLEtBQUssSUFBSTtBQUNkLFFBQUk7QUFBRyxZQUFNLElBQUksVUFBVSxpQ0FBaUM7QUFDNUQsV0FBT2I7QUFBRyxVQUFJO0FBQ1YsWUFBSSxJQUFJLEdBQUcsTUFBTWEsS0FBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUUsUUFBUSxJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxPQUFPQSxLQUFJLEVBQUUsUUFBUSxNQUFNQSxHQUFFLEtBQUssQ0FBQyxHQUFHLEtBQUssRUFBRSxTQUFTLEVBQUVBLEtBQUlBLEdBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUc7QUFBTSxpQkFBT0E7QUFDM0osWUFBSSxJQUFJLEdBQUdBO0FBQUcsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUdBLEdBQUUsS0FBSztBQUN0QyxnQkFBUSxHQUFHLENBQUMsR0FBQztBQUFBLFVBQ1QsS0FBSztBQUFBLFVBQUcsS0FBSztBQUFHLFlBQUFBLEtBQUk7QUFBSTtBQUFBLFVBQ3hCLEtBQUs7QUFBRyxZQUFBYixHQUFFO0FBQVMsbUJBQU8sRUFBRSxPQUFPLEdBQUcsQ0FBQyxHQUFHLE1BQU0sTUFBSztBQUFBLFVBQ3JELEtBQUs7QUFBRyxZQUFBQSxHQUFFO0FBQVMsZ0JBQUksR0FBRyxDQUFDO0FBQUcsaUJBQUssQ0FBQyxDQUFDO0FBQUc7QUFBQSxVQUN4QyxLQUFLO0FBQUcsaUJBQUtBLEdBQUUsSUFBSTtBQUFPLFlBQUFBLEdBQUUsS0FBSyxJQUFHO0FBQUk7QUFBQSxVQUN4QztBQUNJLGdCQUFJLEVBQUVhLEtBQUliLEdBQUUsTUFBTWEsS0FBSUEsR0FBRSxTQUFTLEtBQUtBLEdBQUVBLEdBQUUsU0FBUyxDQUFDLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxHQUFHLENBQUMsTUFBTSxJQUFJO0FBQUUsY0FBQWIsS0FBSTtBQUFHO0FBQUEsWUFBVztBQUM1RyxnQkFBSSxHQUFHLENBQUMsTUFBTSxNQUFNLENBQUNhLE1BQU0sR0FBRyxDQUFDLElBQUlBLEdBQUUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJQSxHQUFFLENBQUMsSUFBSztBQUFFLGNBQUFiLEdBQUUsUUFBUSxHQUFHLENBQUM7QUFBRztBQUFBLFlBQVE7QUFDdEYsZ0JBQUksR0FBRyxDQUFDLE1BQU0sS0FBS0EsR0FBRSxRQUFRYSxHQUFFLENBQUMsR0FBRztBQUFFLGNBQUFiLEdBQUUsUUFBUWEsR0FBRSxDQUFDO0FBQUcsY0FBQUEsS0FBSTtBQUFJO0FBQUEsWUFBUTtBQUNyRSxnQkFBSUEsTUFBS2IsR0FBRSxRQUFRYSxHQUFFLENBQUMsR0FBRztBQUFFLGNBQUFiLEdBQUUsUUFBUWEsR0FBRSxDQUFDO0FBQUcsY0FBQWIsR0FBRSxJQUFJLEtBQUssRUFBRTtBQUFHO0FBQUEsWUFBUTtBQUNuRSxnQkFBSWEsR0FBRSxDQUFDO0FBQUcsY0FBQWIsR0FBRSxJQUFJLElBQUc7QUFDbkIsWUFBQUEsR0FBRSxLQUFLLElBQUs7QUFBRTtBQUFBLFFBQ3JCO0FBQ0QsYUFBSyxLQUFLLEtBQUssU0FBU0EsRUFBQztBQUFBLE1BQzVCLFNBQVEsR0FBUDtBQUFZLGFBQUssQ0FBQyxHQUFHLENBQUM7QUFBRyxZQUFJO0FBQUEsTUFBRSxVQUFXO0FBQUUsWUFBSWEsS0FBSTtBQUFBLE1BQUk7QUFDMUQsUUFBSSxHQUFHLENBQUMsSUFBSTtBQUFHLFlBQU0sR0FBRyxDQUFDO0FBQUcsV0FBTyxFQUFFLE9BQU8sR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksUUFBUSxNQUFNO0VBQzdFO0FBQ0w7QUFDQSxJQUFJLGdCQUFpQnFLLGNBQVFBLFdBQUssaUJBQWtCLFNBQVUsSUFBSSxNQUFNLE1BQU07QUFDMUUsTUFBSSxRQUFRLFVBQVUsV0FBVztBQUFHLGFBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLElBQUksSUFBSSxHQUFHLEtBQUs7QUFDakYsVUFBSSxNQUFNLEVBQUUsS0FBSyxPQUFPO0FBQ3BCLFlBQUksQ0FBQztBQUFJLGVBQUssTUFBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLEdBQUcsQ0FBQztBQUNuRCxXQUFHLENBQUMsSUFBSSxLQUFLLENBQUM7QUFBQSxNQUNqQjtBQUFBLElBQ0o7QUFDRCxTQUFPLEdBQUcsT0FBTyxNQUFNLE1BQU0sVUFBVSxNQUFNLEtBQUssSUFBSSxDQUFDO0FBQzNEO0FBZUEsSUFBSSxZQUFhLFdBQVk7QUFDekIsV0FBU21DLFdBQVUsa0JBQWtCO0FBQ2pDLFFBQUksVUFBVSxvQkFBb0I7QUFDbEMsUUFBSSxPQUFPLFlBQVksVUFBVTtBQUM3QixZQUFNLElBQUksTUFBTSxLQUFLQyxtQ0FBOEM7QUFBQSxJQUN0RTtBQUNELFFBQUksUUFBUSxpQkFBaUIsUUFBVztBQUNwQyxjQUFRLGVBQWUsaUJBQWlCO0FBQUEsSUFDM0MsV0FDUSxRQUFRLGlCQUFpQixpQkFBaUIsYUFDL0MsUUFBUSxpQkFBaUIsaUJBQWlCLGFBQzFDLFFBQVEsaUJBQWlCLGlCQUFpQixTQUFTO0FBQ25ELFlBQU0sSUFBSSxNQUFNLEtBQUtDLHVDQUFrRDtBQUFBLElBQzFFO0FBQ0QsUUFBSSxRQUFRLHVCQUF1QixRQUFXO0FBQzFDLGNBQVEscUJBQXFCO0FBQUEsSUFDaEMsV0FDUSxPQUFPLFFBQVEsdUJBQXVCLFdBQVc7QUFDdEQsWUFBTSxJQUFJLE1BQU0sS0FBS0MsOENBQXlEO0FBQUEsSUFDakY7QUFDRCxRQUFJLFFBQVEsd0JBQXdCLFFBQVc7QUFDM0MsY0FBUSxzQkFBc0I7QUFBQSxJQUNqQyxXQUNRLE9BQU8sUUFBUSx3QkFBd0IsV0FBVztBQUN2RCxZQUFNLElBQUksTUFBTSxLQUFLQyx5Q0FBb0Q7QUFBQSxJQUM1RTtBQUNELFNBQUssVUFBVTtBQUFBLE1BQ1gsb0JBQW9CLFFBQVE7QUFBQSxNQUM1QixjQUFjLFFBQVE7QUFBQSxNQUN0QixxQkFBcUIsUUFBUTtBQUFBLElBQ3pDO0FBQ1EsU0FBSyxLQUFLO0FBQ1YsU0FBSyxxQkFBcUIsSUFBSTtBQUM5QixTQUFLLGFBQWE7QUFDbEIsU0FBSyxjQUFjO0FBQ25CLFNBQUssZUFBZSxJQUFJO0FBQ3hCLFNBQUssaUJBQWlCLElBQUk7QUFDMUIsU0FBSyxTQUFTO0FBQ2QsU0FBSyxrQkFBa0IsSUFBSTtBQUMzQixTQUFLLHlCQUF5QixJQUFJO0VBQ3JDO0FBQ0QsRUFBQUosV0FBVSxRQUFRLFNBQVUsWUFBWSxZQUFZO0FBQ2hELFFBQUksYUFBYSxDQUFBO0FBQ2pCLGFBQVMsS0FBSyxHQUFHLEtBQUssVUFBVSxRQUFRLE1BQU07QUFDMUMsaUJBQVcsS0FBSyxDQUFDLElBQUksVUFBVSxFQUFFO0FBQUEsSUFDcEM7QUFDRCxRQUFJakQsYUFBWSxJQUFJaUQ7QUFDcEIsUUFBSSxtQkFBbUIsY0FBYyxDQUFDLFlBQVksVUFBVSxHQUFHLFlBQVksSUFBSSxFQUFFLElBQUksU0FBVSxpQkFBaUI7QUFBRSxhQUFPLHFCQUFxQixlQUFlO0FBQUEsSUFBRSxDQUFFO0FBQ2pLLFFBQUksb0JBQW9CLHFCQUFxQmpELFVBQVM7QUFDdEQsYUFBUyxlQUFlLFFBQVEsYUFBYTtBQUN6QyxhQUFPLFNBQVMsU0FBVSxNQUFNLE9BQU87QUFDbkMsY0FBTSxRQUFRLFNBQVUsU0FBUztBQUM3QixzQkFBWSxJQUFJLFFBQVEsbUJBQW1CLFFBQVEsTUFBSyxDQUFFO0FBQUEsUUFDOUUsQ0FBaUI7QUFBQSxNQUNqQixDQUFhO0FBQUEsSUFDSjtBQUNELHFCQUFpQixRQUFRLFNBQVUseUJBQXlCO0FBQ3hELHFCQUFlLHlCQUF5QixpQkFBaUI7QUFBQSxJQUNyRSxDQUFTO0FBQ0QsV0FBT0E7QUFBQSxFQUNmO0FBQ0ksRUFBQWlELFdBQVUsVUFBVSxPQUFPLFdBQVk7QUFDbkMsUUFBSSxVQUFVLENBQUE7QUFDZCxhQUFTLEtBQUssR0FBRyxLQUFLLFVBQVUsUUFBUSxNQUFNO0FBQzFDLGNBQVEsRUFBRSxJQUFJLFVBQVUsRUFBRTtBQUFBLElBQzdCO0FBQ0QsUUFBSSxhQUFhLEtBQUs7QUFDdEIsYUFBUzlOLE1BQUssR0FBRyxZQUFZLFNBQVNBLE1BQUssVUFBVSxRQUFRQSxPQUFNO0FBQy9ELFVBQUksZ0JBQWdCLFVBQVVBLEdBQUU7QUFDaEMsVUFBSSx5QkFBeUIsV0FBVyxjQUFjLEVBQUU7QUFDeEQsb0JBQWMsU0FBUyx1QkFBdUIsY0FBYyx1QkFBdUIsZ0JBQWdCLHVCQUF1QixpQkFBaUIsdUJBQXVCLGdCQUFnQix1QkFBdUIscUJBQXFCLHVCQUF1QixzQkFBc0IsdUJBQXVCLHNCQUFzQjtBQUFBLElBQzNUO0FBQUEsRUFDVDtBQUNJLEVBQUE4TixXQUFVLFVBQVUsWUFBWSxXQUFZO0FBQ3hDLFFBQUksVUFBVSxDQUFBO0FBQ2QsYUFBUyxLQUFLLEdBQUcsS0FBSyxVQUFVLFFBQVEsTUFBTTtBQUMxQyxjQUFRLEVBQUUsSUFBSSxVQUFVLEVBQUU7QUFBQSxJQUM3QjtBQUNELFdBQU8sVUFBVSxNQUFNLFFBQVEsUUFBUSxXQUFZO0FBQy9DLFVBQUksWUFBWTlOLEtBQUksV0FBVyxlQUFlO0FBQzlDLGFBQU8sWUFBWSxNQUFNLFNBQVUsSUFBSTtBQUNuQyxnQkFBUSxHQUFHLE9BQUs7QUFBQSxVQUNaLEtBQUs7QUFDRCx5QkFBYSxLQUFLO0FBQ2xCLFlBQUFBLE1BQUssR0FBRyxZQUFZO0FBQ3BCLGVBQUcsUUFBUTtBQUFBLFVBQ2YsS0FBSztBQUNELGdCQUFJLEVBQUVBLE1BQUssVUFBVTtBQUFTLHFCQUFPLENBQUMsR0FBRyxDQUFDO0FBQzFDLDRCQUFnQixVQUFVQSxHQUFFO0FBQzVCLHFDQUF5QixXQUFXLGNBQWMsRUFBRTtBQUNwRCxtQkFBTyxDQUFDLEdBQUcsY0FBYyxTQUFTLHVCQUF1QixjQUFjLHVCQUF1QixnQkFBZ0IsdUJBQXVCLGlCQUFpQix1QkFBdUIsZ0JBQWdCLHVCQUF1QixxQkFBcUIsdUJBQXVCLHNCQUFzQix1QkFBdUIsc0JBQXNCLENBQUM7QUFBQSxVQUN4VSxLQUFLO0FBQ0QsZUFBRyxLQUFJO0FBQ1AsZUFBRyxRQUFRO0FBQUEsVUFDZixLQUFLO0FBQ0QsWUFBQUE7QUFDQSxtQkFBTyxDQUFDLEdBQUcsQ0FBQztBQUFBLFVBQ2hCLEtBQUs7QUFBRyxtQkFBTyxDQUFDLENBQUM7QUFBQSxRQUNwQjtBQUFBLE1BQ2pCLENBQWE7QUFBQSxJQUNiLENBQVM7QUFBQSxFQUNUO0FBQ0ksRUFBQThOLFdBQVUsVUFBVSxTQUFTLFdBQVk7QUFDckMsUUFBSSxRQUFRO0FBQ1osUUFBSSxVQUFVLENBQUE7QUFDZCxhQUFTLEtBQUssR0FBRyxLQUFLLFVBQVUsUUFBUSxNQUFNO0FBQzFDLGNBQVEsRUFBRSxJQUFJLFVBQVUsRUFBRTtBQUFBLElBQzdCO0FBQ0QsWUFBUSxRQUFRLFNBQVUxTCxTQUFRO0FBQzlCLFVBQUksZ0JBQWdCLE1BQU0sc0JBQXNCQSxRQUFPLEVBQUU7QUFDekQsWUFBTSxzQkFBc0IsYUFBYTtBQUN6QyxZQUFNLHNCQUFzQkEsUUFBTyxFQUFFO0FBQUEsSUFDakQsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxFQUFBMEwsV0FBVSxVQUFVLGNBQWMsV0FBWTtBQUMxQyxRQUFJLFVBQVUsQ0FBQTtBQUNkLGFBQVMsS0FBSyxHQUFHLEtBQUssVUFBVSxRQUFRLE1BQU07QUFDMUMsY0FBUSxFQUFFLElBQUksVUFBVSxFQUFFO0FBQUEsSUFDN0I7QUFDRCxXQUFPLFVBQVUsTUFBTSxRQUFRLFFBQVEsV0FBWTtBQUMvQyxVQUFJOU4sS0FBSSxXQUFXLFVBQVU7QUFDN0IsYUFBTyxZQUFZLE1BQU0sU0FBVSxJQUFJO0FBQ25DLGdCQUFRLEdBQUcsT0FBSztBQUFBLFVBQ1osS0FBSztBQUNELFlBQUFBLE1BQUssR0FBRyxZQUFZO0FBQ3BCLGVBQUcsUUFBUTtBQUFBLFVBQ2YsS0FBSztBQUNELGdCQUFJLEVBQUVBLE1BQUssVUFBVTtBQUFTLHFCQUFPLENBQUMsR0FBRyxDQUFDO0FBQzFDLHVCQUFXLFVBQVVBLEdBQUU7QUFDdkIsNEJBQWdCLEtBQUssc0JBQXNCLFNBQVMsRUFBRTtBQUN0RCxtQkFBTyxDQUFDLEdBQUcsS0FBSywyQkFBMkIsYUFBYSxDQUFDO0FBQUEsVUFDN0QsS0FBSztBQUNELGVBQUcsS0FBSTtBQUNQLGlCQUFLLHNCQUFzQixTQUFTLEVBQUU7QUFDdEMsZUFBRyxRQUFRO0FBQUEsVUFDZixLQUFLO0FBQ0QsWUFBQUE7QUFDQSxtQkFBTyxDQUFDLEdBQUcsQ0FBQztBQUFBLFVBQ2hCLEtBQUs7QUFBRyxtQkFBTyxDQUFDLENBQUM7QUFBQSxRQUNwQjtBQUFBLE1BQ2pCLENBQWE7QUFBQSxJQUNiLENBQVM7QUFBQSxFQUNUO0FBQ0ksRUFBQThOLFdBQVUsVUFBVSxPQUFPLFNBQVUsbUJBQW1CO0FBQ3BELFFBQUksUUFBUSxLQUFLLFFBQVEsZ0JBQWdCLGlCQUFpQjtBQUMxRCxRQUFJLFVBQVUsSUFBSSxRQUFRLG1CQUFtQixLQUFLO0FBQ2xELFNBQUssbUJBQW1CLElBQUksbUJBQW1CLE9BQU87QUFDdEQsV0FBTyxJQUFJLGdCQUFnQixPQUFPO0FBQUEsRUFDMUM7QUFDSSxFQUFBQSxXQUFVLFVBQVUsU0FBUyxTQUFVLG1CQUFtQjtBQUN0RCxTQUFLLE9BQU8saUJBQWlCO0FBQzdCLFdBQU8sS0FBSyxLQUFLLGlCQUFpQjtBQUFBLEVBQzFDO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLGNBQWMsU0FBVSxtQkFBbUI7QUFDM0QsV0FBTyxVQUFVLE1BQU0sUUFBUSxRQUFRLFdBQVk7QUFDL0MsYUFBTyxZQUFZLE1BQU0sU0FBVTlOLEtBQUk7QUFDbkMsZ0JBQVFBLElBQUcsT0FBSztBQUFBLFVBQ1osS0FBSztBQUFHLG1CQUFPLENBQUMsR0FBRyxLQUFLLFlBQVksaUJBQWlCLENBQUM7QUFBQSxVQUN0RCxLQUFLO0FBQ0QsWUFBQUEsSUFBRyxLQUFJO0FBQ1AsbUJBQU8sQ0FBQyxHQUFHLEtBQUssS0FBSyxpQkFBaUIsQ0FBQztBQUFBLFFBQzlDO0FBQUEsTUFDakIsQ0FBYTtBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxFQUFBOE4sV0FBVSxVQUFVLFNBQVMsU0FBVSxtQkFBbUI7QUFDdEQsUUFBSSxLQUFLLG1CQUFtQixPQUFPLGlCQUFpQixHQUFHO0FBQ25ELFVBQUksV0FBVyxLQUFLLG1CQUFtQixJQUFJLGlCQUFpQjtBQUM1RCxXQUFLLHNCQUFzQixRQUFRO0FBQUEsSUFDdEM7QUFDRCxTQUFLLDZCQUE2QixpQkFBaUI7QUFBQSxFQUMzRDtBQUNJLEVBQUFBLFdBQVUsVUFBVSxjQUFjLFNBQVUsbUJBQW1CO0FBQzNELFdBQU8sVUFBVSxNQUFNLFFBQVEsUUFBUSxXQUFZO0FBQy9DLFVBQUk7QUFDSixhQUFPLFlBQVksTUFBTSxTQUFVOU4sS0FBSTtBQUNuQyxnQkFBUUEsSUFBRyxPQUFLO0FBQUEsVUFDWixLQUFLO0FBQ0QsZ0JBQUksQ0FBQyxLQUFLLG1CQUFtQixPQUFPLGlCQUFpQjtBQUFHLHFCQUFPLENBQUMsR0FBRyxDQUFDO0FBQ3BFLHVCQUFXLEtBQUssbUJBQW1CLElBQUksaUJBQWlCO0FBQ3hELG1CQUFPLENBQUMsR0FBRyxLQUFLLDJCQUEyQixRQUFRLENBQUM7QUFBQSxVQUN4RCxLQUFLO0FBQ0QsWUFBQUEsSUFBRyxLQUFJO0FBQ1AsWUFBQUEsSUFBRyxRQUFRO0FBQUEsVUFDZixLQUFLO0FBQ0QsaUJBQUssNkJBQTZCLGlCQUFpQjtBQUNuRCxtQkFBTyxDQUFDLENBQUM7QUFBQSxRQUNoQjtBQUFBLE1BQ2pCLENBQWE7QUFBQSxJQUNiLENBQVM7QUFBQSxFQUNUO0FBQ0ksRUFBQThOLFdBQVUsVUFBVSxZQUFZLFdBQVk7QUFDeEMsUUFBSSxRQUFRO0FBQ1osU0FBSyxtQkFBbUIsU0FBUyxTQUFVLE1BQU0sT0FBTztBQUNwRCxZQUFNLHNCQUFzQixLQUFLO0FBQUEsSUFDN0MsQ0FBUztBQUNELFNBQUsscUJBQXFCLElBQUk7RUFDdEM7QUFDSSxFQUFBQSxXQUFVLFVBQVUsaUJBQWlCLFdBQVk7QUFDN0MsV0FBTyxVQUFVLE1BQU0sUUFBUSxRQUFRLFdBQVk7QUFDL0MsVUFBSTtBQUNKLFVBQUksUUFBUTtBQUNaLGFBQU8sWUFBWSxNQUFNLFNBQVU5TixLQUFJO0FBQ25DLGdCQUFRQSxJQUFHLE9BQUs7QUFBQSxVQUNaLEtBQUs7QUFDRCx1QkFBVyxDQUFBO0FBQ1gsaUJBQUssbUJBQW1CLFNBQVMsU0FBVSxNQUFNLE9BQU87QUFDcEQsdUJBQVMsS0FBSyxNQUFNLDJCQUEyQixLQUFLLENBQUM7QUFBQSxZQUNqRixDQUF5QjtBQUNELG1CQUFPLENBQUMsR0FBRyxRQUFRLElBQUksUUFBUSxDQUFDO0FBQUEsVUFDcEMsS0FBSztBQUNELFlBQUFBLElBQUcsS0FBSTtBQUNQLGlCQUFLLHFCQUFxQixJQUFJO0FBQzlCLG1CQUFPLENBQUMsQ0FBQztBQUFBLFFBQ2hCO0FBQUEsTUFDakIsQ0FBYTtBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxFQUFBOE4sV0FBVSxVQUFVLGVBQWUsU0FBVSxtQkFBbUIsY0FBYztBQUMxRSxTQUFLLGFBQWEsSUFBSSxtQkFBbUIsWUFBWTtBQUFBLEVBQzdEO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLGlCQUFpQixTQUFVLG1CQUFtQixnQkFBZ0I7QUFDOUUsU0FBSyxlQUFlLElBQUksbUJBQW1CLGNBQWM7QUFBQSxFQUNqRTtBQUNJLEVBQUFBLFdBQVUsVUFBVSxVQUFVLFNBQVUsbUJBQW1CO0FBQ3ZELFFBQUksUUFBUSxLQUFLLG1CQUFtQixPQUFPLGlCQUFpQjtBQUM1RCxRQUFJLENBQUMsU0FBUyxLQUFLLFFBQVE7QUFDdkIsY0FBUSxLQUFLLE9BQU8sUUFBUSxpQkFBaUI7QUFBQSxJQUNoRDtBQUNELFdBQU87QUFBQSxFQUNmO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLGlCQUFpQixTQUFVLG1CQUFtQjtBQUM5RCxXQUFPLEtBQUssbUJBQW1CLE9BQU8saUJBQWlCO0FBQUEsRUFDL0Q7QUFDSSxFQUFBQSxXQUFVLFVBQVUsZUFBZSxTQUFVLG1CQUFtQixPQUFPO0FBQ25FLFdBQU8sS0FBSyxjQUFjLG1CQUFtQjVDLFdBQXdCLEtBQUs7QUFBQSxFQUNsRjtBQUNJLEVBQUE0QyxXQUFVLFVBQVUsZ0JBQWdCLFNBQVUsbUJBQW1CLEtBQUssT0FBTztBQUN6RSxRQUFJLFFBQVE7QUFDWixRQUFJLEtBQUssbUJBQW1CLE9BQU8saUJBQWlCLEdBQUc7QUFDbkQsVUFBSSxXQUFXLEtBQUssbUJBQW1CLElBQUksaUJBQWlCO0FBQzVELFVBQUksWUFBWSxrQkFBa0IsTUFBTSxtQkFBbUIsS0FBSyxLQUFLO0FBQ3JFLGNBQVEsU0FBUyxLQUFLLFNBQVVyTCxJQUFHO0FBQUUsZUFBT0EsR0FBRSxXQUFXLFNBQVM7QUFBQSxNQUFFLENBQUU7QUFBQSxJQUN6RTtBQUNELFFBQUksQ0FBQyxTQUFTLEtBQUssUUFBUTtBQUN2QixjQUFRLEtBQUssT0FBTyxjQUFjLG1CQUFtQixLQUFLLEtBQUs7QUFBQSxJQUNsRTtBQUNELFdBQU87QUFBQSxFQUNmO0FBQ0ksRUFBQXFMLFdBQVUsVUFBVSxXQUFXLFdBQVk7QUFDdkMsU0FBSyxXQUFXLEtBQUssa0JBQWtCLEdBQUcsS0FBSyxtQkFBbUIsU0FBUyxLQUFLLGFBQWEsS0FBSyxhQUFhLE1BQUssR0FBSSxLQUFLLGVBQWUsU0FBUyxLQUFLLHVCQUF1QixNQUFPLENBQUEsQ0FBQztBQUFBLEVBQ2pNO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLFVBQVUsV0FBWTtBQUN0QyxRQUFJLFdBQVcsS0FBSyxXQUFXLElBQUc7QUFDbEMsUUFBSSxhQUFhLFFBQVc7QUFDeEIsWUFBTSxJQUFJLE1BQU1LLDJCQUFzQztBQUFBLElBQ3pEO0FBQ0QsU0FBSyxxQkFBcUIsU0FBUztBQUNuQyxTQUFLLGVBQWUsU0FBUztBQUM3QixTQUFLLGlCQUFpQixTQUFTO0FBQy9CLFNBQUssY0FBYyxTQUFTO0FBQzVCLFNBQUsseUJBQXlCLFNBQVM7QUFBQSxFQUMvQztBQUNJLEVBQUFMLFdBQVUsVUFBVSxjQUFjLFNBQVUsa0JBQWtCO0FBQzFELFFBQUksUUFBUSxJQUFJQSxXQUFVLG9CQUFvQixLQUFLLE9BQU87QUFDMUQsVUFBTSxTQUFTO0FBQ2YsV0FBTztBQUFBLEVBQ2Y7QUFDSSxFQUFBQSxXQUFVLFVBQVUsa0JBQWtCLFdBQVk7QUFDOUMsUUFBSSxjQUFjLENBQUE7QUFDbEIsYUFBUyxLQUFLLEdBQUcsS0FBSyxVQUFVLFFBQVEsTUFBTTtBQUMxQyxrQkFBWSxFQUFFLElBQUksVUFBVSxFQUFFO0FBQUEsSUFDakM7QUFDRCxRQUFJLFVBQVcsS0FBSyxjQUFlLEtBQUssY0FBYyxLQUFLO0FBQzNELFNBQUssY0FBYyxZQUFZLE9BQU8sU0FBVSxNQUFNLE1BQU07QUFBRSxhQUFPLEtBQUssSUFBSTtBQUFBLElBQUksR0FBRSxPQUFPO0FBQUEsRUFDbkc7QUFDSSxFQUFBQSxXQUFVLFVBQVUsNEJBQTRCLFNBQVUsZ0JBQWdCO0FBQ3RFLFNBQUssa0JBQWtCO0FBQUEsRUFDL0I7QUFDSSxFQUFBQSxXQUFVLFVBQVUsTUFBTSxTQUFVLG1CQUFtQjtBQUNuRCxRQUFJLFVBQVUsS0FBSyxlQUFlLG1CQUFtQixLQUFLO0FBQzFELFdBQU8sS0FBSyxvQkFBb0IsT0FBTztBQUFBLEVBQy9DO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLFdBQVcsU0FBVSxtQkFBbUI7QUFDeEQsV0FBTyxVQUFVLE1BQU0sUUFBUSxRQUFRLFdBQVk7QUFDL0MsVUFBSTtBQUNKLGFBQU8sWUFBWSxNQUFNLFNBQVU5TixLQUFJO0FBQ25DLGtCQUFVLEtBQUssZUFBZSxtQkFBbUIsS0FBSztBQUN0RCxlQUFPLENBQUMsR0FBRyxLQUFLLEtBQUssT0FBTyxDQUFDO0FBQUEsTUFDN0MsQ0FBYTtBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxFQUFBOE4sV0FBVSxVQUFVLFlBQVksU0FBVSxtQkFBbUIsS0FBSyxPQUFPO0FBQ3JFLFFBQUksVUFBVSxLQUFLLGVBQWUsbUJBQW1CLE9BQU8sS0FBSyxLQUFLO0FBQ3RFLFdBQU8sS0FBSyxvQkFBb0IsT0FBTztBQUFBLEVBQy9DO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLGlCQUFpQixTQUFVLG1CQUFtQixLQUFLLE9BQU87QUFDMUUsV0FBTyxVQUFVLE1BQU0sUUFBUSxRQUFRLFdBQVk7QUFDL0MsVUFBSTtBQUNKLGFBQU8sWUFBWSxNQUFNLFNBQVU5TixLQUFJO0FBQ25DLGtCQUFVLEtBQUssZUFBZSxtQkFBbUIsT0FBTyxLQUFLLEtBQUs7QUFDbEUsZUFBTyxDQUFDLEdBQUcsS0FBSyxLQUFLLE9BQU8sQ0FBQztBQUFBLE1BQzdDLENBQWE7QUFBQSxJQUNiLENBQVM7QUFBQSxFQUNUO0FBQ0ksRUFBQThOLFdBQVUsVUFBVSxXQUFXLFNBQVUsbUJBQW1CLE9BQU87QUFDL0QsV0FBTyxLQUFLLFVBQVUsbUJBQW1CNUMsV0FBd0IsS0FBSztBQUFBLEVBQzlFO0FBQ0ksRUFBQTRDLFdBQVUsVUFBVSxnQkFBZ0IsU0FBVSxtQkFBbUIsT0FBTztBQUNwRSxXQUFPLEtBQUssZUFBZSxtQkFBbUI1QyxXQUF3QixLQUFLO0FBQUEsRUFDbkY7QUFDSSxFQUFBNEMsV0FBVSxVQUFVLFNBQVMsU0FBVSxtQkFBbUI7QUFDdEQsUUFBSSxVQUFVLEtBQUssWUFBWSxpQkFBaUI7QUFDaEQsV0FBTyxLQUFLLG9CQUFvQixPQUFPO0FBQUEsRUFDL0M7QUFDSSxFQUFBQSxXQUFVLFVBQVUsY0FBYyxTQUFVLG1CQUFtQjtBQUMzRCxRQUFJLFVBQVUsS0FBSyxZQUFZLGlCQUFpQjtBQUNoRCxXQUFPLEtBQUssUUFBUSxPQUFPO0FBQUEsRUFDbkM7QUFDSSxFQUFBQSxXQUFVLFVBQVUsZUFBZSxTQUFVLG1CQUFtQixLQUFLLE9BQU87QUFDeEUsUUFBSSxVQUFVLEtBQUssZUFBZSxtQkFBbUIsTUFBTSxLQUFLLEtBQUs7QUFDckUsV0FBTyxLQUFLLG9CQUFvQixPQUFPO0FBQUEsRUFDL0M7QUFDSSxFQUFBQSxXQUFVLFVBQVUsb0JBQW9CLFNBQVUsbUJBQW1CLEtBQUssT0FBTztBQUM3RSxRQUFJLFVBQVUsS0FBSyxlQUFlLG1CQUFtQixNQUFNLEtBQUssS0FBSztBQUNyRSxXQUFPLEtBQUssUUFBUSxPQUFPO0FBQUEsRUFDbkM7QUFDSSxFQUFBQSxXQUFVLFVBQVUsY0FBYyxTQUFVLG1CQUFtQixPQUFPO0FBQ2xFLFdBQU8sS0FBSyxhQUFhLG1CQUFtQjVDLFdBQXdCLEtBQUs7QUFBQSxFQUNqRjtBQUNJLEVBQUE0QyxXQUFVLFVBQVUsbUJBQW1CLFNBQVUsbUJBQW1CLE9BQU87QUFDdkUsV0FBTyxLQUFLLGtCQUFrQixtQkFBbUI1QyxXQUF3QixLQUFLO0FBQUEsRUFDdEY7QUFDSSxFQUFBNEMsV0FBVSxVQUFVLFVBQVUsU0FBVSxxQkFBcUI7QUFDekQsUUFBSSxVQUFVLEtBQUssUUFBUSxtQkFBbUI7QUFDOUMsUUFBSSxDQUFDLFNBQVM7QUFDVixXQUFLLEtBQUssbUJBQW1CLEVBQUUsT0FBTTtBQUFBLElBQ3hDO0FBQ0QsUUFBSSxXQUFXLEtBQUssSUFBSSxtQkFBbUI7QUFDM0MsUUFBSSxDQUFDLFNBQVM7QUFDVixXQUFLLE9BQU8sbUJBQW1CO0FBQUEsSUFDbEM7QUFDRCxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFBLFdBQVUsVUFBVSxjQUFjLFNBQVUsYUFBYTlELFdBQVU7QUFDL0QsUUFBSSxRQUFRLFlBQVkrQyxhQUEwQixXQUFXLEdBQUc7QUFDNUQsVUFBSSxPQUFPLFFBQVEsWUFBWUEsYUFBMEIsV0FBVztBQUNwRSxhQUFPL0MsVUFBUyxLQUFLLEtBQUs7SUFDN0I7QUFBQSxFQUNUO0FBQ0ksRUFBQThELFdBQVUsVUFBVSx3QkFBd0IsU0FBVSxVQUFVO0FBQzVELFFBQUksNEJBQTRCLEtBQUssdUJBQXVCLE9BQU8sUUFBUTtBQUMzRSxTQUFLLGFBQWEsbUJBQW1CLDBCQUEwQixhQUFhO0FBQzVFLFNBQUssZUFBZSxtQkFBbUIsMEJBQTBCLGVBQWU7QUFBQSxFQUN4RjtBQUNJLEVBQUFBLFdBQVUsVUFBVSx3QkFBd0IsU0FBVSxVQUFVO0FBQzVELFdBQU8sS0FBSyxtQkFBbUIsa0JBQWtCLFNBQVUsU0FBUztBQUFFLGFBQU8sUUFBUSxhQUFhO0FBQUEsSUFBUyxDQUFFO0FBQUEsRUFDckg7QUFDSSxFQUFBQSxXQUFVLFVBQVUsY0FBYyxTQUFVLFNBQVM5RCxXQUFVO0FBQzNELFFBQUksUUFBUTtBQUNaLFFBQUksY0FBYyxPQUFPLGVBQWVBLFNBQVEsRUFBRTtBQUNsRCxRQUFJO0FBQ0EsVUFBSSxLQUFLLGVBQWUsT0FBTyxRQUFRLGlCQUFpQixHQUFHO0FBQ3ZELFlBQUksU0FBUyxLQUFLLHFCQUFxQkEsV0FBVSxLQUFLLGVBQWUsSUFBSSxRQUFRLGlCQUFpQixFQUFFLE9BQVEsQ0FBQTtBQUM1RyxZQUFJLFVBQVUsTUFBTSxHQUFHO0FBQ25CLGlCQUFPLEtBQUsseUJBQXlCLE9BQU8sS0FBSyxXQUFZO0FBQUUsbUJBQU8sTUFBTSw2REFBNkQsU0FBU0EsV0FBVSxXQUFXO0FBQUEsVUFBRSxDQUFFLEdBQUcsV0FBVztBQUFBLFFBQzVMO0FBQUEsTUFDSjtBQUNELFVBQUksOEJBQThCLEtBQUssd0RBQXdELFNBQVNBLFdBQVUsV0FBVztBQUM3SCxVQUFJLFVBQVUsMkJBQTJCLEdBQUc7QUFDeEMsZUFBTyxLQUFLLHlCQUF5Qiw2QkFBNkIsV0FBVztBQUFBLE1BQ2hGO0FBQUEsSUFDSixTQUNNLElBQVA7QUFDSSxZQUFNLElBQUksTUFBTW9FLHNCQUFpQyxZQUFZLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFBQSxJQUNqRjtBQUFBLEVBQ1Q7QUFDSSxFQUFBTixXQUFVLFVBQVUsMkJBQTJCLFNBQVUsYUFBYSxhQUFhO0FBQy9FLFdBQU8sVUFBVSxNQUFNLFFBQVEsUUFBUSxXQUFZO0FBQy9DLFVBQUk7QUFDSixhQUFPLFlBQVksTUFBTSxTQUFVOU4sS0FBSTtBQUNuQyxnQkFBUUEsSUFBRyxPQUFLO0FBQUEsVUFDWixLQUFLO0FBQ0QsWUFBQUEsSUFBRyxLQUFLLEtBQUssQ0FBQyxHQUFHLEdBQUMsRUFBSSxDQUFDLENBQUM7QUFDeEIsbUJBQU8sQ0FBQyxHQUFHLFdBQVc7QUFBQSxVQUMxQixLQUFLO0FBQ0QsWUFBQUEsSUFBRyxLQUFJO0FBQ1AsbUJBQU8sQ0FBQyxHQUFHLENBQUM7QUFBQSxVQUNoQixLQUFLO0FBQ0QsbUJBQU9BLElBQUc7QUFDVixrQkFBTSxJQUFJLE1BQU1vTyxzQkFBaUMsWUFBWSxNQUFNLEtBQUssT0FBTyxDQUFDO0FBQUEsVUFDcEYsS0FBSztBQUFHLG1CQUFPLENBQUMsQ0FBQztBQUFBLFFBQ3BCO0FBQUEsTUFDakIsQ0FBYTtBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxFQUFBTixXQUFVLFVBQVUsdUJBQXVCLFNBQVU5RCxXQUFVLHVCQUF1QjtBQUNsRixRQUFJLFFBQVE7QUFDWixRQUFJLGVBQWUsc0JBQXNCO0FBQ3pDLFdBQU8sYUFBYSxPQUFPO0FBQ3ZCLFVBQUksU0FBUyxhQUFhLE1BQU1BLFNBQVE7QUFDeEMsVUFBSSxVQUFVLE1BQU0sR0FBRztBQUNuQixlQUFPLE9BQU8sS0FBSyxXQUFZO0FBQzNCLGlCQUFPLE1BQU0sMEJBQTBCQSxXQUFVLHFCQUFxQjtBQUFBLFFBQzFGLENBQWlCO0FBQUEsTUFDSjtBQUNELHFCQUFlLHNCQUFzQjtJQUN4QztBQUFBLEVBQ1Q7QUFDSSxFQUFBOEQsV0FBVSxVQUFVLDRCQUE0QixTQUFVOUQsV0FBVSx1QkFBdUI7QUFDdkYsV0FBTyxVQUFVLE1BQU0sUUFBUSxRQUFRLFdBQVk7QUFDL0MsVUFBSTtBQUNKLGFBQU8sWUFBWSxNQUFNLFNBQVVoSyxLQUFJO0FBQ25DLGdCQUFRQSxJQUFHLE9BQUs7QUFBQSxVQUNaLEtBQUs7QUFDRCwyQkFBZSxzQkFBc0I7QUFDckMsWUFBQUEsSUFBRyxRQUFRO0FBQUEsVUFDZixLQUFLO0FBQ0QsZ0JBQUksQ0FBQyxhQUFhO0FBQU8scUJBQU8sQ0FBQyxHQUFHLENBQUM7QUFDckMsbUJBQU8sQ0FBQyxHQUFHLGFBQWEsTUFBTWdLLFNBQVEsQ0FBQztBQUFBLFVBQzNDLEtBQUs7QUFDRCxZQUFBaEssSUFBRyxLQUFJO0FBQ1AsMkJBQWUsc0JBQXNCO0FBQ3JDLG1CQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsVUFDaEIsS0FBSztBQUFHLG1CQUFPLENBQUMsQ0FBQztBQUFBLFFBQ3BCO0FBQUEsTUFDakIsQ0FBYTtBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxFQUFBOE4sV0FBVSxVQUFVLG9DQUFvQyxXQUFZO0FBQ2hFLFFBQUksUUFBUTtBQUNaLFFBQUksY0FBYyxTQUFVLGlCQUFpQixVQUFVO0FBQ25ELHNCQUFnQixTQUFTLFdBQVc7QUFBQSxJQUNoRDtBQUNRLFFBQUksa0JBQWtCLFNBQVUsVUFBVTtBQUN0QyxhQUFPLFNBQVUsbUJBQW1CO0FBQ2hDLFlBQUksa0JBQWtCLE1BQU0sS0FBSyxpQkFBaUI7QUFDbEQsb0JBQVksaUJBQWlCLFFBQVE7QUFDckMsZUFBTztBQUFBLE1BQ3ZCO0FBQUEsSUFDQTtBQUNRLFFBQUksb0JBQW9CLFdBQVk7QUFDaEMsYUFBTyxTQUFVLG1CQUFtQjtBQUNoQyxlQUFPLE1BQU0sT0FBTyxpQkFBaUI7QUFBQSxNQUNyRDtBQUFBLElBQ0E7QUFDUSxRQUFJLHlCQUF5QixXQUFZO0FBQ3JDLGFBQU8sU0FBVSxtQkFBbUI7QUFDaEMsZUFBTyxNQUFNLFlBQVksaUJBQWlCO0FBQUEsTUFDMUQ7QUFBQSxJQUNBO0FBQ1EsUUFBSSxxQkFBcUIsV0FBWTtBQUNqQyxhQUFPLFNBQVUsbUJBQW1CO0FBQ2hDLGVBQU8sTUFBTSxRQUFRLGlCQUFpQjtBQUFBLE1BQ3REO0FBQUEsSUFDQTtBQUNRLFFBQUksb0JBQW9CLFNBQVUsVUFBVTtBQUN4QyxhQUFPLFNBQVUsbUJBQW1CO0FBQ2hDLFlBQUksa0JBQWtCLE1BQU0sT0FBTyxpQkFBaUI7QUFDcEQsb0JBQVksaUJBQWlCLFFBQVE7QUFDckMsZUFBTztBQUFBLE1BQ3ZCO0FBQUEsSUFDQTtBQUNRLFFBQUksMEJBQTBCLFNBQVUsVUFBVTtBQUM5QyxhQUFPLFNBQVUsbUJBQW1CLGNBQWM7QUFDOUMsY0FBTSx1QkFBdUIsY0FBYyxVQUFVLG1CQUFtQixZQUFZO0FBQ3BGLGNBQU0sYUFBYSxtQkFBbUIsWUFBWTtBQUFBLE1BQ2xFO0FBQUEsSUFDQTtBQUNRLFFBQUksNEJBQTRCLFNBQVUsVUFBVTtBQUNoRCxhQUFPLFNBQVUsbUJBQW1CLGdCQUFnQjtBQUNoRCxjQUFNLHVCQUF1QixnQkFBZ0IsVUFBVSxtQkFBbUIsY0FBYztBQUN4RixjQUFNLGVBQWUsbUJBQW1CLGNBQWM7QUFBQSxNQUN0RTtBQUFBLElBQ0E7QUFDUSxXQUFPLFNBQVUsS0FBSztBQUFFLGFBQVE7QUFBQSxRQUM1QixjQUFjLGdCQUFnQixHQUFHO0FBQUEsUUFDakMsaUJBQWlCLG1CQUFvQjtBQUFBLFFBQ3JDLHNCQUFzQix3QkFBd0IsR0FBRztBQUFBLFFBQ2pELHdCQUF3QiwwQkFBMEIsR0FBRztBQUFBLFFBQ3JELGdCQUFnQixrQkFBa0IsR0FBRztBQUFBLFFBQ3JDLGdCQUFnQixrQkFBbUI7QUFBQSxRQUNuQyxxQkFBcUIsdUJBQXdCO0FBQUEsTUFDaEQ7QUFBQTtFQUNUO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLFVBQVUsU0FBVSxTQUFTO0FBQzdDLFdBQU8sUUFBUSxJQUFJLEtBQUssS0FBSyxPQUFPLENBQUM7QUFBQSxFQUM3QztBQUNJLEVBQUFBLFdBQVUsVUFBVSxPQUFPLFNBQVUsU0FBUztBQUMxQyxRQUFJLHFCQUFxQixTQUFTLFNBQVMsQ0FBQSxHQUFJLE9BQU8sR0FBRyxFQUFFLG9CQUFvQixTQUFVLFNBQVM7QUFBRSxhQUFPO0FBQUEsSUFBVSxHQUFFLFlBQVksZUFBZSxTQUFRLENBQUU7QUFDNUosUUFBSSxLQUFLLGFBQWE7QUFDbEIsVUFBSSxtQkFBbUIsS0FBSyxZQUFZLGtCQUFrQjtBQUMxRCxVQUFJLHFCQUFxQixVQUFhLHFCQUFxQixNQUFNO0FBQzdELGNBQU0sSUFBSSxNQUFNTyx5QkFBb0M7QUFBQSxNQUN2RDtBQUNELGFBQU87QUFBQSxJQUNWO0FBQ0QsV0FBTyxLQUFLLGtCQUFrQixrQkFBa0I7QUFBQSxFQUN4RDtBQUNJLEVBQUFQLFdBQVUsVUFBVSxzQkFBc0IsU0FBVSxTQUFTO0FBQ3pELFFBQUksU0FBUyxLQUFLLEtBQUssT0FBTztBQUM5QixRQUFJLDJCQUEyQixNQUFNLEdBQUc7QUFDcEMsWUFBTSxJQUFJLE1BQU1RLGFBQXdCLFFBQVEsaUJBQWlCLENBQUM7QUFBQSxJQUNyRTtBQUNELFdBQU87QUFBQSxFQUNmO0FBQ0ksRUFBQVIsV0FBVSxVQUFVLGNBQWMsU0FBVSxtQkFBbUI7QUFDM0QsUUFBSSxhQUFhO0FBQUEsTUFDYixrQkFBa0I7QUFBQSxNQUNsQixlQUFlO0FBQUEsTUFDZjtBQUFBLElBQ1o7QUFDUSxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFBLFdBQVUsVUFBVSxpQkFBaUIsU0FBVSxtQkFBbUIsZUFBZSxLQUFLLE9BQU87QUFDekYsUUFBSSxnQkFBZ0I7QUFBQSxNQUNoQixrQkFBa0I7QUFBQSxNQUNsQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ1o7QUFDUSxXQUFPO0FBQUEsRUFDZjtBQUNJLEVBQUFBLFdBQVUsVUFBVSxrQkFBa0IsV0FBWTtBQUM5QyxRQUFJLFFBQVE7QUFDWixXQUFPLFNBQVUsTUFBTTtBQUNuQixVQUFJLFVBQVUsS0FBSyxNQUFNLGlCQUFpQixPQUFPLEtBQUssZUFBZSxLQUFLLFlBQVksS0FBSyxtQkFBbUIsS0FBSyxLQUFLLEtBQUssT0FBTyxLQUFLLGdCQUFnQjtBQUN6SixnQkFBVSxLQUFLLG1CQUFtQixPQUFPO0FBQ3pDLFVBQUksU0FBUyxRQUFRLE9BQU87QUFDNUIsYUFBTztBQUFBLElBQ25CO0FBQUEsRUFDQTtBQUNJLEVBQUFBLFdBQVUsVUFBVSx5QkFBeUIsU0FBVSxTQUFTO0FBQzVELFFBQUksUUFBUTtBQUNaLFFBQUksQ0FBQyxRQUFRLFdBQVc7QUFDcEI7QUFBQSxJQUNIO0FBQ0QsUUFBSSxVQUFVLFFBQVEsS0FBSyxHQUFHO0FBQzFCLGFBQU8sUUFBUSxNQUFNLEtBQUssU0FBVSxVQUFVO0FBQUUsZUFBTyxNQUFNLFlBQVksU0FBUyxRQUFRO0FBQUEsTUFBSSxDQUFBO0FBQUEsSUFDakc7QUFDRCxXQUFPLEtBQUssWUFBWSxTQUFTLFFBQVEsS0FBSztBQUFBLEVBQ3REO0FBQ0ksRUFBQUEsV0FBVSxVQUFVLHdCQUF3QixTQUFVLFVBQVU7QUFDNUQsYUFBUyxLQUFLLEdBQUcsYUFBYSxVQUFVLEtBQUssV0FBVyxRQUFRLE1BQU07QUFDbEUsVUFBSSxVQUFVLFdBQVcsRUFBRTtBQUMzQixVQUFJLFNBQVMsS0FBSyx1QkFBdUIsT0FBTztBQUNoRCxVQUFJLFVBQVUsTUFBTSxHQUFHO0FBQ25CLGNBQU0sSUFBSSxNQUFNUyxxQkFBZ0M7QUFBQSxNQUNuRDtBQUFBLElBQ0o7QUFBQSxFQUNUO0FBQ0ksRUFBQVQsV0FBVSxVQUFVLDZCQUE2QixTQUFVLFVBQVU7QUFDakUsV0FBTyxVQUFVLE1BQU0sUUFBUSxRQUFRLFdBQVk7QUFDL0MsVUFBSSxRQUFRO0FBQ1osYUFBTyxZQUFZLE1BQU0sU0FBVTlOLEtBQUk7QUFDbkMsZ0JBQVFBLElBQUcsT0FBSztBQUFBLFVBQ1osS0FBSztBQUFHLG1CQUFPLENBQUMsR0FBRyxRQUFRLElBQUksU0FBUyxJQUFJLFNBQVV5QyxJQUFHO0FBQUUscUJBQU8sTUFBTSx1QkFBdUJBLEVBQUM7QUFBQSxZQUFFLENBQUUsQ0FBQyxDQUFDO0FBQUEsVUFDdEcsS0FBSztBQUNELFlBQUF6QyxJQUFHLEtBQUk7QUFDUCxtQkFBTyxDQUFDLENBQUM7QUFBQSxRQUNoQjtBQUFBLE1BQ2pCLENBQWE7QUFBQSxJQUNiLENBQVM7QUFBQSxFQUNUO0FBQ0ksRUFBQThOLFdBQVUsVUFBVSwwREFBMEQsU0FBVSxTQUFTOUQsV0FBVSxhQUFhO0FBQ3BILFFBQUksS0FBSyxRQUFRO0FBQ2IsYUFBTyxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sRUFBRSxTQUFTQSxTQUFRO0FBQUEsSUFDOUQsT0FDSTtBQUNELGFBQU8sS0FBSyxrQ0FBa0MsU0FBU0EsV0FBVSxXQUFXO0FBQUEsSUFDL0U7QUFBQSxFQUNUO0FBQ0ksRUFBQThELFdBQVUsVUFBVSwrREFBK0QsU0FBVSxTQUFTOUQsV0FBVSxhQUFhO0FBQ3pILFdBQU8sVUFBVSxNQUFNLFFBQVEsUUFBUSxXQUFZO0FBQy9DLGFBQU8sWUFBWSxNQUFNLFNBQVVoSyxLQUFJO0FBQ25DLGdCQUFRQSxJQUFHLE9BQUs7QUFBQSxVQUNaLEtBQUs7QUFDRCxnQkFBSSxDQUFDLEtBQUs7QUFBUSxxQkFBTyxDQUFDLEdBQUcsQ0FBQztBQUM5QixtQkFBTyxDQUFDLEdBQUcsS0FBSyxZQUFZLEtBQUssS0FBSyxNQUFNLEVBQUUsU0FBU2dLLFNBQVEsQ0FBQztBQUFBLFVBQ3BFLEtBQUs7QUFDRCxZQUFBaEssSUFBRyxLQUFJO0FBQ1AsbUJBQU8sQ0FBQyxHQUFHLENBQUM7QUFBQSxVQUNoQixLQUFLO0FBQUcsbUJBQU8sQ0FBQyxHQUFHLEtBQUssdUNBQXVDLFNBQVNnSyxXQUFVLFdBQVcsQ0FBQztBQUFBLFVBQzlGLEtBQUs7QUFDRCxZQUFBaEssSUFBRyxLQUFJO0FBQ1AsWUFBQUEsSUFBRyxRQUFRO0FBQUEsVUFDZixLQUFLO0FBQUcsbUJBQU8sQ0FBQyxDQUFDO0FBQUEsUUFDcEI7QUFBQSxNQUNqQixDQUFhO0FBQUEsSUFDYixDQUFTO0FBQUEsRUFDVDtBQUNJLEVBQUE4TixXQUFVLFVBQVUsK0JBQStCLFNBQVUsbUJBQW1CO0FBQzVFLFFBQUk7QUFDQSxXQUFLLG1CQUFtQixPQUFPLGlCQUFpQjtBQUFBLElBQ25ELFNBQ00sR0FBUDtBQUNJLFlBQU0sSUFBSSxNQUFNVSxnQkFBMkIsTUFBTSw2QkFBNkIsaUJBQWlCLENBQUM7QUFBQSxJQUNuRztBQUFBLEVBQ1Q7QUFDSSxFQUFBVixXQUFVLFVBQVUsb0NBQW9DLFNBQVUsU0FBUzlELFdBQVUsYUFBYTtBQUM5RixRQUFJLFFBQVE7QUFDWixRQUFJLE9BQU8sUUFBUSxtQkFBbUIsWUFBWTtBQUM5QyxVQUFJLFNBQVMsUUFBUSxlQUFlQSxTQUFRO0FBQzVDLFVBQUksVUFBVSxNQUFNLEdBQUc7QUFDbkIsZUFBTyxPQUFPLEtBQUssV0FBWTtBQUFFLGlCQUFPLE1BQU0sWUFBWSxhQUFhQSxTQUFRO0FBQUEsUUFBRSxDQUFFO0FBQUEsTUFDdEY7QUFBQSxJQUNKO0FBQ0QsV0FBTyxLQUFLLFlBQVksYUFBYUEsU0FBUTtBQUFBLEVBQ3JEO0FBQ0ksRUFBQThELFdBQVUsVUFBVSx5Q0FBeUMsU0FBVSxTQUFTOUQsV0FBVSxhQUFhO0FBQ25HLFdBQU8sVUFBVSxNQUFNLFFBQVEsUUFBUSxXQUFZO0FBQy9DLGFBQU8sWUFBWSxNQUFNLFNBQVVoSyxLQUFJO0FBQ25DLGdCQUFRQSxJQUFHLE9BQUs7QUFBQSxVQUNaLEtBQUs7QUFDRCxnQkFBSSxFQUFFLE9BQU8sUUFBUSxtQkFBbUI7QUFBYSxxQkFBTyxDQUFDLEdBQUcsQ0FBQztBQUNqRSxtQkFBTyxDQUFDLEdBQUcsUUFBUSxlQUFlZ0ssU0FBUSxDQUFDO0FBQUEsVUFDL0MsS0FBSztBQUNELFlBQUFoSyxJQUFHLEtBQUk7QUFDUCxZQUFBQSxJQUFHLFFBQVE7QUFBQSxVQUNmLEtBQUs7QUFBRyxtQkFBTyxDQUFDLEdBQUcsS0FBSyxZQUFZLGFBQWFnSyxTQUFRLENBQUM7QUFBQSxVQUMxRCxLQUFLO0FBQ0QsWUFBQWhLLElBQUcsS0FBSTtBQUNQLG1CQUFPLENBQUMsQ0FBQztBQUFBLFFBQ2hCO0FBQUEsTUFDakIsQ0FBYTtBQUFBLElBQ2IsQ0FBUztBQUFBLEVBQ1Q7QUFDSSxTQUFPOE47QUFDWDtBQzNyQk8sU0FBUyx1QkFBdUIsT0FBTztBQUMxQyxNQUFJLGFBQWEsb0JBQUk7QUFDckIsV0FBUyxLQUFLLEdBQUcsVUFBVSxPQUFPLEtBQUssUUFBUSxRQUFRLE1BQU07QUFDekQsUUFBSSxRQUFRLFFBQVEsRUFBRTtBQUN0QixRQUFJLFdBQVcsSUFBSSxLQUFLLEdBQUc7QUFDdkIsYUFBTztBQUFBLElBQ1YsT0FDSTtBQUNELGlCQUFXLElBQUksS0FBSztBQUFBLElBQ3ZCO0FBQUEsRUFDSjtBQUNELFNBQU87QUFDWDtBQ1RBLFNBQVMsNEJBQTRCLFFBQVE7QUFDekMsU0FBTyxPQUFPLGNBQWM7QUFDaEM7QUFDQSxTQUFTLHdCQUF3QixlQUFlO0FBQzVDLE1BQUksa0JBQWtCLFFBQVc7QUFDN0IsVUFBTSxJQUFJLE1BQU1XLDJCQUFzQztBQUFBLEVBQ3pEO0FBQ0w7QUFDQSxTQUFTLGFBQWEsa0JBQWtCLGVBQWUsZ0JBQWdCLFVBQVU7QUFDN0UsMEJBQXdCLGFBQWE7QUFDckMsMEJBQXdCL0QsUUFBcUIsa0JBQWtCLGVBQWUsU0FBUSxHQUFJLFFBQVE7QUFDdEc7QUFDQSxTQUFTLFlBQVksa0JBQWtCLGNBQWMsVUFBVTtBQUMzRCxNQUFJLDRCQUE0QixnQkFBZ0IsR0FBRztBQUMvQyxVQUFNLElBQUksTUFBTStELDJCQUFzQztBQUFBLEVBQ3pEO0FBQ0QsMEJBQXdCOUQsYUFBMEIsaUJBQWlCLGFBQWEsY0FBYyxRQUFRO0FBQzFHO0FBQ0EsU0FBUywrQkFBK0IsVUFBVTtBQUM5QyxNQUFJLFlBQVksQ0FBQTtBQUNoQixNQUFJLE1BQU0sUUFBUSxRQUFRLEdBQUc7QUFDekIsZ0JBQVk7QUFDWixRQUFJLFlBQVksdUJBQXVCLFVBQVUsSUFBSSxTQUFVLElBQUk7QUFBRSxhQUFPLEdBQUc7QUFBQSxJQUFJLENBQUUsQ0FBQztBQUN0RixRQUFJLGNBQWMsUUFBVztBQUN6QixZQUFNLElBQUksTUFBTStELHNCQUFpQyxNQUFNLFVBQVUsU0FBUSxDQUFFO0FBQUEsSUFDOUU7QUFBQSxFQUNKLE9BQ0k7QUFDRCxnQkFBWSxDQUFDLFFBQVE7QUFBQSxFQUN4QjtBQUNELFNBQU87QUFDWDtBQUNBLFNBQVMsd0JBQXdCLGFBQWEsa0JBQWtCLEtBQUssVUFBVTtBQUMzRSxNQUFJLFlBQVksK0JBQStCLFFBQVE7QUFDdkQsTUFBSSw2QkFBNkIsQ0FBQTtBQUNqQyxNQUFJLFFBQVEsZUFBZSxhQUFhLGdCQUFnQixHQUFHO0FBQ3ZELGlDQUE2QixRQUFRLFlBQVksYUFBYSxnQkFBZ0I7QUFBQSxFQUNqRjtBQUNELE1BQUksMEJBQTBCLDJCQUEyQixHQUFHO0FBQzVELE1BQUksNEJBQTRCLFFBQVc7QUFDdkMsOEJBQTBCLENBQUE7QUFBQSxFQUM3QixPQUNJO0FBQ0QsUUFBSSxVQUFVLFNBQVVDLElBQUc7QUFDdkIsVUFBSSxVQUFVLEtBQUssU0FBVSxJQUFJO0FBQUUsZUFBTyxHQUFHLFFBQVFBLEdBQUU7QUFBQSxNQUFJLENBQUUsR0FBRztBQUM1RCxjQUFNLElBQUksTUFBTUQsc0JBQWlDLE1BQU1DLEdBQUUsSUFBSSxTQUFRLENBQUU7QUFBQSxNQUMxRTtBQUFBLElBQ2I7QUFDUSxhQUFTLEtBQUssR0FBRyw0QkFBNEIseUJBQXlCLEtBQUssMEJBQTBCLFFBQVEsTUFBTTtBQUMvRyxVQUFJLElBQUksMEJBQTBCLEVBQUU7QUFDcEMsY0FBUSxDQUFDO0FBQUEsSUFDWjtBQUFBLEVBQ0o7QUFDRCwwQkFBd0IsS0FBSyxNQUFNLHlCQUF5QixTQUFTO0FBQ3JFLDZCQUEyQixHQUFHLElBQUk7QUFDbEMsVUFBUSxlQUFlLGFBQWEsNEJBQTRCLGdCQUFnQjtBQUNwRjtBQUNBLFNBQVMsc0JBQXNCLFVBQVU7QUFDckMsU0FBTyxTQUFVLFFBQVEsV0FBVywyQkFBMkI7QUFDM0QsUUFBSSxPQUFPLDhCQUE4QixVQUFVO0FBQy9DLG1CQUFhLFFBQVEsV0FBVywyQkFBMkIsUUFBUTtBQUFBLElBQ3RFLE9BQ0k7QUFDRCxrQkFBWSxRQUFRLFdBQVcsUUFBUTtBQUFBLElBQzFDO0FBQUEsRUFDVDtBQUNBO0FDbkVBLFNBQVMsYUFBYTtBQUNsQixTQUFPLFNBQVUsUUFBUTtBQUNyQixRQUFJLFFBQVEsZUFBZWxFLGFBQTBCLE1BQU0sR0FBRztBQUMxRCxZQUFNLElBQUksTUFBTW1FLCtCQUEyQztBQUFBLElBQzlEO0FBQ0QsUUFBSSxRQUFRLFFBQVEsWUFBWUMsb0JBQWlDLE1BQU0sS0FBSztBQUM1RSxZQUFRLGVBQWVwRSxhQUEwQixPQUFPLE1BQU07QUFDOUQsV0FBTztBQUFBLEVBQ2Y7QUFDQTtBQ1JPLFNBQVMsV0FBVyxhQUFhO0FBQ3BDLFNBQU8sU0FBVSxtQkFBbUI7QUFDaEMsV0FBTyxTQUFVLFFBQVEsV0FBVywyQkFBMkI7QUFDM0QsVUFBSSxzQkFBc0IsUUFBVztBQUNqQyxZQUFJLFlBQVksT0FBTyxXQUFXLGFBQWEsT0FBTyxPQUFPLE9BQU8sWUFBWTtBQUNoRixjQUFNLElBQUksTUFBTSw0QkFBNEIsU0FBUyxDQUFDO0FBQUEsTUFDekQ7QUFDRCxhQUFPLHNCQUFzQixJQUFJLFNBQVMsYUFBYSxpQkFBaUIsQ0FBQyxFQUFFLFFBQVEsV0FBVyx5QkFBeUI7QUFBQSxJQUNuSTtBQUFBLEVBQ0E7QUFDQTtBQ1hBLElBQUksU0FBUyxXQUFXMEIsVUFBdUI7QUNBeEMsTUFBTSw0QkFBNEI7QUFDbEMsTUFBTSx1QkFBdUI7QUFDN0IsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxrQ0FBa0M7QUFDeEMsTUFBTSxtQkFBbUI7QUFFekIsTUFBTSxnQkFBOEI7QUFBQSxFQUN2QyxDQUFDLCtCQUErQixHQUFHO0FBQUEsRUFDbkMsQ0FBQyx5QkFBeUIsR0FBRztBQUFBLEVBQzdCLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxFQUFFLEtBQUssV0FBVyxTQUFTLE1BQU07QUFBQSxFQUMxRCxDQUFDLGdDQUFnQyxHQUFHLENBQUM7QUFBQSxFQUNyQyxDQUFDLGdCQUFnQixHQUFHO0FBQ3hCO0FDZEEsU0FBUyxPQUFPO0FBQUc7QUFFbkIsU0FBUyxPQUFPLEtBQUssS0FBSztBQUV0QixhQUFXak0sTUFBSztBQUNaLFFBQUlBLEVBQUMsSUFBSSxJQUFJQSxFQUFDO0FBQ2xCLFNBQU87QUFDWDtBQVdBLFNBQVMsSUFBSSxJQUFJO0FBQ2IsU0FBTyxHQUFFO0FBQ2I7QUFDQSxTQUFTLGVBQWU7QUFDcEIsU0FBTyx1QkFBTyxPQUFPLElBQUk7QUFDN0I7QUFDQSxTQUFTLFFBQVEsS0FBSztBQUNsQixNQUFJLFFBQVEsR0FBRztBQUNuQjtBQUNBLFNBQVMsWUFBWSxPQUFPO0FBQ3hCLFNBQU8sT0FBTyxVQUFVO0FBQzVCO0FBQ0EsU0FBUyxlQUFlcUIsSUFBR2tCLElBQUc7QUFDMUIsU0FBT2xCLE1BQUtBLEtBQUlrQixNQUFLQSxLQUFJbEIsT0FBTWtCLE9BQU9sQixNQUFLLE9BQU9BLE9BQU0sWUFBYSxPQUFPQSxPQUFNO0FBQ3RGO0FBWUEsU0FBUyxTQUFTLEtBQUs7QUFDbkIsU0FBTyxPQUFPLEtBQUssR0FBRyxFQUFFLFdBQVc7QUFDdkM7QUFxQkEsU0FBUyxZQUFZLFlBQVksS0FBSyxTQUFTLElBQUk7QUFDL0MsTUFBSSxZQUFZO0FBQ1osVUFBTSxXQUFXLGlCQUFpQixZQUFZLEtBQUssU0FBUyxFQUFFO0FBQzlELFdBQU8sV0FBVyxDQUFDLEVBQUUsUUFBUTtBQUFBLEVBQ2hDO0FBQ0w7QUFDQSxTQUFTLGlCQUFpQixZQUFZLEtBQUssU0FBUyxJQUFJO0FBQ3BELFNBQU8sV0FBVyxDQUFDLEtBQUssS0FDbEIsT0FBTyxRQUFRLElBQUksTUFBTyxHQUFFLFdBQVcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFDbEQsUUFBUTtBQUNsQjtBQUNBLFNBQVMsaUJBQWlCLFlBQVksU0FBUyxPQUFPLElBQUk7QUFDdEQsTUFBSSxXQUFXLENBQUMsS0FBSyxJQUFJO0FBQ3JCLFVBQU0sT0FBTyxXQUFXLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQztBQUNwQyxRQUFJLFFBQVEsVUFBVSxRQUFXO0FBQzdCLGFBQU87QUFBQSxJQUNWO0FBQ0QsUUFBSSxPQUFPLFNBQVMsVUFBVTtBQUMxQixZQUFNLFNBQVMsQ0FBQTtBQUNmLFlBQU0sTUFBTSxLQUFLLElBQUksUUFBUSxNQUFNLFFBQVEsS0FBSyxNQUFNO0FBQ3RELGVBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDN0IsZUFBTyxDQUFDLElBQUksUUFBUSxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUM7QUFBQSxNQUN4QztBQUNELGFBQU87QUFBQSxJQUNWO0FBQ0QsV0FBTyxRQUFRLFFBQVE7QUFBQSxFQUMxQjtBQUNELFNBQU8sUUFBUTtBQUNuQjtBQUNBLFNBQVMsaUJBQWlCLE1BQU0saUJBQWlCLEtBQUssU0FBUyxjQUFjLHFCQUFxQjtBQUM5RixNQUFJLGNBQWM7QUFDZCxVQUFNLGVBQWUsaUJBQWlCLGlCQUFpQixLQUFLLFNBQVMsbUJBQW1CO0FBQ3hGLFNBQUssRUFBRSxjQUFjLFlBQVk7QUFBQSxFQUNwQztBQUNMO0FBS0EsU0FBUyx5QkFBeUIsU0FBUztBQUN2QyxNQUFJLFFBQVEsSUFBSSxTQUFTLElBQUk7QUFDekIsVUFBTSxRQUFRLENBQUE7QUFDZCxVQUFNLFNBQVMsUUFBUSxJQUFJLFNBQVM7QUFDcEMsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUs7QUFDN0IsWUFBTSxDQUFDLElBQUk7QUFBQSxJQUNkO0FBQ0QsV0FBTztBQUFBLEVBQ1Y7QUFDRCxTQUFPO0FBQ1g7QUFnQ0EsU0FBUyxjQUFjLE9BQU87QUFDMUIsU0FBTyxTQUFTLE9BQU8sS0FBSztBQUNoQztBQStKQSxTQUFTLE9BQU8sUUFBUSxNQUFNO0FBQzFCLFNBQU8sWUFBWSxJQUFJO0FBQzNCO0FBb0RBLFNBQVMsT0FBTyxRQUFRLE1BQU0sUUFBUTtBQUNsQyxTQUFPLGFBQWEsTUFBTSxVQUFVLElBQUk7QUFDNUM7QUFTQSxTQUFTLE9BQU8sTUFBTTtBQUNsQixNQUFJLEtBQUssWUFBWTtBQUNqQixTQUFLLFdBQVcsWUFBWSxJQUFJO0FBQUEsRUFDbkM7QUFDTDtBQUNBLFNBQVMsYUFBYSxZQUFZLFdBQVc7QUFDekMsV0FBUyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSyxHQUFHO0FBQzNDLFFBQUksV0FBVyxDQUFDO0FBQ1osaUJBQVcsQ0FBQyxFQUFFLEVBQUUsU0FBUztBQUFBLEVBQ2hDO0FBQ0w7QUFDQSxTQUFTLFFBQVFOLE9BQU07QUFDbkIsU0FBTyxTQUFTLGNBQWNBLEtBQUk7QUFDdEM7QUFnQkEsU0FBUyxZQUFZQSxPQUFNO0FBQ3ZCLFNBQU8sU0FBUyxnQkFBZ0IsOEJBQThCQSxLQUFJO0FBQ3RFO0FBQ0EsU0FBUyxLQUFLLE1BQU07QUFDaEIsU0FBTyxTQUFTLGVBQWUsSUFBSTtBQUN2QztBQUNBLFNBQVMsUUFBUTtBQUNiLFNBQU8sS0FBSyxHQUFHO0FBQ25CO0FBQ0EsU0FBUyxRQUFRO0FBQ2IsU0FBTyxLQUFLLEVBQUU7QUFDbEI7QUFDQSxTQUFTLE9BQU8sTUFBTSxPQUFPLFNBQVMsU0FBUztBQUMzQyxPQUFLLGlCQUFpQixPQUFPLFNBQVMsT0FBTztBQUM3QyxTQUFPLE1BQU0sS0FBSyxvQkFBb0IsT0FBTyxTQUFTLE9BQU87QUFDakU7QUE2QkEsU0FBUyxLQUFLLE1BQU0sV0FBVyxPQUFPO0FBQ2xDLE1BQUksU0FBUztBQUNULFNBQUssZ0JBQWdCLFNBQVM7QUFBQSxXQUN6QixLQUFLLGFBQWEsU0FBUyxNQUFNO0FBQ3RDLFNBQUssYUFBYSxXQUFXLEtBQUs7QUFDMUM7QUF3Q0EsU0FBUyxXQUFXLE1BQU0sV0FBVyxPQUFPO0FBQ3hDLE9BQUssZUFBZSxnQ0FBZ0MsV0FBVyxLQUFLO0FBQ3hFO0FBc0JBLFNBQVMsU0FBUzZOLFVBQVM7QUFDdkIsU0FBTyxNQUFNLEtBQUtBLFNBQVEsVUFBVTtBQUN4QztBQXVIQSxTQUFTLFNBQVMzTixPQUFNLE1BQU07QUFDMUIsU0FBTyxLQUFLO0FBQ1osTUFBSUEsTUFBSyxjQUFjO0FBQ25CLElBQUFBLE1BQUssT0FBTztBQUNwQjtBQUNBLFNBQVMsZ0JBQWdCLE9BQU8sT0FBTztBQUNuQyxRQUFNLFFBQVEsU0FBUyxPQUFPLEtBQUs7QUFDdkM7QUFTQSxTQUFTLFVBQVUsTUFBTSxLQUFLLE9BQU8sV0FBVztBQUM1QyxNQUFJLFVBQVUsTUFBTTtBQUNoQixTQUFLLE1BQU0sZUFBZSxHQUFHO0FBQUEsRUFDaEMsT0FDSTtBQUNELFNBQUssTUFBTSxZQUFZLEtBQUssT0FBTyxZQUFZLGNBQWMsRUFBRTtBQUFBLEVBQ2xFO0FBQ0w7QUFnRkEsU0FBUyxhQUFhLE1BQU0sUUFBUSxFQUFFLFVBQVUsT0FBTyxhQUFhLE1BQU8sSUFBRyxJQUFJO0FBQzlFLFFBQU0sSUFBSSxTQUFTLFlBQVksYUFBYTtBQUM1QyxJQUFFLGdCQUFnQixNQUFNLFNBQVMsWUFBWSxNQUFNO0FBQ25ELFNBQU87QUFDWDtBQXlCQSxNQUFNLFFBQVE7QUFBQSxFQUNWLFlBQVksU0FBUyxPQUFPO0FBQ3hCLFNBQUssU0FBUztBQUNkLFNBQUssU0FBUztBQUNkLFNBQUssSUFBSSxLQUFLLElBQUk7QUFBQSxFQUNyQjtBQUFBLEVBQ0QsRUFBRSxNQUFNO0FBQ0osU0FBSyxFQUFFLElBQUk7QUFBQSxFQUNkO0FBQUEsRUFDRCxFQUFFLE1BQU0sUUFBUSxTQUFTLE1BQU07QUFDM0IsUUFBSSxDQUFDLEtBQUssR0FBRztBQUNULFVBQUksS0FBSztBQUNMLGFBQUssSUFBSSxZQUFZLE9BQU8sUUFBUTtBQUFBO0FBRXBDLGFBQUssSUFBSSxRQUFRLE9BQU8sUUFBUTtBQUNwQyxXQUFLLElBQUk7QUFDVCxXQUFLLEVBQUUsSUFBSTtBQUFBLElBQ2Q7QUFDRCxTQUFLLEVBQUUsTUFBTTtBQUFBLEVBQ2hCO0FBQUEsRUFDRCxFQUFFLE1BQU07QUFDSixTQUFLLEVBQUUsWUFBWTtBQUNuQixTQUFLLElBQUksTUFBTSxLQUFLLEtBQUssRUFBRSxVQUFVO0FBQUEsRUFDeEM7QUFBQSxFQUNELEVBQUUsUUFBUTtBQUNOLGFBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxFQUFFLFFBQVEsS0FBSyxHQUFHO0FBQ3ZDLGFBQU8sS0FBSyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsTUFBTTtBQUFBLElBQ25DO0FBQUEsRUFDSjtBQUFBLEVBQ0QsRUFBRSxNQUFNO0FBQ0osU0FBSyxFQUFDO0FBQ04sU0FBSyxFQUFFLElBQUk7QUFDWCxTQUFLLEVBQUUsS0FBSyxDQUFDO0FBQUEsRUFDaEI7QUFBQSxFQUNELElBQUk7QUFDQSxTQUFLLEVBQUUsUUFBUSxNQUFNO0FBQUEsRUFDeEI7QUFDTDtBQW1DQSxTQUFTLDJCQUEyQixXQUFXLE9BQU87QUFDbEQsU0FBTyxJQUFJLFVBQVUsS0FBSztBQUM5QjtBQXdJQSxJQUFJO0FBQ0osU0FBUyxzQkFBc0IsV0FBVztBQUN0QyxzQkFBb0I7QUFDeEI7QUFDQSxTQUFTLHdCQUF3QjtBQUM3QixNQUFJLENBQUM7QUFDRCxVQUFNLElBQUksTUFBTSxrREFBa0Q7QUFDdEUsU0FBTztBQUNYO0FBb0JBLFNBQVMsUUFBUSxJQUFJO0FBQ2pCLHdCQUF1QixFQUFDLEdBQUcsU0FBUyxLQUFLLEVBQUU7QUFDL0M7QUFnQ0EsU0FBUyx3QkFBd0I7QUFDN0IsUUFBTSxZQUFZO0FBQ2xCLFNBQU8sQ0FBQyxNQUFNLFFBQVEsRUFBRSxhQUFhLE1BQU8sSUFBRyxPQUFPO0FBQ2xELFVBQU0sWUFBWSxVQUFVLEdBQUcsVUFBVSxJQUFJO0FBQzdDLFFBQUksV0FBVztBQUdYLFlBQU0sUUFBUSxhQUFhLE1BQU0sUUFBUSxFQUFFLFdBQVUsQ0FBRTtBQUN2RCxnQkFBVSxNQUFLLEVBQUcsUUFBUSxRQUFNO0FBQzVCLFdBQUcsS0FBSyxXQUFXLEtBQUs7QUFBQSxNQUN4QyxDQUFhO0FBQ0QsYUFBTyxDQUFDLE1BQU07QUFBQSxJQUNqQjtBQUNELFdBQU87QUFBQSxFQUNmO0FBQ0E7QUFxREEsTUFBTSxtQkFBbUIsQ0FBQTtBQUV6QixNQUFNLG9CQUFvQixDQUFBO0FBQzFCLE1BQU0sbUJBQW1CLENBQUE7QUFDekIsTUFBTSxrQkFBa0IsQ0FBQTtBQUN4QixNQUFNLG1CQUFtQixRQUFRO0FBQ2pDLElBQUksbUJBQW1CO0FBQ3ZCLFNBQVMsa0JBQWtCO0FBQ3ZCLE1BQUksQ0FBQyxrQkFBa0I7QUFDbkIsdUJBQW1CO0FBQ25CLHFCQUFpQixLQUFLLEtBQUs7QUFBQSxFQUM5QjtBQUNMO0FBS0EsU0FBUyxvQkFBb0IsSUFBSTtBQUM3QixtQkFBaUIsS0FBSyxFQUFFO0FBQzVCO0FBc0JBLE1BQU0saUJBQWlCLG9CQUFJO0FBQzNCLElBQUksV0FBVztBQUNmLFNBQVMsUUFBUTtBQUliLE1BQUksYUFBYSxHQUFHO0FBQ2hCO0FBQUEsRUFDSDtBQUNELFFBQU0sa0JBQWtCO0FBQ3hCLEtBQUc7QUFHQyxRQUFJO0FBQ0EsYUFBTyxXQUFXLGlCQUFpQixRQUFRO0FBQ3ZDLGNBQU0sWUFBWSxpQkFBaUIsUUFBUTtBQUMzQztBQUNBLDhCQUFzQixTQUFTO0FBQy9CLGVBQU8sVUFBVSxFQUFFO0FBQUEsTUFDdEI7QUFBQSxJQUNKLFNBQ00sR0FBUDtBQUVJLHVCQUFpQixTQUFTO0FBQzFCLGlCQUFXO0FBQ1gsWUFBTTtBQUFBLElBQ1Q7QUFDRCwwQkFBc0IsSUFBSTtBQUMxQixxQkFBaUIsU0FBUztBQUMxQixlQUFXO0FBQ1gsV0FBTyxrQkFBa0I7QUFDckIsd0JBQWtCLElBQUc7QUFJekIsYUFBUyxJQUFJLEdBQUcsSUFBSSxpQkFBaUIsUUFBUSxLQUFLLEdBQUc7QUFDakQsWUFBTSxXQUFXLGlCQUFpQixDQUFDO0FBQ25DLFVBQUksQ0FBQyxlQUFlLElBQUksUUFBUSxHQUFHO0FBRS9CLHVCQUFlLElBQUksUUFBUTtBQUMzQjtNQUNIO0FBQUEsSUFDSjtBQUNELHFCQUFpQixTQUFTO0FBQUEsRUFDbEMsU0FBYSxpQkFBaUI7QUFDMUIsU0FBTyxnQkFBZ0IsUUFBUTtBQUMzQixvQkFBZ0IsSUFBRztFQUN0QjtBQUNELHFCQUFtQjtBQUNuQixpQkFBZSxNQUFLO0FBQ3BCLHdCQUFzQixlQUFlO0FBQ3pDO0FBQ0EsU0FBUyxPQUFPLElBQUk7QUFDaEIsTUFBSSxHQUFHLGFBQWEsTUFBTTtBQUN0QixPQUFHLE9BQU07QUFDVCxZQUFRLEdBQUcsYUFBYTtBQUN4QixVQUFNLFFBQVEsR0FBRztBQUNqQixPQUFHLFFBQVEsQ0FBQyxFQUFFO0FBQ2QsT0FBRyxZQUFZLEdBQUcsU0FBUyxFQUFFLEdBQUcsS0FBSyxLQUFLO0FBQzFDLE9BQUcsYUFBYSxRQUFRLG1CQUFtQjtBQUFBLEVBQzlDO0FBQ0w7QUFlQSxNQUFNLFdBQVcsb0JBQUk7QUFDckIsSUFBSTtBQUNKLFNBQVMsZUFBZTtBQUNwQixXQUFTO0FBQUEsSUFDTCxHQUFHO0FBQUEsSUFDSCxHQUFHLENBQUU7QUFBQSxJQUNMLEdBQUc7QUFBQTtBQUFBLEVBQ1g7QUFDQTtBQUNBLFNBQVMsZUFBZTtBQUNwQixNQUFJLENBQUMsT0FBTyxHQUFHO0FBQ1gsWUFBUSxPQUFPLENBQUM7QUFBQSxFQUNuQjtBQUNELFdBQVMsT0FBTztBQUNwQjtBQUNBLFNBQVMsY0FBYyxPQUFPLE9BQU87QUFDakMsTUFBSSxTQUFTLE1BQU0sR0FBRztBQUNsQixhQUFTLE9BQU8sS0FBSztBQUNyQixVQUFNLEVBQUUsS0FBSztBQUFBLEVBQ2hCO0FBQ0w7QUFDQSxTQUFTLGVBQWUsT0FBTyxPQUFPNE4sU0FBUSxVQUFVO0FBQ3BELE1BQUksU0FBUyxNQUFNLEdBQUc7QUFDbEIsUUFBSSxTQUFTLElBQUksS0FBSztBQUNsQjtBQUNKLGFBQVMsSUFBSSxLQUFLO0FBQ2xCLFdBQU8sRUFBRSxLQUFLLE1BQU07QUFDaEIsZUFBUyxPQUFPLEtBQUs7QUFDckIsVUFBSSxVQUFVO0FBQ1YsWUFBSUE7QUFDQSxnQkFBTSxFQUFFLENBQUM7QUFDYjtNQUNIO0FBQUEsSUFDYixDQUFTO0FBQ0QsVUFBTSxFQUFFLEtBQUs7QUFBQSxFQUNoQixXQUNRLFVBQVU7QUFDZjtFQUNIO0FBQ0w7QUFtcUJBLFNBQVMsaUJBQWlCLE9BQU87QUFDN0IsV0FBUyxNQUFNO0FBQ25CO0FBSUEsU0FBUyxnQkFBZ0IsV0FBVyxRQUFRLFFBQVEsZUFBZTtBQUMvRCxRQUFNLEVBQUUsVUFBVSxpQkFBaUIsVUFBVTtBQUM3QyxjQUFZLFNBQVMsRUFBRSxRQUFRLE1BQU07QUFDckMsTUFBSSxDQUFDLGVBQWU7QUFFaEIsd0JBQW9CLE1BQU07QUFDdEIsWUFBTSxpQkFBaUIsVUFBVSxHQUFHLFNBQVMsSUFBSSxHQUFHLEVBQUUsT0FBTyxXQUFXO0FBSXhFLFVBQUksVUFBVSxHQUFHLFlBQVk7QUFDekIsa0JBQVUsR0FBRyxXQUFXLEtBQUssR0FBRyxjQUFjO0FBQUEsTUFDakQsT0FDSTtBQUdELGdCQUFRLGNBQWM7QUFBQSxNQUN6QjtBQUNELGdCQUFVLEdBQUcsV0FBVztJQUNwQyxDQUFTO0FBQUEsRUFDSjtBQUNELGVBQWEsUUFBUSxtQkFBbUI7QUFDNUM7QUFDQSxTQUFTLGtCQUFrQixXQUFXLFdBQVc7QUFDN0MsUUFBTSxLQUFLLFVBQVU7QUFDckIsTUFBSSxHQUFHLGFBQWEsTUFBTTtBQUN0QixZQUFRLEdBQUcsVUFBVTtBQUNyQixPQUFHLFlBQVksR0FBRyxTQUFTLEVBQUUsU0FBUztBQUd0QyxPQUFHLGFBQWEsR0FBRyxXQUFXO0FBQzlCLE9BQUcsTUFBTTtFQUNaO0FBQ0w7QUFDQSxTQUFTLFdBQVcsV0FBVyxHQUFHO0FBQzlCLE1BQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxNQUFNLElBQUk7QUFDOUIscUJBQWlCLEtBQUssU0FBUztBQUMvQjtBQUNBLGNBQVUsR0FBRyxNQUFNLEtBQUssQ0FBQztBQUFBLEVBQzVCO0FBQ0QsWUFBVSxHQUFHLE1BQU8sSUFBSSxLQUFNLENBQUMsS0FBTSxLQUFNLElBQUk7QUFDbkQ7QUFDQSxTQUFTLEtBQUssV0FBVyxTQUFTL0UsV0FBVWdGLGtCQUFpQixXQUFXLE9BQU8sZUFBZSxRQUFRLENBQUMsRUFBRSxHQUFHO0FBQ3hHLFFBQU0sbUJBQW1CO0FBQ3pCLHdCQUFzQixTQUFTO0FBQy9CLFFBQU0sS0FBSyxVQUFVLEtBQUs7QUFBQSxJQUN0QixVQUFVO0FBQUEsSUFDVixLQUFLLENBQUU7QUFBQTtBQUFBLElBRVA7QUFBQSxJQUNBLFFBQVE7QUFBQSxJQUNSO0FBQUEsSUFDQSxPQUFPLGFBQWM7QUFBQTtBQUFBLElBRXJCLFVBQVUsQ0FBRTtBQUFBLElBQ1osWUFBWSxDQUFFO0FBQUEsSUFDZCxlQUFlLENBQUU7QUFBQSxJQUNqQixlQUFlLENBQUU7QUFBQSxJQUNqQixjQUFjLENBQUU7QUFBQSxJQUNoQixTQUFTLElBQUksSUFBSSxRQUFRLFlBQVksbUJBQW1CLGlCQUFpQixHQUFHLFVBQVUsQ0FBQSxFQUFHO0FBQUE7QUFBQSxJQUV6RixXQUFXLGFBQWM7QUFBQSxJQUN6QjtBQUFBLElBQ0EsWUFBWTtBQUFBLElBQ1osTUFBTSxRQUFRLFVBQVUsaUJBQWlCLEdBQUc7QUFBQSxFQUNwRDtBQUNJLG1CQUFpQixjQUFjLEdBQUcsSUFBSTtBQUN0QyxNQUFJLFFBQVE7QUFDWixLQUFHLE1BQU1oRixZQUNIQSxVQUFTLFdBQVcsUUFBUSxTQUFTLENBQUUsR0FBRSxDQUFDLEdBQUcsUUFBUSxTQUFTO0FBQzVELFVBQU0sUUFBUSxLQUFLLFNBQVMsS0FBSyxDQUFDLElBQUk7QUFDdEMsUUFBSSxHQUFHLE9BQU8sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQ25ELFVBQUksQ0FBQyxHQUFHLGNBQWMsR0FBRyxNQUFNLENBQUM7QUFDNUIsV0FBRyxNQUFNLENBQUMsRUFBRSxLQUFLO0FBQ3JCLFVBQUk7QUFDQSxtQkFBVyxXQUFXLENBQUM7QUFBQSxJQUM5QjtBQUNELFdBQU87QUFBQSxFQUNuQixDQUFTLElBQ0M7QUFDTixLQUFHLE9BQU07QUFDVCxVQUFRO0FBQ1IsVUFBUSxHQUFHLGFBQWE7QUFFeEIsS0FBRyxXQUFXZ0YsbUJBQWtCQSxpQkFBZ0IsR0FBRyxHQUFHLElBQUk7QUFDMUQsTUFBSSxRQUFRLFFBQVE7QUFDaEIsUUFBSSxRQUFRLFNBQVM7QUFFakIsWUFBTSxRQUFRLFNBQVMsUUFBUSxNQUFNO0FBRXJDLFNBQUcsWUFBWSxHQUFHLFNBQVMsRUFBRSxLQUFLO0FBQ2xDLFlBQU0sUUFBUSxNQUFNO0FBQUEsSUFDdkIsT0FDSTtBQUVELFNBQUcsWUFBWSxHQUFHLFNBQVMsRUFBQztBQUFBLElBQy9CO0FBQ0QsUUFBSSxRQUFRO0FBQ1Isb0JBQWMsVUFBVSxHQUFHLFFBQVE7QUFDdkMsb0JBQWdCLFdBQVcsUUFBUSxRQUFRLFFBQVEsUUFBUSxRQUFRLGFBQWE7QUFFaEY7RUFDSDtBQUNELHdCQUFzQixnQkFBZ0I7QUFDMUM7QUFvREEsTUFBTSxnQkFBZ0I7QUFBQSxFQUNsQixXQUFXO0FBQ1Asc0JBQWtCLE1BQU0sQ0FBQztBQUN6QixTQUFLLFdBQVc7QUFBQSxFQUNuQjtBQUFBLEVBQ0QsSUFBSSxNQUFNLFVBQVU7QUFDaEIsUUFBSSxDQUFDLFlBQVksUUFBUSxHQUFHO0FBQ3hCLGFBQU87QUFBQSxJQUNWO0FBQ0QsVUFBTSxZQUFhLEtBQUssR0FBRyxVQUFVLElBQUksTUFBTSxLQUFLLEdBQUcsVUFBVSxJQUFJLElBQUksQ0FBQTtBQUN6RSxjQUFVLEtBQUssUUFBUTtBQUN2QixXQUFPLE1BQU07QUFDVCxZQUFNLFFBQVEsVUFBVSxRQUFRLFFBQVE7QUFDeEMsVUFBSSxVQUFVO0FBQ1Ysa0JBQVUsT0FBTyxPQUFPLENBQUM7QUFBQSxJQUN6QztBQUFBLEVBQ0s7QUFBQSxFQUNELEtBQUssU0FBUztBQUNWLFFBQUksS0FBSyxTQUFTLENBQUMsU0FBUyxPQUFPLEdBQUc7QUFDbEMsV0FBSyxHQUFHLGFBQWE7QUFDckIsV0FBSyxNQUFNLE9BQU87QUFDbEIsV0FBSyxHQUFHLGFBQWE7QUFBQSxJQUN4QjtBQUFBLEVBQ0o7QUFDTDs7Ozs7Ozs7Ozs7O0lDMStEZSxJQUFNLENBQUE7QUFBQTs7aUNBQVgsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBQUNDLEtBQU0sQ0FBQTs7bUNBQVgsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7d0NBQUo7QUFBQTs7Ozs7Ozs7Ozs7QUFNeUMsTUFBQSxXQUFBLEVBQUUsVUFBVSxJQUFBOzs7QUFBSyxNQUFBO0FBQUE7QUFBQSxJQUFBLFFBQUksV0FBUTtBQUFBOzs7Ozs7Z0JBQWYsSUFBRTs7Ozs7QUFBL0MsYUFBa0UsUUFBQSxLQUFBLE1BQUE7Ozs7OztBQUFsQixVQUFBO0FBQUEsTUFBQSxLQUFBLGNBQUE7QUFBQSxNQUFBQSxTQUFJLFdBQVE7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBQTs7Ozs7Ozs7OztBQUhsQyxNQUFBO0FBQUE7QUFBQSxJQUFBLFFBQUksYUFBVTtBQUFBOzs7aUJBQUc7Ozs7QUFDWixNQUFBO0FBQUE7QUFBQSxJQUFBLFFBQUksVUFBTztBQUFBOzs7OztLQUFHLElBQUcsRUFBQSxFQUFDLGVBQWUsTUFBRTtBQUFBOzs7Ozs7O0FBQ2pFLE1BQUE7QUFBQTtBQUFBLElBQUEsUUFBSSxZQUFRQyxvQkFBQSxHQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFIVCxXQUFBLEtBQUEsU0FBQSxrQkFBQTtBQUFBO0FBQUEsUUFBQTtRQUFNLElBQVksQ0FBQSxJQUFHLDZCQUE2QjtBQUFBLE1BQVMsSUFBQSxpQkFBQTtBQUFBOztBQUF2RSxhQU1LLFFBQUEsS0FBQSxNQUFBO0FBTEQsYUFBMEQsS0FBQSxLQUFBOzs7OztBQUMxRCxhQUE2RSxLQUFBLEtBQUE7Ozs7Ozs7Ozs7Ozs7OztBQUQvQyxVQUFBO0FBQUEsTUFBQSxLQUFBLGNBQUE7QUFBQSxNQUFBLFFBQUksYUFBVTtBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUNULFVBQUE7QUFBQSxNQUFBLEtBQUEsY0FBQTtBQUFBLE1BQUEsUUFBSSxVQUFPO0FBQUEsaUJBQUEsSUFBQSxRQUFBOzs7T0FBRyxJQUFHLEVBQUEsRUFBQyxlQUFlLE1BQUU7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFDakU7QUFBQTtBQUFBLFFBQUEsUUFBSTtBQUFBLFFBQVE7Ozs7Ozs7Ozs7OztBQUhULFVBQUE7QUFBQSxNQUFBLEtBQUEscUJBQUEsa0JBQUE7QUFBQTtBQUFBLFFBQUE7UUFBTSxJQUFZLENBQUEsSUFBRyw2QkFBNkI7QUFBQSxNQUFTLElBQUEsb0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSDFFLElBQU0sQ0FBQSxLQUFBQyxrQkFBQSxHQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXJCZixhQWlDSyxRQUFBLE1BQUEsTUFBQTtBQWhDRCxhQW1CSyxNQUFBLElBQUE7QUFsQkQsYUFXQSxNQUFBLEdBQUE7QUFISyxhQUVDLEtBQUEsSUFBQTs7QUFFTixhQUtDLE1BQUEsS0FBQTs7OztRQUZlLElBQU8sQ0FBQTtBQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7WUFDUCxJQUFVLENBQUE7QUFBQSxVQUFBO0FBQUE7Ozs7Ozs7TUFEVkYsS0FBTyxDQUFBLEdBQUE7Ozs7VUFBUEEsS0FBTyxDQUFBO0FBQUEsUUFBQTtBQUFBOzs7UUFJdEJBLEtBQU0sQ0FBQTtBQUFBLFFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBN0ZMLFFBQUEsaUJBQWlCLFVBQVUsSUFBcUIsZ0JBQWdCO01BRWxFLFdBQUEsQ0FBQTtBQUVBLE1BQUEsVUFBVTtBQUVWLE1BQUEsZUFBZTtNQUVmLFNBQUEsQ0FBQTtBQUVFLFFBQUEsYUFBYyxPQUFBO1FBQ1osRUFBRSxZQUFZLElBQUE7QUFDZDs7O1FBS0EsRUFBRSxZQUFZLElBQUE7QUFDZCxRQUFFLGVBQUE7QUFDRSxVQUFBLGlCQUFpQixHQUFBOzs7c0JBR3JCLGdCQUFBLFlBQUE7OztRQUlBLEVBQUUsWUFBWSxJQUFBO1lBQ1IsTUFBTSxPQUFPO0FBQ25CLFFBQUUsZUFBQTtVQUNFLGdCQUFnQixNQUFNLEdBQUE7OztzQkFHMUIsZ0JBQUEsWUFBQTtBQUFBOztRQUlGLFVBQUEsTUFBQTtVQUNJLE1BQU0sT0FBTyxZQUFZO0FBQy9CLFdBQU8sV0FBQTtBQUNQLFFBQUksU0FBQTtBQUFBO0FBR0YsUUFBQSxVQUFXLE9BQUE7QUFDYixpQkFBQSxHQUFBLGVBQWUsQ0FBQTtBQUNmOztBQUdFLFFBQUEsY0FBYyxHQUF1QixNQUFjLEtBQUssRUFBRSxjQUFjLFFBQVEsRUFBRSxrQkFBa0I7QUFrQjFHLFVBQUEsTUFBQTtvQkFDSSxXQUFXLGVBQWUsWUFBQSxDQUFBO0FBQ3BCLFVBQUEsS0FBSyxTQUFTLGVBQWUsbUJBQW1CO0FBQ3RELE9BQUcsTUFBQTtBQUFBOztBQXFCYSxjQUFPLEtBQUE7OztBQU9zRSxRQUFBLGdCQUFBLE9BQUEsUUFBUSxDQUFDOzs7O0FBL0MxRztBQUNJLHFCQUFBLEdBQUEsZUFBZSxDQUFBO2FBQ1YsU0FBQTtBQUNELHVCQUFBLEdBQUEsU0FBUyxRQUFBO0FBQUE7QUFFVCx1QkFBQSxHQUFBLFNBQVMsU0FBUyxPQUFRLE9BQUE7QUFFbEIsbUJBQUEsV0FBVyxFQUFFLFFBQVEsT0FBTyxLQUM1QixXQUFXLEVBQUUsWUFBWSxPQUFPLEtBQ2hDLFdBQVcsRUFBRSxTQUFTLE9BQU8sS0FDN0IsV0FBVyxFQUFFLGFBQWEsT0FBTztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0Q5QyxNQUFNLDJCQUEyQixPQUFPO0FBQUEsRUFHM0MsU0FBZTtBQUNYLFNBQUssZ0JBQWdCO0FBQUEsTUFDakIsU0FBUztBQUFBLE1BQ1QsYUFBYSxFQUFFLG9CQUFvQjtBQUFBLE1BQ25DLFVBQVU7QUFBQSxNQUNWLFVBQVUsTUFBTTtBQUNaLGFBQUssVUFBVTtBQUFBLE1BQ25CO0FBQUEsSUFBQSxDQUNIO0FBQUEsRUFDTDtBQUFBLEVBRUEsWUFBWTtBQUNSLFdBQU8sV0FBVztBQUNsQixRQUFJLE9BQU8sRUFBRSxTQUFTLGlDQUFrQyxDQUFBO0FBQ3hELGlCQUFhLE1BQU07QUFDZixVQUFJRyxjQUErQjtBQUFBLFFBQy9CLFFBQVEsU0FBUyxlQUFlLGVBQWU7QUFBQSxNQUFBLENBQ2xEO0FBQUEsSUFBQSxDQUNKO0FBQUEsRUFDTDtBQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbUNZLGFBQTZILFFBQUEsT0FBQSxNQUFBO0FBQTNDO0FBQUEsUUFBQTtBQUFBO0FBQUEsUUFBQSxPQUFPO0FBQUEsTUFBSzs7Ozs7QUFBYSxnQkFBQTtBQUFBO0FBQUEsY0FBQSxJQUFPLENBQUEsRUFBQTtBQUFBLFlBQVE7QUFBZixxQkFBTyxTQUFRLE1BQUEsTUFBQSxTQUFBO0FBQUE7Ozs7Ozs7OztBQUF4QztBQUFBLFVBQUE7QUFBQTtBQUFBLFVBQUEsT0FBTztBQUFBLFFBQUs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRjlGLGFBQW9ILFFBQUEsT0FBQSxNQUFBO0FBQTdDLFlBQUE7QUFBQSxNQUFBLE9BQU87Ozs7O0FBQW9CLGdCQUFBO0FBQUE7QUFBQSxjQUFBLElBQU8sQ0FBQSxFQUFBO0FBQUEsWUFBUTtBQUFmLHFCQUFPLFNBQVEsTUFBQSxNQUFBLFNBQUE7QUFBQTs7Ozs7Ozs7O0FBQTFDLGNBQUE7QUFBQSxRQUFBLE9BQU87QUFBQTs7Ozs7Ozs7Ozs7OztBQUw3RSxNQUFBO0FBQUE7QUFBQSxJQUFBLE9BQU8sUUFBSztBQUFBOzs7O0FBQ2dCLE1BQUE7QUFBQTtBQUFBLElBQUEsT0FBTyxNQUFHO0FBQUE7Ozs7Ozs7OztNQUd0Q0gsS0FBTSxDQUFBLEVBQUMsU0FBUztBQUFBO0FBQVUsYUFBQUU7OztNQUVyQkYsS0FBTSxDQUFBLEVBQUMsU0FBUztBQUFBO0FBQU8sYUFBQUM7QUFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUnJDLGFBV08sUUFBQSxPQUFBLE1BQUE7QUFWSCxhQUdLLE9BQUEsSUFBQTs7O0FBREQsYUFBNkMsTUFBQSxJQUFBOzs7QUFFakQsYUFBeUIsT0FBQSxJQUFBOzs7Ozs7O0FBSHBCLFVBQUE7QUFBQSxNQUFBLEtBQUEsY0FBQTtBQUFBLE1BQUFELFFBQU8sUUFBSztBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUNnQixVQUFBO0FBQUEsTUFBQSxLQUFBLGNBQUE7QUFBQSxNQUFBQSxRQUFPLE1BQUc7QUFBQSxpQkFBQSxJQUFBLFFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSjVDLElBQU8sQ0FBQTtBQUFBOztpQ0FBWixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFBQ0EsS0FBTyxDQUFBOzttQ0FBWixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozt3Q0FBSjtBQUFBOzs7Ozs7Ozs7Ozs7QUE5Q1EsUUFBQSxpQkFBaUIsVUFBVSxJQUFxQixNQUFNLGNBQWM7QUFDcEUsUUFBQSxlQUFlLFVBQVUsSUFBbUIsTUFBTSxZQUFZO01BRWhFLFVBQUE7QUFBQTtNQUVJLE9BQU8sRUFBRSxVQUFVO0FBQUEsTUFDbkIsS0FBSyxFQUFFLGFBQWE7QUFBQSxNQUNwQixTQUFTO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTixVQUFXLFdBQUE7QUFDRCxjQUFBLFVBQVUsTUFBTSxPQUFPO1lBQ3pCLFNBQUE7QUFDQSx1QkFBYSxlQUFBO0FBQUE7QUFFYix1QkFBYSxnQkFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O01BY3JCLE9BQU8sRUFBRSxXQUFXO0FBQUEsTUFDcEIsUUFBUSxFQUFFLGVBQWUsS0FBSyxjQUFjO0FBQUEsTUFDNUMsTUFBTTtBQUFBLE1BQ04sT0FBTyxlQUFlLElBQUksZ0JBQWdCO0FBQUEsTUFDMUMsVUFBVyxXQUFBO0FBQ1AsdUJBQWUsSUFBSSxrQkFBa0IsTUFBTSxPQUFPLEtBQUs7QUFBQTs7O0FBS25FLFVBQUEsTUFBQTtBQUNVLFVBQUEsZUFBZSxlQUFlLElBQUksK0JBQStCO0FBQ3ZFLGlCQUFBLEdBQUEsUUFBUSxDQUFDLEVBQUUsVUFBVSxjQUFBLE9BQUE7QUFDZixVQUFBLGFBQWEsZUFBZSxJQUFJLHlCQUF5QjtBQUMvRCxpQkFBQSxHQUFBLFFBQVEsQ0FBQyxFQUFFLFVBQVUsWUFBQSxPQUFBO0FBQUE7OzZCQVk2RCxVQUFPLEtBQUE7Ozs7NkJBRUksUUFBSyxLQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUGpGLE1BQUE7QUFBQTtBQUFBLElBQUEsUUFBTyxPQUFJO0FBQUE7OztBQUNYLE1BQUE7QUFBQTtBQUFBLElBQUEsUUFBTyxVQUFPO0FBQUE7Ozs7OztBQUlWLE1BQUE7QUFBQTtBQUFBLEtBQUEsSUFBTyxFQUFBLEVBQUEsZUFBZSxFQUFFLGVBQWUsS0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRjZCLFlBQUEsY0FBQSxHQUFBLEVBQUUsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUw5RixhQWtCTyxRQUFBLE9BQUEsTUFBQTtBQWpCSCxhQVFLLE9BQUEsSUFBQTs7Ozs7QUFKRCxhQUE4RixNQUFBLEtBQUE7O0FBQzlGLGFBRUssTUFBQSxJQUFBOzs7QUFFVCxhQUF5QixPQUFBLEtBQUE7O0FBQ3pCLGFBTUMsT0FBQSxLQUFBO0FBRmlCLFlBQUE7QUFBQSxNQUFBLFFBQU87Ozs7Ozs7OztjQUNWLElBQXFCLENBQUE7QUFBQTtBQUFBLGdCQUFDLElBQU8sRUFBQSxFQUFBO0FBQUEsY0FBRztBQUFBO0FBQWhDLGtCQUFxQixDQUFBO0FBQUE7QUFBQSxnQkFBQyxJQUFNLEVBQUEsRUFBQztBQUFBLGNBQUcsRUFBQSxNQUFBLE1BQUEsU0FBQTtBQUFBOzs7Ozs7O0FBZDFDLFVBQUE7QUFBQSxNQUFBLEtBQUEsY0FBQTtBQUFBLE1BQUEsUUFBTyxPQUFJO0FBQUEsaUJBQUEsSUFBQSxRQUFBO0FBQ1gsVUFBQTtBQUFBLE1BQUEsS0FBQSxjQUFBO0FBQUEsTUFBQSxRQUFPLFVBQU87QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFJVixVQUFBO0FBQUEsTUFBQSxLQUFBLGNBQUE7QUFBQSxPQUFBLElBQU8sRUFBQSxFQUFBLGVBQWUsRUFBRSxlQUFlLEtBQUE7QUFBQSxpQkFBQSxJQUFBLFFBQUE7OztBQVE5QixjQUFBO0FBQUEsUUFBQSxRQUFPO0FBQUE7Ozs7Ozs7Ozs7OztBQWhCM0IsTUFBQSxXQUFBO0FBQUEsRUFBQSxRQUFPLFVBQU1FLGtCQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7QUFBYixVQUFBO0FBQUEsTUFBQUYsU0FBTyxRQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQURoQixJQUFjLENBQUE7QUFBQTs7aUNBQW5CLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7OztBQUZkLGFBMEJPLFFBQUEsT0FBQSxNQUFBO0FBekJILGFBd0JLLE9BQUEsR0FBQTs7Ozs7Ozs7O1FBdkJNQSxLQUFjLENBQUE7O21DQUFuQixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozt3Q0FBSjtBQUFBOzs7Ozs7Ozs7Ozs7O0FBN0NBLFFBQUEsaUJBQWlCLFVBQVUsSUFBcUIsTUFBTSxjQUFjO0FBQ3BFLFFBQUEsZUFBZSxVQUFVLElBQW1CLE1BQU0sWUFBWTtNQUVoRSxVQUFBLENBQUE7UUFJRSxjQUFBLE1BQUE7b0JBQ0YsVUFBVSxlQUFlLFdBQUEsQ0FBQTtBQUFBO0FBR3ZCLFFBQUEsYUFBYTtRQUViLHdCQUF5QixTQUFBLE9BQXVCLFVBQUE7QUFDNUMsVUFBQSxXQUFXLGVBQWUsSUFBSSwrQkFBK0I7QUFDN0QsVUFBQSxVQUFVLE1BQU0sT0FBTztBQUN2QixVQUFBLGVBQWUsaUJBQWlCLEtBQUssT0FBTztRQUM5QyxVQUFBOzs7UUFHQSxTQUFBO0FBQ0EsbUJBQWEsV0FBVyxHQUFHO0FBQUE7QUFFM0IsbUJBQWEsYUFBYSxHQUFHO0FBQUE7QUFFakMsZUFBVyxRQUFRO0FBQUE7UUFHakJJLGFBQUEsT0FBbUIsS0FBYSxVQUFBO0FBQ2xDLFVBQU0sZUFBQTtBQUNOLFVBQU0sZ0JBQUE7VUFDQSxhQUFhLGFBQWEsR0FBRztVQUM3QixlQUFlLGdCQUFnQixHQUFHO0FBQ2xDLFVBQUEsZUFBZTtBQUNyQjs7QUFHSixVQUFBLFlBQUE7QUFDVSxVQUFBLGVBQWU7QUFDckI7O0FBYWdELFFBQUEsZ0JBQUEsQ0FBQUMsU0FBQSxVQUFVRCxXQUFVQyxRQUFPLEtBQUssS0FBSzs7NkJBVWhELFVBQU8sS0FBQTs7Ozs7O0FBekRoRCxtQkFBQSxHQUFHLGlCQUFpQixRQUFRLE9BQVEsT0FBTSxFQUFFLE1BQU0sQ0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0gvQyxJQUFNLFFBQU4sTUFBOEI7QUFBQSxFQUlqQyxZQUFtRSxnQkFBaUM7QUFBakMsU0FBQSxpQkFBQTtBQUMvRCxTQUFLLFVBQVU7QUFDZixTQUFLLGVBQWU7RUFDeEI7QUFBQSxFQUVBLE1BQWEsT0FBTztBQUNoQixTQUFLLFVBQVU7QUFDZixTQUFLLGVBQWU7QUFDZCxVQUFBLFFBQVEsSUFBSSxDQUFDLEtBQUssc0JBQXNCLEtBQUssZUFBZSxZQUFhLENBQUEsQ0FBQztBQUMxRSxVQUFBLFVBQVUsS0FBSyxlQUFlLFdBQVc7QUFDL0MsVUFBTSxlQUFvQyxDQUFBO0FBQy9CLGVBQUFBLFdBQVUsS0FBSyxTQUFTO0FBQy9CLFlBQU0sSUFBdUIsRUFBRSxHQUFHQSxTQUFRLFNBQVMsT0FBTyxhQUFhO0FBQ2pFLFlBQUEsWUFBWSxRQUFRLEtBQUssQ0FBQzVOLE9BQU1BLEdBQUUsUUFBUTROLFFBQU8sR0FBRztBQUMxRCxVQUFJLFdBQVc7QUFDWCxVQUFFLFVBQVU7QUFDWixjQUFNLEtBQUssSUFBSXhNLE9BQUFBLE9BQU8sRUFBRSxPQUFPO0FBQy9CLGNBQU0sYUFBYSxJQUFJQSxPQUFBQSxPQUFPLFVBQVUsT0FBTztBQUMvQyxZQUFJLEdBQUcsUUFBUSxVQUFVLE1BQU0sR0FBRztBQUM5QixZQUFFLGNBQWM7QUFBQSxRQUNwQjtBQUFBLE1BQ0o7QUFDQSxtQkFBYSxLQUFLLENBQUM7QUFBQSxJQUN2QjtBQUNBLFNBQUssZUFBZTtBQUFBLEVBQ3hCO0FBQUEsRUFFTyxjQUFjO0FBQ1YsV0FBQSxLQUFLLGVBQWUsSUFBSSxnQkFBZ0I7QUFBQSxFQUNuRDtBQUFBLEVBRU8sYUFBYTtBQUNoQixXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBRUEsTUFBYSxjQUFjO0FBQ3ZCLFVBQU0sS0FBSztBQUNYLFdBQU8sS0FBSztFQUNoQjtBQUFBLEVBRU8sdUJBQXVCO0FBQzFCLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxNQUFhLHFCQUFxQjs7QUFDeEIsVUFBQSxXQUFXLEtBQUs7QUFDdEIsUUFBSSxDQUFDLFVBQVU7QUFDWDtBQUFBLElBQ0o7QUFDSSxRQUFBO0FBQ0EsUUFBQTtBQUNBLFlBQU0sTUFBTSxRQUFRLElBQUksV0FBVyxpQkFBaUI7QUFBQSxRQUNoRCxTQUFTO0FBQUEsVUFDTCxpQkFBaUI7QUFBQSxRQUNyQjtBQUFBLE1BQUEsQ0FDSDtBQUFBLGFBQ0k7QUFDTCxjQUFRLE1BQU0sQ0FBQztBQUNmO0FBQUEsSUFDSjtBQUNBLFVBQU0sTUFBTSxDQUFBO0FBQ1osUUFBSSxNQUFNLFNBQVE5QyxNQUFBLElBQUksU0FBSixnQkFBQUEsSUFBVSxPQUFPLEdBQUc7QUFDbEMsaUJBQVcsZUFBYSxTQUFJLFNBQUosbUJBQVUsWUFBVyxDQUFBLEdBQUk7QUFDN0MsY0FBTXNQLFVBQVMsS0FBSyxrQkFBa0IsR0FBRyxZQUFZLFdBQVc7QUFDaEUsWUFBSSxLQUFLQSxPQUFNO0FBQUEsTUFDbkI7QUFBQSxJQUNKO0FBQ0EsU0FBSyxVQUFVLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFBQSxFQUN4QztBQUFBLEVBRUEsTUFBYSxlQUFleE8sTUFBYTtBQUNyQyxXQUFPLFFBQVEsSUFBSSxDQUFDLEtBQUssa0JBQWtCQSxJQUFHLEdBQUcsS0FBSyxnQkFBZ0JBLElBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLFVBQVU7QUFDbEYsYUFBQTtBQUFBLFFBQ0gsVUFBVSxNQUFNLENBQUM7QUFBQSxRQUNqQixRQUFRLE1BQU0sQ0FBQztBQUFBLE1BQUE7QUFBQSxJQUNuQixDQUNIO0FBQUEsRUFDTDtBQUFBLEVBRUEsTUFBYSxrQkFBa0JBLE1BQWE7QUFDcEMsUUFBQTtBQUNBLFlBQU0sV0FBVyxNQUFNLFFBQVEsSUFBSSxHQUFHQSxzQkFBcUI7QUFBQSxRQUN2RCxTQUFTO0FBQUEsVUFDTCxnQkFBZ0I7QUFBQSxVQUNoQixpQkFBaUI7QUFBQSxRQUNyQjtBQUFBLE1BQUEsQ0FDSDtBQUNELGFBQU8sU0FBUztBQUFBLGFBQ1g7QUFDTCxjQUFRLE1BQU0sQ0FBQztBQUNSLGFBQUE7QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBYSxnQkFBZ0JBLE1BQWE7QUFDbEMsUUFBQTtBQUNBLFlBQU0sTUFBTSxNQUFNLFFBQVEsSUFBSSxHQUFHQSxnQkFBZTtBQUFBLFFBQzVDLFNBQVM7QUFBQSxVQUNMLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFFBQ3JCO0FBQUEsTUFBQSxDQUNIO0FBQ0QsYUFBTyxJQUFJO0FBQUEsYUFDTjtBQUNMLGNBQVEsTUFBTSxDQUFDO0FBQ1IsYUFBQTtBQUFBLElBQ1g7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFhLGdCQUFnQixLQUFhO0FBQ3RDLFVBQU1BLE9BQU0sR0FBRyxLQUFLLFlBQUEsS0FBaUI7QUFDakMsUUFBQTtBQUNBLFlBQU0sTUFBTSxNQUFNLFFBQVEsSUFBSSxHQUFHQSxrQkFBaUI7QUFBQSxRQUM5QyxTQUFTO0FBQUEsVUFDTCxnQkFBZ0I7QUFBQSxVQUNoQixpQkFBaUI7QUFBQSxRQUNyQjtBQUFBLE1BQUEsQ0FDSDtBQUNELGFBQU8sSUFBSTtBQUFBLGFBQ047QUFDTCxjQUFRLE1BQU0sQ0FBQztBQUNSLGFBQUE7QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBYSxlQUFlLEtBQWE7QUFDckMsVUFBTSxNQUFNLEdBQUc7QUFDVCxVQUFBLFFBQVEsTUFBTSxLQUFLLGVBQWUsR0FBRyxLQUFLLGlCQUFpQixLQUFLO0FBQ3RFLFVBQU0sZUFBZSxNQUFNO0FBQzNCLFVBQU0sU0FBUyxNQUFNO0FBQ2QsV0FBQSxNQUFNLFFBQVEsSUFBSTtBQUFBLE1BQ3JCLFdBQVcsaUJBQWlCLFFBQVEsUUFBUSxpQkFBaUIsT0FBTyxNQUFNLElBQUk7QUFBQSxNQUM5RSxXQUFXLGVBQWUsRUFBRSxRQUFRLFFBQVEsaUJBQWlCLHFCQUFxQixLQUFLLFVBQVUsWUFBWSxHQUFHLEtBQUs7QUFBQSxNQUNySCxXQUFXLGlCQUFpQixRQUFRLFFBQVEsaUJBQWlCLGVBQWUsUUFBUSxLQUFLO0FBQUEsSUFBQSxDQUM1RjtBQUFBLEVBQ0w7QUFDSjtBQTVJYSxRQUFOeU8sa0JBQUE7QUFBQSxFQUROLFdBQVc7QUFBQSxFQUtJQyxrQkFBQSxHQUFDLE9BQXdCLE1BQU0sY0FBYyxDQUFBO0FBQUEsR0FKaEQsS0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTGIsYUFBd0UsUUFBQSxRQUFBLE1BQUE7Ozs7Ozs7QUFBdEQsY0FBQTtBQUFBO0FBQUEsWUFBQTs7QUFBQSxnQkFBTyxDQUFBLEVBQUEsTUFBQSxNQUFBLFNBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSlYsTUFBQSxFQUFBLFVBQXNCLEtBQUEsSUFBQTtBQUN0QixNQUFBLEVBQUEsV0FBb0IsTUFBQSxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzRDbUIsTUFBQSxXQUFBLEVBQUUsS0FBSyxJQUFBOzs7O0FBQTJELE1BQUE7QUFBQTtBQUFBLElBQUEsT0FBTyxNQUFHO0FBQUE7Ozs7Ozs7Z0JBQW5FLElBQUU7OztBQUFTLFdBQUFqTyxJQUFBLFFBQUE7QUFBQSxNQUFBLE9BQU8sR0FBRzs7Ozs7O0FBQXhELGFBQWlILFFBQUEsS0FBQSxNQUFBOzs7QUFBNUUsYUFBc0UsS0FBQUEsRUFBQTs7OztBQUFmLFVBQUE7QUFBQSxNQUFBLEtBQUEsY0FBQTtBQUFBLE1BQUEwTixRQUFPLE1BQUc7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBeEQsVUFBQTtBQUFBLE1BQUEsS0FBQSxrQkFBQTtBQUFBLE1BQUFBLFFBQU8sTUFBRzs7Ozs7Ozs7Ozs7O0FBQzNCLE1BQUEsV0FBQSxFQUFFLFFBQVEsSUFBQTs7O0FBQUssTUFBQTtBQUFBO0FBQUEsSUFBQSxPQUFPLFNBQU07QUFBQTs7Ozs7O2dCQUFoQixJQUFFOzs7OztBQUF4QyxhQUE2RCxRQUFBLEtBQUEsTUFBQTs7Ozs7O0FBQXBCLFVBQUE7QUFBQSxNQUFBLEtBQUEsY0FBQTtBQUFBLE1BQUFBLFFBQU8sU0FBTTtBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUFBOzs7Ozs7Ozs7QUFDM0IsTUFBQSxXQUFBLEVBQUUsU0FBUyxJQUFBOzs7QUFBSyxNQUFBO0FBQUE7QUFBQSxJQUFBLE9BQU8sVUFBTztBQUFBOzs7Ozs7Z0JBQWpCLElBQUU7Ozs7O0FBQXpDLGFBQStELFFBQUEsS0FBQSxNQUFBOzs7Ozs7QUFBckIsVUFBQTtBQUFBLE1BQUEsS0FBQSxjQUFBO0FBQUEsTUFBQUEsUUFBTyxVQUFPO0FBQUEsaUJBQUEsSUFBQSxRQUFBO0FBQUE7Ozs7Ozs7OztBQUMxQixNQUFBLFdBQUEsRUFBRSxhQUFhLElBQUE7OztBQUFLLE1BQUE7QUFBQTtBQUFBLElBQUEsT0FBTyxjQUFXO0FBQUE7Ozs7OztnQkFBckIsSUFBRTs7Ozs7QUFBN0MsYUFBdUUsUUFBQSxLQUFBLE1BQUE7Ozs7OztBQUF6QixVQUFBO0FBQUEsTUFBQSxLQUFBLGNBQUE7QUFBQSxNQUFBQSxRQUFPLGNBQVc7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBQTs7Ozs7Ozs7Ozs7SUFRakYsSUFBVyxDQUFBLEVBQUEsSUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7TUFBWEEsS0FBVyxDQUFBLEVBQUEsSUFBQTtBQUFBLGlCQUFBLEVBQUEsU0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7OztBQUZYLFdBQUEsY0FBQSxHQUFBLEVBQUUsUUFBUTtBQUFBOztBQUFqQixhQUF5QixRQUFBLE1BQUEsTUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FBakJDLE1BQUE7QUFBQTtBQUFBLElBQUEsT0FBTyxPQUFJO0FBQUE7Ozs7O0FBQ1gsTUFBQTtBQUFBO0FBQUEsSUFBQSxPQUFPLE1BQUc7QUFBQTs7Ozs7OztBQUd1RixNQUFBLFdBQUEsRUFBRSxRQUFRLElBQUE7Ozs7Ozs7Ozs7Ozs7QUFJaEksTUFBQTtBQUFBO0FBQUEsSUFBQSxPQUFPLE9BQUdRLG9CQUFBLEdBQUE7QUFBQTtBQUNWLE1BQUE7QUFBQTtBQUFBLElBQUEsT0FBTyxVQUFNQyxvQkFBQSxHQUFBO0FBQUE7QUFDYixNQUFBO0FBQUE7QUFBQSxJQUFBLE9BQU8sV0FBT0Msb0JBQUEsR0FBQTtBQUFBO0FBQ2QsTUFBQTtBQUFBO0FBQUEsSUFBQSxPQUFPLGVBQVdULG9CQUFBLEdBQUE7QUFBQTs7OztNQUt0QkQsS0FBTyxDQUFBO0FBQUE7QUFBQSxhQUFBRTs7Ozs7Ozs7Ozs7Ozs7Z0JBZmdCLEdBQUM7O2dCQUFZLEdBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUpsRCxhQXlCSyxRQUFBLE1BQUEsTUFBQTtBQXhCRCxhQWVLLE1BQUEsSUFBQTtBQWRELGFBTUssTUFBQSxJQUFBO0FBTEQsYUFBMkMsTUFBQSxJQUFBOzs7QUFDM0MsYUFBMkMsTUFBQSxJQUFBOzs7OztBQUczQyxhQUErSSxNQUFBLE1BQUE7QUFBbkYsYUFBOEQsUUFBQSxHQUFBO0FBQXBDLGFBQThCLEtBQUEsR0FBQTs7O0FBR3hILGFBS0ssTUFBQSxJQUFBOzs7Ozs7Ozs7Ozs7O0FBRVQsYUFBSSxNQUFBLEVBQUE7O0FBQ0osYUFNSyxNQUFBLElBQUE7Ozs7Ozs7Ozs7Ozs7QUFyQjZCLFVBQUE7QUFBQSxNQUFBLEtBQUEsY0FBQTtBQUFBLE1BQUFGLFFBQU8sT0FBSTtBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUNYLFVBQUE7QUFBQSxNQUFBLEtBQUEsY0FBQTtBQUFBLE1BQUFBLFFBQU8sTUFBRztBQUFBLGlCQUFBLElBQUEsUUFBQTtBQU8vQjtBQUFBO0FBQUEsUUFBQUEsUUFBTztBQUFBLFFBQUc7Ozs7Ozs7Ozs7OztBQUNWO0FBQUE7QUFBQSxRQUFBQSxRQUFPO0FBQUEsUUFBTTs7Ozs7Ozs7Ozs7O0FBQ2I7QUFBQTtBQUFBLFFBQUFBLFFBQU87QUFBQSxRQUFPOzs7Ozs7Ozs7Ozs7QUFDZDtBQUFBO0FBQUEsUUFBQUEsUUFBTztBQUFBLFFBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMUN6QixRQUFBVyxZQUFXO0FBRWIsTUFBQUMsV0FBVTtRQUVILFFBQUFQLFFBQUEsSUFBQTtRQUVMLGtCQUFBLFlBQUE7b0JBQ0ZRLFVBQUEsTUFBZSxVQUFVLElBQVksT0FBTyxFQUFFLGdCQUFnQlIsUUFBTyxHQUFHLENBQUE7QUFDeEUsaUJBQUEsR0FBQU8sV0FBVSxLQUFBO0FBQUE7TUFHVkM7QUFFRSxRQUFBLGtCQUFrQixPQUFPLEtBQUssSUFBQTtBQU1wQyxVQUFBLE1BQUE7QUFDSTs7UUFHRUMsVUFBQSxNQUFBO0FBQ0YsSUFBQUgsVUFBUyxRQUFRO0FBQUE7OEJBV3FDRzs7Ozs7Ozs7c0JBcEJ2RCxjQUFBLE1BQUE7QUFDUSxlQUFBRCxVQUFTLGdCQUFnQixRQUFRQSxPQUFNLElBQUk7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQzBEZSxJQUFjLENBQUE7QUFBQSxNQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFBZGIsS0FBYyxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTVCcEUsSUFBTyxDQUFBO0FBQUE7O2lDQUFaLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFEVixhQTJCSyxRQUFBLEtBQUEsTUFBQTs7Ozs7Ozs7OztRQTFCTUEsS0FBTyxDQUFBOzttQ0FBWixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs0QkFBSixRQUFJLElBQUEsWUFBQSxRQUFBLEtBQUEsR0FBQTs7Ozs7Ozs7O3FDQUFKLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFISixVQUFBLGNBQUEsR0FBQSxFQUFFLFNBQVM7QUFBQTs7QUFBakIsYUFBd0IsUUFBQSxLQUFBLE1BQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJIO0FBQUE7QUFBQSxNQUFBQSxTQUFPO0FBQUE7QUFBVyxhQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFGTDtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRa0MsTUFBQSxVQUFBLEVBQUUsVUFBVSxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBSDFDO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPLE1BQUEsVUFBQSxFQUFFLFlBQVksSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFGYSxNQUFBLFVBQUEsRUFBRSxTQUFTLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSDFDLE1BQUEsVUFBQSxFQUFFLGFBQWEsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFSa0QsTUFBQTtBQUFBO0FBQUEsSUFBQSxRQUFPLE9BQUk7QUFBQTs7O0FBQ3BHLE1BQUE7QUFBQTtBQUFBLElBQUEsUUFBTyxVQUFPO0FBQUE7Ozs7OztLQUVWLElBQU0sRUFBQSxFQUFDLGVBQWUsTUFBRTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQUk1QkEsS0FBVSxDQUFBO0FBQUE7QUFBQSxRQUFDQSxLQUFNLEVBQUEsRUFBQztBQUFBLE1BQUc7QUFBQTtBQUFBLGFBQUE7QUFFaEI7QUFBQTtBQUFBLE1BQUFBLFNBQU87QUFBQTtBQUFPLGFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYjVCLGFBc0JPLFFBQUEsT0FBQSxNQUFBO0FBckJILGFBUUssT0FBQSxJQUFBO0FBTEQsYUFBeUcsTUFBQTFOLEVBQUE7Ozs7O0FBRXpHLGFBRUssTUFBQSxJQUFBOzs7QUFFVCxhQUF5QixPQUFBLElBQUE7Ozs7Ozs7Ozs7OztBQU5xRSxXQUFBLENBQUEsV0FBQTtBQUFBLE1BQUEsTUFBQSxjQUFBO0FBQUEsTUFBQSxRQUFPLE9BQUk7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFDcEcsV0FBQSxDQUFBLFdBQUE7QUFBQSxNQUFBLE1BQUEsY0FBQTtBQUFBLE1BQUEsUUFBTyxVQUFPO0FBQUEsaUJBQUEsSUFBQSxRQUFBOzs7T0FFVixJQUFNLEVBQUEsRUFBQyxlQUFlLE1BQUU7QUFBQSxpQkFBQSxJQUFBLFFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQWI1QzBOLEtBQU8sQ0FBQTtBQUFBO0FBQUEsYUFBQTs7SUFFREEsS0FBYyxDQUFBO0FBQUEsYUFBQTs7Ozs7Ozs7Ozs7O0FBSDdCLGFBbUNLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXhFSyxRQUFBLFFBQVEsVUFBVSxJQUFXLE1BQU0sS0FBSztNQUMxQyxVQUFBLENBQUE7QUFDQSxNQUFBWSxXQUFVO1FBRVIsYUFBQSxDQUFBO0FBRU4sVUFBQSxZQUFBO29CQUNJLFVBQUEsTUFBZ0IsTUFBTSxZQUFBLENBQUE7QUFDdEIsaUJBQUEsR0FBQUEsV0FBVSxLQUFBO0FBQUE7QUFHUixRQUFBLHdCQUF3QixRQUFBO0FBQ3RCLFFBQUEsV0FBVyxHQUFHLEdBQUE7Ozs7c0JBSWQsV0FBVyxHQUFHLElBQUksTUFBQSxVQUFBO1lBQ1osTUFBTSxlQUFlLEdBQUc7WUFDeEIsSUFBSSxRQUFRLEtBQU0sQ0FBQTNQLE9BQU1BLEdBQUUsUUFBUSxHQUFHO1VBQ3ZDLEdBQUE7QUFDQSxVQUFFLFVBQVU7QUFDWixVQUFFLGNBQWM7QUFBQTs7c0JBR3BCLFdBQVcsR0FBRyxJQUFJLE9BQUEsVUFBQTtBQUFBOztBQUl0QixNQUFBLGlCQUFzQztRQUVwQyxnQkFBQSxDQUFpQixPQUFtQm9QLFlBQUE7QUFDdEMsaUJBQUEsR0FBQSxpQkFBaUJBLE9BQUE7QUFDakIsVUFBTSxnQkFBQTtBQUNOLFVBQU0sZUFBQTtBQUFBO0FBZTJELFFBQUEsZ0JBQUEsQ0FBQUEsU0FBQSxVQUFVLGNBQWMsT0FBT0EsT0FBTTs0QkFXM0QsZUFBZUEsUUFBTyxHQUFHOzhCQUs3QixlQUFlQSxRQUFPLEdBQUc7QUFNL0IsUUFBQSxpQkFBQSxNQUFBLGFBQUEsR0FBQSxpQkFBaUIsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEOUQsYUFBcUMsUUFBQSxLQUFBLE1BQUE7QUFBQTs7Ozs7Ozs7Ozs7TUEzQjdCO1FBRU8sUUFBQVUsUUFBQSxJQUFBO0FBZVgsVUFBQSxNQUFBO0FBQ0ksaUJBQUEsR0FBQSxPQUFPLFNBQVMsY0FBYyxLQUFLLENBQUE7QUFDbkMsYUFBUyxlQUFlLHVCQUF1QixFQUFFLFlBQVksSUFBSTtBQUNqRSxJQUFBQSxRQUFPLElBQUk7QUFBQTs7Ozs7Ozs7QUFoQmY7QUFDVSxjQUFBLEtBQUssU0FBUyxlQUFlLHVCQUF1QjtZQUN0RCxJQUFBO2NBQ0ksTUFBQTtBQUNBLGlCQUFLLE9BQUE7QUFBQTtBQUVULHVCQUFBLEdBQUEsT0FBTyxTQUFTLGNBQWMsS0FBSyxDQUFBO0FBQ25DLG1CQUFTLGVBQWUsdUJBQXVCLEVBQUUsWUFBWSxJQUFJO0FBQ2pFLFVBQUFBLFFBQU8sSUFBSTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDb0QrQixNQUFBO0FBQUE7QUFBQSxJQUFBLFFBQUssT0FBSTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU5oQztBQUFBLFFBQUE7QUFBQSxRQUFBO0FBQUE7QUFBQSxRQUFBLFFBQUs7QUFBQSxNQUFHO0FBQ1osV0FBQSxJQUFBLFNBQUE7QUFBQSxNQUFBLElBQWlCLENBQUEsRUFBQTtBQUFBLE1BQVEsUUFBSyxNQUMvQix1REFDQSxnQ0FBZ0M7QUFBQTs7QUFKMUMsYUFRSSxRQUFBLElBQUEsTUFBQTtBQURBLGFBQWtELElBQUEsSUFBQTs7Ozs7Ozs7O0FBTDNDLFVBQUE7QUFBQSxNQUFBLEtBQUEsb0JBQUE7QUFBQSxNQUFBLElBQWlCLENBQUEsRUFBQTtBQUFBLE1BQVEsUUFBSyxNQUMvQix1REFDQSxtQ0FBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTzFDLGFBQXlCLFFBQUEsSUFBQSxNQUFBO0FBQUE7Ozs7Ozs7Ozs7QUFXYSxNQUFBO0FBQUE7QUFBQSxJQUFBLFFBQUssT0FBSTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU5oQyxXQUFBLElBQUEsYUFBQTtBQUFBLE1BQUEsUUFBSyxHQUFHO0FBQ1osV0FBQSxJQUFBLFNBQUE7QUFBQSxNQUFBLElBQWlCLENBQUEsRUFBQTtBQUFBLE1BQVEsUUFBSyxNQUMvQix1REFDQSxnQ0FBZ0M7QUFBQTs7QUFKMUMsYUFRSSxRQUFBLElBQUEsTUFBQTtBQURBLGFBQWtELElBQUEsSUFBQTs7Ozs7Ozs7OztBQUFoQixVQUFBO0FBQUEsTUFBQSxLQUFBLGNBQUE7QUFBQSxNQUFBLFFBQUssT0FBSTtBQUFBLGlCQUFBLElBQUEsUUFBQTtBQU5oQyxVQUFBO0FBQUEsTUFBQSxLQUFBLHdCQUFBO0FBQUEsTUFBQSxRQUFLLE1BQUc7OztBQUNaLFVBQUE7QUFBQSxNQUFBLEtBQUEsb0JBQUE7QUFBQSxNQUFBLElBQWlCLENBQUEsRUFBQTtBQUFBLE1BQVEsUUFBSyxNQUMvQix1REFDQSxtQ0FBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7O01BV25CO0FBQUE7QUFBQSxRQUFBLE9BQWlCO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FBQWpCLFVBQUE7QUFBQSxNQUFBO0FBQUEsOEJBQUE7QUFBQSxRQUFBZixRQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUZoQixNQUFBO0FBQUE7QUFBQSxJQUFBLE9BQWlCO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBakIsVUFBQSxrQkFBQTtBQUFBLE1BQUFBLFFBQWlCLFlBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE5Qi9DLElBQUssQ0FBQTtBQUFBOzttQ0FBVixRQUFJLEtBQUEsR0FBQTs7Ozs7SUFZRCxJQUFVLENBQUEsRUFBQyxTQUFTLEtBQUMsa0JBQUE7QUFBQTs7O0lBR25CLElBQVUsQ0FBQTtBQUFBOztpQ0FBZixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7TUFjREEsS0FBZ0IsQ0FBQSxFQUFDLFNBQVM7QUFBQTtBQUFVLGFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQURtQyxXQUFBLE1BQUEsYUFBQTtBQUFBLE1BQUEsT0FBaUIsR0FBRzs7Ozs7Ozs7O0FBL0I1RyxhQXVDSyxRQUFBLE1BQUEsTUFBQTtBQXRDRCxhQXFDSyxNQUFBLElBQUE7QUFwQ0QsYUE0QkksTUFBQSxFQUFBOzs7Ozs7Ozs7Ozs7QUFDSixhQU1LLE1BQUEsSUFBQTs7Ozs7Ozs7UUFsQ01BLEtBQUssQ0FBQTs7cUNBQVYsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7NENBQUo7QUFBQTs7O1FBWUdBLEtBQVUsQ0FBQSxFQUFDLFNBQVM7QUFBQSxRQUFDOzs7Ozs7Ozs7Ozs7Ozs7UUFHbkJBLEtBQVUsQ0FBQTs7bUNBQWYsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7d0NBQUo7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYTBFLFVBQUEsQ0FBQSxXQUFBO0FBQUEsTUFBQSxLQUFBLDBCQUFBO0FBQUEsTUFBQUEsUUFBaUIsTUFBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBM0VsRyxRQUFBO0FBQUE7TUFFRSxLQUFLO0FBQUEsTUFDTCxNQUFNLEVBQUUsYUFBYTtBQUFBLE1BQ3JCLE1BQU07QUFBQSxNQUNOLFdBQVdnQjtBQUFBQTs7TUFHWCxLQUFLO0FBQUEsTUFDTCxNQUFNLEVBQUUsV0FBVztBQUFBLE1BQ25CLE1BQU07QUFBQSxNQUNOLFdBQVdDO0FBQUFBOztNQUdYLEtBQUs7QUFBQSxNQUNMLE1BQU0sRUFBRSxZQUFZO0FBQUEsTUFDcEIsTUFBTTtBQUFBLE1BQ04sV0FBV0M7QUFBQUE7O0FBSWIsUUFBQSxLQUFLLFVBQVUsSUFBcUIsTUFBTSxjQUFjO0FBQ3hELFFBQUEsTUFBTSxVQUFVLElBQXFCLE1BQU0sY0FBYztRQUN6RCxVQUFVLElBQUk7TUFDaEIsaUJBQWlCLEdBQUc7QUFDbEIsUUFBQSxVQUFXLFNBQWdCOztBQUFBLFlBQUFuUSxNQUFBLFFBQVEsS0FBTSxPQUFNLEVBQUUsUUFBUSxHQUFHLE1BQWpDLGdCQUFBQSxJQUFvQztBQUFBO0FBWS9ELFFBQUEsc0JBQXVCLFVBQVUsYUFBQSxHQUFBLG1CQUFtQixJQUFBO1FBQ3BELGNBQUEsTUFBQTtvQkFDRixpQkFBQSxDQUFBLEdBQXFCLEdBQUcsa0JBQUEsQ0FBQSxDQUFBO0FBQUE7TUFFeEIsbUJBQW1CLE1BQU0sQ0FBQztBQWFFLFFBQUEsZ0JBQUEsVUFBQSxvQkFBb0IsSUFBSTtBQWV4QixRQUFBLGtCQUFBLFVBQUEsb0JBQW9CLElBQUk7K0JBUXlCOzs7O3NCQWxEOUUsYUFBYSxlQUFlLElBQUssT0FBQTs7VUFFNUIsS0FBSyxFQUFFO0FBQUEsVUFDUCxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQUEsVUFDbkIsV0FBV2lRO0FBQUFBLFVBQ1gsTUFBTTtBQUFBLFVBQ04sUUFBUSxFQUFFO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q2YsTUFBTSw4QkFBOEIsT0FBTztBQUFBLEVBQzlDLGNBQWM7QUFDSjtBQUdOLFNBQUEsTUFBQTtBQUFBLEVBRko7QUFBQSxFQUdBLFNBQVM7QUFDQyxVQUFBLHdCQUF3QixTQUFTLGNBQWMsUUFBUTtBQUM3RCwwQkFBc0IsYUFBYSxjQUFjLEVBQUUsZUFBZSxDQUFDO0FBQ25FLDBCQUFzQixVQUFVLElBQUksaUJBQWlCLGVBQWUsaUJBQWlCO0FBQy9ELDBCQUFBLG1CQUFtQixhQUFhLEtBQUssR0FBRztBQUN4QywwQkFBQSxpQkFBaUIsU0FBUyxDQUFDLFVBQVU7QUFDbkQsVUFBQSxLQUFLLHVCQUF1QixFQUMzQjtBQUFBLFFBQ0csSUFBSSxTQUFTO0FBQUEsVUFDVCxPQUFPLEVBQUUsdUJBQXVCO0FBQUEsVUFDaEMsTUFBTTtBQUFBLFVBQ04sT0FBTyxNQUFNLGtCQUFrQjtBQUFBLFFBQUEsQ0FDbEM7QUFBQSxNQUFBLEVBRUosYUFDQSxFQUFBO0FBQUEsUUFDRyxJQUFJLFNBQVM7QUFBQSxVQUNULE9BQU8sRUFBRSxRQUFRO0FBQUEsVUFDakIsTUFBTTtBQUFBLFVBQ04sT0FBTyxNQUFNLE9BQU8sU0FBUyxPQUFPO0FBQUEsUUFBQSxDQUN2QztBQUFBLE1BQUEsRUFFSixpQkFBaUIsS0FBSztBQUMzQixZQUFNLGdCQUFnQjtBQUFBLElBQUEsQ0FDekI7QUFDREcsb0JBQTBCLHFCQUFxQjtBQUUvQyxTQUFLLGdCQUFnQjtBQUFBLE1BQ2pCLFNBQVM7QUFBQSxNQUNULGFBQWEsRUFBRSwyQkFBMkI7QUFBQSxNQUMxQyxVQUFVO0FBQUEsTUFDVixVQUFVLE1BQU0sa0JBQWtCO0FBQUEsSUFBQSxDQUNyQztBQUNELFNBQUssZ0JBQWdCO0FBQUEsTUFDakIsU0FBUztBQUFBLE1BQ1QsYUFBYSxFQUFFLGVBQWU7QUFBQSxNQUM5QixVQUFVLE1BQU0sT0FBTyxTQUFTLE9BQU87QUFBQSxJQUFBLENBQzFDO0FBQUEsRUFDTDtBQUNKO0FBRUEsU0FBUyxvQkFBb0I7QUFDekIsTUFBSSxPQUFPO0FBQUEsSUFDUCxPQUFPLEVBQUUsdUJBQXVCO0FBQUEsSUFDaEMsU0FBUztBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLEVBQUEsQ0FDWDtBQUNELGFBQVcsTUFBTTtBQUNiLFFBQUlDLFFBQVM7QUFBQSxNQUNULFFBQVEsU0FBUyxlQUFlLGlCQUFpQjtBQUFBLElBQUEsQ0FDcEQ7QUFBQSxFQUFBLENBQ0o7QUFDTDtBQzVETyxNQUFNLGtCQUFvQztBQUFBLEVBQzdDLEVBQUUsS0FBSyxXQUFXLE1BQU0sV0FBVyxRQUFRLHVCQUF1QixTQUFTLE1BQU0sUUFBUSxNQUFNLFNBQVMsUUFBUTtBQUFBLEVBQ2hILEVBQUUsS0FBSyxnQkFBZ0IsTUFBTSxnQkFBZ0IsUUFBUSxvQkFBb0IsU0FBUyxNQUFNLFFBQVEsTUFBTSxTQUFTLFFBQVE7QUFDM0g7QUNOQSxTQUFTQyxrQkFBZ0IsV0FBVztBQUNsQyxTQUFPLGFBQWEsU0FBVSxhQUFhO0FBQzdDO0FBRUEsU0FBU0MsaUJBQWUsV0FBVztBQUNqQyxTQUFPLGFBQWEsU0FBVSxhQUFhO0FBQzdDO0lBR0FDLGFBQWlCLFNBQVNBLFVBQVNDLFlBQVcsUUFBUSxZQUFZO0FBQ2hFLE1BQUksT0FBTyxXQUFXLFVBQVU7QUFDOUIsVUFBTSxJQUFJLE1BQU0sc0JBQXNCO0FBQUEsRUFDdkM7QUFFRCxNQUFJLGFBQWEsT0FBTztBQUN4QixNQUFJLGdCQUFnQjtBQUNwQixNQUFJO0FBQ0osTUFBSTtBQUVKLFdBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxLQUFLLEdBQUc7QUFDdEMsZ0JBQVksT0FBTyxXQUFXLENBQUM7QUFDL0IsY0FBVSxPQUFPLENBQUM7QUFFbEIsUUFBSUgsa0JBQWdCLFNBQVMsS0FBS0MsaUJBQWUsT0FBTyxXQUFXLElBQUksQ0FBQyxDQUFDLEdBQUc7QUFDMUUsV0FBSztBQUNMLGlCQUFXLE9BQU8sQ0FBQztBQUFBLElBQ3BCO0FBRUQscUJBQWlCRSxXQUFVLE9BQU87QUFFbEMsUUFBSSxrQkFBa0IsWUFBWTtBQUNoQyxhQUFPLE9BQU8sTUFBTSxHQUFHLElBQUksQ0FBQztBQUFBLElBQzdCLFdBQ1EsZ0JBQWdCLFlBQVk7QUFDbkMsYUFBTyxPQUFPLE1BQU0sR0FBRyxJQUFJLFFBQVEsU0FBUyxDQUFDO0FBQUEsSUFDOUM7QUFBQSxFQUNGO0FBRUQsU0FBTztBQUNUO0FDdkNBLFNBQVMsZ0JBQWdCLFdBQVc7QUFDbEMsU0FBTyxhQUFhLFNBQVUsYUFBYTtBQUM3QztBQUVBLFNBQVMsZUFBZSxXQUFXO0FBQ2pDLFNBQU8sYUFBYSxTQUFVLGFBQWE7QUFDN0M7QUFHQSxJQUFBQyxZQUFpQixTQUFTLGNBQWMsUUFBUTtBQUM5QyxNQUFJLE9BQU8sV0FBVyxVQUFVO0FBQzlCLFVBQU0sSUFBSSxNQUFNLHNCQUFzQjtBQUFBLEVBQ3ZDO0FBRUQsTUFBSSxhQUFhLE9BQU87QUFDeEIsTUFBSSxhQUFhO0FBQ2pCLE1BQUksWUFBWTtBQUNoQixNQUFJLGdCQUFnQjtBQUNwQixXQUFTLElBQUksR0FBRyxJQUFJLFlBQVksS0FBSztBQUNuQyxnQkFBWSxPQUFPLFdBQVcsQ0FBQztBQUcvQixRQUFJLGVBQWUsU0FBUyxHQUFHO0FBRTdCLFVBQUksaUJBQWlCLFFBQVEsZ0JBQWdCLGFBQWEsR0FBRztBQUMzRCxzQkFBYztBQUFBLE1BQ2YsT0FDSTtBQUNILHNCQUFjO0FBQUEsTUFDZjtBQUFBLElBQ0YsV0FDUSxhQUFhLEtBQU87QUFDM0Isb0JBQWM7QUFBQSxJQUNmLFdBQ1EsYUFBYSxPQUFRLGFBQWEsTUFBTztBQUNoRCxvQkFBYztBQUFBLElBQ2YsV0FDUSxhQUFhLFFBQVMsYUFBYSxPQUFRO0FBQ2xELG9CQUFjO0FBQUEsSUFDZjtBQUNELG9CQUFnQjtBQUFBLEVBQ2pCO0FBRUQsU0FBTztBQUNUO0FDNUNBLElBQUlGLGFBQVd2TztBQUNmLElBQUksWUFBWUM7SUFDaEIsVUFBaUJzTyxXQUFTLEtBQUssTUFBTSxTQUFTO0FDMEI5QyxJQUFJLFdBQVd2TztBQUVmLElBQUksWUFBWTtBQUNoQixJQUFJLFlBQVk7QUFDaEIsSUFBSSxhQUFhO0FBQ2pCLElBQUksb0JBQW9CO0FBQ3hCLElBQUksb0JBQW9CO0FBRXhCLFNBQVMsU0FBUyxPQUFPLGFBQWE7QUFDcEMsTUFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixVQUFNLElBQUksTUFBTSxzQkFBc0I7QUFBQSxFQUN2QztBQUNELE1BQUksWUFBWSxNQUNiLFFBQVEsV0FBVyxXQUFXLEVBQzlCLFFBQVEsV0FBVyxXQUFXLEVBQzlCLFFBQVEsWUFBWSxXQUFXLEVBQy9CLFFBQVEsbUJBQW1CLFdBQVcsRUFDdEMsUUFBUSxtQkFBbUIsV0FBVztBQUN6QyxTQUFPLFNBQVMsV0FBVyxHQUFHO0FBQ2hDO0FBRUEsSUFBQSxtQkFBaUIsU0FBVSxPQUFPLFNBQVM7QUFDekMsTUFBSSxjQUFlLFdBQVcsUUFBUSxlQUFnQjtBQUN0RCxNQUFJLFNBQVMsU0FBUyxPQUFPLFdBQVc7QUFDeEMsTUFBSSxnQkFBZ0IsSUFBSTtBQUN0QixXQUFPO0FBQUEsRUFDUjtBQUNELFNBQU8sU0FBUyxRQUFRLEVBQUU7QUFDNUI7Ozs7Ozs7Ozs7Ozs7QUMvQ08sSUFBTSxpQkFBTixNQUFnRDtBQUFBLEVBU25ELFlBQTZDLG1CQUFtQjtBQUM1RCxTQUFLLFNBQVMsT0FBTyxPQUFPLElBQUksYUFBYTtBQUM3QyxTQUFLLG9CQUFvQjtBQUFBLEVBQzdCO0FBQUEsRUFFTyxJQUFJLEtBQXlCO0FBQ3pCLFdBQUEsS0FBSyxPQUFPLEdBQUc7QUFBQSxFQUMxQjtBQUFBLEVBRUEsTUFBYSxJQUFJLEtBQWEsS0FBVTtBQUMvQixTQUFBLE9BQU8sR0FBRyxJQUFJO0FBQ1osV0FBQSxjQUFjLEtBQUssR0FBRztBQUFBLEVBQ2pDO0FBQUEsRUFFQSxNQUFNLGNBQWM7QUFDVixVQUFBME8sT0FBTSxNQUFNO0FBQ1osVUFBQSxhQUFhLE9BQU8sS0FBSyxhQUFhO0FBQzVDLGVBQVcsT0FBTyxZQUFZO0FBQ3RCLFVBQUFBLEtBQUksR0FBRyxNQUFNLFFBQVc7QUFDeEIsYUFBSyxPQUFPLEdBQUcsSUFBSUEsS0FBSSxHQUFHO0FBQUEsTUFBQSxPQUN2QjtBQUNILGNBQU0sY0FBYyxLQUFLLGNBQWMsR0FBRyxDQUFDO0FBQUEsTUFDL0M7QUFBQSxJQUNKO0FBRUEsU0FBSyxvQkFBb0IsTUFBTSxLQUFLLGtCQUFrQixjQUFjO0FBQy9ELFNBQUEsa0JBQWtCLENBQUMsR0FBRyxlQUFlO0FBQzFDLFNBQUssb0JBQW9CO0FBQ3pCLFNBQUssb0JBQW9CO0FBQ3pCLFVBQU0sS0FBSztBQUVKLFdBQUE7QUFBQSxFQUNYO0FBQUEsRUFFUSxzQkFBc0I7QUFDcEIsVUFBQSxpQkFBaUIsS0FBSyxJQUFJLGdDQUFnQztBQUNoRSxlQUFXLE1BQU0sZ0JBQWdCO0FBQ2xCLGlCQUFBLEtBQUssS0FBSyxtQkFBbUI7QUFDaEMsWUFBQSxFQUFFLFFBQVEsR0FBRyxLQUFLO0FBQ2hCLFlBQUEsVUFBVSxHQUFHLFdBQVc7QUFDMUI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFFUSxzQkFBc0I7QUFDcEIsVUFBQSxpQkFBaUIsS0FBSyxJQUFJLG9CQUFvQjtBQUNwRCxlQUFXLE1BQU0sZ0JBQWdCO0FBQ2xCLGlCQUFBLEtBQUssS0FBSyxpQkFBaUI7QUFDOUIsWUFBQSxFQUFFLFFBQVEsR0FBRyxLQUFLO0FBQ2hCLFlBQUEsVUFBVSxHQUFHLFdBQVc7QUFDMUI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFFTyxhQUFhO0FBQ2hCLFdBQU8sQ0FBQyxHQUFHLEtBQUssaUJBQWlCLEdBQUcsS0FBSyxpQkFBaUI7QUFBQSxFQUM5RDtBQUFBLEVBRU8scUJBQXFCO0FBQ3hCLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQUEsRUFFTyx1QkFBdUI7QUFDMUIsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUVPLGVBQWUsS0FBSztBQUNoQixXQUFBLEtBQUssYUFBYSxLQUFLLENBQUMsTUFBTSxFQUFFLFFBQVEsR0FBRztBQUFBLEVBQ3REO0FBQUEsRUFFQSxNQUFhLGlCQUFpQixLQUFhLFNBQWtCO0FBQzlDLGVBQUEsS0FBSyxDQUFDLEdBQUcsS0FBSyxpQkFBaUIsR0FBRyxLQUFLLGlCQUFpQixHQUFHO0FBQzlELFVBQUEsRUFBRSxRQUFRLEtBQUs7QUFDZixVQUFFLFVBQVU7QUFDWjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0EsVUFBTSxLQUFLO0VBQ2Y7QUFBQSxFQUVBLE1BQWEsbUJBQW1CLFNBQWtCO0FBQ3ZDLFdBQUEsS0FBSyxJQUFJLGlDQUFpQyxPQUFPO0FBQUEsRUFDNUQ7QUFBQSxFQUVBLE1BQWEscUJBQXFCO0FBQzlCLFVBQU0sS0FBSztBQUFBLE1BQ1A7QUFBQSxNQUNBLEtBQUssZ0JBQWdCLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssU0FBUyxFQUFFLFFBQVUsRUFBQTtBQUFBLElBQUE7QUFFeEUsV0FBTyxLQUFLO0FBQUEsTUFDUjtBQUFBLE1BQ0EsS0FBSyxrQkFBa0IsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxTQUFTLEVBQUUsUUFBVSxFQUFBO0FBQUEsSUFBQTtBQUFBLEVBRTlFO0FBQUEsRUFFQSxNQUFhLGlCQUFpQixXQUFtQixVQUFrQixTQUFjO0FBQ3pFLFFBQUE7QUFDSSxVQUFBLEtBQUssa0JBQWtCLFFBQVEsR0FBRztBQUNsQyx5QkFBaUIsS0FBSyxtQkFBbUI7QUFDekM7QUFBQSxNQUNKO0FBQ00sWUFBQSxLQUFLLGlDQUFpQyxTQUFTO0FBQy9DLFlBQUEsV0FBVyxpQkFBaUIsUUFBUSxRQUFRLDBCQUEwQixhQUFhLFlBQVksT0FBTztBQUFBLGFBQ3ZHO0FBQ1ksdUJBQUEsS0FBSyxtQkFBbUIsR0FBSTtBQUFBLElBQ2pEO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBYSxpQkFBaUIsV0FBbUIsVUFBcUM7QUFDOUUsUUFBQTtBQUNPLGFBQUEsTUFBTSxXQUFXLGVBQWUsRUFBRSxRQUFRLFFBQVEsMEJBQTBCLGFBQWEsVUFBVTtBQUFBLGFBQ3JHO0FBQ1ksdUJBQUEsS0FBSyxtQkFBbUIsR0FBSTtBQUN0QyxhQUFBO0FBQUEsSUFDWDtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQWEsZ0JBQWdCLFdBQWtDO0FBQzNELFVBQU0sV0FBVyxlQUFlLEVBQUUsUUFBUSxXQUFXLGlCQUFpQixXQUFXO0FBQ2pGLFVBQU0sV0FBVyxlQUFlLEVBQUUsUUFBUSxXQUFXLDJCQUEyQixXQUFXO0FBQUEsRUFDL0Y7QUFBQSxFQUVBLE1BQWMsaUNBQWlDLFdBQW1CO0FBQzlELFVBQU0sU0FBUywwQkFBMEI7QUFDekMsVUFBTSxXQUFXLGVBQWUsRUFBRSxRQUFRLFFBQVEsUUFBUSxNQUFNLElBQUk7QUFBQSxFQUN4RTtBQUFBLEVBRVEsa0JBQWtCLFVBQWtCO0FBQ2pDLFdBQUEsYUFBYUMsaUJBQVMsUUFBUTtBQUFBLEVBQ3pDO0FBQ0o7QUEvSWEsaUJBQU5yQixrQkFBQTtBQUFBLEVBRE4sV0FBVztBQUFBLEVBVUlDLGtCQUFBLEdBQUMsT0FBTyxNQUFNLGlCQUFpQixDQUFBO0FBQUEsR0FUbEMsY0FBQTs7Ozs7Ozs7Ozs7OztBQ0hOLElBQU0sZUFBTixNQUE0QztBQUFBLEVBRy9DLFlBQ3dDLGNBQ0MsTUFDQyxnQkFDQSxnQkFDVCxPQUMvQjtBQUxzQyxTQUFBLGVBQUE7QUFDQyxTQUFBLE9BQUE7QUFDQyxTQUFBLGlCQUFBO0FBQ0EsU0FBQSxpQkFBQTtBQUNULFNBQUEsUUFBQTtBQVBqQyxTQUFPLFVBQVU1TztBQUFBQSxFQVFkO0FBQUEsRUFFSCxNQUFNLE9BQU87QUFDSCxVQUFBLEtBQUssZUFBZTtBQUNwQixVQUFBaVEsbUJBQWtCLEtBQUssZUFBZSxtQkFBbUI7QUFDMUQsU0FBQSxhQUFhLG1CQUFtQkEsZ0JBQWU7QUFDaEQsUUFBQSxxQ0FBcUNBLGlCQUFnQixJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEdBQUcsR0FBRztBQUN0RixVQUFNLHNCQUFzQixLQUFLLGVBQWUsSUFBSSwrQkFBK0I7QUFDbkYsUUFBSSxDQUFDLHFCQUFxQjtBQUNoQixZQUFBLFVBQVUsS0FBSyxlQUFlLHFCQUFxQjtBQUNyRCxVQUFBLHNDQUFzQyxRQUFRLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEtBQUssR0FBRyxHQUFHO0FBQzFFLFdBQUEsYUFBYSxtQkFBbUIsT0FBTztBQUFBLElBQ2hEO0FBQ0EsU0FBSyxLQUFLO0FBQ0gsV0FBQTtBQUFBLEVBQ1g7QUFBQSxFQUVBLE1BQU0sV0FBVyxLQUFhO0FBQ3JCLFNBQUEsZUFBZSxpQkFBaUIsS0FBSyxJQUFJO0FBQzlDLFVBQU12QixVQUFTLEtBQUssZUFBZSxlQUFlLEdBQUc7QUFDaEQsU0FBQSxhQUFhLFdBQVdBLE9BQU07QUFBQSxFQUN2QztBQUFBLEVBRUEsTUFBTSxhQUFhLEtBQWE7QUFDdkIsU0FBQSxlQUFlLGlCQUFpQixLQUFLLEtBQUs7QUFDMUMsU0FBQSxhQUFhLGFBQWEsR0FBRztBQUFBLEVBQ3RDO0FBQUEsRUFFQSxNQUFNLGtCQUFrQjtBQUNmLFNBQUEsZUFBZSxtQkFBbUIsS0FBSztBQUN0QyxVQUFBLFVBQVUsS0FBSyxlQUFlLHFCQUFxQjtBQUNsRCxXQUFBLEtBQUssYUFBYSxtQkFBbUIsT0FBTztBQUFBLEVBQ3ZEO0FBQUEsRUFFQSxNQUFNLGlCQUFpQjtBQUNkLFNBQUEsZUFBZSxtQkFBbUIsSUFBSTtBQUNyQyxVQUFBLFVBQVUsS0FBSyxlQUFlLHFCQUFxQjtBQUNsRCxXQUFBLEtBQUssYUFBYSx3QkFBd0IsT0FBTztBQUFBLEVBQzVEO0FBQ0o7QUFoRGEsZUFBTkMsa0JBQUE7QUFBQSxFQUROLFdBQVc7QUFBQSxFQUtKQyxrQkFBQSxHQUFDLE9BQU8sTUFBTSxZQUFZLENBQUE7QUFBQSxFQUMxQkEsa0JBQUEsR0FBQyxPQUFPLE1BQU0sYUFBYSxDQUFBO0FBQUEsRUFDM0JBLGtCQUFBLEdBQUMsT0FBTyxNQUFNLGNBQWMsQ0FBQTtBQUFBLEVBQzVCQSxrQkFBQSxHQUFDLE9BQU8sTUFBTSxjQUFjLENBQUE7QUFBQSxFQUM1QkEsa0JBQUEsR0FBQyxPQUFPLE1BQU0sS0FBSyxDQUFBO0FBQUEsR0FSZCxZQUFBO0FDUk4sTUFBTSxVQUFVLFlBQVk7QUFDL0IsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa0JWLFFBQUEzTyxXQUFVLE9BQU9DLE1BQUssU0FBUztBQUMzQixVQUFBLFdBQVcsTUFBTSxNQUFNQSxNQUFLO0FBQUEsTUFDOUIsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsYUFBYTtBQUFBLE1BQ2IsU0FBUztBQUFBLFFBQ0wsZ0JBQWdCO0FBQUEsTUFDcEI7QUFBQSxNQUNBLFVBQVU7QUFBQSxNQUNWLGdCQUFnQjtBQUFBLE1BQ2hCLE1BQU0sS0FBSyxVQUFVLElBQUk7QUFBQSxJQUFBLENBQzVCO0FBQ0QsV0FBTyxTQUFTO0VBQUs7QUFHbkIsUUFBQSxNQUFNLE1BQU1ELFNBQVEsMkJBQTJCLEVBQUUsU0FBUyxHQUFHLE1BQU0sTUFBQSxDQUFPO0FBRTFFLFFBQUEsV0FBVyxJQUFJLEtBQUs7QUFFMUIsYUFBVyxXQUFXLFVBQVU7QUFDeEIsUUFBQSxRQUFRLFNBQVMsTUFBTTtBQUN2QjtBQUFBLElBQ0o7QUFDQSxRQUFJLFFBQVEsUUFBUSxRQUFRLGlFQUFpRSxNQUFNLElBQUk7QUFDbkcsY0FBUSxVQUFVO0FBQUEsSUFDdEI7QUFDSSxRQUFBLFFBQVEsU0FBUyxjQUFjO0FBQy9CLGNBQVEsVUFBVTtBQUNsQixjQUFRLFVBQVU7QUFDbEIsWUFBTUEsU0FBUSwyQkFBMkIsRUFBRSxTQUFVLENBQUE7QUFDckQ7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUVTLFdBQUEsT0FBTyxHQUFHLEdBQUc7QUFBQSxJQUNsQixJQUFJO0FBQUEsSUFDSixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVDtBQUFBLEVBQUEsQ0FDSDtBQUNELFFBQU1BLFNBQVEsMkJBQTJCLEVBQUUsU0FBVSxDQUFBO0FBQ3JELGFBQVcsTUFBTSxPQUFPLE9BQU8sU0FBUyxPQUFBLEdBQVUsR0FBSTtBQUMxRDs7Ozs7Ozs7Ozs7OztBQ3BEQSxNQUFNLHVCQUF1QjtBQUd0QixJQUFNLGdCQUFOLE1BQThDO0FBQUEsRUFHakQsWUFBMEMsZ0JBQWdCO0FBQ3RELFNBQUssa0JBQWtCO0FBQUEsRUFDM0I7QUFBQSxFQUVBLE1BQWEsWUFBWSxHQUFXLFNBQWlCO0FBQ2pELGVBQVcsZUFBZSxFQUFFLFFBQVEsUUFBUSxHQUFHLE9BQU87QUFBQSxFQUMxRDtBQUFBLEVBRUEsTUFBTSxpQkFBaUI7QUFDZixRQUFBO0FBQ0EsWUFBTXlPLFVBQVMsV0FBVyxlQUFBLEVBQWlCLFFBQVEsUUFBUSxvQkFBb0I7QUFDL0UsVUFBSUEsWUFBVyxNQUFNO0FBQ2pCLGFBQUssaUJBQWlCO0FBQUEsTUFDMUI7QUFDQTtBQUFBLGFBQ0s7QUFDTCxVQUFJLHlCQUF5QjtBQUFBLElBQ2pDO0FBQ0EsVUFBTXdCLFVBQVMsT0FBTztBQUN0QixRQUFJLENBQUNBLFNBQVE7QUFDVDtBQUFBLElBQ0o7QUFDTSxVQUFBLEtBQUssWUFBWSxzQkFBc0JBLE9BQU07QUFDbkQsU0FBSyxpQkFBaUI7QUFBQSxFQUMxQjtBQUFBLEVBRUEsbUJBQW1CO0FBQ1IsV0FBQTtBQUFBLEVBU1g7QUFBQSxFQUVBLE1BQU0sYUFBYTtBQUNYLFFBQUEsT0FBTyx1QkFBdUIsVUFBVTtBQUN4QyxVQUFJLG9EQUFvRDtBQUN4RCxXQUFLLHFCQUFxQjtBQUMxQjtBQUFBLElBQ0o7QUFDQSxRQUFJLDRCQUE0QjtBQUMxQixVQUFBLGdCQUFnQixNQUFNLEtBQUs7QUFDakMsUUFBSSxrQkFBa0JsUSxXQUFTO0FBQzNCLHNCQUFnQixlQUFlLHNCQUFzQjtBQUNqRCxVQUFBLHFCQUFxQixnQkFBZ0Isc0JBQXNCQSxTQUFPO0FBQ3RFLFVBQUksMENBQTBDO0FBQzlDLFdBQUssUUFBUTtBQUFBLElBQUEsT0FDVjtBQUNDLFVBQUEsZ0JBQWdCQSxZQUFVLE1BQU07QUFBQSxJQUN4QztBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sbUJBQW1CO0FBQ3JCLFdBQU8sTUFBTSxhQUFhLEVBQUUsT0FBTyxXQUFZLENBQUEsRUFBRSxLQUFLLENBQUMsUUFBUSxJQUFJLEtBQU0sQ0FBQTtBQUFBLEVBQzdFO0FBQUEsRUFFQSxNQUFNLFVBQVU7QUFDWixVQUFNa1EsVUFBUyxNQUFNLE1BQU0sWUFBWSxFQUFFLE9BQU8sWUFBWSxFQUFFLEtBQUssQ0FBQyxRQUFRLElBQUksS0FBTSxDQUFBO0FBQ3RGLFFBQUksQ0FBQ0EsU0FBUTtBQUNUO0FBQUEsSUFDSjtBQUNRO0FBRVIsb0JBQWdCLG1CQUFtQjtBQUM3QixVQUFBLEtBQUssWUFBWSxzQkFBc0JBLE9BQU07QUFDbkQsUUFBSSxzQ0FBc0M7QUFDL0IsZUFBQSxNQUFNLGdCQUFnQixHQUFJO0FBQUEsRUFDekM7QUFBQSxFQUVBLE1BQU0sdUJBQXVCO0FBQ25CLFVBQUEsTUFBTSxNQUFNQztBQUNsQixVQUFNLFdBQVcsSUFBSTtBQUNyQixVQUFNLEtBQUssU0FBUyxLQUFLLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTTtBQUNqRCxRQUFJLENBQUMsSUFBSTtBQUNMO0FBQUEsSUFDSjtBQUNBLFVBQU0sZ0JBQWdCLEdBQUc7QUFDekIsVUFBTSxTQUFTLElBQUlqTyxPQUFBLE9BQU9sQyxTQUFPLEVBQUUsUUFBUSxhQUFhO0FBQ3hELFFBQUksU0FBUyxHQUFHO0FBQ1IsVUFBQSxhQUFhLEVBQUUsU0FBUyxFQUFFLG9CQUFvQixHQUFHLE1BQU0sT0FBQSxDQUFRLEVBQUU7SUFDekU7QUFBQSxFQUNKO0FBQ0o7QUF6RmEsZ0JBQU4yTyxrQkFBQTtBQUFBLEVBRE4sV0FBVztBQUFBLEVBSUlDLGtCQUFBLEdBQUMsT0FBTyxNQUFNLGNBQWMsQ0FBQTtBQUFBLEdBSC9CLGFBQUE7Ozs7Ozs7Ozs7Ozs7QUNNYixJQUFJO0FBR0csSUFBTSxlQUFOLE1BQTRDO0FBQUEsRUFLL0MsWUFBNkMsbUJBQW1CO0FBQzVELFNBQUssb0JBQW9CO0FBQ3BCLFNBQUEsb0NBQW9CO0VBQzdCO0FBQUEsRUFFQSxNQUFNLG1CQUFtQixTQUEyQjtBQUNoRCxRQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsUUFBUTtBQUM3QjtBQUFBLElBQ0o7QUFDQSxlQUFXLEtBQUssU0FBUztBQUNqQixVQUFBLENBQUMsRUFBRSxTQUFTO0FBQ1o7QUFBQSxNQUNKO0FBQ00sWUFBQSxLQUFLLFdBQVcsQ0FBQztBQUFBLElBQzNCO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSx5QkFBeUI7QUFDWCxvQkFBQSxRQUFRLE9BQU8sTUFBTTtBQUMzQndCLFlBQUFBLFFBQU8sSUFBSSxFQUFFO0FBQ2YsVUFBQSxFQUFFQSxpQkFBZ0IsU0FBUztBQUMzQixjQUFNLElBQUksTUFBTSx5QkFBeUIsRUFBRSxNQUFNO0FBQUEsTUFDckQ7QUFDQSxVQUFJLHlCQUF5QixFQUFFLE9BQU8sRUFBRSxPQUFPO0FBQy9DLFdBQUssb0JBQW9CQSxPQUFNLEVBQUUsS0FBSyxFQUFFLElBQUk7QUFDNUMsWUFBTUEsTUFBSztBQUNYLFdBQUssY0FBYyxJQUFJLEVBQUUsS0FBS0EsS0FBSTtBQUFBLElBQUEsQ0FDckM7QUFBQSxFQUNMO0FBQUEsRUFFQSxNQUFNLHNCQUFzQjtBQUN4QixVQUFNLFVBQVUsTUFBTSxLQUFLLGtCQUFrQixjQUFjO0FBQzNELFFBQUksQ0FBQyxTQUFTO0FBQ1Y7QUFBQSxJQUNKO0FBQ0EsZUFBVyxLQUFLLFNBQVM7QUFDZixZQUFBLEtBQUssV0FBVyxDQUFDO0FBQUEsSUFDM0I7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFNLFdBQVcsUUFBd0I7QUFDckMsUUFBSSxDQUFDLFlBQVk7QUFDYixXQUFLLHdCQUF3QjtBQUFBLElBQ2pDO0FBQ0ksUUFBQSxDQUFDLE9BQU8sV0FBWSxDQUFDLE9BQU8sVUFBVSxDQUFDLE9BQU8sUUFBUztBQUN2RDtBQUFBLElBQ0o7QUFDQSxRQUFJLE9BQU8sUUFBUTtBQUVUQSxZQUFBQSxRQUFPLElBQUksT0FBTztBQUNwQixVQUFBLEVBQUVBLGlCQUFnQixTQUFTO0FBQzNCLGNBQU0sSUFBSSxNQUFNLHlCQUF5QixPQUFPLE1BQU07QUFBQSxNQUMxRDtBQUNBLFVBQUkseUJBQXlCLE9BQU8sT0FBTyxPQUFPLE9BQU87QUFDekQsV0FBSyxvQkFBb0JBLE9BQU0sT0FBTyxLQUFLLE9BQU8sSUFBSTtBQUN0RCxZQUFNQSxNQUFLO0FBQ1gsV0FBSyxjQUFjLElBQUksT0FBTyxLQUFLQSxLQUFJO0FBQ3ZDO0FBQUEsSUFDSjtBQUNBLFVBQU0sVUFBa0MsQ0FBQTtBQUNsQyxVQUFBLFNBQVMsRUFBRTtBQUNSLGFBQUEsSUFBSSxRQUFnQixNQUFjO0FBQ2hDLGFBQUEsS0FBSywrQ0FBK0MsT0FBTyxRQUFRLHNCQUFzQixFQUFFLE9BQU8sTUFBTSxJQUFJLENBQUM7QUFBQSxJQUN4SDtBQUNNLFVBQUEsWUFBWSxDQUFDL1AsVUFBaUI7QUFDNUIsVUFBQSxXQUFXQSxLQUFJLEdBQUc7QUFDbEIsZUFBTyxXQUFXQSxLQUFJO0FBQUEsTUFDMUI7QUFDTSxZQUFBLElBQUksTUFBTSxVQUFVQSxpQkFBZ0I7QUFBQSxJQUFBO0FBRTlDLFVBQU0sYUFBYSxPQUFPO0FBQ3RCLFFBQUE7QUFDQSxVQUFJLE9BQU8sUUFBUSxPQUFPLEdBQUcsRUFBRSxXQUFXLFFBQVEsT0FBTztBQUFBLGFBQ3BEO0FBQ0wsWUFBTSxrQkFBa0IsT0FBTyxNQUFNLE9BQU8sQ0FBQztBQUM3QztBQUFBLElBQ0o7QUFDSSxRQUFBO0FBQ0osUUFBSSxFQUFFLHFCQUFxQixPQUFPLFdBQVcsU0FBUyxXQUFXLE9BQU8sVUFBVTtBQUN4RSxZQUFBLElBQUksTUFBTSx5QkFBeUIsa0NBQWtDO0FBQUEsSUFDL0U7QUFDTSxVQUFBLE9BQU8sSUFBSTtBQUNiLFFBQUEsRUFBRSxnQkFBZ0IsU0FBUztBQUNyQixZQUFBLElBQUksTUFBTSx5QkFBeUIsWUFBWTtBQUFBLElBQ3pEO0FBQ0EsU0FBSyxvQkFBb0IsTUFBTSxPQUFPLEtBQUssVUFBVTtBQUNqRCxRQUFBO0FBQ0EsWUFBTSxLQUFLO0FBQ1gsV0FBSyxjQUFjLElBQUksT0FBTyxLQUFLLElBQUk7QUFBQSxhQUNsQztBQUNMLFlBQU0sa0JBQWtCLE9BQU8sTUFBTSxPQUFPLENBQUM7QUFBQSxJQUNqRDtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sYUFBYSxLQUFhO0FBQzVCLFVBQU1xTyxVQUFTLEtBQUssY0FBYyxJQUFJLEdBQUc7QUFDekMsUUFBSSxDQUFDQSxTQUFRO0FBQ1Q7QUFBQSxJQUNKO0FBQ0FBLFlBQU8sU0FBUztBQUNoQixjQUFVLElBQXFCLE1BQU0sY0FBYyxFQUFFLDBCQUEwQixHQUFHO0FBQ2xGLGNBQVUsSUFBcUIsTUFBTSxjQUFjLEVBQUUsa0JBQWtCLEdBQUc7QUFDckUsU0FBQSxjQUFjLE9BQU8sR0FBRztBQUFBLEVBQ2pDO0FBQUEsRUFFQSxNQUFNLHdCQUF3QixTQUEyQjtBQUNyRCxVQUFNLE9BQU8sUUFBUSxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUc7QUFDOUQsZUFBV3BQLE1BQUssTUFBTTtBQUNsQixVQUFJLDhCQUE4QkEsSUFBRztBQUMvQixZQUFBLEtBQUssYUFBYUEsRUFBQztBQUFBLElBQzdCO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSw2QkFBNkIsU0FBMkI7QUFDbkQsV0FBQSxLQUFLLG1CQUFtQixPQUFPO0FBQUEsRUFDMUM7QUFBQSxFQUVPLDBCQUEwQjtBQUNoQixpQkFBQTtBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQUEsT0FDUm1LO0FBQUFBLElBQUE7QUFBQSxFQUVSO0FBQUEsRUFFUSxvQkFBb0JpRixTQUFnQixXQUFtQjJCLGFBQW9CO0FBQy9FM0IsWUFBTyxrQkFBa0IsQ0FBQyxZQUE0QjtBQUNsRCxZQUFNLEtBQUssVUFBVSxJQUFxQixNQUFNLGNBQWM7QUFDOUQsU0FBRyxnQkFBZ0I7QUFBQSxRQUNmLEdBQUc7QUFBQSxRQUNILFFBQVE7QUFBQSxRQUNSLFlBQUEyQjtBQUFBQSxNQUFBLENBQ0g7QUFBQSxJQUFBO0FBR0wsVUFBTSxLQUFLLFVBQVUsSUFBcUIsTUFBTSxjQUFjO0FBQzlEM0IsWUFBTyxlQUFlLE9BQU8sVUFBa0IsWUFBaUI7QUFDNUQsYUFBTyxNQUFNLEdBQUcsaUJBQWlCLFdBQVcsVUFBVSxPQUFPO0FBQUEsSUFBQTtBQUVqRUEsWUFBTyxjQUFjLE9BQU8sYUFBcUI7QUFDN0MsYUFBTyxNQUFNLEdBQUcsaUJBQWlCLFdBQVcsUUFBUTtBQUFBLElBQUE7QUFFeERBLFlBQU8sd0JBQXdCLENBQUMsa0JBQWlDO0FBQzdELFlBQU0sS0FBSyxVQUFVLElBQXFCLE1BQU0sY0FBYztBQUMzRCxTQUFBLGdCQUFnQixXQUFXLGFBQWE7QUFBQSxJQUFBO0FBQUEsRUFFbkQ7QUFDSjtBQXZKYSxlQUFOQyxrQkFBQTtBQUFBLEVBRE4sV0FBVztBQUFBLEVBTUlDLGtCQUFBLEdBQUMsT0FBTyxNQUFNLGlCQUFpQixDQUFBO0FBQUEsR0FMbEMsWUFBQTs7Ozs7Ozs7Ozs7O0FDZE4sSUFBTSxvQkFBTixNQUF3QjtBQUFBLEVBQzNCLE1BQU0sWUFBWSxjQUF5QztBQUN2RCxVQUFNLE1BQU0sTUFBTSxXQUFXLGVBQWlCLEVBQUEsUUFBUSxRQUFRLFlBQVk7QUFDMUUsUUFBSSxDQUFDLEtBQUs7QUFDTixhQUFPO0lBQ1g7QUFDQSxVQUFNLFFBQVE7QUFDZCxVQUFNLFNBQW1CLENBQUE7QUFDekIsZUFBVyxLQUFLLE9BQU87QUFDbkIsVUFBSSxFQUFFLEtBQUssV0FBVyxHQUFHLEdBQUc7QUFDeEI7QUFBQSxNQUNKO0FBQ0EsVUFBSSxFQUFFLFNBQVUsTUFBTSxTQUFTLGlCQUFpQixFQUFFLG9CQUFvQixLQUFPLE1BQU0sU0FBUyxpQkFBaUIsRUFBRSxjQUFjLEdBQUk7QUFDdEgsZUFBQSxLQUFLLGlCQUFpQixFQUFFLE1BQU07QUFBQSxNQUN6QztBQUFBLElBQ0o7QUFDTyxXQUFBO0FBQUEsRUFDWDtBQUFBLEVBRUEsTUFBTSxlQUFlLEdBQTRCO0FBQzdDLFVBQU0sTUFBTSxNQUFNLFdBQVcsZUFBaUIsRUFBQSxRQUFRLFFBQVEsQ0FBQztBQUMvRCxXQUFPLE9BQU87QUFBQSxFQUNsQjtBQUFBLEVBRUEsTUFBTSxZQUFZLFVBQWtCO0FBQ2hDLFVBQU0sVUFBVSxNQUFNLEtBQUssZUFBZSxRQUFRO0FBQzlDLFFBQUE7QUFDTyxhQUFBLEtBQUssTUFBTSxPQUFPO0FBQUEsYUFDcEI7QUFDQyxZQUFBLHVCQUF1QixVQUFVLENBQUM7QUFDakMsYUFBQTtBQUFBLElBQ1g7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFNLFVBQVVzQixTQUFnQjtBQUNyQixXQUFBLE1BQU0sS0FBSyxlQUFlQSxPQUFNO0FBQUEsRUFDM0M7QUFBQSxFQUVBLE1BQU0sZ0JBQTJDO0FBQzdDLFVBQU0sVUFBVSxNQUFNLEtBQUssWUFBWSxlQUFlO0FBQ3RELFFBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxRQUFRO0FBQzdCLFVBQUksa0NBQXVDO0FBQzNDLGFBQU87SUFDWDtBQUNBLFVBQU0sTUFBTSxDQUFBO0FBQ1osZUFBVyxLQUFLLFNBQVM7QUFDckIsVUFBSSxxQ0FBcUMsQ0FBQztBQUNwQyxZQUFBLE1BQU0sS0FBSyxjQUFjLENBQUM7QUFDaEMsWUFBTSxJQUFJLFlBQVk7QUFDbEIsY0FBTSxDQUFDLFVBQVVBLE9BQU0sSUFBSSxNQUFNLFFBQVEsSUFBSSxDQUFDLEtBQUssWUFBWSxHQUFHLGlCQUFpQixHQUFHLEtBQUssVUFBVSxHQUFHLFdBQVcsQ0FBQyxDQUFDO0FBQ3JILGVBQU8sRUFBRSxHQUFHLFVBQVUsUUFBQUEsU0FBUSxTQUFTLE9BQU87TUFBSTtBQUVsRCxVQUFBLEtBQUssR0FBRztBQUFBLElBQ2hCO0FBQ0EsVUFBTSxTQUEyQixNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3RELFdBQU8sVUFBVSxDQUFBO0FBQUEsRUFDckI7QUFBQSxFQUVBLGNBQWMsR0FBRztBQUNQLFVBQUEsSUFBSSxFQUFFLE1BQU0sR0FBRztBQUNyQixhQUFTLElBQUksRUFBRSxTQUFTLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDaEMsVUFBQSxFQUFFLENBQUMsR0FBRztBQUNOLGVBQU8sRUFBRSxDQUFDO0FBQUEsTUFDZDtBQUFBLElBQ0o7QUFDTyxXQUFBO0FBQUEsRUFDWDtBQUNKO0FBbkVhLG9CQUFOdkIsa0JBQUE7QUFBQSxFQUROLFdBQVc7QUFBQSxHQUNDLGlCQUFBOzs7Ozs7Ozs7Ozs7QUNOTixJQUFNLFdBQU4sTUFBb0M7QUFBQSxFQUd2QyxjQUFjO0FBQ1YsU0FBSyxpQkFBaUI7RUFDMUI7QUFBQSxFQUVBLFVBQVU7QUFDTixXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBRUEsR0FBRyxXQUFtQixVQUFvQjtBQUN0QyxRQUFJLENBQUMsS0FBSyxlQUFlLFNBQVMsR0FBRztBQUM1QixXQUFBLGVBQWUsU0FBUyxJQUFJO0lBQ3JDO0FBQ0EsU0FBSyxlQUFlLFNBQVMsRUFBRSxLQUFLLFFBQVE7QUFDNUMsV0FBTyxNQUFNLEtBQUssSUFBSSxXQUFXLFFBQVE7QUFBQSxFQUM3QztBQUFBLEVBRUEsSUFBSSxXQUFtQixVQUFxQjtBQUN4QyxRQUFJLENBQUMsVUFBVTtBQUNKLGFBQUEsS0FBSyxlQUFlLFNBQVM7QUFDcEM7QUFBQSxJQUNKO0FBQ1MsYUFBQSxJQUFJLEdBQUcsSUFBSSxLQUFLLGVBQWUsU0FBUyxFQUFFLFFBQVEsS0FBSztBQUM1RCxVQUFJLEtBQUssZUFBZSxTQUFTLEVBQUUsQ0FBQyxNQUFNLFVBQVU7QUFDaEQsYUFBSyxlQUFlLFNBQVMsRUFBRSxPQUFPLEdBQUcsQ0FBQztBQUMxQztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBRUEsS0FBSyxjQUFzQixNQUFXO0FBQzlCLFFBQUEsS0FBSyxlQUFlLFNBQVMsR0FBRztBQUNoQyxXQUFLLGVBQWUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxPQUFPO0FBQzNDLFdBQUcsR0FBRyxJQUFJO0FBQUEsTUFBQSxDQUNiO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDSjtBQXZDYSxXQUFOQSxrQkFBQTtBQUFBLEVBRE4sV0FBVztBQUFBLEdBQ0MsUUFBQTs7Ozs7Ozs7Ozs7OztBQ0dOLElBQU0saUJBQU4sTUFBZ0Q7QUFBQSxFQUk1QyxZQUFvQzJCLFdBQVU7QUFDakQsU0FBSyxjQUFjO0FBQ25CLFNBQUssV0FBV0E7QUFBQSxFQUNwQjtBQUFBLEVBRU8sZ0JBQWdCLFNBQWtCO0FBQ3JDLFFBQ0ksS0FBSyxZQUFZLEtBQUssQ0FBQyxRQUFRO0FBQzNCLFVBQUksV0FBVyxRQUFRLFVBQVUsSUFBSSxZQUFZLFFBQVE7QUFBQSxJQUFBLENBQzVELEdBQ0g7QUFDUyxhQUFBLElBQUk1RyxRQUFNLGlFQUFpRTtBQUFBLElBQ3RGO0FBQ0EsUUFDSSxRQUFRLFlBQ1IsS0FBSyxZQUFZLEtBQUssQ0FBQyxRQUFRO0FBQzNCLFVBQUksYUFBYSxRQUFRO0FBQUEsSUFBQSxDQUM1QixHQUNIO0FBQ1MsYUFBQSxJQUFJLFFBQVEsaUNBQWlDO0FBQUEsSUFDeEQ7QUFDSyxTQUFBLFlBQVksS0FBSyxPQUFPO0FBQ3hCLFNBQUEsU0FBUyxnQ0FBZ0MsT0FBTztBQUNyRCxRQUFJLG9CQUFvQixRQUFRLG1CQUFtQixRQUFRLFNBQVM7QUFBQSxFQUN4RTtBQUFBLEVBRU8sMEJBQTBCZ0YsU0FBZ0I7QUFDN0MsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFlBQVksUUFBUSxLQUFLO0FBQzlDLFVBQUlBLFlBQVcsS0FBSyxZQUFZLENBQUMsRUFBRSxRQUFRO0FBQ2pDLGNBQUEsTUFBTSxLQUFLLFlBQVksQ0FBQztBQUMxQixZQUFBLHNCQUFzQkEsb0JBQW1CLElBQUksU0FBUztBQUNyRCxhQUFBLFlBQVksT0FBTyxHQUFHLENBQUM7QUFDNUIsWUFBSSxJQUFJLFVBQVU7QUFDVCxlQUFBLFNBQVMsd0JBQXdCLElBQUksUUFBUTtBQUFBLFFBQ3REO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFFTyxrQkFBa0IsU0FBa0I7QUFDdkMsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFlBQVksUUFBUSxLQUFLO0FBQzlDLFVBQUksUUFBUSxZQUFZLEtBQUssWUFBWSxDQUFDLEVBQUUsV0FBVyxRQUFRLFdBQVcsS0FBSyxZQUFZLENBQUMsRUFBRSxRQUFRO0FBQzdGLGFBQUEsWUFBWSxPQUFPLEdBQUcsQ0FBQztBQUM1QjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0ssU0FBQSxTQUFTLGdDQUFnQyxPQUFPO0FBQUEsRUFDekQ7QUFBQSxFQUVPLGNBQXlCO0FBQzVCLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQ0o7QUF4RGEsaUJBQU5DLGtCQUFBO0FBQUEsRUFETixXQUFXO0FBQUEsRUFLV0Msa0JBQUEsR0FBQyxPQUFPLE1BQU0sUUFBUSxDQUFBO0FBQUEsR0FKaEMsY0FBQTtBQ0ViLElBQUksT0FBTyxPQUFPLGNBQWMsY0FBYyxVQUFVLFVBQVUsWUFBYSxFQUFDLFFBQVEsU0FBUyxJQUFJLElBQUk7QUFFekcsU0FBUyxTQUFTLFFBQVEsT0FBTyxRQUFRLFlBQVk7QUFDbkQsTUFBSSxPQUFPLGtCQUFrQjtBQUMzQixXQUFPLGlCQUFpQixPQUFPLFFBQVEsVUFBVTtBQUFBLEVBQ3JELFdBQWEsT0FBTyxhQUFhO0FBQzdCLFdBQU8sWUFBWSxLQUFLLE9BQU8sS0FBSyxHQUFHLFdBQVk7QUFDakQsYUFBTyxPQUFPLEtBQUs7QUFBQSxJQUN6QixDQUFLO0FBQUEsRUFDRjtBQUNIO0FBR0EsU0FBUyxRQUFRLFVBQVUsS0FBSztBQUM5QixNQUFJLE9BQU8sSUFBSSxNQUFNLEdBQUcsSUFBSSxTQUFTLENBQUM7QUFFdEMsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxTQUFLLENBQUMsSUFBSSxTQUFTLEtBQUssQ0FBQyxFQUFFLFlBQVcsQ0FBRTtBQUFBLEVBQ3pDO0FBRUQsU0FBTztBQUNUO0FBR0EsU0FBUyxRQUFRLEtBQUs7QUFDcEIsTUFBSSxPQUFPLFFBQVE7QUFBVSxVQUFNO0FBQ25DLFFBQU0sSUFBSSxRQUFRLE9BQU8sRUFBRTtBQUUzQixNQUFJLE9BQU8sSUFBSSxNQUFNLEdBQUc7QUFFeEIsTUFBSSxRQUFRLEtBQUssWUFBWSxFQUFFO0FBRS9CLFNBQU8sU0FBUyxLQUFJO0FBQ2xCLFNBQUssUUFBUSxDQUFDLEtBQUs7QUFDbkIsU0FBSyxPQUFPLE9BQU8sQ0FBQztBQUNwQixZQUFRLEtBQUssWUFBWSxFQUFFO0FBQUEsRUFDNUI7QUFFRCxTQUFPO0FBQ1Q7QUFHQSxTQUFTLGFBQWEsSUFBSSxJQUFJO0FBQzVCLE1BQUksT0FBTyxHQUFHLFVBQVUsR0FBRyxTQUFTLEtBQUs7QUFDekMsTUFBSSxPQUFPLEdBQUcsVUFBVSxHQUFHLFNBQVMsS0FBSztBQUN6QyxNQUFJLFVBQVU7QUFFZCxXQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLFFBQUksS0FBSyxRQUFRLEtBQUssQ0FBQyxDQUFDLE1BQU07QUFBSSxnQkFBVTtBQUFBLEVBQzdDO0FBRUQsU0FBTztBQUNUO0FBRUEsSUFBSSxVQUFVO0FBQUEsRUFDWixXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixJQUFJO0FBQUEsRUFDSixPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxjQUFjO0FBQUEsRUFDZCxhQUFhO0FBQUEsRUFDYixZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxLQUFLLE9BQU8sTUFBTTtBQUFBLEVBQ2xCLEtBQUssT0FBTyxLQUFLO0FBQUEsRUFDakIsS0FBSyxPQUFPLEtBQUs7QUFBQSxFQUNqQixLQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQ1I7QUFFQSxJQUFJLFlBQVk7QUFBQTtBQUFBLEVBRWQsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBO0FBQUEsRUFFUCxLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUE7QUFBQSxFQUVSLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQTtBQUFBLEVBRVQsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsU0FBUztBQUNYO0FBQ0EsSUFBSSxjQUFjO0FBQUEsRUFDaEIsSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUNYO0FBQ0EsSUFBSSxRQUFRO0FBQUEsRUFDVixJQUFJO0FBQUEsRUFDSixJQUFJO0FBQUEsRUFDSixJQUFJO0FBQUEsRUFDSixJQUFJO0FBQ047QUFDQSxJQUFJLFlBQVksQ0FBQTtBQUVoQixTQUFTLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUMzQixVQUFRLElBQUksT0FBTyxDQUFDLENBQUMsSUFBSSxNQUFNO0FBQ2pDO0FBRUEsSUFBSSxZQUFZLENBQUE7QUFFaEIsSUFBSSxrQkFBa0I7QUFFdEIsSUFBSSxTQUFTO0FBRWIsSUFBSSxzQkFBc0IsQ0FBQTtBQUcxQixJQUFJLE9BQU8sU0FBU25ILE1BQUssR0FBRztBQUMxQixTQUFPLFFBQVEsRUFBRSxZQUFXLENBQUUsS0FBSyxVQUFVLEVBQUUsWUFBYSxDQUFBLEtBQUssRUFBRSxZQUFhLEVBQUMsV0FBVyxDQUFDO0FBQy9GO0FBRUEsSUFBSSxTQUFTLFNBQVM5SCxRQUFPLEdBQUc7QUFDOUIsU0FBTyxPQUFPLEtBQUssT0FBTyxFQUFFLEtBQUssU0FBVUwsSUFBRztBQUM1QyxXQUFPLFFBQVFBLEVBQUMsTUFBTTtBQUFBLEVBQzFCLENBQUc7QUFDSDtBQUVBLElBQUksY0FBYyxTQUFTaVIsYUFBWSxHQUFHO0FBQ3hDLFNBQU8sT0FBTyxLQUFLLFNBQVMsRUFBRSxLQUFLLFNBQVVqUixJQUFHO0FBQzlDLFdBQU8sVUFBVUEsRUFBQyxNQUFNO0FBQUEsRUFDNUIsQ0FBRztBQUNIO0FBR0EsU0FBUyxTQUFTLE9BQU87QUFDdkIsV0FBUyxTQUFTO0FBQ3BCO0FBR0EsU0FBUyxXQUFXO0FBQ2xCLFNBQU8sVUFBVTtBQUNuQjtBQUdBLFNBQVMscUJBQXFCO0FBQzVCLFNBQU8sVUFBVSxNQUFNLENBQUM7QUFDMUI7QUFFQSxTQUFTLHNCQUFzQjtBQUM3QixTQUFPLFVBQVUsSUFBSSxTQUFVLEdBQUc7QUFDaEMsV0FBTyxPQUFPLENBQUMsS0FBSyxZQUFZLENBQUMsS0FBSyxPQUFPLGFBQWEsQ0FBQztBQUFBLEVBQy9ELENBQUc7QUFDSDtBQUlBLFNBQVMsT0FBTyxPQUFPO0FBQ3JCLE1BQUksU0FBUyxNQUFNLFVBQVUsTUFBTTtBQUNuQyxNQUFJLFVBQVUsT0FBTztBQUNyQixNQUFJLE9BQU87QUFFWCxNQUFJLE9BQU8sc0JBQXNCLFlBQVksV0FBVyxZQUFZLGNBQWMsWUFBWSxhQUFhLENBQUMsT0FBTyxVQUFVO0FBQzNILFdBQU87QUFBQSxFQUNSO0FBRUQsU0FBTztBQUNUO0FBR0EsU0FBUyxVQUFVLFNBQVM7QUFDMUIsTUFBSSxPQUFPLFlBQVksVUFBVTtBQUMvQixjQUFVLEtBQUssT0FBTztBQUFBLEVBQ3ZCO0FBRUQsU0FBTyxVQUFVLFFBQVEsT0FBTyxNQUFNO0FBQ3hDO0FBR0EsU0FBUyxZQUFZLE9BQU8sVUFBVTtBQUNwQyxNQUFJO0FBQ0osTUFBSTtBQUVKLE1BQUksQ0FBQztBQUFPLFlBQVE7QUFFcEIsV0FBUyxPQUFPLFdBQVc7QUFDekIsUUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLFdBQVcsR0FBRyxHQUFHO0FBQ3hELGlCQUFXLFVBQVUsR0FBRztBQUV4QixXQUFLLElBQUksR0FBRyxJQUFJLFNBQVMsVUFBUztBQUNoQyxZQUFJLFNBQVMsQ0FBQyxFQUFFLFVBQVU7QUFBTyxtQkFBUyxPQUFPLEdBQUcsQ0FBQztBQUFBO0FBQU87QUFBQSxNQUM3RDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBR0QsTUFBSSxTQUFVLE1BQUs7QUFBTyxhQUFTLFlBQVksS0FBSztBQUN0RDtBQUdBLFNBQVMsY0FBYyxPQUFPO0FBQzVCLE1BQUksTUFBTSxNQUFNLFdBQVcsTUFBTSxTQUFTLE1BQU07QUFFaEQsTUFBSSxJQUFJLFVBQVUsUUFBUSxHQUFHO0FBRzdCLE1BQUksS0FBSyxHQUFHO0FBQ1YsY0FBVSxPQUFPLEdBQUcsQ0FBQztBQUFBLEVBQ3RCO0FBR0QsTUFBSSxNQUFNLE9BQU8sTUFBTSxJQUFJLFlBQWEsTUFBSyxRQUFRO0FBQ25ELGNBQVUsT0FBTyxHQUFHLFVBQVUsTUFBTTtBQUFBLEVBQ3JDO0FBR0QsTUFBSSxRQUFRLE1BQU0sUUFBUTtBQUFLLFVBQU07QUFFckMsTUFBSSxPQUFPLE9BQU87QUFDaEIsVUFBTSxHQUFHLElBQUk7QUFFYixhQUFTQSxNQUFLLFdBQVc7QUFDdkIsVUFBSSxVQUFVQSxFQUFDLE1BQU07QUFBSyxnQkFBUUEsRUFBQyxJQUFJO0FBQUEsSUFDeEM7QUFBQSxFQUNGO0FBQ0g7QUFFQSxTQUFTLE9BQU8sVUFBVTtBQUV4QixNQUFJLE9BQU8sYUFBYSxhQUFhO0FBQ25DLFdBQU8sS0FBSyxTQUFTLEVBQUUsUUFBUSxTQUFVLEtBQUs7QUFDNUMsYUFBTyxPQUFPLFVBQVUsR0FBRztBQUFBLElBQ2pDLENBQUs7QUFBQSxFQUNGLFdBQVUsTUFBTSxRQUFRLFFBQVEsR0FBRztBQUVsQyxhQUFTLFFBQVEsU0FBVSxNQUFNO0FBQy9CLFVBQUksS0FBSztBQUFLLG1CQUFXLElBQUk7QUFBQSxJQUNuQyxDQUFLO0FBQUEsRUFDTCxXQUFhLE9BQU8sYUFBYSxVQUFVO0FBRXZDLFFBQUksU0FBUztBQUFLLGlCQUFXLFFBQVE7QUFBQSxFQUN6QyxXQUFhLE9BQU8sYUFBYSxVQUFVO0FBQ3ZDLGFBQVMsT0FBTyxVQUFVLFFBQVEsT0FBTyxJQUFJLE1BQU0sT0FBTyxJQUFJLE9BQU8sSUFBSSxDQUFDLEdBQUcsT0FBTyxHQUFHLE9BQU8sTUFBTSxRQUFRO0FBQzFHLFdBQUssT0FBTyxDQUFDLElBQUksVUFBVSxJQUFJO0FBQUEsSUFDaEM7QUFJRCxRQUFJLFFBQVEsS0FBSyxDQUFDLEdBQ2QsU0FBUyxLQUFLLENBQUM7QUFFbkIsUUFBSSxPQUFPLFVBQVUsWUFBWTtBQUMvQixlQUFTO0FBQ1QsY0FBUTtBQUFBLElBQ1Q7QUFFRCxlQUFXO0FBQUEsTUFDVCxLQUFLO0FBQUEsTUFDTDtBQUFBLE1BQ0E7QUFBQSxNQUNBLFVBQVU7QUFBQSxJQUNoQixDQUFLO0FBQUEsRUFDRjtBQUNIO0FBR0EsSUFBSSxhQUFhLFNBQVNrUixZQUFXLE1BQU07QUFDekMsTUFBSSxNQUFNLEtBQUssS0FDWCxRQUFRLEtBQUssT0FDYixTQUFTLEtBQUssUUFDZCxnQkFBZ0IsS0FBSyxVQUNyQixXQUFXLGtCQUFrQixTQUFTLE1BQU07QUFDaEQsTUFBSSxlQUFlLFFBQVEsR0FBRztBQUM5QixlQUFhLFFBQVEsU0FBVSxXQUFXO0FBQ3hDLFFBQUksYUFBYSxVQUFVLE1BQU0sUUFBUTtBQUN6QyxRQUFJLE1BQU0sV0FBVztBQUNyQixRQUFJLFVBQVUsV0FBVyxNQUFNLENBQUM7QUFDaEMsUUFBSSxVQUFVLFlBQVksTUFBTSxNQUFNLEtBQUssT0FBTztBQUNsRCxRQUFJLENBQUMsVUFBVSxPQUFPO0FBQUc7QUFFekIsUUFBSSxDQUFDO0FBQU8sY0FBUTtBQUNwQixRQUFJLE9BQU8sTUFBTSxJQUFJLFFBQVEsV0FBVyxVQUFVLElBQUk7QUFDdEQsY0FBVSxPQUFPLElBQUksVUFBVSxPQUFPLEVBQUUsT0FBTyxTQUFVLFFBQVE7QUFFL0QsVUFBSSxtQkFBbUIsU0FBUyxPQUFPLFdBQVcsU0FBUztBQUMzRCxhQUFPLEVBQUUsb0JBQW9CLE9BQU8sVUFBVSxTQUFTLGFBQWEsT0FBTyxNQUFNLElBQUk7QUFBQSxJQUMzRixDQUFLO0FBQUEsRUFDTCxDQUFHO0FBQ0g7QUFHQSxTQUFTLGFBQWEsT0FBTyxTQUFTLE9BQU90QyxVQUFTO0FBQ3BELE1BQUksUUFBUSxZQUFZQSxVQUFTO0FBQy9CO0FBQUEsRUFDRDtBQUVELE1BQUk7QUFFSixNQUFJLFFBQVEsVUFBVSxTQUFTLFFBQVEsVUFBVSxPQUFPO0FBRXRELHFCQUFpQixRQUFRLEtBQUssU0FBUztBQUV2QyxhQUFTLEtBQUssT0FBTztBQUNuQixVQUFJLE9BQU8sVUFBVSxlQUFlLEtBQUssT0FBTyxDQUFDLEdBQUc7QUFDbEQsWUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLFFBQVEsS0FBSyxRQUFRLENBQUMsQ0FBQyxJQUFJLE1BQU0sTUFBTSxDQUFDLEtBQUssUUFBUSxLQUFLLFFBQVEsQ0FBQyxDQUFDLE1BQU0sSUFBSTtBQUM3RiwyQkFBaUI7QUFBQSxRQUNsQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBR0QsUUFBSSxRQUFRLEtBQUssV0FBVyxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssa0JBQWtCLFFBQVEsYUFBYSxLQUFLO0FBQ25JLFVBQUksUUFBUSxPQUFPLE9BQU8sT0FBTyxNQUFNLE9BQU87QUFDNUMsWUFBSSxNQUFNO0FBQWdCLGdCQUFNLGVBQWdCO0FBQUE7QUFBTSxnQkFBTSxjQUFjO0FBQzFFLFlBQUksTUFBTTtBQUFpQixnQkFBTSxnQkFBZTtBQUNoRCxZQUFJLE1BQU07QUFBYyxnQkFBTSxlQUFlO0FBQUEsTUFDOUM7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNIO0FBR0EsU0FBUyxTQUFTLE9BQU9BLFVBQVM7QUFDaEMsTUFBSSxXQUFXLFVBQVUsR0FBRztBQUM1QixNQUFJLE1BQU0sTUFBTSxXQUFXLE1BQU0sU0FBUyxNQUFNO0FBRWhELE1BQUksQ0FBQyxRQUFRLE9BQU8sS0FBSyxNQUFNLEtBQUs7QUFBRztBQUd2QyxNQUFJLFFBQVEsTUFBTSxRQUFRO0FBQUssVUFBTTtBQVFyQyxNQUFJLFVBQVUsUUFBUSxHQUFHLE1BQU0sTUFBTSxRQUFRO0FBQUssY0FBVSxLQUFLLEdBQUc7QUFNcEUsR0FBQyxXQUFXLFVBQVUsWUFBWSxTQUFTLEVBQUUsUUFBUSxTQUFVLFNBQVM7QUFDdEUsUUFBSSxTQUFTLFlBQVksT0FBTztBQUVoQyxRQUFJLE1BQU0sT0FBTyxLQUFLLFVBQVUsUUFBUSxNQUFNLE1BQU0sSUFBSTtBQUN0RCxnQkFBVSxLQUFLLE1BQU07QUFBQSxJQUMzQixXQUFlLENBQUMsTUFBTSxPQUFPLEtBQUssVUFBVSxRQUFRLE1BQU0sSUFBSSxJQUFJO0FBQzVELGdCQUFVLE9BQU8sVUFBVSxRQUFRLE1BQU0sR0FBRyxDQUFDO0FBQUEsSUFDbkQsV0FBZSxZQUFZLGFBQWEsTUFBTSxPQUFPLEtBQUssVUFBVSxXQUFXLEdBQUc7QUFLNUUsVUFBSSxFQUFFLE1BQU0sV0FBVyxNQUFNLFlBQVksTUFBTSxTQUFTO0FBQ3RELG9CQUFZLFVBQVUsTUFBTSxVQUFVLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDdEQ7QUFBQSxJQUNGO0FBQUEsRUFDTCxDQUFHO0FBS0QsTUFBSSxPQUFPLE9BQU87QUFDaEIsVUFBTSxHQUFHLElBQUk7QUFFYixhQUFTNU8sTUFBSyxXQUFXO0FBQ3ZCLFVBQUksVUFBVUEsRUFBQyxNQUFNO0FBQUssZ0JBQVFBLEVBQUMsSUFBSTtBQUFBLElBQ3hDO0FBRUQsUUFBSSxDQUFDO0FBQVU7QUFBQSxFQUNoQjtBQUdELFdBQVMsS0FBSyxPQUFPO0FBQ25CLFFBQUksT0FBTyxVQUFVLGVBQWUsS0FBSyxPQUFPLENBQUMsR0FBRztBQUNsRCxZQUFNLENBQUMsSUFBSSxNQUFNLFlBQVksQ0FBQyxDQUFDO0FBQUEsSUFDaEM7QUFBQSxFQUNGO0FBU0QsTUFBSSxNQUFNLG9CQUFvQixFQUFFLE1BQU0sVUFBVSxDQUFDLE1BQU0sWUFBWSxNQUFNLGlCQUFpQixVQUFVLEdBQUc7QUFDckcsUUFBSSxVQUFVLFFBQVEsRUFBRSxNQUFNLElBQUk7QUFDaEMsZ0JBQVUsS0FBSyxFQUFFO0FBQUEsSUFDbEI7QUFFRCxRQUFJLFVBQVUsUUFBUSxFQUFFLE1BQU0sSUFBSTtBQUNoQyxnQkFBVSxLQUFLLEVBQUU7QUFBQSxJQUNsQjtBQUVELFVBQU0sRUFBRSxJQUFJO0FBQ1osVUFBTSxFQUFFLElBQUk7QUFBQSxFQUNiO0FBR0QsTUFBSSxRQUFRO0FBRVosTUFBSSxVQUFVO0FBQ1osYUFBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsS0FBSztBQUN4QyxVQUFJLFNBQVMsQ0FBQyxFQUFFLFVBQVUsVUFBVSxNQUFNLFNBQVMsYUFBYSxTQUFTLENBQUMsRUFBRSxXQUFXLE1BQU0sU0FBUyxXQUFXLFNBQVMsQ0FBQyxFQUFFLFFBQVE7QUFDbkkscUJBQWEsT0FBTyxTQUFTLENBQUMsR0FBRyxPQUFPNE8sUUFBTztBQUFBLE1BQ2hEO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFHRCxNQUFJLEVBQUUsT0FBTztBQUFZO0FBRXpCLFdBQVMsS0FBSyxHQUFHLEtBQUssVUFBVSxHQUFHLEVBQUUsUUFBUSxNQUFNO0FBQ2pELFFBQUksTUFBTSxTQUFTLGFBQWEsVUFBVSxHQUFHLEVBQUUsRUFBRSxFQUFFLFdBQVcsTUFBTSxTQUFTLFdBQVcsVUFBVSxHQUFHLEVBQUUsRUFBRSxFQUFFLE9BQU87QUFDaEgsVUFBSSxVQUFVLEdBQUcsRUFBRSxFQUFFLEVBQUUsS0FBSztBQUMxQixZQUFJLFNBQVMsVUFBVSxHQUFHLEVBQUUsRUFBRTtBQUM5QixZQUFJLFdBQVcsT0FBTztBQUN0QixZQUFJLGNBQWMsT0FBTyxJQUFJLE1BQU0sUUFBUTtBQUMzQyxZQUFJLG1CQUFtQixDQUFBO0FBRXZCLGlCQUFTdk4sS0FBSSxHQUFHQSxLQUFJLFlBQVksUUFBUUEsTUFBSztBQUMzQywyQkFBaUIsS0FBSyxLQUFLLFlBQVlBLEVBQUMsQ0FBQyxDQUFDO0FBQUEsUUFDM0M7QUFFRCxZQUFJLGlCQUFpQixPQUFPLEtBQUssRUFBRSxNQUFNLFVBQVUsS0FBTSxFQUFDLEtBQUssRUFBRSxHQUFHO0FBRWxFLHVCQUFhLE9BQU8sUUFBUSxPQUFPdU4sUUFBTztBQUFBLFFBQzNDO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0g7QUFHQSxTQUFTLGNBQWNBLFVBQVM7QUFDOUIsU0FBTyxvQkFBb0IsUUFBUUEsUUFBTyxJQUFJO0FBQ2hEO0FBRUEsU0FBUyxRQUFRLEtBQUssUUFBUSxRQUFRO0FBQ3BDLGNBQVksQ0FBQTtBQUNaLE1BQUksT0FBTyxRQUFRLEdBQUc7QUFFdEIsTUFBSSxPQUFPLENBQUE7QUFDWCxNQUFJLFFBQVE7QUFFWixNQUFJQSxXQUFVO0FBRWQsTUFBSSxJQUFJO0FBQ1IsTUFBSSxRQUFRO0FBQ1osTUFBSSxVQUFVO0FBQ2QsTUFBSSxXQUFXO0FBQ2YsTUFBSSxVQUFVO0FBRWQsTUFBSSxXQUFXLFVBQWEsT0FBTyxXQUFXLFlBQVk7QUFDeEQsYUFBUztBQUFBLEVBQ1Y7QUFFRCxNQUFJLE9BQU8sVUFBVSxTQUFTLEtBQUssTUFBTSxNQUFNLG1CQUFtQjtBQUNoRSxRQUFJLE9BQU87QUFBTyxjQUFRLE9BQU87QUFFakMsUUFBSSxPQUFPO0FBQVMsTUFBQUEsV0FBVSxPQUFPO0FBRXJDLFFBQUksT0FBTztBQUFPLGNBQVEsT0FBTztBQUVqQyxRQUFJLE9BQU8sWUFBWTtBQUFXLGdCQUFVLE9BQU87QUFFbkQsUUFBSSxPQUFPLFlBQVk7QUFBVyxnQkFBVSxPQUFPO0FBRW5ELFFBQUksT0FBTyxPQUFPLGFBQWE7QUFBVSxpQkFBVyxPQUFPO0FBQUEsRUFDNUQ7QUFFRCxNQUFJLE9BQU8sV0FBVztBQUFVLFlBQVE7QUFFeEMsU0FBTyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQzNCLFVBQU0sS0FBSyxDQUFDLEVBQUUsTUFBTSxRQUFRO0FBRTVCLFdBQU8sQ0FBQTtBQUVQLFFBQUksSUFBSSxTQUFTO0FBQUcsYUFBTyxRQUFRLFdBQVcsR0FBRztBQUVqRCxVQUFNLElBQUksSUFBSSxTQUFTLENBQUM7QUFDeEIsVUFBTSxRQUFRLE1BQU0sTUFBTSxLQUFLLEdBQUc7QUFHbEMsUUFBSSxFQUFFLE9BQU87QUFBWSxnQkFBVSxHQUFHLElBQUk7QUFFMUMsY0FBVSxHQUFHLEVBQUUsS0FBSztBQUFBLE1BQ2xCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFVLEtBQUssQ0FBQztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ1g7QUFBQSxNQUNBLFNBQVNBO0FBQUEsSUFDZixDQUFLO0FBQUEsRUFDRjtBQUdELE1BQUksT0FBT0EsYUFBWSxlQUFlLENBQUMsY0FBY0EsUUFBTyxLQUFLLFFBQVE7QUFDdkUsd0JBQW9CLEtBQUtBLFFBQU87QUFDaEMsYUFBU0EsVUFBUyxXQUFXLFNBQVUsR0FBRztBQUN4QyxlQUFTLEdBQUdBLFFBQU87QUFBQSxJQUNwQixHQUFFLE9BQU87QUFFVixRQUFJLENBQUMsaUJBQWlCO0FBQ3BCLHdCQUFrQjtBQUNsQixlQUFTLFFBQVEsU0FBUyxXQUFZO0FBQ3BDLG9CQUFZLENBQUE7QUFBQSxNQUNiLEdBQUUsT0FBTztBQUFBLElBQ1g7QUFFRCxhQUFTQSxVQUFTLFNBQVMsU0FBVSxHQUFHO0FBQ3RDLGVBQVMsR0FBR0EsUUFBTztBQUNuQixvQkFBYyxDQUFDO0FBQUEsSUFDaEIsR0FBRSxPQUFPO0FBQUEsRUFDWDtBQUNIO0FBRUEsU0FBUyxRQUFRb0MsV0FBVTtBQUN6QixNQUFJLFFBQVEsVUFBVSxTQUFTLEtBQUssVUFBVSxDQUFDLE1BQU0sU0FBWSxVQUFVLENBQUMsSUFBSTtBQUNoRixTQUFPLEtBQUssU0FBUyxFQUFFLFFBQVEsU0FBVSxLQUFLO0FBQzVDLFFBQUksV0FBVyxVQUFVLEdBQUcsRUFBRSxPQUFPLFNBQVUsTUFBTTtBQUNuRCxhQUFPLEtBQUssVUFBVSxTQUFTLEtBQUssYUFBYUE7QUFBQSxJQUN2RCxDQUFLO0FBRUQsYUFBUyxRQUFRLFNBQVUsTUFBTTtBQUMvQixVQUFJLFFBQVEsS0FBSyxRQUFRO0FBQ3ZCLGFBQUssT0FBTTtBQUFBLE1BQ1o7QUFBQSxJQUNQLENBQUs7QUFBQSxFQUNMLENBQUc7QUFDSDtBQUVBLElBQUksT0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1Y7QUFDRjtBQUVBLFNBQVMsS0FBSyxNQUFNO0FBQ2xCLE1BQUksT0FBTyxVQUFVLGVBQWUsS0FBSyxNQUFNLENBQUMsR0FBRztBQUNqRCxZQUFRLENBQUMsSUFBSSxLQUFLLENBQUM7QUFBQSxFQUNwQjtBQUNIO0FBRUEsSUFBSSxPQUFPLFdBQVcsYUFBYTtBQUNqQyxNQUFJLFdBQVcsT0FBTztBQUV0QixVQUFRLGFBQWEsU0FBVSxNQUFNO0FBQ25DLFFBQUksUUFBUSxPQUFPLFlBQVksU0FBUztBQUN0QyxhQUFPLFVBQVU7QUFBQSxJQUNsQjtBQUVELFdBQU87QUFBQSxFQUNYO0FBRUUsU0FBTyxVQUFVO0FBQ25COzs7Ozs7Ozs7Ozs7O0FDcG1CQSxRQUFRLFNBQVMsV0FBWTtBQUNsQixTQUFBO0FBQ1g7QUFHTyxJQUFNLFdBQU4sTUFBb0M7QUFBQSxFQU9oQyxZQUFvQyxVQUFxQjtBQUpoRSxTQUFRLFNBQVM7QUFBQSxNQUNiLFNBQVM7QUFBQSxJQUFBO0FBSVQsUUFBSSwrQkFBK0I7QUFDbkMsU0FBSyxXQUFXO0FBQUEsRUFDcEI7QUFBQSxFQUVPLHNCQUFzQkEsV0FBa0IsVUFBc0M7QUFDekUsWUFBQUEsV0FBVSxLQUFLLFFBQVEsUUFBUTtBQUN2QyxTQUFLLFNBQVMsR0FBR0EsVUFBUyxTQUFBLEdBQVksUUFBUTtBQUFBLEVBQ2xEO0FBQUEsRUFFTyx3QkFBd0JBLFdBQWtCO0FBQzdDLFlBQVEsT0FBT0EsU0FBUTtBQUN2QixTQUFLLFNBQVMsSUFBSUEsVUFBUyxTQUFVLENBQUE7QUFBQSxFQUN6QztBQUFBLEVBRU8sZ0NBQWdDLFNBQWtCO0FBQ2pELFFBQUEsUUFBUSxZQUFZLFFBQVEsVUFBVTtBQUN0QyxXQUFLLHNCQUFzQixRQUFRLFVBQVUsUUFBUSxRQUFRO0FBQUEsSUFDakU7QUFBQSxFQUNKO0FBQUEsRUFFTyxrQ0FBa0MsU0FBa0I7QUFDbkQsUUFBQSxRQUFRLFlBQVksUUFBUSxVQUFVO0FBQ2pDLFdBQUEsd0JBQXdCLFFBQVEsUUFBUTtBQUFBLElBQ2pEO0FBQUEsRUFDSjtBQUNKO0FBakNhLFdBQU4zQixrQkFBQTtBQUFBLEVBRE4sV0FBVztBQUFBLEVBUVcsZ0JBQUEsR0FBQyxPQUFPLE1BQU0sUUFBUSxDQUFBO0FBQUEsR0FQaEMsUUFBQTs7Ozs7Ozs7Ozs7O0FDUE4sSUFBTSxpQkFBTixNQUFnRDtBQUFBLEVBRzVDLGNBQWM7QUFDWixTQUFBLHFDQUFxQjtFQUM5QjtBQUFBLEVBRUEsZ0JBQWdCLFdBQW1CLGVBQThCO0FBQ3hELFNBQUEsZUFBZSxJQUFJLFdBQVcsYUFBYTtBQUFBLEVBQ3BEO0FBQUEsRUFFQSxrQkFBa0IsS0FBYTtBQUN0QixTQUFBLGVBQWUsT0FBTyxHQUFHO0FBQUEsRUFDbEM7QUFBQSxFQUVBLG9CQUFvQjtBQUNoQixVQUFNLFNBQXVELENBQUE7QUFDN0QsU0FBSyxlQUFlLFFBQVEsQ0FBQyxPQUFPLFFBQVE7QUFDeEMsYUFBTyxLQUFLLEVBQUUsS0FBSyxNQUFPLENBQUE7QUFBQSxJQUFBLENBQzdCO0FBQ00sV0FBQTtBQUFBLEVBQ1g7QUFDSjtBQXRCYSxpQkFBTixnQkFBQTtBQUFBLEVBRE4sV0FBVztBQUFBLEdBQ0MsY0FBQTtBQ3FCYixNQUFNLFlBQVksSUFBSTtBQUN0QixVQUFVLEtBQXNCLE1BQU0sY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFO0FBQ3pFLFVBQVUsS0FBcUIsTUFBTSxhQUFhLEVBQUUsR0FBRyxhQUFhLEVBQUU7QUFDdEUsVUFBVSxLQUFvQixNQUFNLFlBQVksRUFBRSxHQUFHLFlBQVksRUFBRTtBQUNuRSxVQUFVLEtBQW9CLE1BQU0sWUFBWSxFQUFFLEdBQUcsWUFBWSxFQUFFO0FBQ25FLFVBQVUsS0FBeUIsTUFBTSxpQkFBaUIsRUFBRSxHQUFHLGlCQUFpQixFQUFFO0FBQ2xGLFVBQVUsS0FBZ0IsTUFBTSxRQUFRLEVBQUUsR0FBRyxRQUFRO0FBQ3JELFVBQVUsS0FBZ0IsTUFBTSxRQUFRLEVBQUUsR0FBRyxRQUFRLEVBQUU7QUFDdkQsVUFBVSxLQUFzQixNQUFNLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRTtBQUN6RSxVQUFVLEtBQWEsTUFBTSxLQUFLLEVBQUUsR0FBRyxLQUFLLEVBQUU7QUFDOUMsVUFBVSxLQUFzQixNQUFNLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxpQkFBaUI7QUMzQjFGLFNBQVMsbUJBQW1CO0FBQ3BCLE1BQUEsQ0FBQyxPQUFPLGNBQWM7QUFDdEIsUUFBSSxpQ0FBaUM7QUFDckMsV0FBTyxzQkFBc0IzTztBQUM3QixXQUFPLGVBQWUsVUFBVSxJQUFtQixNQUFNLFlBQVksRUFBRTtBQUN2RSxXQUFPLDJCQUEyQjtBQUFBLEVBQ3RDO0FBQ0o7In0=
